% \iffalse meta-comment
%
%% File: tl-act.dtx Copyright (C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX3 Project.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental Actions on Token Lists}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
 %\usepackage{tl-act}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%
% \title{^^A
%   The \textsf{tl-act} package: actions on token lists^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%         
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
%   This module provides some basic functionalities to manipulate
%   token lists expandably on a token by token basis.
% 
%   \section{Token list actions}
%
%   \begin{function}[EXP]{\tl_expandable_uppercase:n,\tl_expandable_lowercase:n}
%     \begin{syntax}
%       \cs{tl_expandable_uppercase:n} \Arg{token list}
%       \cs{tl_expandable_lowercase:n} \Arg{token list}
%     \end{syntax}
%     These functions expandably uppercase or lowercase the token list,
%     even within braces. The correspondance between upper- and lower-case
%     letters does not use \TeX{}'s \cs{lccode} and \cs{uccode}, but rather
%     private lists, \cs{c_upper_tl} and \cs{c_lower_tl} of the form
%     |{a}{A} {b}{B}| etc.\footnote{Bruno: should those be \texttt{g}
%       variables, to let the user add to them?}
%   \end{function}
%
%   \begin{function}[EXP]{\tl_token_reverse:n}
%     \begin{syntax}
%       \cs{tl_token_reverse:n} \Arg{token list}
%     \end{syntax}
%     This function reverses the order of tokens in the \meta{token list}:
%     the first token becomes the last, etc. Spaces are not lost.
%     The content of each brace group is also reversed, but of course
%     the braces cannot be exchanged, so they remain the \enquote{right
%       way around}. The character code of catcode 1 and 2 tokens
%     (usually braces) is lost, but that should never be a problem.
%   \end{function}
%
%   \begin{function}[EXP]{\tl_token_length:n}
%     \begin{syntax}
%       \cs{tl_token_length:n} \Arg{token list}
%     \end{syntax}
%     This function counts the number of \emph{tokens} in the
%     \meta{token list}, including spaces and braces.
%   \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{tl-act} implementation}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%    
%
%    \begin{macrocode}
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%    \end{macrocode}
%
% \begin{macro}[EXP]{\exp_args:cf}
%   This variant is used below. It could also be coded as
%   \cs{exp_args:Nc} \cs{exp_args:Nf}, or as
%   \cs{exp_args:Ncf} \cs{prg_do_nothing:}, but this lower-level
%   code is faster. Not that it matters anyways.
%    \begin{macrocode}
\cs_new:Npn \exp_args:cf #1 #2
  {
    \cs:w #1 \exp_after:wN \cs_end:
    \exp_after:wN { \tex_romannumeral:D -`0 #2 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\tl_act:nn}
%   For full expansion, we usually use \cs{tex_romannumeral:D}.
%   Here, the result is naturally surrounded by braces, so we need
%   to remove those.
%    \begin{macrocode}
\cs_new:Npn \tl_act:nn
  { \exp_after:wN \use:n \tex_romannumeral:D -`0 \tl_act_aux:nn }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\tl_act_aux:nn}
%   The first argument is the action to apply (a piece of csname),
%   the second is the token list. We act one \enquote{word} at a time,
%   delimited by explicit spaces (the only spaces that are ignored by
%   \TeX{}'s macro argument grabber). The \texttt{x}-expansion is needed
%   to get a space where we want. Without \cs{prg_do_nothing:} we would
%   lose braces around words.
%    \begin{macrocode}
\cs_new:Npx \tl_act_aux:nn #1 #2
  {
    \exp_not:N \tl_act_word_loop:nwwn {#1}
    \exp_not:N \prg_do_nothing: #2
    \exp_not:N \q_nil \c_space_tl
    \exp_not:N \q_recursion_stop
    { }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\tl_act_word_loop:nnwwn}
%   Grab one word (the argument before that is the action). Act on that word.
%   The odd looking \cs{use_i:nn} removes \cs{prg_do_nothing:} that was
%   inserted. Once that word is finished, it will automatically be outputted.
%   Then add a space. The last word won't get an extra space because the
%   corresponding line is skipped when we find \cs{q_nil}, which marks
%   the end of the token list.
%    \begin{macrocode}
\cs_new:Npn \tl_act_word_loop:nwwn #1 #2 ~ %
  {
    \use_i:nn { \tl_act_brace_loop:nwn {#1} } #2
    \q_recursion_tail \q_recursion_stop {}
    \use:c {#1_act_space:}
    \tl_act_word_loop:nwwn {#1} \prg_do_nothing:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\tl_act_brace_loop:nwn}
%   Within each word, we must do things slowly: test whether
%   the first token is of catcode 1. If it is, then we have a group,
%   and we should act accordingly. Otherwise, the leading token is
%   an \texttt{N}-type argument, possibly the end of the word,
%   \cs{q_recursion_tail}. It can also be \cs{q_mark}, the end of
%   a token list. This needs optimization.
%    \begin{macrocode}
\cs_new:Npn \tl_act_brace_loop:nwn #1 #2 \q_recursion_stop #3
  {
    \tl_if_head_begin_group:nTF {#2}
      { \tl_act_group_do:nn  }
      { \tl_act_normal_do:nN }
    {#1} #2 \q_recursion_stop {#3}
  }
\cs_new:Npn \tl_act_group_do:nn #1 #2
  {
    \exp_args:cf {#1_act_group:n}
      { \tl_act_aux:nn {#1} {#2} }
    \tl_act_brace_loop:nwn {#1}
  }
\cs_new:Npn \tl_act_normal_do:nN #1 #2
  {
    \quark_if_recursion_tail_stop_do:Nn #2 { \use:c {#1_act_output:n} }
    \quark_if_nil:NT #2
      { \use_i_delimit_by_q_recursion_stop:nw { \tl_act_end:nn {#1} } }
    \exp_args:cf {#1_act_output:n}
      {
        \exp_args:NNv \prg_case_str:nnn #2 % <- bad coding!
          { #1_act }
          { \use:c {#1_act_default:N} #2 }
      }
    \tl_act_brace_loop:nwn {#1}
  }
\cs_new:Npn \tl_act_end:nn #1 #2
  {
    \use:c {#1_act_output:n} {#2}
    \use_none_delimit_by_q_recursion_stop:w
  }
\cs_new:Npn \tl_act_output_normal:n #1 #2 \q_recursion_stop #3
  { #2 \q_recursion_stop { #3 #1 } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tl_token_reverse:n}
% \begin{macro}{\c_reverse_act,\c_reverse_act_output:n,
%     \c_reverse_act_default:N,\c_reverse_act_space:,\c_reverse_act_group:n}
%   Building the action table for reversing a token list.
%    \begin{macrocode}
\cs_new:Npn \tl_token_reverse:n { \tl_act:nn {c_reverse} }
\tl_const:Nn \c_reverse_act { }
\cs_new:Npn \c_reverse_act_output:n #1 #2 \q_recursion_stop #3
  { #2 \q_recursion_stop { #1 #3 } }
\cs_new_eq:NN \c_reverse_act_default:N \exp_stop_f:
\cs_new:Npn \c_reverse_act_space: { \c_reverse_act_output:n { ~ } }
\cs_new_eq:NN \c_reverse_act_group:n \c_reverse_act_output:n
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\tl_token_length:n}
% \begin{macro}{\c_length_act,\c_length_act_output:n,
%     \c_length_act_default:N,\c_length_act_space:,\c_length_act_group:n}
%   Building the action table for the length of a token list.
%    \begin{macrocode}
\tl_const:Nn \c_length_act { }
\cs_new_eq:NN \c_length_act_output:n \tl_act_output_normal:n
\cs_new:Npn \c_length_act_default:N #1 { + \c_one }
\cs_new:Npn \c_length_act_space:
  { \c_length_act_output:n { + \c_one } }
\cs_new:Npn \c_length_act_group:n #1
  { \c_length_act_output:n { \use:n #1 + \c_two } }
\cs_new:Npn \tl_token_length:n #1
  { \int_eval:n { 0 \tl_act:nn {c_length} {#1} } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\tl_expandable_lowercase:n, \tl_expandable_uppercase:n}
% \begin{macro}{\c_lower_act,\c_upper_act}
% \begin{macro}{\c_lower_act_output:n,\c_lower_act_default:N,
%     \c_lower_act_space:,\c_lower_act_group:n,\c_upper_act_output:n,
%     \c_upper_act_default:N,\c_upper_act_space:,\c_upper_act_group:n}
%    \begin{macrocode}
\group_begin:
  \cs_set:Npn \tl_act_put_letter:nn #1 #2
    {
      \char_set_lccode:nn {`A} {#1}
      \char_set_lccode:nn {`B} {#2}
      \tl_to_lowercase:n
        { \tl_put_left:Nn \l_tmpa_tl { {A} {B} } }
    }
  % uppercase
  \tl_set:Nn \l_tmpa_tl
    {
      { \i  } { I }
      { \j  } { J }
      { \oe } { \exp_stop_f: \OE }
      { \o  } { \exp_stop_f: \O  }
      { \ae } { \exp_stop_f: \AE }
    }
  \prg_stepwise_inline:nnnn {`Z} {-1} {`A}
    { \tl_act_put_letter:nn {#1+32} {#1} }
  \exp_args:NNo \tl_const:Nn \c_upper_act { \l_tmpa_tl }
  % lowercase
  \tl_set:Nn \l_tmpa_tl
    {
      { \OE } { \exp_stop_f: \oe }
      { \O  } { \exp_stop_f: \o  }
      { \AE } { \exp_stop_f: \ae }
    }
  \prg_stepwise_inline:nnnn {`Z} {-1} {`A}
    { \tl_act_put_letter:nn {#1} {#1+32} }
  \exp_args:NNo \tl_const:Nn \c_lower_act { \l_tmpa_tl }
\group_end:
\cs_new_eq:NN \c_upper_act_output:n \tl_act_output_normal:n
\cs_new_eq:NN \c_upper_act_default:N \exp_stop_f:
\cs_new:Npn \c_upper_act_space: { \c_upper_act_output:n { ~ } }
\cs_new_eq:NN \c_upper_act_group:n \c_upper_act_output:n
\cs_new_eq:NN \c_lower_act_output:n  \c_upper_act_output:n
\cs_new_eq:NN \c_lower_act_default:N \c_upper_act_default:N
\cs_new_eq:NN \c_lower_act_space:    \c_upper_act_space:
\cs_new_eq:NN \c_lower_act_group:n   \c_upper_act_group:n
\cs_new:Npn \tl_expandable_uppercase:n { \tl_act:nn {c_upper} }
\cs_new:Npn \tl_expandable_lowercase:n { \tl_act:nn {c_lower} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
% 
% \PrintIndex
