% \iffalse meta-comment
%
%% File: l3str.dtx Copyright (C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX3 Project.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental Strings}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%
% \title{^^A
%   The \textsf{l3str} package: manipulating strings of characters^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%         
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
%   \begin{function}[EXP]{\str_sanitize:n}
%     \begin{syntax}
%       \cs{str_sanitize:n} \Arg{tokens}
%     \end{syntax}
%     Converts the \meta{tokens} to a string where spaces have
%     category code $10$. This function is f-expandable, and
%     doing so does not lose any space, since f-expansion only
%     loses leading spaces with category code $10$.
%   \end{function}
%
%   \begin{function}[EXP]{\str_desanitize:n}
%     \begin{syntax}
%       \cs{str_desanitize:n} \Arg{sanitized string}
%     \end{syntax}
%     Converts catcode-other spaces to normal spaces.
%     \begin{texnote}
%       This is the e\TeX{} primitive \cs{detokenize} renamed.
%     \end{texnote}
%   \end{function}
%
%   \begin{function}[EXP]{\str_sanitize_args:Nn,\str_sanitize_args:Nnn}
%     \begin{syntax}
%       \cs{str_sanitize_args:Nn} \meta{function} \Arg{tokens}
%       \cs{str_sanitize_args:Nnn} \meta{function} \Arg{tokens1} \Arg{tokens2}
%     \end{syntax}
%     Converts the \meta{tokens} using \cs{str_sanitize:n}.
%   \end{function}
%
%   \begin{function}[TF]{\tl_if_str:n}
%     \begin{syntax}
%       \cs{tl_if_str:nTF} \Arg{token list} \Arg{true code} \Arg{false code}
%     \end{syntax}
%     Tests if the \meta{token list} is a string or a sanitized string.
%   \end{function}
%
%   \begin{variable}{\l_str_tmp_tl}
%     Used for \cs{tl_if_str:nTF}.
%   \end{variable}
%
%   \begin{function}[EXP]{\str_length:n}
%     \begin{syntax}
%       \cs{str_length:n} \Arg{tokens}
%     \end{syntax}
%     Expands to the number of characters in \meta{tokens}.
%   \end{function}
%
%   \begin{function}[pTF]{\str_if_contains_char:nN}
%     \begin{syntax}
%       \cs{str_if_contains_char:nN} \Arg{string} \meta{char}
%     \end{syntax}
%     Tests whether the \meta{char} is in the \meta{string}.
%     The \meta{char} is given either directly, or as a one
%     letter control sequence.\footnote{Bruno: is that a
%       good idea?}
%   \end{function}
%
%   \section{Possibilities}
%
%   \begin{itemize}
%   \item \cs{str_item:nn} \Arg{str} \Arg{int} giving the \meta{int}th
%     character;
%   \item \cs{str_substr:nnn} \Arg{str} \Arg{begin int} \Arg{end int}
%     giving the piece of string between positions \meta{begin} and
%     \meta{end}; other packages take the approach \cs{str_substr:nnn}
%     \Arg{str} \Arg{begin} \Arg{length};
%   \item \cs{str_between:nnn} \Arg{str}
%     \Arg{begin delimiter} \Arg{end delimiter} giving the piece of
%     \meta{str} between \meta{begin} and \meta{end}; could be used
%     with empty \meta{begin} or \meta{end} to indicate that we
%     want everything until \meta{end} or starting from \meta{begin},
%     respectively;
%   \item \cs{str_count_in:nn} \Arg{str} \Arg{substr} giving the number
%     of occurrences of \meta{substr} in \meta{str};
%   \item \cs{str_if_in:nn} \Arg{str} \Arg{substr} deciding if the
%     \meta{substr} appears in \meta{str}.
%   \item \cs{str_if_head_eq:nN} alias of \cs{tl_if_head_eq_charcode:nN}
%   \item \cs{str_if_numeric/decimal/integer:n}, perhaps in \pkg{l3fp}?
%   \end{itemize}
%   Some functionalities of \pkg{stringstrings} and \pkg{xstring} as well.
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3str} implementation}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%    
%
%    \begin{macrocode}
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%    \end{macrocode}
%
% \begin{macro}[EXP]{\str_sanitize:n}
% \begin{macro}[EXP,aux]{\str_sanitize_loop:w,\str_sanitize_end:w}
%   Replaces all spaces by \enquote{other} spaces, after converting
%   the token list to a string via \cs{tl_to_str:n}.
%    \begin{macrocode}
\group_begin:
\char_set_lccode:nn {`\*}{`\ }
\char_set_lccode:nn {`\A}{`\A}
\tl_to_lowercase:n {
  \group_end:
  \cs_new:Npn \str_sanitize:n #1
    {
      \exp_after:wN \str_sanitize_loop:w \tl_to_str:n {#1} ~ %
      A ~ A ~ A ~ A ~ A ~ A ~ A ~ A ~ \q_mark \q_stop
    }
  \cs_new:Npn \str_sanitize_loop:w
      #1 ~ #2 ~ #3 ~ #4 ~ #5 ~ #6 ~ #7 ~ #8 ~ #9 \q_stop
    {
      \if_meaning:w A #8
        \str_sanitize_end:w
      \fi:
      \str_sanitize_loop:w
      #9 #1 * #2 * #3 * #4 * #5 * #6 * #7 * #8 * \q_stop
    }
  \cs_new:Npn \str_sanitize_end:w \fi: #1 \q_mark #2 * A #3 \q_stop
    { \fi: #2 }
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_desanitize:n}
%   Converting \enquote{other} spaces to normal spaces is very easy
%   using the e\TeX{} primitive.
%    \begin{macrocode}
\cs_new_eq:NN \str_desanitize:n \tl_to_str:n
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\str_sanitize_args:Nn,\str_sanitize_args:Nnn}
%   \begin{syntax}
%     \cs{str_sanitize_args:Nn} \meta{function} \Arg{token list}
%     \cs{str_sanitize_args:Nnn} \meta{function}
%     ~~\Arg{token list1} \Arg{token list2}
%   \end{syntax}
%   Converts the token lists to strings with spaces of category
%   other, and gives the result as arguments to \meta{function}.
%    \begin{macrocode}
\cs_new:Npn \str_sanitize_args:Nn #1 #2
  {
    \exp_args:Nf #1
      { \str_sanitize:n {#2} }
  }
\cs_new:Npn \str_sanitize_args:Nnn #1 #2 #3
  {
    \exp_args:Nff #1
      { \str_sanitize:n {#2} }
      { \str_sanitize:n {#3} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[TF]{\tl_if_str:n}
%   A token list is a string if it is either equal to the result of
%   \cs{tl_to_str:n} or that of \cs{str_sanitize:n}. This test cannot
%   be made expandable, because it is not possible to distinguish
%   expandably an active character let equal to its non-active counterpart
%   from that non-active counterpart.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \tl_if_str:n #1 { T , F , TF }
  {
    \tl_set:No \l_str_tmp_tl { \tl_to_str:n {#1} }
    \tl_if_eq:NNTF #1 \l_str_tmp_tl
      { \prg_return_true: }
      {
        \tl_set:Nf \l_str_tmp_tl { \str_sanitize:n {#1} }
        \tl_if_eq:NNTF #1 \l_str_tmp_tl
          { \prg_return_true: }
          { \prg_return_false: }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\str_length:n}
% \begin{macro}[EXP,aux]{\str_length_loop:NNNNNNNNN}
%   The length of a string is found by first changing all spaces
%   to other spaces using \cs{str_sanitize:n}, then counting
%   characters $9$ at a time. When the end is reached, |#9|
%   has the form |X|\meta{digit}, the catcode test is true,
%   the digit gets added to the sum, and the loop is terminated
%   by \cs{use_none_delimit_by_q_stop:w}.
%    \begin{macrocode}
\cs_new:Npn \str_length:n #1
  {
    \int_eval:n
      {
        \exp_last_unbraced:Nf \str_length_loop:NNNNNNNNN
          { \str_sanitize:n {#1} }
          {X8}{X7}{X6}{X5}{X4}{X3}{X2}{X1}{X0} \q_stop
      }
  }
\cs_new:Npn \str_length_loop:NNNNNNNNN #1#2#3#4#5#6#7#8#9
  {
    \if_catcode:w X #9
      \exp_after:wN \use_none_delimit_by_q_stop:w
    \fi:
    \c_nine + \str_length_loop:NNNNNNNNN
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[pTF]{\str_if_contains_char:nN}
% \begin{macro}{\str_if_contains_char_loop:NN}
%   Loop over the characters of the string, comparing character codes.
%   We allow |#2| to be a single-character control sequence, hence the
%   use of \cs{if_int_compare:w} rather than \cs{if_charcode:w}.
%   The loop is broken if character codes match. Otherwise,
%   the trailing brace group is taken as the second argument of
%   \cs{str_if_contains_char_loop:NN}, makes the test be true,
%   cleans up, and returns \enquote{false}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \str_if_contains_char:nN #1 #2 {p,T,F,TF}
  {
    \exp_last_unbraced:NNf
      \str_if_contains_char_loop:NN
      #2
      { \str_sanitize:n {#1} }
    { #2 \exp_stop_f: \prg_return_false: \use_none:nn }
    \q_stop
  }
\cs_new_nopar:Npn \str_if_contains_char_loop:NN #1 #2
  {
    \if_int_compare:w `#1 = `#2 \exp_stop_f:
      \prg_return_true:
      \exp_after:wN \use_none_delimit_by_q_stop:w
    \fi:
    \str_if_contains_char_loop:NN #1
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\str_if_in:nn}
%   \begin{syntax}
%     \cs{str_if_in:nnTF} \Arg{string} \Arg{substring}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the \meta{substring} appears in \meta{string}.
%    \begin{macrocode}
 % \prg_new_conditional:Npnn \str_if_in:nn {p,T,F,TF}
 %   { \str_sanitize_args:Nnn \str_if_in_aux:nn }
 % \cs_new:Npn \str_if_in_aux:nn #1 #2
 %   {
 %     \str_if_in_aux_ii:w #1 A \q_mark #2 A \q_stop
 %   }
 % \cs_new:Npn \str_if_in_aux_ii:w #1 #2 \q_mark #3
 %   {
 %     \if_meaning:w #1 #3
 %       \exp_after:wN 
 %   }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
% 
% \PrintIndex
