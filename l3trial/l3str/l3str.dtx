% \iffalse meta-comment
%
%% File: l3str.dtx Copyright (C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX3 Project.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental Strings}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%
% \title{^^A
%   The \textsf{l3str} package: manipulating strings of characters^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%         
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \LaTeX3 provides a set of functions to manipulate strings of characters,
% ignoring the category codes of those characters. This module manipulates
% three kinds of explicit input
% \begin{itemize}
% \item \meta{token lists}, which are always converted to a \meta{string}
%   using \cs{tl_to_str:n},
% \item \meta{strings}, in which spaces have category code $10$ (blank space),
% \item \meta{other strings}, in which every character including spaces
%   have category code \enquote{other}.
% \end{itemize}
% The module also introduces a \meta{str var} variable type, which are token
% lists containing \meta{other strings} (\emph{i.e.}, spaces have category
% code \enquote{other}).
%
% Four main types of functions:
% \begin{itemize}
% \item \cs{str_...:N...}, acting on a \meta{str var}: these are fast
%   and safe, but of course require the material to have been stored
%   in a \meta{str var} with for instance \cs{str_set:Nn};
% \item \cs{str_...:n...}, taking any \meta{token list} (or \meta{string}
%   or \meta{other string}), converting it to an \meta{other string}:
%   these are the safest operations;
% \item \cs{str_..._ignore_spaces:n...}, taking any \meta{token list}
%   (or \meta{string} or \meta{other string}), converts it to a \meta{string},
%   and hence ignoring all spaces: these are the fastest operations;
% \item \cs{str_..._unsafe:n...}, expecting a \meta{other string},
%   which may break in all sorts of surprising ways if used on token
%   list input: these are mostly meant for internal use.
% \end{itemize}
%
% \section{Converting between token lists and strings}
%
% \begin{function}{\str_new:N, \str_const:Nn, \str_set:Nn, \str_gset:Nn}
%   \begin{syntax}
%     \cs{str_new:N} \meta{str var}
%     \cs{str_set:Nn} \meta{str var} \Arg{token list}
%   \end{syntax}
%   Creates the \meta{str var}. Converts the \meta{token list} to
%   an \meta{other string}, and saves the result in \meta{str var}.
% \end{function}
%
% \begin{function}[EXP]{\tl_to_str:N,\tl_to_str:n}
%   \begin{syntax}
%     \cs{tl_to_str:N} \meta{tl var}
%     \cs{tl_to_str:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string}, where spaces have
%   category code $10$. These functions are fast, but do not create
%   \enquote{safe} strings.
% \end{function}
%
% \begin{function}[EXP]{\tl_to_other_str:N,\tl_to_other_str:n}
%   \begin{syntax}
%     \cs{tl_to_other_str:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to an \meta{other string}, where
%   spaces have category code \enquote{other}. These functions create
%   \enquote{safe} strings.
%   \begin{texnote}
%     These functions can be \texttt{f}-expanded without fear of losing
%     a leading space, since spaces do not have category code $10$ in
%     their result.
%   \end{texnote}
% \end{function}
%
% \section{Variables and constants}
%
% \begin{variable}{\l_tmpa_str,\l_tmpb_str,\g_tmpa_str,\g_tmpb_str}
%   Scratch variables, used nowhere in the \LaTeX3 kernel.
% \end{variable}
%
% \begin{variable}{\c_space_str,\c_backslash_str,
%     \c_lbrace_str,\c_rbrace_str,\c_hash_str,\c_percent_str}
%   Constant strings, containing a single character, with category code $12$.
% \end{variable}
%
% \section{Characters given by their position}
%
% \begin{function}[EXP]{\str_length:N}
% \begin{function}[EXP]{\str_length:n}
% \begin{function}[EXP]{\str_length_ignore_spaces:n}
% \begin{function}[EXP]{\str_length_unsafe:n}
%   \begin{syntax}
%     \cs{str_length:n} \Arg{token list}
%   \end{syntax}
%   Leaves the length of the string representation of \meta{token list}
%   in the input stream. The functions differ in their treatment of spaces.
%   In the case of \cs{str_length:N} and \cs{str_length:n},
%   all characters including spaces are counted.
%   The \cs{str_length_ignore_spaces:n} returns the number of non-space
%   characters.
%   The \cs{str_length_unsafe:n} expects an \meta{other string}
%   instead of a general \meta{token list}, and returns the total
%   number of characters, as \cs{str_length:n} does.
%   \begin{texnote}
%     The \cs{str_length:n} of a given token list may depend
%     on the category codes in effect when it is measured,
%     and the value of the \tn{escapechar}: for instance
%     |\str_length:n {\a}| may return $1$, $2$ or $3$ depending
%     on the escape character, and the category code of \texttt{a}.
%   \end{texnote}
% \end{function}
% \end{function}
% \end{function}
% \end{function}
%
% \begin{function}[EXP]{\str_head:N}
% \begin{function}[EXP]{\str_head:n}
% \begin{function}[EXP]{\str_head_ignore_spaces:n}
% \begin{function}[EXP]{\str_head_unsafe:n}
%   \begin{syntax}
%     \cs{str_head:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} into a \meta{string} or
%   \meta{other string}. The first character in the \meta{string} is then
%   left in the input stream, with category code \enquote{other}.
%   The functions differ in their treatment of spaces.
%   In the case of \cs{str_head:N} and \cs{str_head:n},
%   a leading space is returned with category code \enquote{other}.
%   The \cs{str_head_ignore_spaces:n} function returns the first
%   non-space character.
%   The \cs{str_head_unsafe:n} function expects an \meta{other string}
%   instead of a general \meta{token list}, and otherwise behaves as
%   \cs{str_head:n}.
%   If the \meta{token list} is empty (or blank in the case of the
%   \texttt{_ignore_spaces} variant), then nothing is left on the
%   input stream.
% \end{function}
% \end{function}
% \end{function}
% \end{function}
%
% \begin{function}[EXP]{\str_tail:N}
% \begin{function}[EXP]{\str_tail:n}
% \begin{function}[EXP]{\str_tail_ignore_spaces:n}
% \begin{function}[EXP]{\str_tail_unsafe:n}
%   \begin{syntax}
%     \cs{str_tail:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string} or
%   \meta{other string}, removes the first character, and leaves
%   the remainding characters (if any) in the input stream.
%   The functions differ in their treatment of spaces.
%   The \cs{str_tail:N} and \cs{str_tail:n} functions return a
%   \meta{other string}, where all spaces have category code \enquote{other}.
%   In the case of \cs{str_tail_ignore_spaces:n}, the first non-space
%   character is removed, and any further spaces is returned with
%   category code $10$.
%   The \cs{str_tail_unsafe:n} function expects a \meta{other string},
%   and otherwise behaves as \cs{str_tail:n}.
% \end{function}
% \end{function}
% \end{function}
% \end{function}
%
%^^A Should that be "str_char"?
% \begin{function}[EXP]{\str_item:Nn}
% \begin{function}[EXP]{\str_item:nn}
% \begin{function}[EXP]{\str_item_ignore_spaces:nn}
% \begin{function}[EXP]{\str_item_unsafe:nn}
%   \begin{syntax}
%     \cs{str_item:nn} \Arg{token list} \Arg{integer expression}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string} or
%   \meta{other string} depending on the variant, and
%   leaves in the input stream the character in position
%   \meta{integer expression} of the \meta{string}.
%   In the case of \cs{str_item:Nn} and \cs{str_item:nn},
%   all characters including spaces are taken into account,
%   and have category code \enquote{other}.
%   The \cs{str_item_ignore_spaces:nn} function skips spaces
%   in its argument.
%   The \cs{str_item_unsafe:nn} function expects its argument
%   to be an \meta{other string}, and otherwise behaves as
%   \cs{str_item:nn}.
%   If the \meta{integer expression} is negative, characters
%   are counted from the end of the \meta{string}. Hence, $-1$ is
%   the right-most character, \emph{etc.}, while $0$ is the first
%   (left-most) character.
% \end{function}
% \end{function}
% \end{function}
% \end{function}
%
%^^A Should that be "str_substr"? Should |#3| be the end-position, or the
%^^A length to extract? What is more natural? What is easier to implement?
% \begin{function}[EXP]{\str_from_to:Nnn}
% \begin{function}[EXP]{\str_from_to:nnn}
% \begin{function}[EXP]{\str_from_to_ignore_spaces:nnn}
% \begin{function}[EXP]{\str_from_to_unsafe:nnn}
%   \begin{syntax}
%     \cs{str_from_to:nnn} \Arg{token list} \Arg{start index} \Arg{end index}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string} or \meta{other string}
%   depending on the variant, and leaves in the input stream the characters
%   between \meta{start index} (inclusive) and \meta{end index} (exclusive).
%   [...]
%   ^^A Not sure what to do with negative indices.
% \end{function}
% \end{function}
% \end{function}
% \end{function}
%
% \section{String conditionals}
%
% \begin{function}[EXP,pTF]{\str_if_eq:NN}
% \begin{function}[EXP,pTF]
%   {
%     \str_if_eq:nn, \str_if_eq:Vn, \str_if_eq:on, \str_if_eq:no,
%     \str_if_eq:nV, \str_if_eq:VV, \str_if_eq:xx
%   }
%   \begin{syntax}
%     \cs{str_if_eq_p:nn} \Arg{tl1} \Arg{tl2}
%     \cs{str_if_eq:nnTF} \Arg{tl1} \Arg{tl2} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Compares the two \meta{token lists} on a character by character
%   basis, and is \texttt{true} if the two lists contain the same
%   characters in the same order. Thus for example
%   \begin{verbatim}
%     \str_if_eq_p:xx { abc } { \tl_to_str:n { abc } }
%   \end{verbatim}
%   is logically \texttt{true}. All versions of these functions are fully
%   expandable (including those involving an \texttt{x}-type
%   expansion).
% \end{function}
% \end{function}
%
% \begin{function}[EXP,pTF]{\str_if_contains_char:NN}
% \begin{function}[EXP,pTF]{\str_if_contains_char:nN}
%   \begin{syntax}
%     \cs{str_if_contains_char:nN} \Arg{token list} \meta{char}
%   \end{syntax}
%   Converts the \meta{token list} to an \meta{other string}
%   and tests whether the \meta{char} is present in the
%   \meta{other string}.
%   The \meta{char} can be given either directly, or as a one
%   letter control sequence.
% \end{function}
% \end{function}
%
% \section{Internal string functions}
%
% \begin{function}[EXP]{\str_sanitize_args:Nn,\str_sanitize_args:Nnn}
%   \begin{syntax}
%     \cs{str_sanitize_args:Nnn} \meta{function}
%     ~~\Arg{token list1} \Arg{token list2}
%   \end{syntax}
%   Converts the \meta{token lists} to \meta{other strings}
%   and hands-in the result as arguments to \meta{function}.
% \end{function}
%
% \section{Experimental string functions}
%
% \begin{function}[rEXP]{\str_map_function:NN}
%   \begin{syntax}
%     \cs{str_map_function:NN} \meta{str var} \meta{function}
%   \end{syntax}
%   Maps the \meta{function} over every character in the \meta{str var}.
% \end{function}
%
% \subsection{Conditionals}
%
% \begin{function}[EXP,pTF]{\str_if_bytes:N}
%   \begin{syntax}
%     \cs{str_if_bytes:NTF} \meta{str var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the \meta{str var} only contains characters
%   in the range $0$--$255$.
% \end{function}
%
% \begin{function}[EXP,pTF]{\str_if_bytes_UTF_viii:N}
%   \begin{syntax}
%     \cs{str_if_bytes_UTF_viii:N} \meta{str var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the \meta{str var} only contains characters
%   in the range $0$--$255$, and forms a valid \texttt{UTF8} string.
%   \textbf{Missing!} ^^A Missing.
% \end{function}
%
% \subsection{Conversion}
%
% \begin{function}{\str_native_from_bytes_UTF_viii:NN}
%   \begin{syntax}
%     \cs{str_native_from_bytes_UTF_viii:NN} \meta{str~var1} \meta{str~var2}
%   \end{syntax}
%   Reads the contents of the \meta{str~var2} as an \texttt{UTF8}-encoded
%   sequence of bytes, and stores the resulting characters (which can
%   now have any character code) into \meta{str~var1}.
%   This function raises an error if the \meta{str~var2} is not
%   a valid sequence of bytes in the \texttt{UTF8} encoding.
%   In the \pdfTeX{} engine, this function raises an error if any of the
%   resulting characters is outside the range $0$--$255$ (in other words,
%   don't use this function with \pdfTeX{}).
% \end{function}
%
% \begin{function}{\str_bytes_UTF_viii_from_native:NN}
%   \begin{syntax}
%     \cs{str_bytes_UTF_viii_from_native:NN} \meta{str~var1} \meta{str~var2}
%   \end{syntax}
%   Converts each character of the \meta{str~var2} into
%   a sequence of bytes, as defined by the \texttt{UTF8}
%   encoding, and stores the result in \meta{str~var1}.
%   In the \pdfTeX{} engine, this function is of course
%   of very little use, but can be used without harm:
%   characters in the range $0$--$127$ are left unchanged,
%   and characters in the range $128$--$255$ become two-byte
%   sequences, as per the definition of \texttt{UTF8}.
% \end{function}
%
% \begin{function}{\str_bytes_escape_hexadecimal:NN}
% \begin{function}{\str_bytes_unescape_hexadecimal:NN}
%   \begin{syntax}
%     \cs{str_bytes_escape_hexadecimal:NN} \meta{str var1} \meta{str var2}
%     \cs{str_bytes_unescape_hexadecimal:NN} \meta{str var1} \meta{str var2}
%   \end{syntax}
%   See \cs{pdfescapehex}.
% \end{function}
% \end{function}
%
% \begin{function}{\str_bytes_escape_name:NN}
% \begin{function}{\str_bytes_unescape_name:NN}
%   \begin{syntax}
%     \cs{str_bytes_escape_name:NN} \meta{str var1} \meta{str var2}
%     \cs{str_bytes_unescape_name:NN} \meta{str var1} \meta{str var2}
%   \end{syntax}
%   See \cs{pdfescapename}.
% \end{function}
% \end{function}
%
% \begin{function}{\str_bytes_escape_string:NN}
% \begin{function}{\str_bytes_unescape_string:NN}
%   \begin{syntax}
%     \cs{str_bytes_escape_string:NN} \meta{str var1} \meta{str var2}
%     \cs{str_bytes_unescape_string:NN} \meta{str var1} \meta{str var2}
%   \end{syntax}
%   See \cs{pdfescapestring}.
% \end{function}
% \end{function}
%
% \begin{function}{\str_bytes_percent_encode:NN}
% \begin{function}{\str_bytes_percent_decode:NN}
%   \begin{syntax}
%     \cs{str_bytes_percent_encode:NN} meta{str var1} \meta{str var2}
%     \cs{str_bytes_percent_decode:NN} meta{str var1} \meta{str var2}
%   \end{syntax}
%   Used for urls.
% \end{function}
% \end{function}
%
% \section{Possibilities}
%
% \begin{itemize}
% \item More encodings (see Heiko's \pkg{stringenc}).
%   In particular, what is needed for pdf: \texttt{UTF-16}?
%   Also, percent encoding.
% \item \cs{str_between:nnn} \Arg{str}
%   \Arg{begin delimiter} \Arg{end delimiter} giving the piece of
%   \meta{str} between \meta{begin} and \meta{end}; could be used
%   with empty \meta{begin} or \meta{end} to indicate that we
%   want everything until \meta{end} or starting from \meta{begin},
%   respectively;
% \item \cs{str_count_in:nn} \Arg{str} \Arg{substr} giving the number
%   of occurrences of \meta{substr} in \meta{str};
% \item \cs{str_if_head_eq:nN} alias of \cs{tl_if_head_eq_charcode:nN}
% \item \cs{str_if_numeric/decimal/integer:n}, perhaps in \pkg{l3fp}?
% \item \cs{tl_if_str:N} to test whether a tl var is a valid str var?
% \end{itemize}
% Some functionalities of \pkg{stringstrings} and \pkg{xstring} as well.
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3str} implementation}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%    \end{macrocode}
%
% Those string-related functions are defined in \pkg{l3kernel}.
% \begin{itemize}
% \item \cs{str_if_eq:nn}[pTF] and variants,
% \item \cs{str_if_eq_return:on},
% \item \cs{tl_to_str:n}, \cs{tl_to_str:N}, \cs{tl_to_str:c},
% \item \cs{token_to_str:N}, \cs{cs_to_str:N}
% \item \cs{str_head:n}, \cs{str_head_aux:w}, (changed behaviour slightly)
% \item \cs{str_tail:n}, \cs{str_tail_aux:w}, (changed behaviour slightly)
% \item \cs{str_length_skip_spaces} (deprecated)
% \item \cs{str_length_loop:NNNNNNNNN} (unchanged)
% \end{itemize}
%
% \subsection{Converting between token lists and strings}
%
% \begin{macro}[EXP]{\tl_to_other_str:N,\tl_to_other_str:n}
% \begin{macro}[EXP,aux]{\tl_to_other_str_loop:w,\tl_to_other_str_end:w}
%   Replaces all spaces by \enquote{other} spaces, after converting
%   the token list to a string via \cs{tl_to_str:n}.
%    \begin{macrocode}
\group_begin:
\char_set_lccode:nn {`\*}{`\ }
\char_set_lccode:nn {`\A}{`\A}
\tl_to_lowercase:n {
  \group_end:
  \cs_new:Npn \tl_to_other_str:n #1
    {
      \exp_after:wN \tl_to_other_str_loop:w \tl_to_str:n {#1} ~ %
      A ~ A ~ A ~ A ~ A ~ A ~ A ~ A ~ \q_mark \q_stop
    }
  \cs_new_nopar:Npn \tl_to_other_str_loop:w
      #1 ~ #2 ~ #3 ~ #4 ~ #5 ~ #6 ~ #7 ~ #8 ~ #9 \q_stop
    {
      \if_meaning:w A #8
        \tl_to_other_str_end:w
      \fi:
      \tl_to_other_str_loop:w
      #9 #1 * #2 * #3 * #4 * #5 * #6 * #7 * #8 * \q_stop
    }
  \cs_new_nopar:Npn \tl_to_other_str_end:w \fi: #1 \q_mark #2 * A #3 \q_stop
    { \fi: #2 }
}
\cs_new_nopar:Npn \tl_to_other_str:N
  { \exp_args:No \tl_to_other_str:n }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_sanitize_args:Nn,\str_sanitize_args:Nnn}
%   Here, \texttt{f}-expansion does not lose leading spaces,
%   since they have catcode \enquote{other} after \cs{str_sanitize:n}.
%    \begin{macrocode}
\cs_new:Npn \str_sanitize_args:Nn #1 #2
  {
    \exp_args:Nf #1
      { \tl_to_other_str:n {#2} }
  }
\cs_new:Npn \str_sanitize_args:Nnn #1#2#3
  {
    \exp_args:Nff #1
      { \tl_to_other_str:n {#2} }
      { \tl_to_other_str:n {#3} }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Variables and constants}
%
% \begin{variable}{\g_str_tmpa_tl}
%   Internal variable needed to do the expansion in
%   \cs{str_set:Nx} before assigning.
%    \begin{macrocode}
\tl_new:N \g_str_tmpa_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\str_new:N,\str_const:Nn,\str_set:Nn,\str_gset:Nn}
%   Simply convert the token list inputs to \meta{other strings}.
%    \begin{macrocode}
\cs_new_eq:NN \str_new:N \tl_new:N
\cs_new_protected:Npn \str_const:Nn #1 #2
  { \tl_const:Nx #1 { \tl_to_other_str:n {#2} } }
\cs_new_protected:Npn \str_set:Nn #1 #2
  { \tl_set:Nx #1 { \tl_to_other_str:n {#2} } }
\cs_new_protected:Npn \str_gset:Nn #1 #2
  { \tl_gset:Nx #1 { \tl_to_other_str:n {#2} } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\str_const:Nx,\str_set:Nx,\str_gset:Nx}
%   First expand, then convert to \meta{other string}.
%    \begin{macrocode}
\cs_new_protected:Npn \str_const:Nx #1 #2
  {
    \tl_gset:Nx \g_str_tmpa_tl {#2}
    \tl_const:Nx #1 { \tl_to_other_str:N \g_str_tmpa_tl }
  }
\cs_new_protected:Npn \str_set:Nx #1 #2
  {
    \tl_gset:Nx \g_str_tmpa_tl {#2}
    \tl_set:Nx #1 { \tl_to_other_str:N \g_str_tmpa_tl }
  }
\cs_new_protected:Npn \str_gset:Nx #1 #2
  {
    \tl_gset:Nx \g_str_tmpa_tl {#2}
    \tl_gset:Nx #1 { \tl_to_other_str:N \g_str_tmpa_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_tmpa_str,\l_tmpb_str}
% \begin{variable}{\g_tmpa_str,\g_tmpb_str}
%   A few scratch variables for short-term storage.
%    \begin{macrocode}
\str_new:N \l_tmpa_str
\str_new:N \l_tmpb_str
\str_new:N \g_tmpa_str
\str_new:N \g_tmpb_str
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{variable}{\c_space_str,\c_backslash_str,
%     \c_lbrace_str,\c_rbrace_str,\c_hash_str,\c_percent_str}
%   It is faster here to use \cs{tl_const:Nx} than \cs{str_const:Nx}
%   (but evil?). On the other hand, we need the space to
%   be converted to an \enquote{other} space.
%    \begin{macrocode}
\tl_const:Nx \c_backslash_str { \cs_to_str:N \\ }
\tl_const:Nx \c_lbrace_str    { \cs_to_str:N \{ }
\tl_const:Nx \c_rbrace_str    { \cs_to_str:N \} }
\tl_const:Nx \c_hash_str      { \cs_to_str:N \# }
\tl_const:Nx \c_percent_str   { \cs_to_str:N \% }
\str_const:Nn \c_space_str { ~ }
%    \end{macrocode}
% \end{variable}
%
% \subsection{Characters given by their position}
%
% \begin{macro}[EXP]{\str_length:N}
% \begin{macro}[EXP]{\str_length:n}
% \begin{macro}[EXP]{\str_length_ignore_spaces:n}
% \begin{macro}[EXP]{\str_length_unsafe:n}
% \begin{macro}[EXP,aux]{\str_length_aux:n,\str_length_loop:NNNNNNNNN}
%   The length of a string is found by first changing all spaces
%   to other spaces using \cs{tl_to_other_str:n}, then counting
%   characters $9$ at a time. When the end is reached, |#9|
%   has the form |X|\meta{digit}, the catcode test is true,
%   the digit gets added to the sum, and the loop is terminated
%   by \cs{use_none_delimit_by_q_stop:w}.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_length:N #1
  { \str_length_aux:n { \exp_after:wN \str_length_loop:NNNNNNNNN #1 } }
\cs_new:Npn \str_length:n { \str_sanitize_args:Nn \str_length_unsafe:n }
\cs_new_nopar:Npn \str_length_unsafe:n #1
  { \str_length_aux:n { \str_length_loop:NNNNNNNNN #1 } }
\cs_new:Npn \str_length_ignore_spaces:n #1
  {
    \str_length_aux:n
      { \exp_after:wN \str_length_loop:NNNNNNNNN \tl_to_str:n {#1} }
  }
\cs_new:Npn \str_length_aux:n #1
  {
    \int_eval:n
      {
        #1
        { X \c_eight } { X \c_seven } { X \c_six   }
        { X \c_five  } { X \c_four  } { X \c_three }
        { X \c_two   } { X \c_one   } { X \c_zero  }
        \q_stop
      }
  }
\cs_set:Npn \str_length_loop:NNNNNNNNN #1#2#3#4#5#6#7#8#9
  {
    \if_catcode:w X #9
      \exp_after:wN \use_none_delimit_by_q_stop:w
    \fi:
    \c_nine + \str_length_loop:NNNNNNNNN
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_head:N}
% \begin{macro}[EXP]{\str_head:n}
% \begin{macro}[EXP]{\str_head_ignore_spaces:n}
% \begin{macro}[EXP]{\str_head_unsafe:n}
% \begin{macro}[EXP,aux]{\str_head_aux:w}
%    \begin{macrocode}
\cs_set_nopar:Npn \str_head:N #1
  { \exp_after:wN \use_i_delimit_by_q_stop:nw #1 { } \q_stop }
\cs_new:Npn \str_head_ignore_spaces:n #1
  { \exp_after:wN \use_i_delimit_by_q_stop:nw \tl_to_str:n {#1} { } \q_stop }
\cs_new_nopar:Npn \str_head_unsafe:n #1
  { \use_i_delimit_by_q_stop:nw #1 { } \q_stop }
\cs_set:Npn \str_head:n #1
  {
    \exp_after:wN \str_head_aux:w
    \tl_to_str:n {#1}
    { { } } ~ \q_stop
  }
\cs_set_nopar:Npx \str_head_aux:w #1 ~ %
  { \exp_not:N \use_i_delimit_by_q_stop:nw #1 \c_space_str }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_tail:N}
% \begin{macro}[EXP]{\str_tail:n}
% \begin{macro}[EXP]{\str_tail_ignore_spaces:n}
% \begin{macro}[EXP]{\str_tail_unsafe:n}
% \begin{macro}[EXP,aux]{\str_tail_aux:w}
%    \begin{macrocode}
\cs_new_nopar:Npn \str_tail:N #1
  {
    \exp_after:wN \str_tail_aux:w
    #1
    X { } X \q_stop
  }
\cs_set:Npn \str_tail:n #1
  {
    \exp_last_unbraced:Nf \str_tail_aux:w
      { \tl_to_other_str:n {#1} }
    X { } X \q_stop
  }
\cs_new:Npn \str_tail_ignore_spaces:n #1
  {
    \exp_after:wN \str_tail_aux:w
    \tl_to_str:n {#1}
    X { } X \q_stop
  }
\cs_new_nopar:Npn \str_tail_unsafe:n #1
  {
    \str_tail_aux:w
    #1
    X { } X \q_stop
  }
\cs_set_nopar:Npn \str_tail_aux:w #1 #2 X #3 \q_stop { #2 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Extracting sub-strings}
%
% \begin{macro}[EXP,int]{\str_skip_many_do:nnw}
% \begin{macro}[rEXP,int]{\str_keep_many_do:nnw}
%   The \texttt{skip_many} function gobbles a number of arguments given by
%   its first argument, then performs its second argument.
%   If the number is zero or negative, nothing is removed.
%   The \texttt{keep_many} outputs the arguments to the left
%   into the input stream.
%    \begin{macrocode}
\cs_new:Npn \str_skip_many_do:nnw #1
  {
    \exp_args:NNf \str_many_do_aux:Nn
      \str_skip_many_do_loop:wnnnnnnnn
      { \int_eval:n {#1} }
  }
\cs_new:Npn \str_many_do_aux:Nn #1#2
  {
    \int_compare:nNnTF {#2} > \c_zero
      {
        \exp_args:Nff \str_many_do_aux_ii:nnn
          {
            \exp_after:wN \exp_after:wN
            \exp_after:wN \exp_stop_f:
            \prg_replicate:nn { (#2+4)/8 } { #1 }
          }
          { \prg_replicate:nn { 8*((#2+4)/8) - #2 } { {} } }
      }
      { \use:n }
  }
\cs_new:Npn \str_many_do_aux_ii:nnn #1#2#3
  { #1 \use_i:nn {#3} \q_stop #2 }
\cs_new:Npn \str_skip_many_do_loop:wnnnnnnnn #1 \q_stop #2#3#4#5#6#7#8#9
  { #1 \q_stop }
\cs_new:Npn \str_keep_many_do:nnw #1
  {
    \exp_args:NNf \str_many_do_aux:Nn
      \str_keep_many_do_loop:wnnnnnnnn
      { \int_eval:n {#1} }
  }
\cs_new:Npn \str_keep_many_do_loop:wnnnnnnnn #1 \q_stop #2#3#4#5#6#7#8#9
  { #2#3#4#5#6#7#8#9 #1 \q_stop }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_item:Nn}
% \begin{macro}[EXP]{\str_item:nn}
% \begin{macro}[EXP]{\str_item_ignore_spaces:nn}
% \begin{macro}[EXP]{\str_item_unsafe:nn}
% \begin{macro}[EXP,aux]{\str_item_aux:nn}
%   The \cs{str_item_ignore_spaces:nn} function cheats a little bit
%   in that it doesn't hand to \cs{str_item_unsafe:nn} a true
%   \meta{other string}. This is alright, as everything else
%   is done with undelimited arguments.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_item:Nn
  { \exp_args:No \str_item_unsafe:nn }
\cs_new_nopar:Npn \str_item:nn
  { \str_sanitize_args:Nn \str_item_unsafe:nn }
\cs_new:Npn \str_item_ignore_spaces:nn #1
  { \exp_args:No \str_item_unsafe:nn { \tl_to_str:n {#1} } }
\cs_new_nopar:Npn \str_item_unsafe:nn #1#2
  {
    \exp_args:Nff \str_item_aux:nn
      { \int_eval:n {#2} }
      { \str_length_unsafe:n {#1} }
      #1
    \q_stop
  }
\cs_new_nopar:Npn \str_item_aux:nn #1#2
  {
    \int_compare:nNnTF {#1} < \c_zero
      {
        \int_compare:nNnTF {#1} < {-#2}
          { \use_none_delimit_by_q_stop:w }
          {
            \str_skip_many_do:nnw { #1 + #2 }
              { \use_i_delimit_by_q_stop:nw }
          }
      }
      {
        \int_compare:nNnTF {#1} < {#2}
          {
            \str_skip_many_do:nnw {#1}
              { \use_i_delimit_by_q_stop:nw }
          }
          { \use_none_delimit_by_q_stop:w }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_from_to:Nnn}
% \begin{macro}[EXP]{\str_from_to:nnn}
% \begin{macro}[EXP]{\str_from_to_ignore_spaces:nnn}
% \begin{macro}[EXP]{\str_from_to_unsafe:nnn}
% \begin{macro}[EXP,aux]{\str_from_to_aux:nnnn}
%   Sanitize the string, then limit the second and third arguments
%   to be at most the length of the string (this avoids needing
%   to check for the end of the string when grabbing characters).
%   Afterwards, skip characters, then keep some more, and finally
%   drop the end of the string.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_from_to:Nnn
  { \exp_args:No \str_from_to_unsafe:nnn }
\cs_new_nopar:Npn \str_from_to:nnn
  { \str_sanitize_args:Nn \str_from_to_unsafe:nnn }
\cs_new:Npn \str_from_to_ignore_spaces:nnn #1
  {
    \exp_args:Nfo \str_from_to_aux:nnnn
      { \str_length_ignore_spaces:n {#1} }
      { \tl_to_str:n {#1} }
  }
\cs_new:Npn \str_from_to_unsafe:nnn #1
  {
    \exp_args:Nf \str_from_to_aux:nnnn
      { \str_length_unsafe:n {#1} }
      {#1}
  }
\cs_new:Npn \str_from_to_aux:nnnn #1#2#3#4
  {
    \str_skip_many_do:nnw { \int_min:nn {#3} {#1} }
      {
        \str_keep_many_do:nnw
          { \int_min:nn {#4} {#1} - \int_max:nn {\int_min:nn {#3} {#1}} {0} }
          { \use_none_delimit_by_q_stop:w }
      }
    #2
    \q_stop
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{String conditionals}
%
% \begin{macro}[EXP,pTF]{\str_if_eq:NN}
% \begin{macro}[EXP,pTF]{\str_if_eq:nn,\str_if_eq:xx}
%   The \texttt{nn} and \texttt{xx} variants are already
%   defined in \pkg{l3basics}.
%    \begin{macrocode}
\cs_new_eq:NN \str_if_eq_p:NN \tl_if_eq_p:NN
\cs_new_eq:NN \str_if_eq:NNTF \tl_if_eq:NNTF
\cs_new_eq:NN \str_if_eq:NNT  \tl_if_eq:NNT
\cs_new_eq:NN \str_if_eq:NNF  \tl_if_eq:NNF
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\str_if_contains_char:NN}
% \begin{macro}[EXP,pTF]{\str_if_contains_char:nN}
% \begin{macro}[EXP,aux]{\str_if_contains_char_aux:nN}
% \begin{macro}[EXP,aux]{\str_if_contains_char_loop:NN}
%   Loop over the characters of the string, comparing character codes.
%   We allow |#2| to be a single-character control sequence, hence the
%   use of \cs{if_int_compare:w} rather than \cs{if_charcode:w}.
%   The loop is broken if character codes match. Otherwise,
%   the trailing brace group is taken as the second argument of
%   \cs{str_if_contains_char_loop:NN}, makes the test be true,
%   cleans up, and returns \enquote{false}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \str_if_contains_char:NN #1#2 { p , T , F , TF }
  { \exp_args:No \str_if_contains_char_aux:nN {#1} #2 }
\prg_new_conditional:Npnn \str_if_contains_char:nN #1#2 { p , T , F , TF }
  { \str_sanitize_args:Nn \str_if_contains_char_aux:nN {#1} #2 }
\cs_new_nopar:Npn \str_if_contains_char_aux:nN #1#2
  {
    \str_if_contains_char_loop:NN #2
      #1
      { #2 \exp_stop_f: \prg_return_false: \use_none:nn }
    \q_stop
  }
\cs_new_nopar:Npn \str_if_contains_char_loop:NN #1 #2
  {
    \if_int_compare:w `#1 = `#2 \exp_stop_f:
      \prg_return_true:
      \exp_after:wN \use_none_delimit_by_q_stop:w
    \fi:
    \str_if_contains_char_loop:NN #1
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Experimental string functions}
%
% \begin{macro}{\str_map_function:NN}
%   Faster than the \cs{tl_map_function:NN} function.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_map_function:NN #1#2
  {
    \exp_after:wN \str_map_function_aux:NN
    \exp_after:wN #2 #1 \q_recursion_tail \q_recursion_stop
  }
\cs_new_nopar:Npn \str_map_function_aux:NN #1#2
  {
    \quark_if_recursion_tail_stop:N #2
    #1 #2
    \str_map_function_aux:NN #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\str_aux_convert_store:NNn}
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_other:n {`\^^@}
  \cs_new_protected_nopar:Npn \str_aux_convert_store:NNn #1#2#3
    {
      \char_set_lccode:nn {`\^^@} {#3}
      \tl_to_lowercase:n { #1 #2 {^^@} }
    }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Conditionals}
%
% \begin{macro}[EXP,pTF]{\str_if_bytes:N}
%    \begin{macrocode}
\prg_new_conditional:Npnn \str_if_bytes:N #1 { p , T , F , TF }
  {
    \exp_after:wN \str_if_bytes_loop:N
    #1 \q_recursion_tail \q_recursion_stop
  }
\cs_new_nopar:Npn \str_if_bytes_loop:N #1
  {
    \quark_if_recursion_tail_stop_do:Nn #1 { \prg_return_true: }
    \int_compare:nNnTF {`#1} < {256}
      { \str_if_bytes_loop:N }
      { \prg_return_false: \use_none_delimit_by_q_recursion_stop:w }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Escape and unescape strings for pdf use}
%
% \begin{macro}{\str_aux_char_if_hexadecimal_digit:NTF}
%   Either $0$--$9$ or \texttt{A}--\texttt{F} or \texttt{a}--\texttt{f}
%   gives \texttt{true}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npx \str_aux_char_if_hexadecimal_digit:NTF #1
  { \tl_if_in:nnTF { \tl_to_str:n {0123456789ABCDEFabcdef} } {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\str_aux_char_if_octal_digit:NTF}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \str_aux_char_if_octal_digit:NTF #1
  { \tl_if_in:nnTF { 01234567 } {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\str_aux_byte_to_hexadecimal:N}
%    \begin{macrocode}
\cs_new_nopar:Npn \str_aux_byte_to_hexadecimal:N #1
  {
    \int_compare:nNnTF {`#1} < {256}
      {
        \int_to_letter:n { \int_div_truncate:nn {`#1} \c_sixteen }
        \int_to_letter:n { \int_mod:nn {`#1} \c_sixteen }
      }
      { \msg_expandable_error:n { Invalid~byte~`#1'. } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\str_aux_byte_to_octal:N}
%    \begin{macrocode}
\cs_new_nopar:Npn \str_aux_byte_to_octal:N #1
  {
    \int_compare:nNnTF {`#1} < {64}
      {
        0
        \int_to_letter:n { \int_div_truncate:nn {`#1} \c_eight }
        \int_to_letter:n { \int_mod:nn {`#1} \c_eight }
      }
      {
        \int_compare:nNnTF {`#1} < {256}
          { \int_to_octal:n {`#1} }
          { \msg_expandable_error:n { Invalid~byte~`#1'. } }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\str_bytes_escape_hexadecimal:NN}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \str_bytes_escape_hexadecimal:NN #1#2
  {
    \str_set:Nx #1
      { \str_map_function:NN #2 \str_aux_byte_to_hexadecimal:N }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\str_bytes_escape_name:NN}
%    \begin{macrocode}
\str_const:Nx \c_str_bytes_escape_name_str
  { \c_hash_str \c_percent_str () /<>[]{} }
\cs_new_protected_nopar:Npn \str_bytes_escape_name:NN #1#2
  {
    \str_set:Nx #1
      { \str_map_function:NN #2 \str_bytes_escape_name_aux:N }
  }
\cs_new_nopar:Npn \str_bytes_escape_name_aux:N #1
  {
    \int_compare:nNnTF {`#1} < {"21}
      { \c_hash_str \str_aux_byte_to_hexadecimal:N #1 }
      {
        \int_compare:nNnTF {`#1} > {"7E}
          { \c_hash_str \str_aux_byte_to_hexadecimal:N #1 }
          {
            \str_if_contains_char:NNTF \c_str_bytes_escape_name_str #1
              { \c_hash_str \str_aux_byte_to_hexadecimal:N #1 }
              {#1}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\str_bytes_escape_string:NN}
%   Any character below (and including) space, and any character
%   above (anc including) \texttt{del}, are converted to octal.
%   One backslash is added before each parenthesis and backslash.
%    \begin{macrocode}
\str_const:Nx \c_str_bytes_escape_string_str { \c_backslash_str ( ) }
\cs_new_protected_nopar:Npn \str_bytes_escape_string:NN #1#2
  {
    \str_set:Nx #1
      { \str_map_function:NN #2 \str_bytes_escape_string_aux:N }
  }
\cs_new_nopar:Npn \str_bytes_escape_string_aux:N #1
  {
    \int_compare:nNnTF {`#1} < {"21}
      { \c_backslash_str \str_aux_byte_to_octal:N #1 }
      {
        \int_compare:nNnTF {`#1} > {"7E}
          { \c_backslash_str \str_aux_byte_to_octal:N #1 }
          {
            \str_if_contains_char:NNT \c_str_bytes_escape_string_str #1
              { \c_backslash_str }
            #1
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\str_bytes_unescape_hexadecimal:NN}
%   Takes chars two by two, and interprets each pair as a hexadecimal code
%   for a character. Any non-hexadecimal-digit is ignored. An odd-length
%   string gets a |0| appended to it.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \str_bytes_unescape_hexadecimal:NN #1#2
  {
    \group_begin:
      \tl_gclear:N \g_str_tmpa_tl
      \exp_after:wN \str_bytes_unescape_hexadecimal_aux:N #2
      \q_recursion_tail \q_recursion_stop
    \group_end:
    \tl_set_eq:NN #1 \g_str_tmpa_tl
  }
\cs_new_protected_nopar:Npn \str_bytes_unescape_hexadecimal_aux:N #1
  {
    \quark_if_recursion_tail_stop:N #1
    \str_aux_char_if_hexadecimal_digit:NTF #1
      { \str_bytes_unescape_hexadecimal_aux_ii:NN #1 }
      { \str_bytes_unescape_hexadecimal_aux:N }
  }
\cs_new_protected_nopar:Npn \str_bytes_unescape_hexadecimal_aux_ii:NN #1#2
  {
    \quark_if_recursion_tail_stop_do:Nn #2
      {
        \str_aux_convert_store:NNn
          \tl_gput_right:Nx \g_str_tmpa_tl { "#1 0 }
      }
    \str_aux_char_if_hexadecimal_digit:NTF #2
      {
        \str_aux_convert_store:NNn
          \tl_gput_right:Nx \g_str_tmpa_tl { "#1#2 }
        \str_bytes_unescape_hexadecimal_aux:N
      }
      { \str_bytes_unescape_hexadecimal_aux_ii:NN #1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\str_bytes_unescape_name:NN}
%   This changes all occurrences of |#| followed by two upper- or lowercase
%   hexadecimal digits by the corresponding unescaped character.
%    \begin{macrocode}
\group_begin:
  \char_set_lccode:nn {`\*} {`\#}
  \tl_to_lowercase:n
    {
      \group_end:
      \cs_new_protected_nopar:Npn \str_bytes_unescape_name:NN #1#2
        {
          \group_begin:
            \tl_gclear:N \g_str_tmpa_tl
            \exp_after:wN \str_bytes_unescape_name_aux:wN #2
            * \q_recursion_tail \q_recursion_stop
          \group_end:
          \tl_set_eq:NN #1 \g_str_tmpa_tl
        }
      \cs_new_protected_nopar:Npn \str_bytes_unescape_name_aux:wN #1 * #2
        {
          \tl_gput_right:Nx \g_str_tmpa_tl {#1}
          \quark_if_recursion_tail_stop:N #2
          \str_aux_char_if_hexadecimal_digit:NTF #2
            { \str_bytes_unescape_name_aux_ii:NN #2 }
            {
              \tl_gput_right:Nx \g_str_tmpa_tl { \c_hash_str }
              \str_bytes_unescape_name_aux:wN #2
            }
        }
    }
\cs_new_protected_nopar:Npn \str_bytes_unescape_name_aux_ii:NN #1#2
  {
    \str_aux_char_if_hexadecimal_digit:NTF #2
      {
        \str_aux_convert_store:NNn
          \tl_gput_right:Nx \g_str_tmpa_tl { "#1#2 }
        \str_bytes_unescape_name_aux:wN
      }
      {
        \tl_gput_right:Nx \g_str_tmpa_tl {#1}
        \str_bytes_unescape_name_aux:wN #2
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\str_bytes_unescape_string:NN}
%   Here, we need to detect backslashes, which escape characters
%   as follows.
%   \begin{itemize}
%   \item[\texttt{\string\n}] Line feed ($10$)
%   \item[\texttt{\string\r}] Carriage return ($13$)
%   \item[\texttt{\string\t}] Horizontal tab ($9$)
%   \item[\texttt{\string\b}] Backspace ($8$)
%   \item[\texttt{\string\f}] Form feed ($12$)
%   \item[\texttt{(}] Left parenthesis
%   \item[\texttt{)}] Right parenthesis
%   \item[\texttt{\string\\}] Backslash
%   \item[\texttt{\string\ddd}] Character code \texttt{ddd} (octal)
%   \end{itemize}
%   If followed by an end-of-line character, the backslash and
%   the end-of-line are ignored. If followed by anything else,
%   the backslash is ignored.
%   The pdf specification indicates that LF, CR, and CRLF should be
%   converted to LF: \emph{this is not implemented here}.
%    \begin{macrocode}
\group_begin:
  \char_set_lccode:nn {`\*} {`\\}
  \char_set_catcode_other:N \^^J
  \char_set_catcode_other:N \^^M
  \tl_to_lowercase:n
    {
      \group_end:
      \cs_new_protected_nopar:Npn \str_bytes_unescape_string:NN #1#2
        {
          \group_begin:
            \tl_gclear:N \g_str_tmpa_tl
            \exp_after:wN \str_bytes_unescape_string_aux:wN #2
            * \q_recursion_tail \q_recursion_stop
          \group_end:
          \tl_set_eq:NN #1 \g_str_tmpa_tl
        }
      \cs_new_protected_nopar:Npn \str_bytes_unescape_string_aux:wN #1 * #2
        {
          \tl_gput_right:Nx \g_str_tmpa_tl {#1}
          \quark_if_recursion_tail_stop:N #2
          \str_aux_char_if_octal_digit:NTF #2
            { \str_bytes_unescape_string_aux_d:NN #2 }
            {
              \int_set:Nn \l_str_char_int
                {
                  \prg_case_str:xxn {#2}
                    {
                      {n} {10}
                      {r} {13}
                      {t} {9}
                      {b} {8}
                      {f} {12}
                      {(} {40}
                      {)} {41}
                      {\c_backslash_str} {92}
                      {^^J} {-1}
                      {^^M} {-1}
                    }
                    {`#2}
                }
              \int_compare:nNnF \l_str_char_int = \c_minus_one
                {
                  \str_aux_convert_store:NNn
                    \tl_gput_right:Nx \g_str_tmpa_tl \l_str_char_int
                }
              \str_bytes_unescape_string_aux:wN
            }
        }
    }
\cs_new_protected_nopar:Npn \str_bytes_unescape_string_aux_d:NN #1#2
  {
    \str_aux_char_if_octal_digit:NTF #2
      { \str_bytes_unescape_string_aux_dd:NNN #1#2 }
      {
        \str_aux_convert_store:NNn
          \tl_gput_right:Nx \g_str_tmpa_tl {'#1}
        \str_bytes_unescape_string_aux:wN #2
      }
  }
\cs_new_protected_nopar:Npn \str_bytes_unescape_string_aux_dd:NNN #1#2#3
  {
    \str_aux_char_if_octal_digit:NTF #3
      {
        \str_aux_convert_store:NNn
          \tl_gput_right:Nx \g_str_tmpa_tl {'#1#2#3}
        \str_bytes_unescape_string_aux:wN
      }
      {
        \str_aux_convert_store:NNn
          \tl_gput_right:Nx \g_str_tmpa_tl {'#1#2}
        \str_bytes_unescape_string_aux:wN #3
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Percent encoding}
%
% \begin{macro}{\str_bytes_percent_encode:NN}
%    \begin{macrocode}
\str_const:Nn \c_str_bytes_percent_encode_str { [] }
\str_const:Nn \c_str_bytes_percent_encode_not_str { "-.<> }
\cs_new_protected_nopar:Npn \str_bytes_percent_encode:NN #1#2
  {
    \str_set:Nx #1
      { \str_map_function:NN #2 \str_bytes_percent_encode_aux:N }
  }
\cs_new_nopar:Npn \str_bytes_percent_encode_aux:N #1
  {
    \int_compare:nNnTF {`#1} < {"41}
      {
        \str_if_contains_char:NNTF \c_str_bytes_percent_encode_not_str #1
          { #1 }
          { \c_percent_str \str_aux_byte_to_hexadecimal:N #1 }
      }
      {
        \int_compare:nNnTF {`#1} > {"7E}
          { \c_percent_str \str_aux_byte_to_hexadecimal:N #1 }
          {
            \str_if_contains_char:NNTF \c_str_bytes_percent_encode_str #1
              { \c_percent_str \str_aux_byte_to_hexadecimal:N #1 }
              { #1 }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\str_bytes_percent_decode:NN}
%    \begin{macrocode}
\group_begin:
  \char_set_lccode:nn {`\*} {`\%}
  \tl_to_lowercase:n
    {
      \group_end:
      \cs_new_protected_nopar:Npn \str_bytes_percent_decode:NN #1#2
        {
          \group_begin:
            \tl_gclear:N \g_str_tmpa_tl
            \exp_after:wN \str_bytes_percent_decode_aux:wN #2
            * \q_recursion_tail \q_recursion_stop
          \group_end:
          \tl_set_eq:NN #1 \g_str_tmpa_tl
        }
      \cs_new_protected_nopar:Npn \str_bytes_percent_decode_aux:wN #1 * #2
        {
          \tl_gput_right:Nx \g_str_tmpa_tl {#1}
          \quark_if_recursion_tail_stop:N #2
          \str_aux_char_if_hexadecimal_digit:NTF #2
            { \str_bytes_percent_decode_aux_ii:NN #2 }
            {
              \tl_gput_right:Nx \g_str_tmpa_tl { \c_percent_str }
              \str_bytes_percent_decode_aux:wN #2
            }
        }
    }
\cs_new_protected_nopar:Npn \str_bytes_percent_decode_aux_ii:NN #1#2
  {
    \str_aux_char_if_hexadecimal_digit:NTF #2
      {
        \str_aux_convert_store:NNn
          \tl_gput_right:Nx \g_str_tmpa_tl { "#1#2 }
        \str_bytes_percent_decode_aux:wN
      }
      {
        \tl_gput_right:Nx \g_str_tmpa_tl {#1}
        \str_bytes_percent_decode_aux:wN #2
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{UTF-8 support}
%
% \begin{variable}{\l_str_char_int,\l_str_bytes_int}
%    \begin{macrocode}
\int_new:N \l_str_char_int  % holds the number of bytes expected
\int_new:N \l_str_bytes_int % holds the value of the current char
\tl_new:N \g_str_tmpb_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\str_native_from_bytes_UTF_viii:NN}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \str_native_from_bytes_UTF_viii:NN #1#2
  {
    \group_begin:
      \tl_gclear:N \g_str_tmpa_tl
      \exp_after:wN \str_native_from_bytes_UTF_viii_aux_i:N
      #2 \q_recursion_tail \q_recursion_stop
    \group_end:
    \tl_set_eq:NN #1 \g_str_tmpa_tl
  }
\cs_new_protected_nopar:Npn \str_native_from_bytes_UTF_viii_aux_i:N #1
  {
    \quark_if_recursion_tail_stop:N #1
    \int_set:Nn \l_str_char_int { `#1 }
    \str_native_from_bytes_UTF_viii_aux_ii:nN {128} \c_one
    \str_native_from_bytes_UTF_viii_aux_ii:nN {64}  \c_zero
    \str_native_from_bytes_UTF_viii_aux_ii:nN {32}  \c_two
    \str_native_from_bytes_UTF_viii_aux_ii:nN {16}  \c_three
    \str_native_from_bytes_UTF_viii_aux_ii:nN {8}   \c_four
    \msg_error:nnx { str } { utf8-invalid-byte } {#1}
    \use_i:nnn \str_native_from_bytes_UTF_viii_aux_i:N
    \q_stop
    \str_native_from_bytes_UTF_viii_aux_iii:N
  }
\cs_new_protected_nopar:Npn
  \str_native_from_bytes_UTF_viii_aux_ii:nN #1#2
  {
    \int_compare:nNnTF \l_str_char_int < {#1}
      {
        \int_set_eq:NN \l_str_bytes_int #2
        \use_none_delimit_by_q_stop:w
      }
      { \int_sub:Nn \l_str_char_int {#1} }
  }
\cs_new_protected_nopar:Npn
  \str_native_from_bytes_UTF_viii_aux_iii:N #1
  {
    \int_compare:nNnTF \l_str_bytes_int < \c_two
      { \str_native_from_bytes_UTF_viii_aux_iv: #1 }
      {
        \if_meaning:w \q_recursion_tail #1
          \msg_error:nn { str } { utf8-premature-end }
          \exp_after:wN \use_none_delimit_by_q_recursion_stop:w
        \fi:
        \quark_if_recursion_tail_stop:N #1
        \tex_multiply:D \l_str_char_int by 64 \scan_stop: % no interface??
        \int_decr:N \l_str_bytes_int
        \int_compare:nNnTF {`#1} < {128}
          { \use_ii:nn }
          { \int_compare:nNnTF {`#1} < {192} }
          {
            \int_add:Nn \l_str_char_int { `#1 - 128 }
            \str_native_from_bytes_UTF_viii_aux_iii:N
          }
          {
            \msg_error:nnx { str } { utf8-missing-byte } {#1}
            \str_native_from_bytes_UTF_viii_aux_i:N #1
          }
      }
  }
\cs_new_protected_nopar:Npn
  \str_native_from_bytes_UTF_viii_aux_iv:
  {
    \int_compare:nNnTF \l_str_bytes_int = \c_zero
      {
        \msg_error:nnx { str } { utf8-extra-byte }
          { \int_eval:n { \l_str_char_int + 128 } }
      }
      {
        \pdftex_if_engine:TF
          {
            \int_compare:nNnTF { \l_str_char_int } < { 256 }
              { \use:n }
              {
                \msg_error:nnx { str } { utf8-pdftex-overflow }
                  { \int_use:N \l_str_char_int }
                \use_none:n
              }
          }
          { \use:n }
          {
            \str_aux_convert_store:NNn
              \tl_gput_right:Nx \g_str_tmpa_tl { \l_str_char_int }
          }
      }
    \str_native_from_bytes_UTF_viii_aux_i:N
  }
\msg_new:nnn { str } { utf8-invalid-byte }
  {
    \int_compare:nNnTF {`#1} < {256}
      { Byte~number~\int_eval:n {`#1}~invalid~in~utf-8~encoding. }
      { The~character~number~\int_eval:n {`#1}~is~not~a~byte. }
  }
\msg_new:nnn { str } { utf8-missing-byte }
  { The~byte~number~\int_eval:n {`#1}~is~not~a~valid~continuation~byte. }
\msg_new:nnn { str } { utf8-extra-byte }
  { The~byte~number~\int_eval:n {`#1}~is~only~valid~as~a~continuation~byte. }
\msg_new:nnnn { str } { utf8-premature-end }
  { Incomplete~last~utf8~character. }
  {
    The~sequence~of~byte~that~I~need~to~convert~to~utf8 \
    ended~before~the~last~character~was~complete.~Perhaps \
    it~was~mistakenly~truncated?
  }
\msg_new:nnn { str } { utf8-pdftex-overflow }
  { The~character~number~#1~is~too~big~for~pdfTeX. }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\str_bytes_UTF_viii_from_native:NN}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \str_bytes_UTF_viii_from_native:NN #1#2
  {
    \group_begin:
      \tl_gclear:N \g_str_tmpa_tl
      \str_map_function:NN #2 \str_bytes_UTF_viii_from_native_aux_i:N
    \group_end:
    \tl_set_eq:NN #1 \g_str_tmpa_tl
  }
\cs_new_protected_nopar:Npn \str_bytes_UTF_viii_from_native_aux_i:N #1
  {
    \int_set:Nn \l_str_char_int {`#1}
    \int_compare:nNnTF \l_str_char_int < {128}
      { \tl_gput_right:Nx \g_str_tmpa_tl {#1} }
      {
        \tl_gclear:N \g_str_tmpb_tl
        \int_set:Nn \l_str_bytes_int { 64 }
        \str_bytes_UTF_viii_from_native_aux_ii:n {32}
        \str_bytes_UTF_viii_from_native_aux_ii:n {16}
        \str_bytes_UTF_viii_from_native_aux_ii:n {8}
        \ERROR % somehow the unicode char was > "1FFFFF > "10FFFF
        \tl_gclear:N \g_str_tmpb_tl
        \use_none:n \q_stop
        \str_aux_convert_store:NNn
          \tl_gput_right:Nx \g_str_tmpa_tl
          { 2 * \l_str_bytes_int + \l_str_char_int }
        \tl_gput_right:Nx \g_str_tmpa_tl { \g_str_tmpb_tl }
      }
  }
\cs_new_protected_nopar:Npn \str_bytes_UTF_viii_from_native_aux_ii:n #1
  {
    \str_aux_convert_store:NNn
      \tl_gput_left:Nx \g_str_tmpb_tl
      { 128 + \int_mod:nn { \l_str_char_int } {64} }
    \tex_divide:D \l_str_char_int by 64 \scan_stop: % no interface??
    \int_add:Nn \l_str_bytes_int {#1}
    \int_compare:nNnT \l_str_char_int < {#1}
      { \use_none_delimit_by_q_stop:w }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Deprecated string functions}
%
% \begin{macro}{\str_length_skip_spaces:N,\str_length_skip_spaces:n}
%   The naming scheme is a little bit more consistent
%   with \enquote{ignore_spaces} instead of \enquote{skip_spaces}.
%    \begin{macrocode}
\cs_gset_eq:NN \str_length_skip_spaces:N \str_length_ignore_spaces:N
\cs_gset_eq:NN \str_length_skip_spaces:n \str_length_ignore_spaces:n
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
% 
% \PrintIndex
