% \iffalse meta-comment
%
%% File: l3str.dtx Copyright (C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX3 Project.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental Strings}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%
% \title{^^A
%   The \textsf{l3str} package: manipulating strings of characters^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%         
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \section{Variables and constants}
%
% \begin{variable}{\l_tmpa_str,\l_tmpb_str,\g_tmpa_str}
%   Scratch variables, used nowhere in the \LaTeX3 kernel.
% \end{variable}
%
% \begin{variable}{\c_space_str,\c_backslash_str,
%     \c_percent_str,\c_lbrace_str,\c_rbrace_str}
%   Constant strings, containing a single character, with category code $12$.
% \end{variable}
%
% \begin{function}{\str_new:N, \str_const:Nn, \str_set:Nn, \str_gset:Nn}
%   String variables are always \enquote{sanitized}, \emph{i.e.},
%   all the characters have category code \enquote{other}, even spaces!
%   Apart from that, they behave like token lists.
% \end{function}
%
% \section{Head and tail of string}
%
% This is already in \pkg{l3tl}.
%
% \begin{function}[EXP]{\str_head:n,\str_tail:n}
%   \begin{syntax}
%     \cs{str_head:n} \Arg{tokens}
%     \cs{str_tail:n} \Arg{tokens}
%   \end{syntax}
%   Converts the \meta{tokens} into a string, as described for
%   \cs{tl_to_str:n}. The \cs{str_head:n} function then leaves
%   the first character of this string in the input stream.
%   The \cs{str_tail:n} function leaves all characters except
%   the first in the input stream. The first character may be
%   a space. If the \meta{tokens} argument is entirely empty,
%   nothing is left in the input stream.
% \end{function}
% 
% \section{\enquote{Sanitize} strings}
% 
% \begin{function}[EXP]{\str_sanitize:n}
%   \begin{syntax}
%     \cs{str_sanitize:n} \Arg{tokens}
%   \end{syntax}
%   Converts the \meta{tokens} to a string where spaces have
%   category code $10$. This function is f-expandable, and
%   doing so does not lose any space, since f-expansion only
%   loses leading spaces with category code $10$.
% \end{function}
% 
% \begin{function}[EXP]{\str_desanitize:n}
%   \begin{syntax}
%     \cs{str_desanitize:n} \Arg{sanitized string}
%   \end{syntax}
%   Converts catcode-other spaces to normal spaces.
%   \begin{texnote}
%     This is the e\TeX{} primitive \cs{detokenize} renamed.
%   \end{texnote}
% \end{function}
% 
% \begin{function}[EXP]{\str_sanitize_args:Nn,
%     \str_sanitize_args:NNn,\str_sanitize_args:Nnn}
%   \begin{syntax}
%     \cs{str_sanitize_args:Nnn} \meta{function}
%     ~~\Arg{token list1} \Arg{token list2}
%   \end{syntax}
%   Converts the token lists to strings with spaces of category
%   other, and gives the result as arguments to \meta{function}.
% \end{function}
% 
% \begin{function}[TF]{\tl_if_str:n}
%   \begin{syntax}
%     \cs{tl_if_str:nTF} \Arg{token list} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the \meta{token list} is a string or a sanitized string.
% \end{function}
% 
% \begin{variable}{\l_str_tmp_tl}
%   Used for \cs{tl_if_str:nTF}.
% \end{variable}
% 
% \section{Misc}
%
% \begin{function}[EXP]{\str_length:n}
%   \begin{syntax}
%     \cs{str_length:n} \Arg{tokens}
%   \end{syntax}
%   Expands to the number of characters in \meta{tokens}.
% \end{function}
%
% \begin{function}[rEXP]{\str_from_to:nnn,\str_from_to:Nnn}
%   \begin{syntax}
%     \cs{str_from_to:Nnn} \meta{string} \Arg{int1} \Arg{int2}
%   \end{syntax}
%   Extracts the part of the \meta{string} between the \meta{int1}th
%   and the \meta{int2}th character.
% \end{function}
%
% \begin{function}[pTF]{\str_if_contains_char:nN}
%   \begin{syntax}
%     \cs{str_if_contains_char:nN} \Arg{string} \meta{char}
%   \end{syntax}
%   Tests whether the \meta{char} is in the \meta{string}.
%   The \meta{char} is given either directly, or as a one
%   letter control sequence.\footnote{Bruno: is that a
%     good idea?}
% \end{function}
% 
% \section{Possibilities}
% 
% \begin{itemize}
% \item \cs{str_item:nn} \Arg{str} \Arg{int} giving the \meta{int}th
%   character;
% \item \cs{str_substr:nnn} \Arg{str} \Arg{begin int} \Arg{end int}
%   giving the piece of string between positions \meta{begin} and
%   \meta{end}; other packages take the approach \cs{str_substr:nnn}
%   \Arg{str} \Arg{begin} \Arg{length};
% \item \cs{str_between:nnn} \Arg{str}
%   \Arg{begin delimiter} \Arg{end delimiter} giving the piece of
%   \meta{str} between \meta{begin} and \meta{end}; could be used
%   with empty \meta{begin} or \meta{end} to indicate that we
%   want everything until \meta{end} or starting from \meta{begin},
%   respectively;
% \item \cs{str_count_in:nn} \Arg{str} \Arg{substr} giving the number
%   of occurrences of \meta{substr} in \meta{str};
% \item \cs{str_if_in:nn} \Arg{str} \Arg{substr} deciding if the
%   \meta{substr} appears in \meta{str}.
% \item \cs{str_if_head_eq:nN} alias of \cs{tl_if_head_eq_charcode:nN}
% \item \cs{str_if_numeric/decimal/integer:n}, perhaps in \pkg{l3fp}?
% \end{itemize}
% Some functionalities of \pkg{stringstrings} and \pkg{xstring} as well.
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3str} implementation}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%    
%
%    \begin{macrocode}
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%    \end{macrocode}
%
% \subsection{Variables and constants}
%
% \begin{variable}{\l_tmpa_str,\l_tmpb_str}
% \begin{variable}{\g_tmpa_str}
%    \begin{macrocode}
\tl_new:N \l_tmpa_str
\tl_new:N \l_tmpb_str
\tl_new:N \g_tmpa_str
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{variable}{\c_space_str,\c_backslash_str,
%     \c_percent_str,\c_lbrace_str,\c_rbrace_str}
%   Only the space forces us to use a lowercasing trick.
%    \begin{macrocode}
\tl_const:Nx \c_backslash_str { \cs_to_str:N \\ }
\tl_const:Nx \c_percent_str { \cs_to_str:N \% }
\tl_const:Nx \c_lbrace_str { \cs_to_str:N \{ }
\tl_const:Nx \c_rbrace_str { \cs_to_str:N \} }
\group_begin:
  \char_set_catcode_other:N \*
  \char_set_lccode:nn {`\*} {`\ }
  \tl_to_lowercase:n { \tl_const:Nn \c_space_str {*} }
\group_end:
%    \end{macrocode}
% \end{variable}
%
% \subsection{\enquote{Sanitized} strings}
%
% \begin{macro}[EXP]{\str_sanitize:n}
% \begin{macro}[EXP,aux]{\str_sanitize_loop:w,\str_sanitize_end:w}
%   Replaces all spaces by \enquote{other} spaces, after converting
%   the token list to a string via \cs{tl_to_str:n}.
%    \begin{macrocode}
\group_begin:
\char_set_lccode:nn {`\*}{`\ }
\char_set_lccode:nn {`\A}{`\A}
\tl_to_lowercase:n {
  \group_end:
  \cs_set:Npn \str_sanitize:n #1
    {
      \exp_after:wN \str_sanitize_loop:w \tl_to_str:n {#1} ~ %
      A ~ A ~ A ~ A ~ A ~ A ~ A ~ A ~ \q_mark \q_stop
    }
  \cs_set:Npn \str_sanitize_loop:w
      #1 ~ #2 ~ #3 ~ #4 ~ #5 ~ #6 ~ #7 ~ #8 ~ #9 \q_stop
    {
      \if_meaning:w A #8
        \str_sanitize_end:w
      \fi:
      \str_sanitize_loop:w
      #9 #1 * #2 * #3 * #4 * #5 * #6 * #7 * #8 * \q_stop
    }
  \cs_set:Npn \str_sanitize_end:w \fi: #1 \q_mark #2 * A #3 \q_stop
    { \fi: #2 }
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_desanitize:n}
%   Converting \enquote{other} spaces to normal spaces is very easy
%   using the e\TeX{} primitive.
%    \begin{macrocode}
\cs_set_eq:NN \str_desanitize:n \tl_to_str:n
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\str_sanitize_args:Nn,
%     \str_sanitize_args:NNn,\str_sanitize_args:Nnn}
%   Here, \texttt{f}-expansion does not lose leading spaces,
%   since they have catcode \enquote{other} after \cs{str_sanitize:n}.
%    \begin{macrocode}
\cs_new:Npn \str_sanitize_args:Nn #1 #2
  { \exp_args:Nf #1 { \str_sanitize:n {#2} } }
\cs_new:Npn \str_sanitize_args:NNn #1#2#3
  { \exp_args:NNf #1 #2 { \str_sanitize:n {#3} } }
\cs_new:Npn \str_sanitize_args:Nnn #1#2#3
  {
    \exp_args:Nff #1
      { \str_sanitize:n {#2} }
      { \str_sanitize:n {#3} }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{String variables}
%
% \begin{macro}{\str_new:N,\str_const:Nn,\str_set:Nn,\str_gset:Nn}
%   Simply add sanitizing at the right places.
%    \begin{macrocode}
\cs_new_eq:NN \str_new:N \tl_new:N
\cs_new_protected_nopar:Npn \str_const:Nn
  { \str_sanitize_args:NNn \tl_const:Nn }
\cs_new_protected_nopar:Npn \str_set:Nn
  { \str_sanitize_args:NNn \tl_set:Nn }
\cs_new_protected_nopar:Npn \str_gset:Nn
  { \str_sanitize_args:NNn \tl_gset:Nn }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Head and tail of string}
%
% \begin{macro}{\str_head:n, \str_tail:n}
% \begin{macro}[aux]{\str_head_aux:w}
%   After \cs{tl_to_str:n}, we have a list of character tokens,
%   all with category code 12, except the space, which has category
%   code 10. Directly using \cs{tl_head:w} would thus lose leading spaces.
%   Instead, we take an argument delimited by an explicit space, and
%   then only use \cs{tl_head:w}. If the string started with a
%   space, then the argument of \cs{str_head_aux:w} is empty, and
%   the function correctly returns a space character. Otherwise,
%   it returns the first token of |#1|, which is the first token
%   of the string. If the string is empty, we return an empty result.
%
%   To remove the first character of \cs{tl_to_str:n} |{#1}|,
%   we test it using \cs{if_charcode:w} \cs{scan_stop:},
%   always false for characters. If the argument was non-empty,
%   then \cs{str_tail_aux:w} returns everything until the first
%   \texttt{X} (with category code letter, no risk of confusing
%   with the user input). If the argument was empty, the first
%   \texttt{X} is taken by \cs{if_charcode:w}, and nothing
%   is returned. We use \texttt{X} as a \meta{marker}, rather than
%   a quark because the test \cs{if_charcode:w} \cs{scan_stop:}
%   \meta{marker} has to be false.
%    \begin{macrocode}
\cs_set:Npn \str_head:n #1
  {
    \exp_after:wN \str_head_aux:w
    \tl_to_str:n {#1}
    { { } } ~ \q_stop
  }
\cs_set_nopar:Npn \str_head_aux:w #1 ~ %
  { \tl_head:w #1 { ~ } }
\cs_set:Npn \str_tail:n #1
  {
    \exp_after:wN \str_tail_aux:w
    \reverse_if:N \if_charcode:w
        \scan_stop: \tl_to_str:n {#1} X X \q_stop
  }
\cs_set_nopar:Npn \str_tail_aux:w #1 X #2 \q_stop { \fi: #1 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsection{Length of a string}
%
% \begin{macro}[EXP]{\str_length:n}
% \begin{macro}[EXP]{\str_length:N}
% \begin{macro}[EXP,aux]{\str_length_loop:NNNNNNNNN}
%   The length of a string is found by first changing all spaces
%   to other spaces using \cs{str_sanitize:n}, then counting
%   characters $9$ at a time. When the end is reached, |#9|
%   has the form |X|\meta{digit}, the catcode test is true,
%   the digit gets added to the sum, and the loop is terminated
%   by \cs{use_none_delimit_by_q_stop:w}.
%    \begin{macrocode}
\cs_set:Npn \str_length:n #1
  {
    \int_eval:n
      {
        \exp_last_unbraced:Nf \str_length_loop:NNNNNNNNN
          { \str_sanitize:n {#1} }
          {X8}{X7}{X6}{X5}{X4}{X3}{X2}{X1}{X0} \q_stop
      }
  }
\cs_set:Npn \str_length:N #1
  {
    \int_eval:n
      {
        \exp_after:wN \str_length_loop:NNNNNNNNN #1
          {X8}{X7}{X6}{X5}{X4}{X3}{X2}{X1}{X0} \q_stop
      }
  }
\cs_set:Npn \str_length_loop:NNNNNNNNN #1#2#3#4#5#6#7#8#9
  {
    \if_catcode:w X #9
      \exp_after:wN \use_none_delimit_by_q_stop:w
    \fi:
    \c_nine + \str_length_loop:NNNNNNNNN
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Extracting sub-strings}
%
% \begin{macro}[EXP,int]{\str_skip_many_do:nnw}
% \begin{macro}[rEXP,int]{\str_keep_many_do:nnw}
%   The \texttt{skip_many} function gobbles a number of arguments given by
%   its first argument, then performs its second argument.
%   If the number is zero or negative, nothing is removed.
%   The \texttt{keep_many} outputs the arguments to the left
%   into the input stream.
%    \begin{macrocode}
\cs_new:Npn \str_skip_many_do:nnw #1
  {
    \exp_args:NNf \str_many_do_aux:Nn
      \str_skip_many_do_loop:wnnnnnnnn
      { \int_eval:n {#1} }
  }
\cs_new:Npn \str_many_do_aux:Nn #1#2
  {
    \int_compare:nNnTF {#2} > \c_zero
      {
        \exp_args:Nff \str_many_do_aux_ii:nnn
          {
            \exp_after:wN \exp_after:wN
            \exp_after:wN \exp_stop_f:
            \prg_replicate:nn { (#2+4)/8 } { #1 }
          }
          { \prg_replicate:nn { 8*((#2+4)/8) - #2 } { {} } }
      }
      { \use:n }
  }
\cs_new:Npn \str_many_do_aux_ii:nnn #1#2#3
  { #1 \use_i:nn {#3} \q_stop #2 }
\cs_new:Npn \str_skip_many_do_loop:wnnnnnnnn #1 \q_stop #2#3#4#5#6#7#8#9
  { #1 \q_stop }
\cs_new:Npn \str_keep_many_do:nnw #1
  {
    \exp_args:NNf \str_many_do_aux:Nn
      \str_keep_many_do_loop:wnnnnnnnn
      { \int_eval:n {#1} }
  }
\cs_new:Npn \str_keep_many_do_loop:wnnnnnnnn #1 \q_stop #2#3#4#5#6#7#8#9
  { #2#3#4#5#6#7#8#9 #1 \q_stop }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_from_to:nnn,\str_from_to:Nnn}
%   Sanitize the string, then limit the second and third arguments
%   to be at most the length of the string (this avoids needing
%   to check for the end of the string when grabbing characters).
%   Afterwards, skip characters, then keep some more, and finally
%   drop the end of the string.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_from_to:nnn
  { \str_sanitize_args:Nn \str_from_to_aux:nnn }
\cs_new_nopar:Npn \str_from_to:Nnn
  { \exp_args:No \str_from_to_aux:nnn }
\cs_new:Npn \str_from_to_aux:nnn #1#2#3
  {
    \exp_args:Nf \str_from_to_aux_ii:nnnw
      { \str_length:n {#1} }
      {#2}
      {#3}
    #1
    \q_stop
  }
\cs_new:Npn \str_from_to_aux_ii:nnnw #1#2#3
  {
    \str_skip_many_do:nnw { \int_min:nn {#2} {#1} }
      {
        \str_keep_many_do:nnw
          { \int_min:nn {#3} {#1} - \int_max:nn {\int_min:nn {#2} {#1}} {0} }
          { \use_none_delimit_by_q_stop:w }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Misc}
%
% \begin{macro}[pTF]{\str_if_contains_char:nN}
% \begin{macro}{\str_if_contains_char_loop:NN}
%   Loop over the characters of the string, comparing character codes.
%   We allow |#2| to be a single-character control sequence, hence the
%   use of \cs{if_int_compare:w} rather than \cs{if_charcode:w}.
%   The loop is broken if character codes match. Otherwise,
%   the trailing brace group is taken as the second argument of
%   \cs{str_if_contains_char_loop:NN}, makes the test be true,
%   cleans up, and returns \enquote{false}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \str_if_contains_char:nN #1 #2 {p,T,F,TF}
  {
    \exp_last_unbraced:NNf
      \str_if_contains_char_loop:NN
      #2
      { \str_sanitize:n {#1} }
    { #2 \exp_stop_f: \prg_return_false: \use_none:nn }
    \q_stop
  }
\cs_set_nopar:Npn \str_if_contains_char_loop:NN #1 #2
  {
    \if_int_compare:w `#1 = `#2 \exp_stop_f:
      \prg_return_true:
      \exp_after:wN \use_none_delimit_by_q_stop:w
    \fi:
    \str_if_contains_char_loop:NN #1
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\str_if_in:nn}
%   \begin{syntax}
%     \cs{str_if_in:nnTF} \Arg{string} \Arg{substring}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the \meta{substring} appears in \meta{string}.
%    \begin{macrocode}
 % \prg_new_conditional:Npnn \str_if_in:nn {p,T,F,TF}
 %   { \str_sanitize_args:Nnn \str_if_in_aux:nn }
 % \cs_set:Npn \str_if_in_aux:nn #1 #2
 %   {
 %     \str_if_in_aux_ii:w #1 A \q_mark #2 A \q_stop
 %   }
 % \cs_set:Npn \str_if_in_aux_ii:w #1 #2 \q_mark #3
 %   {
 %     \if_meaning:w #1 #3
 %       \exp_after:wN 
 %   }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[TF]{\tl_if_str:n}
%   A token list is a string if it is either equal to the result of
%   \cs{tl_to_str:n} or that of \cs{str_sanitize:n}. This test cannot
%   be made expandable, because it is not possible to distinguish
%   expandably an active character let equal to its non-active counterpart
%   from that non-active counterpart.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \tl_if_str:n #1 { T , F , TF }
  {
    \tl_set:No \l_str_tmp_tl { \tl_to_str:n {#1} }
    \tl_if_eq:NNTF #1 \l_str_tmp_tl
      { \prg_return_true: }
      {
        \tl_set:Nf \l_str_tmp_tl { \str_sanitize:n {#1} }
        \tl_if_eq:NNTF #1 \l_str_tmp_tl
          { \prg_return_true: }
          { \prg_return_false: }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
% 
% \PrintIndex
