% \iffalse meta-comment
%
%% File: l3regex.dtx Copyright (C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX3 Project.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental Regular Expressions}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \textsf{l3regex} package: regular expressions in \TeX{}^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \section{\pkg{l3regex} documentation}
%
% The \pkg{l3regex} package provides regular expression testing,
% extraction of submatches, and replacement, all acting on strings
% of characters. The syntax of regular expressions is mostly a subset
% of the PCRE syntax (and probably POSIX as well). For performance
% reasons, only a limited set of features are implemented. Notably,
% back-references are not supported.
%
% Let us give a few examples. After
% \begin{verbatim}
%   \str_set:Nn \l_my_str { That~cat~sat~today. }
%   \regex_replace_once:Nnn \l_my_str { at } { is }
% \end{verbatim}
% the string variable \cs{l_my_str} holds the text
% \enquote{\texttt{This cat sat today.}}, where the first
% occurrence of \enquote{\texttt{at}} was replaced
% by \enquote{\texttt{is}}. A more complicated example is
% a pattern to add a comma at the end of each word:
% \begin{verbatim}
%   \regex_replace_all:Nnn \l_my_str { (\w*) } { $1 , }
% \end{verbatim}
% The |\w| sequence represents any \enquote{word} character,
% and |*| indicates that the |\w| sequence should be repeated
% as many times as possible, hence matching a word in the
% input string. The parentheses \enquote{capture} what their
% contents matched in the input string, and this can be used
% in the replacement text as |$1| (and higher numbers if several
% groups are used in the regular expression).
%
% \subsection{Syntax of regular expressions}
%
% Most characters match exactly themselves. Some characters are
% special and must be escaped with a backslash (\emph{e.g.}, |\*|
% matches an explicit star character). Some escape sequences of
% the form backslash--letter also have a special meaning
% (for instance |\d| matches any digit). As a rule,
% \begin{itemize}
% \item every alphanumeric character (\texttt{A}--\texttt{Z},
%   \texttt{a}--\texttt{z}, \texttt{0}--\texttt{9}) matches
%   exactly itself, none of them should be escaped, because
%   most of those escape sequences have special meanings;
% \item non-alphanumeric printable ascii character can always
%   be safely escaped, and for highest portability, it should
%   always be escaped (this avoids problems if some currently
%   \enquote{normal} characters is given a meaning in later
%   releases);
% \item spaces should always be escaped (even in character
%   classes);
% \item any other character may be escaped or not, without any
%   effect: both versions will match exactly that character.
% \end{itemize}
% Note that these rules play nicely with the fact that many
% non-alphanumeric characters are difficult to input into \TeX{}
% under normal category codes. For instance, |\$\%\^\\abc\#|
% matches the literal string |$%^\abc#|.
% \begin{texnote}
%   When converting the regular expression to a string,
%   the value of the escape character is set to be a backslash.
% \end{texnote}
%
% Any special character which appears at a place where its special
% behaviour cannot apply matches itself instead (for instance,
% a quantifier appearing at the beginning of a string).
%
% Special characters.
% \begin{itemize}
% \item Expressions are not anchored by default. If the first non-space
%   character of the expression is |^|, then it becomes anchored at the
%   start, and if the last non-space character is |$|, it is anchored
%   at the end.
% \item[\texttt{.}] A single period matches any character,
%   including newlines.\footnote{Should that be changed?}
% \item |\d| matches one digit, |\D| matches one
%   non-digit\footnote{What should we decide for Unicode?},
%   |\w| matches a \enquote{word character}, alphanumeric or underscore
%   (|[A-Za-z0-9_]|), while |\W| matches any non-word character.
% \item[\texttt{[]}] Introduce a \enquote{character class} (see below),
%   which matches exactly one character in the string.
% \item[\texttt{()}] Parentheses for groups serve two purposes:
%   they form groups on which quantifiers can operate, and are also
%   \enquote{capturing groups} (see below).
% \item[\texttt{?*+}] Quantifiers: \texttt{?} indicates
%   that the previous character or group (produced using parentheses)
%   is optional; \texttt{*} indicates that it can be repeated zero
%   or more times; \texttt{+} indicates that it must appear at least
%   once, but can be repeated.
% \end{itemize}
%
% In character classes, only |^|, |-|, |]|, |\| and spaces are special,
% and should be escaped. Other non-alphanumeric characters can
% still be escaped without harm. The escape sequences |\d|,
% |\D|, |\w|, |\W| are also supported in character classes.
% If the first character is |^|, then the meaning of the character
% class is inverted. Ranges of characters can be expressed using
% |-|, for instance, |[\D 0-5]| is equivalent to |[^6-9]|.
%
% Capturing groups are a means of extracting information about the
% match. Parenthesized groups are labelled in the order of their
% opening parenthesis, starting at $1$. The contents of those groups
% corresponding to the \enquote{best} match (leftmost longest)
% can be extracted and stored in a sequence of strings using for
% instance \cs{regex_extract_once:nnNTF}.
%
% \subsection{Precompiling regular expressions}
%
% If a regular expression is to be used several times,
% it is better to compile it once rather than doing it
% each time the regular expression is used. The precompiled
% regular expression is stored as a token list variable. All
% of the \pkg{l3regex} module's functions can be given their
% regular expression argument either as an explicit string
% or as a precompiled regular expression.
%
% \begin{function}{\regex_set:Nn}
% \begin{function}{\regex_gset:Nn}
%   \begin{syntax}
%     \cs{regex_set:Nn} \meta{tl var} \Arg{regex}
%   \end{syntax}
%   Stores a precompiled version of the \meta{regular expression}
%   in the \meta{tl var}. For instance, this function can be used
%   as
%   \begin{verbatim}
%     \tl_new:N \l_my_regex_tl
%     \regex_set:Nn \l_my_regex_tl { my\ regex\ is\ (nice|simple) }
%   \end{verbatim}
%   The assignment is local for \cs{regex_set:Nn}
%   and global for \cs{regex_gset:Nn}.
% \end{function}
% \end{function}
%
% \subsection{String matching and extraction}
%
% \begin{function}[TF]{\regex_match:nn}
% \begin{function}[TF]{\regex_match:Nn}
%   \begin{syntax}
%     \cs{regex_match:nnTF} \Arg{regex} \Arg{string} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the \meta{regular expression} matches any substring
%   of \meta{string}. For instance,
%   \begin{verbatim}
%     \regex_match:nnTF { b [cde]* } { abecdcx } { TRUE } { FALSE }
%     \regex_match:nnTF { [b-dq-w] } { example } { TRUE } { FALSE }
%   \end{verbatim}
%   leaves \texttt{TRUE FALSE} in the input stream.
% \end{function}
% \end{function}
%
% \begin{function}{\regex_count:nnN}
% \begin{function}{\regex_count:NnN}
%   \begin{syntax}
%     \cs{regex_count:nnN} \Arg{regex} \Arg{string} \meta{int var}
%   \end{syntax}
%   Sets \meta{int var} equal to the number of times
%   \meta{regular expression} appears in \meta{string}.
%   The search starts by finding the left-most longest match,
%   respecting greedy and ungreedy operators. Then the search
%   starts again from the character following the last character
%   of the previous match, until reaching the end of the string.
%   For instance,
%   \begin{verbatim}
%     \int_new:N \l_foo_int
%     \regex_count:nnN { (b*|c) } { abbababcbb } \l_foo_int
%   \end{verbatim}
%   results in \cs{l_foo_int} taking the value $5$.
%   \begin{texnote}
%     This function can lead to infinite recursion
%     if the \meta{regular expression} matches an empty string.
%   \end{texnote}
% \end{function}
% \end{function}
%
% \begin{function}[TF]{\regex_extract_once:nnN}
% \begin{function}[TF]{\regex_extract_once:NnN}
% \begin{function}{\regex_extract_once:nnN}
% \begin{function}{\regex_extract_once:NnN}
%   \begin{syntax}
%     \cs{regex_extract_once:nnNTF} \Arg{regex} \Arg{string} \meta{seq~var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Finds the first match of the \meta{regular expression}
%   in the \meta{string}. If it exists, the match is stored
%   as the zeroeth item of the \meta{seq~var}, and further
%   items are the contents of capturing groups, in the order
%   of their opening left parenthesis. The \meta{seq~var}
%   is assigned locally. If there is no match,
%   the \meta{seq~var} is not altered.
%   The testing versions return \meta{true} if a match was found,
%   and \meta{false} otherwise.
%   For instance, assume that you type
%   \begin{verbatim}
%     \regex_extract_once:nnNTF { ^(La)?TeX(!*)$ } { LaTeX!!! }
%       \l_foo_seq { true } { false }
%   \end{verbatim}
%   Then the regular expression (anchored at the start with |^| and
%   at the end with |$|) will match the whole string. The first
%   capturing group, |(La)?|, matches |La|, and the second capturing
%   group, |(!*)|, matches |!!!|. Thus, |\l_foo_seq| will contain
%   the items |{LaTeX!!!}|, |{La}|, and |{!!!}|, and the \texttt{true}
%   branch is left in the input stream.
% \end{function}
% \end{function}
% \end{function}
% \end{function}
%
% \begin{function}{\regex_extract_map_variable:nnNn}
% \begin{function}{\regex_extract_map_variable:NnNn}
%   \begin{syntax}
%     \cs{regex_extract_map_variable:nnNn} \Arg{regex} \Arg{string} \meta{seq~var} \Arg{code}
%   \end{syntax}
%   For each match of the \meta{regular expression} in the \meta{string},
%   the \meta{seq~var} is set to be equal to a sequence of strings:
%   the zeroeth item is the whole match, and subsequent items are
%   the contents of capturing groups, in the order of their opening
%   left parenthesis. Then the \meta{code} is run, and a new match is
%   attempted, starting from the character following the last character
%   of the previous match. All assignments to the \meta{seq~variable}
%   are done locally. If no match is found, the \meta{seq~variable}
%   is not modified.
% \end{function}
% \end{function}
%
% \subsection{String replacement}
%
% \begin{function}[TF]{\regex_replace_once:nnN}
% \begin{function}[TF]{\regex_replace_once:NnN}
% \begin{function}{\regex_replace_once:nnN}
% \begin{function}{\regex_replace_once:NnN}
%   \begin{syntax}
%     \cs{regex_replace_once:nnN} \Arg{regular expression} \Arg{replacement} \meta{str~var}
%   \end{syntax}
%   Searches for the \meta{regular expression} in the \meta{string}
%   and replaces the matching part with the \meta{replacement}. The result
%   is assigned locally to \meta{str~var}. In the \meta{replacement},
%   \texttt{\$0} represents the full match, \texttt{\$1} represent
%   the contents of the first capturing group, \texttt{\$2} of the second,
%   \emph{etc.}
% \end{function}
% \end{function}
% \end{function}
% \end{function}
%
% \begin{function}[TF]{\regex_replace_all:nnN}
% \begin{function}[TF]{\regex_replace_all:NnN}
% \begin{function}{\regex_replace_all:nnN}
% \begin{function}{\regex_replace_all:NnN}
%   \begin{syntax}
%     \cs{regex_replace_all:nnN} \Arg{regular expression} \Arg{replacement} \meta{str~var}
%   \end{syntax}
%   Replaces all occurrences of the \cs{regular expression}
%   in the \meta{string} by the \meta{replacement}, where
%   \texttt{\$0} represents the full match, \texttt{\$1}
%   represent the contents of the first capturing group,
%   \texttt{\$2} of the second, \emph{etc.} Every match
%   is treated independently. The result is assigned
%   locally to \meta{str~var}.
% \end{function}
% \end{function}
% \end{function}
% \end{function}
%
% \subsection{Bugs, misfeatures, future work, and other possibilities}
%
% Things that would be specific to this syntax, not present in PCRE.
% \begin{itemize}
% \item |#| as a synonym of |.*?|
% \item Facility to match balanced things? (\emph{cf.} callout?)
% \end{itemize}
%
% The list below starts with useful tasks, and ends with things
% that won't be added. The order is not precise.
% \begin{itemize}
% \item Test.
% \item Test more.
% \item Test "(a(b)c|d(e)f)*" for group numbers.
% \item Test "(a?)*" for infinite loop.
% \item Stop matching as soon as there is no thread left.
% \item Implement regex matching on external files.
% \item The \texttt{\{\}} quantifiers are only half-implemented.
% \item Newline conventions are not done: |.| should not match newlines.
% \item |\h|, |\H|, |\s|, |\S|, |\v|, |\V|, also |\N|
%
% \item Simple assertions: |^| and |$| incorrectly implemented.
%   Add support for |\b|, |\B| (word boundary/not),
%   |\A|, |\Z|, |\z| (anchor at start/end of string),
%   |\G| (anchor at match start, useful for |replace_all|).
% \item General look-ahead/behind assertions?
%
% \item
%   |\a| (hex 07),
%   |\cx=\^^x|,
%   |\e| (hex 1B),
%   |\f| (hex 0C),
%   |\n| (hex 0A),
%   |\r| (hex 0D),
%   |\t| (hex 09),
%   |\ddd| (octal \texttt{ddd}),
%   |\xhh| (hex code \texttt{hh}),
%   |\x{hhh..}| (hex code \texttt{hh..}),
%   |\b| (hex 08 within character classes).
%
% \item Caseless matching.
% \item |\p{..}| and |\P{..}| for having/not having a Unicode property,
%   |\X| for \enquote{extended} Unicode sequence.
% \item |(*..)| and |(?..)| sequences to set some options.
% \item |(?:...)|, a non-capturing group.
% \item "(?|..|..)" to reset the capturing group number at the start
%   of each alternative.
% \item Conditional subpatterns with look ahead/behind.
% \end{itemize}
%
% Probably not to be implemented.
% \begin{itemize}
% \item Callout with |(?C...)|.
% \item |\K| for resetting the beginning of the match.
% \item POSIX character classes.
% \item Named subpatterns.
% \item Conditional subpatterns (others).
% \item Comments.
% \item Recursion.
% \item Subroutine calls.
% \item Atomic grouping, possessive quantifiers.
% \item Backtracking control verbs.
% \item |\Q|, |\E|
% \item Back-references.
% \item |\C| single byte in UTF-8 mode.
% \end{itemize}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3regex} implementation}
%
%<*package>
%    \begin{macrocode}
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
\RequirePackage{l3str}
%    \end{macrocode}
%
% Most regex engines use backtracking. This allows to provide very
% powerful features (back-references come to mind first), but it is
% costly. Since \TeX{} is not first and foremost a programming language,
% complicated code tends to run slowly, and we must use faster, albeit
% slightly more restrictive, techniques, coming from automata theory.
%
% Given a regular expression of $n$ characters, we build a
% non-deterministic finite automaton (NFA) with roughly $n$ states,
% which accepts precisely those strings matching that regular expression.
% We then run the string through the NFA, and check the return value.
%
% \subsection{Constants and variables}
%
% \begin{macro}{\regex_tmp:w}
%   Temporary function used to do some expansions in optimized ways.
%    \begin{macrocode}
\cs_new:Npn \regex_tmp:w { }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}[int]{\l_regex_error_code_int}
%   This integer parameter takes a non-zero value if
%   the pattern is malformed. The value matches with
%   the convention given in the \texttt{pcreapi}
%   documentation (but not all of the PCRE errors
%   can occur, since some constructions are not supported).
%    \begin{macrocode}
\int_new:N \l_regex_error_code_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[aux]{\c_regex_d_tl,\c_regex_D_tl}
% \begin{variable}[aux]{\c_regex_w_tl,\c_regex_W_tl}
%   These constant token lists encode which characters
%   are recognized by |\d|, |\D|, |\w|, |\W| in regular
%   expressions.
%^^A How should D, W behave in unicode for chars >256?
%    \begin{macrocode}
\tl_const:Nn \c_regex_d_tl
  {
    \regex_item_range:nn {48} {57} % 0--9
  }
\tl_const:Nn \c_regex_D_tl
  {
    \regex_item_less:n {48} % 0
    \regex_item_more:n {57} % 9
  }
\tl_const:Nn \c_regex_w_tl
  {
    \regex_item_range:nn {48}  {57} % 0--9
    \regex_item_range:nn {65}  {90} % A--Z
    \regex_item_equal:n  {95}       % _
    \regex_item_range:nn {97} {122} % a--z
  }
\tl_const:Nn \c_regex_W_tl
  {
    \regex_item_less:n   {48}      % 0
    \regex_item_range:nn {58} {64} % (`9+1)--(`A-1)
    \regex_item_range:nn {91} {94} % (`Z+1)--(`_-1)
    \regex_item_equal:n  {96}      % `
    \regex_item_more:n  {122}      % z
  }
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \subsection{Helpers}
%
% \subsubsection{General}
%
% \begin{macro}[int,EXP]{\regex_cs_use:cF}
%   Use the csname provided if it exists, otherwise,
%   fall back to the default.
%    \begin{macrocode}
\cs_new:Npn \regex_cs_use:cF #1
  { \cs_if_exist:cTF {#1} { \use:c {#1} } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_toks_put_left:Nx}
% \begin{macro}[int]{\regex_toks_put_right:Nx}
%   Adding material to toks registers, on the left or right.
%^^A todo: remove those int_eval by homogenizing the uses.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_toks_put_left:Nx #1#2
  {
    \cs_set_nopar:Npx \regex_tmp:w {#2}
    \tex_toks:D #1 \exp_after:wN \exp_after:wN \exp_after:wN
      { \exp_after:wN \regex_tmp:w \tex_the:D \tex_toks:D #1 }
  }
\cs_new_protected:Npn \regex_toks_put_right:Nx #1#2
  {
    \cs_set_nopar:Npx \regex_tmp:w {#2}
    \tex_toks:D #1 \exp_after:wN
      { \tex_the:D \tex_toks:D \exp_after:wN #1 \regex_tmp:w }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\regex_str_set:Nn}
%   Just make sure that the escape character is correct when the input
%   is converted to a string.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_str_set:Nn #1#2
  {
    \group_begin:
    \int_set:Nn \tex_escapechar:D { `\\ }
    \use:x
      {
        \group_end:
        \str_set:Nn \exp_not:N #1 { \tl_to_str:n {#2} }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Interrupting recursions, and build errors}
%
% \begin{macro}[int]{\regex_if_tail_stop:N}
% \begin{macro}[int]{\regex_if_tail_error:Nn}
%   Set the error code accordingly.
%    \begin{macrocode}
\cs_new_eq:NN \regex_if_tail_stop:N \quark_if_recursion_tail_stop:N
\cs_new_protected_nopar:Npn \regex_if_tail_error:Nn #1#2
  { \quark_if_recursion_tail_stop_do:Nn #1 { \regex_build_error:n {#2} } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\regex_build_error:n}
%   This macro is called if anything goes wrong when building
%   the NFA corresponding to a given regular expression
%   Negative codes are specific to the \LaTeX3 implementation.
%   Other error codes match with the PCRE codes.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_error:n #1
  {
    \msg_error:nnxx { regex } { build-error } {\int_eval:n{#1}}
      {
        \prg_case_int:nnn {#1}
          {
            {-9} {File~not~found}
            {-8} {Unsupported~construct}
            {1}  {\iow_char:N\\~at~end~of~pattern }
            {2}  {\iow_char:N\\c~at~end~of~pattern }
            {4}  {Numbers~out~of~order~in~\iow_char:N\{\iow_char\}~quantifier.}
            {6}  {Missing~terminating~\iow_char:N\]~for~character~class }
            {7}  {Invalid~escape~sequence~in~character~class}
            {8}  {Range~out~of~order~in~character~class}
            {22} {Unmatched~parentheses}
            {34} {Character~value~in~\iow_char:N\\x{...}~sequence~is~too~large}
            {44} {Invalid~UTF-8~string}
            {46} {Malformed~\iow_char:N\\P~or\iow_char:N\\p~sequence}
            {47} {Unknown~property~after~\iow_char:N\\P~or\iow_char:N\\p}
            {51} {Octal~value~is~greater~than~\iow_char:N\\377}
            {68} {\iow_char:N\\c~must~be~followed~by~an~ASCII~character}
          }
          { Internal~bug. }
      }
  }
\msg_new:nnn { regex } { build-error } { (error~#1): #2 }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Testing characters}
%
% \begin{macro}[int]{\regex_break_point:TF,\regex_break_true:w}
%   When testing whether a character of the query string matches
%   a given character class in the regular expression, we often
%   have to test it against several ranges of characters, checking
%   if any one of those matches. This is done with a structure like
%   \begin{quote}
%     \meta{test1} \ldots{} \meta{test$\sb{n}$} \\
%     \cs{regex_break_point:TF} \Arg{true code} \Arg{false code}
%   \end{quote}
%   If any of the tests succeeds, it calls \cs{regex_break_true:w},
%   which cleans up and leaves \meta{true code} in the input stream.
%   Otherwise, \cs{regex_break_point:TF} leaves the \meta{false code}
%   in the input stream.
%    \begin{macrocode}
\cs_new_nopar:Npn \regex_break_true:w #1 \regex_break_point:TF #2 #3 {#2}
\cs_new_eq:NN \regex_break_point:TF \use_ii:nn
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_item_equal:n,\regex_item_range:nn}
% \begin{macro}[int]{\regex_item_less:n,\regex_item_more:n}
%   Simple comparisons triggering \cs{regex_break_true:w} when true.
%    \begin{macrocode}
\cs_new_nopar:Npn \regex_item_equal:n #1
  {
    \if_num:w #1 = \l_regex_current_char_int
      \exp_after:wN \regex_break_true:w
    \fi:
  }
\cs_new_nopar:Npn \regex_item_range:nn #1 #2
  {
    \reverse_if:N \if_num:w #1 > \l_regex_current_char_int
      \reverse_if:N \if_num:w #2 < \l_regex_current_char_int
        \exp_after:wN \exp_after:wN \exp_after:wN \regex_break_true:w
      \fi:
    \fi:
  }
\cs_new_nopar:Npn \regex_item_less:n #1
  {
    \if_num:w #1 > \l_regex_current_char_int
      \exp_after:wN \regex_break_true:w
    \fi:
  }
\cs_new_nopar:Npn \regex_item_more:n #1
  {
    \if_num:w #1 < \l_regex_current_char_int
      \exp_after:wN \regex_break_true:w
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Grabbing digits}
%
% \begin{macro}[aux]{\regex_get_digits:nw}
% \begin{macro}[aux]{\regex_get_digits_aux:nnw}
%   Grabs digits (of category code other), skipping any intervening
%   space, until encountering a non-digit, and places the result
%   in a brace group after |#1|.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_get_digits:nw #1
  { \regex_get_digits_aux:nnw {#1} { } }
\cs_new_protected:Npn \regex_get_digits_aux:nnw #1#2#3
  {
    \token_if_eq_charcode:NNTF #3 \c_space_token
      { \regex_get_digits_aux:nnw {#1} {#2} }
      {
        \tl_if_in:nnTF { 0123456789 } {#3}
          { \regex_get_digits_aux:nnw {#1} {#2#3} }
          { #1 {#2} #3 }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{A few error messages}
%
% \begin{macro}[aux]{\regex_error_end_escape:}
% \begin{macro}[aux]{\regex_error_end_class:}
%^^A todo: comment
%    \begin{macrocode}
\cs_new_protected:Npn \regex_error_end_escape:
  { \msg_error:nn { regex } { premature-end } }
\cs_new_protected:Npn \regex_error_end_class:
  { \msg_error:nn { regex } { premature-end } }
\msg_new:nnn { regex } { premature-end }
  { This~regular~expression~has~ended~at~the~wrong~time! }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsection{NFA}
%
% \subsubsection{Stored NFA}
%
% Variables that we need.
%    \begin{macrocode}
\str_new:N  \l_regex_pattern_str
\int_new:N  \l_regex_nesting_int
\tl_new:N   \l_regex_tmpb_tl
\tl_new:N   \l_regex_tmpc_tl
\int_new:N  \l_regex_tmpa_int
\int_new:N  \l_regex_state_max_int
\int_new:N  \l_regex_state_left_int
\seq_new:N  \l_regex_state_left_seq
\int_new:N  \l_regex_state_right_int
\seq_new:N  \l_regex_state_right_seq
\int_new:N  \l_regex_capturing_group_int
\seq_new:N  \l_regex_capturing_group_seq
\bool_new:N \l_regex_anchored_end_bool
\int_new:N  \l_regex_current_char_int
\cs_new_eq:NN \regex_build_tmp_class:nn \use_none:nn
\bool_new:N \l_regex_class_bool
\tl_new:N   \l_regex_class_tl
\tl_new:N   \l_regex_one_or_group_tl
\int_new:N  \l_regex_repetition_int
%    \end{macrocode}
%
% A given pattern is often reused to match many different strings.
% We thus give a means of storing the nfa corresponding to a given
% pattern in an \meta{nfa var}: a token list variable of the form
% \begin{quote}
%   \cs{regex_nfa:Nw} \meta{nfa variable} \\
%   \cs{l_regex_max_int} $n$ \\
%   \cs{tex_toks:D} 0 \{ \meta{instruction0} \} \\
%   \ldots{}                              \\
%   \cs{tex_toks:D} $n$ \{ \meta{instruction$\sb{n}$} \} \\
%   \cs{scan_stop:}
% \end{quote}
% where $n$ is the number of states in the automaton,
% and the various \meta{instruction$\sb{i}$} control
% how the automaton behaves in state $i$. The \cs{regex_nfa:Nw}
% function removes the whole automaton from the input stream
% and produces an error: the \meta{nfa var} should only be
% accessed through dedicated functions. This rather drastic
% approach is taken because assignments triggered by the
% contents of \meta{nfa var} may overwrite data which is used
% elsewhere, unless everything is done in a group.
%
% \begin{macro}{\regex_nfa_new:Nn}
% \begin{macro}[aux]{\regex_nfa:Nw}
% \begin{macro}[aux]{\regex_nfa_new_aux:n}
%   This function defines a new non-deterministic finite automaton (nfa),
%   which recognizes the string given as the second argument.
%   The auxiliary \cs{regex_nfa:Nw} is not protected: this ensures that
%   the nfa will properly be replaced by an error message in expansion
%   contexts.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_nfa_new:Nn #1#2
  {
    \group_begin:
      \regex_build:n {#2}
      \use:x
        {
          \group_end:
          \tl_set:Nn \exp_not:N #1
            {
              \exp_not:N \regex_nfa:Nw \exp_not:N #1
              \l_regex_state_max_int \int_use:N \l_regex_state_max_int
              \prg_stepwise_function:nnnN
                {1} {1} {\l_regex_state_max_int}
                \regex_nfa_new_aux:n
              \scan_stop:
            }
        }
  }
\cs_new_nopar:Npn \regex_nfa_new_aux:n #1
  { \tex_toks:D #1 { \tex_the:D \tex_toks:D #1 } }
\cs_new:Npn \regex_nfa:Nw #1 #2 \scan_stop:
  { \msg_expandable_error:n { Automaton~#1 used~incorrectly. } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Helpers for building an NFA}
%
% \begin{macro}[int]{\regex_build_new_state:}
%   Here, we add a new state to the automaton:
%   empty the corresponding toks now, then set
%   \cs{l_regex_state_left/right_int} to their
%   new values.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_new_state:
  {
    \int_incr:N \l_regex_state_max_int
    \tex_toks:D \l_regex_state_max_int = { }
    \l_regex_state_left_int  = \l_regex_state_right_int
    \l_regex_state_right_int = \l_regex_state_max_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_transition_aux:NN}
% \begin{macro}[aux]{\regex_build_transitions_aux:NNNN}
%   These functions create a new state, and put one or two transitions
%   starting from the current state.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_transition_aux:NN #1#2
  {
    \regex_build_new_state:
    \regex_toks_put_right:Nx \l_regex_state_left_int
      { #1 { \int_use:N \l_regex_state_left_int } { \int_use:N #2 } }
  }
\cs_new_protected_nopar:Npn \regex_build_transitions_aux:NNNN #1#2#3#4
  {
    \regex_build_new_state:
    \regex_toks_put_right:Nx \l_regex_state_left_int
      {
        #1 { \int_use:N \l_regex_state_left_int } { \int_use:N #2 }
        #3 { \int_use:N \l_regex_state_left_int } { \int_use:N #4 }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{From regex to NFA: framework}
%
% In order for the construction \texttt{ab|cd} to work, we enclose
% the whole pattern within parentheses. These have the added benefit
% to form a capturing group: hence we get the data of the whole match
% for free. However, we need to be careful with anchoring.
%
% \begin{macro}[int]{\regex_build:n}
%   First, reset a few variables and store the pattern
%   in \cs{l_regex_pattern_str}.
%   The first character of \cs{l_regex_pattern_str} may be
%   |^|, in which case the search is anchored. After testing
%   for that and inserting the relevant state(s) into the automaton,
%   loop over the pattern string, building the automaton.
%   Finally, \cs{regex_build_end:} adds the finishing code
%   (success condition, for instance).
%    \begin{macrocode}
\cs_new_protected:Npn \regex_build:n #1
  {
    \regex_build_setup:
    \regex_str_set:Nn \l_regex_pattern_str {#1}
    \exp_after:wN \regex_build_first:N \l_regex_pattern_str
    \q_recursion_tail \q_recursion_stop
    \regex_build_end:
%<trace>    \regex_trace_nfa:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_build_setup:}
%   Hopefully, we didn't forget to initialize anything here.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_setup:
  {
    % ^^A todo: complete!
    \int_set_eq:NN \l_regex_capturing_group_int \c_minus_one
    \int_set_eq:NN \l_regex_nesting_int \c_minus_one
    \int_zero:N \l_regex_state_left_int
    \int_zero:N \l_regex_state_right_int
    \int_zero:N \l_regex_state_max_int
    \regex_build_new_state:
    \tex_toks:D 0 { } % ?
    \bool_set_false:N \l_regex_anchored_end_bool
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_build_loop:N}
%   The \cs{regex_build_loop:N} function grabs a character.
%   If it is the end of the pattern, stop looping.
%   If the character has a meaning in regexes, use the
%   corresponding function, otherwise use the default
%   \cs{regex_build_normal:N}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_loop:N #1
  {
    \regex_if_tail_stop:N #1
    \regex_cs_use:cF { regex_build_#1: }
      { \regex_build_normal:N #1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Escaping in patterns}
%
% \begin{macro}[aux]{\regex_build_\:}
%   After a backslash, we use a variant of \cs{regex_build_loop:N},
%   which produces an error if it sees the end of the
%   pattern. The meaning of special and non-special characters
%   is changed when following the backslash, hence the extra
%   \texttt{/}.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_build_ \c_backslash_str : } #1
  {
    \regex_if_tail_error:Nn #1 {1}
    \regex_cs_use:cF { regex_build_/#1: }
      { \regex_build_normal:N #1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Anchors, start and end}
%
% \begin{macro}[int]{\regex_build_first:N}
% \begin{macro}[aux]{\regex_build_first_unanchored:}
%   If the first non-space character in the pattern is |^|,
%   then the search should be anchored. Otherwise, we add
%   instructions to the first state of the automaton,
%   so that it produces threads starting from the first state
%   at every character. Moving forward to the next state has
%   higher priority than waiting for a later character.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_first:N #1
  {
    \token_if_eq_charcode:NNTF #1 \c_space_token
      { \regex_build_first:N }
      {
        \token_if_eq_charcode:NNTF #1 ^
          {
            \regex_build_loop:N ( % )
            %^^A document that this parenthesis catches the full match,
            %^^A and ensures that "ab|cd" works.
          }
          {
            \regex_build_first_unanchored:
            \regex_build_loop:N ( #1 % )
          }
      }
  }
\cs_new_protected_nopar:Npn \regex_build_first_unanchored:
  {
    \regex_build_transitions_aux:NNNN
      \regex_action_free_copy:nn \l_regex_state_right_int
      \regex_action_cost:nn \l_regex_state_left_int
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_$:} %^^A $
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_letter:N \$
  \cs_new_protected_nopar:Npn \regex_build_$: #1 %^^A $
    {
      \if_charcode:w \exp_not:N #1 \c_space_token
        \exp_after:wN \regex_build_$:  % ^^A $
      \else:
        \if_meaning:w #1 \q_recursion_tail
          \bool_set_true:N \l_regex_anchored_end_bool
        \fi:
        \exp_after:wN \regex_build_loop:N
        \exp_after:wN #1
      \fi:
    }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\regex_build_end:}
%   %^^A todo:complete.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_end:
  {
    \int_compare:nNnT \l_regex_nesting_int > \c_zero
      { \regex_build_error:n {22} }
    \int_incr:N \l_regex_nesting_int
    \exp_last_unbraced:Nf \regex_build_loop:N % ^^A (
      { \prg_replicate:nn { \l_regex_nesting_int } ) }
      \q_recursion_tail \q_recursion_stop
    \regex_toks_put_right:Nx \l_regex_state_right_int
      {
        \bool_if:NTF \l_regex_anchored_end_bool
          {
            \exp_not:N \if_num:w
                \c_minus_one = \l_regex_current_char_int
              \regex_action_success:n { \int_use:N \l_regex_state_right_int }
            \exp_not:N \else:
              \regex_action_fail:n { \int_use:N \l_regex_state_right_int }
            \exp_not:N \fi:
          }
          { \regex_action_success:n { \int_use:N \l_regex_state_right_int } }
      }
    %^^A \l_regex_end_build_tl %?
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Normal character, and simple character classes}
%
% \begin{macro}[aux]{\regex_build_normal:N}
%   A normal alphanumeric or an escaped non-alphanumeric
%   (actually, any unknown combination) will match itself
%   and the thread will fail otherwise. We prepare
%   \cs{regex_build_tmp_class:nn} with the relevant test and
%   commands. The program steps to be inserted in those
%   commands will come as |##1| and |##2|: we don't know
%   yet what those will be before checking for quantifiers.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_normal:N #1
  {
    \cs_set:Npx \regex_build_tmp_class:nn ##1##2
      {
        \exp_not:n { \exp_not:N \if_num:w }
            \int_value:w `#1 = \l_regex_current_char_int
          \regex_action_cost:nn { ##1 } { ##2 }
        \exp_not:n { \exp_not:N \else: }
          \regex_action_fail:n { ##1 }
        \exp_not:n { \exp_not:N \fi: }
      }
    \regex_build_one_quantifier:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_.:}
%   Similar to \cs{regex_build_normal:N} but accepts any character,
%   and refuses $-1$, which marks the end of the string.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_build_.: }
  {
    \cs_set:Npn \regex_build_tmp_class:nn ##1##2
      {
        \exp_not:N \if_num:w \c_minus_one = \l_regex_current_char_int
          \regex_action_fail:n {##1}
        \exp_not:N \else:
          \regex_action_cost:nn {##1} {##2}
        \exp_not:N \fi:
      }
    \regex_build_one_quantifier:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_/d:,\regex_build_/D}
% \begin{macro}[aux]{\regex_build_/w:,\regex_build_/W}
% \begin{macro}[aux]{\regex_build_escaped_letter_aux:N}
%   The constants \cs{c_regex_d_tl}, \emph{etc.} hold
%   a list of tests which match the corresponding character
%   class, and jump to the \cs{regex_break_point:TF} marker.
%   As for a normal character, we check for quantifiers.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_escaped_letter_aux:N #1
  {
    \cs_set:Npn \regex_build_tmp_class:nn ##1##2
      {
        \exp_not:N #1
        \exp_not:N \regex_break_point:TF
          { \regex_action_cost:nn {##1} {##2} }
          { \regex_action_fail:n {##1} }
      }
    \regex_build_one_quantifier:
  }
\cs_new_protected_nopar:cpn { regex_build_/d: }
  { \regex_build_escaped_letter_aux:N \c_regex_d_tl }
\cs_new_protected_nopar:cpn { regex_build_/D: }
  { \regex_build_escaped_letter_aux:N \c_regex_D_tl }
\cs_new_protected_nopar:cpn { regex_build_/w: }
  { \regex_build_escaped_letter_aux:N \c_regex_w_tl }
\cs_new_protected_nopar:cpn { regex_build_/W: }
  { \regex_build_escaped_letter_aux:N \c_regex_W_tl }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Character classes}
%
% \begin{macro}[aux]{\regex_build_[:}
%   This starts a class. The code for the class is collected
%   in \cs{l_regex_class_tl}. The first character is special,
%   then we will switch to \cs{regex_class_loop:N} to read
%   characters one by one until the end of the class.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_build_[: }
  {
    \tl_clear:N \l_regex_class_tl
    \regex_class_first:N
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_class_]:}
%   At the end of the class, act just as for a single character,
%   but with a more complicated test.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_class_]: }
  {
    \cs_set:Npn \regex_build_tmp_class:nn ##1##2
      {
        \exp_not:o \l_regex_class_tl
        \bool_if:NTF \l_regex_class_bool
          {
            \exp_not:N \regex_break_point:TF
              { \regex_action_cost:nn {##1} {##2} }
              { \regex_action_fail:n {##1} }
          }
          {
            \exp_not:N \regex_break_point:TF
              { \regex_action_fail:n {##1} }
              { \regex_action_cost:nn {##1} {##2} }
          }
      }
    \regex_build_one_quantifier:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_class_first:N}
%   If the first non-space character is |^|, then the class is inverted.
%   We keep track of this in \cs{l_regex_class_bool}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_class_first:N #1
  {
    \token_if_eq_charcode:NNTF #1 \c_space_token
      { \regex_class_first:N }
      {
        \token_if_eq_charcode:NNTF #1 ^
          {
            \bool_set_false:N \l_regex_class_bool
            \regex_class_loop:N
          }
          {
            \bool_set_true:N \l_regex_class_bool
            \regex_class_loop:N #1
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_class_loop:N}
% \begin{macro}[aux]{\regex_class_\:}
%   We collect characters one by one using \cs{regex_class_loop:N}.
%   The \cs{regex_class_\string\:} function only differs from it
%   by having an extra \texttt{/}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_class_loop:N #1
  {
    \regex_if_tail_error:Nn #1 {6}
    \regex_cs_use:cF { regex_class_#1: }
      { \regex_class_normal:N #1 }
  }
\cs_new_protected_nopar:cpn { regex_class_ \c_backslash_str : } #1
  {
    \regex_if_tail_error:Nn #1 {6} % ^^A is there a more specific error ?
    \regex_cs_use:cF { regex_class_/#1: }
      { \regex_class_normal:N #1 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_class_normal:N}
% \begin{macro}[aux]{\regex_class_single:N}
%   Most characters are treated here. We look ahead for a dash.
%   If there is none, then the character matches itself.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_class_normal:N #1 #2
  {
    \token_if_eq_charcode:NNTF #2 \c_space_token
      { \regex_class_normal:N #1 }
      {
        \token_if_eq_charcode:NNTF #2 -
          { \regex_class_range:NN #1 }
          { \regex_class_single:N #1 #2 }
      }
  }
\cs_new_protected_nopar:Npn \regex_class_single:N #1
  {
    \tl_put_right:Nx \l_regex_class_tl
      { \regex_item_equal:n { \int_value:w `#1 } }
    \regex_class_loop:N
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_class_range:NN}
% \begin{macro}[aux]{\regex_class_range_interrupted:N}
% \begin{macro}[aux]{\regex_class_range_escaped:NNN}
% \begin{macro}[aux]{\regex_class_range_put:NN}
%   If the character is followed by a dash, we look for
%   the end-point of the range. In most cases, that's
%   simply |#2|, except in the two special cases |]| and |\|.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_class_range:NN #1 #2
  {
    \regex_if_tail_error:Nn #2 {6}
    \if_charcode:w #2 \c_backslash_str
      \exp_after:wN \use_i:nn
    \else: %^^A [
      \if_charcode:w #2 ]
        \exp_after:wN \exp_after:wN \exp_after:wN \use_ii:nnn
      \else:
        \exp_after:wN \exp_after:wN \exp_after:wN \use_iii:nnn
      \fi:
    \fi:
    { \regex_class_range_escaped:NNN #1 #2 }
    { \regex_class_range_interrupted:N #1 #2 }
    {
      \regex_class_range_put:NN #1#2
      \regex_class_loop:N
    }
  }
\cs_new_protected_nopar:Npn \regex_class_range_interrupted:N #1
  {
    \tl_put_right:Nx \l_regex_class_tl
      {
        \regex_item_single:n { \int_value:w `#1 }
        \regex_item_single:n {45} % -
      }
    \regex_class_loop:N
  }
\cs_new_protected_nopar:Npn \regex_class_range_escaped:NNN #1#2#3
  {
    \regex_if_tail_error:Nn #3 {6}
    \cs_if_exist:cTF { regex_class_/#3: }
      { \regex_class_range_interrupted:N #1#2#3 }
      {
        \regex_class_range_put:NN #1#3
        \regex_class_loop:N
      }
  }
\cs_new_protected_nopar:Npn \regex_class_range_put:NN #1#2
  {
    \if_num:w `#1 > `#2 \exp_stop_f:
      \regex_build_error:n {8}
    \else:
      \tl_put_right:Nx \l_regex_class_tl
        {
          \if_meaning:w #1 #2
            \regex_item_equal:n
          \else:
            \regex_item_range:nn { \int_value:w `#1 }
          \fi:
          { \int_value:w `#2 }
        }
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_class_/d:,\regex_class_/D:}
% \begin{macro}[aux]{\regex_class_/w:,\regex_class_/W:}
%   Similar to \cs{regex_class_single:N}, adding the appropriate
%   ranges of characters to the class.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_class_/d: }
  {
    \tl_put_right:Nn \l_regex_class_tl \c_regex_d_tl
    \regex_class_loop:N
  }
\cs_new_protected_nopar:cpn { regex_class_/D: }
  {
    \tl_put_right:Nn \l_regex_class_tl \c_regex_D_tl
    \regex_class_loop:N
  }
\cs_new_protected_nopar:cpn { regex_class_/w: }
  {
    \tl_put_right:Nn \l_regex_class_tl \c_regex_w_tl
    \regex_class_loop:N
  }
\cs_new_protected_nopar:cpn { regex_class_/W: }
  {
    \tl_put_right:Nn \l_regex_class_tl \c_regex_W_tl
    \regex_class_loop:N
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Ignoring spaces}
%
% \begin{macro}{\regex_build_~:}
% \begin{macro}{\regex_class_~:}
%   Spaces are ignored in regexes unless escaped.
%   This is necessary because \eTeX{} inserts a space
%   after control sequences when detokenizing.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_build_~: } { \regex_build_loop:N }
\cs_new_protected_nopar:cpn { regex_class_~: } { \regex_class_loop:N }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Quantifiers}
%
% \begin{macro}[aux]{\regex_build_quantifier_end:n}
%   When all quantifiers are found, we will call the relevant function.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_quantifier_end:n #1
  { \use:c { regex_build_ \l_regex_one_or_group_tl _ #1 : } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_quantifier:w}
%   We need to look ahead and find any quantifier, then call
%   the relevant \cs{regex_build_one/group_\meta{quantifiers}:}
%   function.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_quantifier:w #1
  {
    \exp_args:No \tl_if_in:nnTF { \c_space_str ? * + } {#1}
      { \use:c { regex_build_quantifier_#1:w } }
      {
        \regex_build_quantifier_end:n { }
        \regex_build_loop:N
      }
    #1
  }
\cs_new_protected_nopar:cpn { regex_build_quantifier_~:w } #1
  { \regex_build_quantifier:w }
\cs_new_protected_nopar:cpn { regex_build_quantifier_?:w }
  { \regex_build_quantifier_aux:nnN { } }
\cs_new_protected_nopar:cpn { regex_build_quantifier_*:w }
  { \regex_build_quantifier_aux:nnN { } }
\cs_new_protected_nopar:cpn { regex_build_quantifier_+:w }
  { \regex_build_quantifier_aux:nnN { } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_quantifier_aux:nnN}
%   Once the \enquote{main} quantifier (\texttt{?}, \texttt{*},
%   \texttt{+} or a braced construction) is found, we check
%   whether it is lazy (followed by a question mark),
%   and calls the appropriate function. Here |#1| holds some extra
%   arguments that the final function needs in the case of braced
%   constructions.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_quantifier_aux:nnN #1#2#3
  {
    \token_if_eq_charcode:NNTF #3 \c_space_token
      { \regex_build_quantifier_aux:nnN {#1} {#2} }
      {
        % \tl_if_in:nnTF { ? + } {#3}
        \token_if_eq_charcode:NNTF #3 ?
          {
            \regex_build_quantifier_end:n { #2 #3 } #1
            \regex_build_loop:N
          }
          {
            \regex_build_quantifier_end:n { #2 } #1
            \regex_build_loop:N #3
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_quantifier_\{:w}
% \begin{macro}[aux]{\regex_build_quantifier_lbrace:nw}
% \begin{macro}[aux]{\regex_build_quantifier_lbrace:nnw}
%   Three possible syntaxes: \texttt{\{\meta{int}\}},
%   \texttt{\{\meta{int},\}}, or \texttt{\{\meta{int},\meta{int}\}}.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_build_quantifier_ \c_lbrace_str :w } #1
  { \regex_get_digits:nw { \regex_build_quantifier_lbrace:nw } }
\cs_new_protected_nopar:Npn \regex_build_quantifier_lbrace:nw #1#2
  {
    \tl_if_empty:nTF {#1}
      {
        \regex_build_quantifier_end:n { }
        \exp_after:wN \regex_build_loop:N \c_lbrace_str #1#2
      }
      {
        \if_charcode:w \exp_not:N #2 ,
          \exp_after:wN \use_i:nnn
        \else:
          \if_charcode:w \exp_not:N #2 \c_rbrace_str
            \exp_after:wN \exp_after:wN \exp_after:wN \use_ii:nnn
          \else:
            \exp_after:wN \exp_after:wN \exp_after:wN \use_iii:nnn
          \fi:
        \fi:
        {
          \regex_get_digits:nw
            { \regex_build_quantifier_lbrace:nnw {#1} }
        }
        { \regex_build_quantifier_aux:nnN {{#1}} {n} }
        {
          \regex_build_quantifier_end:n { }
          \exp_after:wN \regex_build_loop:N \c_lbrace_str #1#2
        }
      }
  }
\cs_new_protected_nopar:Npn \regex_build_quantifier_lbrace:nnw #1#2#3
  {
    \str_if_eq:onTF { \c_rbrace_str } { #3 }
      {
        \tl_if_empty:nTF {#2}
          { \regex_build_quantifier_aux:nnN { {#1} {\c_max_int} } {nn} }
          {
            \if_num:w #1 > #2 \exp_stop_f:
              \regex_build_error:n {4}
            \fi:
            \regex_build_quantifier_aux:nnN { {#1} {#2}         } {nn}
          }
      }
      {
        \regex_build_quantifier_end:n { }
        \exp_after:wN \regex_build_loop:N \c_lbrace_str #1#2#3
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Quantifiers for one character or character class}
%
% \begin{macro}[aux]{\regex_build_one_quantifier:}
%   Used for one single character, or a character class.
%   Contrarily to \cs{regex_build_group_quantifier:},
%   we don't need to keep track of submatches, and no thread
%   can be created within one repetition, so things are easier.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_one_quantifier:
  {
    \tl_set:Nn \l_regex_one_or_group_tl { one }
    \regex_build_quantifier:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_one_:}
%   If no quantifier is found, then the character or character class
%   should just be built into a transition from the current
%   \enquote{right} state to a new state. We abuse
%   \cs{regex_build_transitions_aux:NNNN} for that,
%   omitting the second transition.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_one_:
  {
    \regex_build_transition_aux:NN
      \regex_build_tmp_class:nn \l_regex_state_right_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_one_?:}
% \begin{macro}[aux]{\regex_build_one_??:}
%   The two transitions are a costly transition controlled by
%   the character class, and a free transition, both going to
%   a common new state. The only difference between the greedy
%   and lazy operators is the order of transitions.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_build_one_?: }
  {
    \regex_build_transitions_aux:NNNN
      \regex_build_tmp_class:nn  \l_regex_state_right_int
      \regex_action_free_copy:nn \l_regex_state_right_int
  }
\cs_new_protected_nopar:cpn { regex_build_one_??: }
  {
    \regex_build_transitions_aux:NNNN
      \regex_action_free_copy:nn \l_regex_state_right_int
      \regex_build_tmp_class:nn  \l_regex_state_right_int
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_one_*:}
% \begin{macro}[aux]{\regex_build_one_*?:}
%   Build a costly transition going from the current state to itself,
%   and a free transition moving to a new state.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_build_one_*: }
  {
    \regex_build_transitions_aux:NNNN
      \regex_build_tmp_class:nn  \l_regex_state_left_int
      \regex_action_free_copy:nn \l_regex_state_right_int
  }
\cs_new_protected_nopar:cpn { regex_build_one_*?: }
  {
    \regex_build_transitions_aux:NNNN
      \regex_action_free_copy:nn \l_regex_state_right_int
      \regex_build_tmp_class:nn  \l_regex_state_left_int
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_one_+:}
% \begin{macro}[aux]{\regex_build_one_+?:}
%   Build a transition from the current state to a new state,
%   controlled by the character class, then build two transitions
%   from this new state to the original state (for repetition)
%   and to another new state (to move on to the rest of the pattern).
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_build_one_+: }
  {
    \regex_build_one_:
    \int_set_eq:NN \l_regex_tmpa_int \l_regex_state_left_int
    \regex_build_transitions_aux:NNNN
      \regex_action_free_copy:nn \l_regex_tmpa_int
      \regex_action_free_move:nn \l_regex_state_right_int
  }
\cs_new_protected_nopar:cpn { regex_build_one_+?: }
  {
    \regex_build_one_:
    \int_set_eq:NN \l_regex_tmpa_int \l_regex_state_left_int
    \regex_build_transitions_aux:NNNN
      \regex_action_free_copy:nn \l_regex_state_right_int
      \regex_action_free_move:nn \l_regex_tmpa_int
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_one_n:}
% \begin{macro}[aux]{\regex_build_one_n?:}
%   This function is called in case the syntax is
%   \texttt{\{\meta{int}\}}. Greedy and lazy operators
%   are identical, since the number of repetitions is fixed.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_one_n: #1
  {
    \int_set_eq:NN \l_regex_tmpa_int \l_regex_state_right_int
    \regex_build_new_state:
    \regex_build_new_state:
    \regex_toks_put_right:Nx \l_regex_tmpa_int
      {
        \exp_not:N \if_num:w #1 > \l_regex_repetition_int
          \regex_action_repeat_move:nn
            { \int_use:N \l_regex_tmpa_int }
            { \int_use:N \l_regex_state_left_int }
        \exp_not:N \else:
          \regex_action_no_repeat_move:nn
            { \int_use:N \l_regex_tmpa_int }
            { \int_use:N \l_regex_state_right_int }
        \exp_not:N \fi:
      }
    \regex_toks_put_right:Nx \l_regex_state_left_int
      {
        \regex_build_tmp_class:nn
          { \int_use:N \l_regex_state_left_int }
          { \int_use:N \l_regex_tmpa_int }
      }
  }
\cs_new_eq:cN { regex_build_one_n?: } \regex_build_one_n:
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_one_nn:}
% \begin{macro}[aux]{\regex_build_one_nn?:}
% \begin{macro}[aux]{\regex_build_one_nn_aux:nn}
%   This function is called when the syntax is either
%   \texttt{\{\meta{int},\}} or \texttt{\{\meta{int},\meta{int}\}}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_one_nn: #1#2
  {
    \regex_build_one_nn_aux:nn {#1}
      {
        \exp_not:N \if_num:w #2 > \l_regex_repetition_int
          \regex_action_repeat_copy:nn
            { \int_use:N \l_regex_tmpa_int }
            { \int_use:N \l_regex_state_left_int }
        \exp_not:N \fi:
        \regex_action_no_repeat_move:nn
          { \int_use:N \l_regex_tmpa_int }
          { \int_use:N \l_regex_state_right_int }
      }
  }
\cs_new_protected_nopar:cpn { regex_build_one_nn?: } #1#2
  {
    \regex_build_one_nn_aux:nn {#1}
      {
        \regex_action_no_repeat_copy:nn
          { \int_use:N \l_regex_tmpa_int }
          { \int_use:N \l_regex_state_right_int }
        \exp_not:N \if_num:w #2 > \l_regex_repetition_int
          \regex_action_repeat_move:nn
            { \int_use:N \l_regex_tmpa_int }
            { \int_use:N \l_regex_state_left_int }
        \exp_not:N \fi:
      }
  }
\cs_new_protected_nopar:Npn \regex_build_one_nn_aux:nn #1#2
  {
    \int_set_eq:NN \l_regex_tmpa_int \l_regex_state_right_int
    \regex_build_new_state:
    \regex_build_new_state:
    \regex_toks_put_right:Nx \l_regex_tmpa_int
      {
        \exp_not:N \if_num:w #1 > \l_regex_repetition_int
          \regex_action_repeat_move:nn
            { \int_use:N \l_regex_tmpa_int }
            { \int_use:N \l_regex_state_left_int }
        \exp_not:N \else:
          #2
        \exp_not:N \fi:
      }
    \regex_toks_put_right:Nx \l_regex_state_left_int
      {
        \regex_build_tmp_class:nn
          { \int_use:N \l_regex_state_left_int }
          { \int_use:N \l_regex_tmpa_int }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Groups and alternation}
%
% We support the syntax \texttt{(\meta{expr1}|\ldots{}%^^A
%   |\meta{expr$\sb{n}$})\meta{quantifier}} for alternations.
%
% \begin{macro}[aux]{\regex_build_(:, \regex_build_):}
% \begingroup\lccode`\*=`\|\relax\lowercase{\endgroup
% \begin{macro}[aux]{\regex_build_|:}}
% \begin{macro}[aux]{\regex_build_begin_alternation:,
%     \regex_build_end_alternation:}
%   Grouping and alternation go together.
%   \begin{itemize}
%   \item Allocate the next available number for the end vertex
%     of the alternation/group and store it on a stack (so that nested
%     alternations work).
%   \item Put free transitions to separate all cases of the alternation.
%   \item Build each branch separately, and merge them to the common
%     end-node.
%   \item Test for a quantifier, and if needed, transfer the initial
%     vertex to a new vertex. %^^A todo: check that we have a clean sLate.
%   \end{itemize}
%
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_build_(: }
  {
    \int_incr:N \l_regex_nesting_int
    \regex_build_new_state:
    \int_incr:N \l_regex_capturing_group_int
    \seq_push:Nx \l_regex_capturing_group_seq
      { \int_use:N \l_regex_capturing_group_int }
    \seq_push:Nx \l_regex_state_left_seq
      { \int_use:N \l_regex_state_left_int }
    \seq_push:Nx \l_regex_state_right_seq
      { \int_use:N \l_regex_state_right_int }
    \regex_build_begin_alternation:
    \regex_build_loop:N
  }
\cs_new_protected_nopar:cpn { regex_build_|: }
  {
    \regex_build_end_alternation:
    \regex_build_begin_alternation:
    \regex_build_loop:N
  }
\cs_new_protected_nopar:cpn { regex_build_): }
  {
    \int_compare:nNnTF \l_regex_nesting_int = \c_zero
      {
        \regex_build_error:n {22}
        \regex_build_loop:N
      }
      {
        \int_decr:N \l_regex_nesting_int
        \regex_build_end_alternation:
        \seq_pop:NN \l_regex_state_left_seq  \l_regex_tmpb_tl
        \int_set:Nn \l_regex_state_left_int  \l_regex_tmpb_tl
        \seq_pop:NN \l_regex_state_right_seq \l_regex_tmpb_tl
        \int_set:Nn \l_regex_state_right_int \l_regex_tmpb_tl
            %^^A obsolete the correct thread.
            % \regex_toks_put_right:Nx \l_regex_left_int
            %   { \regex_thread_obsolete:n { \int_use:N \l_regex_left_int } }
        \regex_build_group_quantifier:
      }
  }
%    \end{macrocode}
%   Building each branch.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_begin_alternation:
  {
    \regex_build_new_state:
    \seq_get:NN \l_regex_state_left_seq \l_regex_tmpb_tl
    \int_set:Nn \l_regex_state_left_int \l_regex_tmpb_tl
    \regex_toks_put_right:Nx \l_regex_state_left_int
      {
        \regex_action_free_copy:nn
          { \int_use:N \l_regex_state_left_int }
          { \int_use:N \l_regex_state_right_int }
      }
  }
\cs_new_protected_nopar:Npn \regex_build_end_alternation:
  {
    \seq_get:NN \l_regex_state_right_seq \l_regex_tmpb_tl
    \regex_toks_put_right:Nx \l_regex_state_right_int
      {
        \regex_action_free_move:nn
          { \int_use:N \l_regex_state_right_int }
          { \l_regex_tmpb_tl }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Quantifiers for groups}
%
% \begin{macro}[aux]{\regex_build_group_quantifier:}
%   Used for one group. We need to keep track of submatches,
%   threads can be created within one repetition, so things are hard.
%   The code for the group that was just built starts
%   at \cs{l_regex_state_left_int} and ends at
%   \cs{l_regex_state_right_int}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_group_quantifier:
  {
    \tl_set:Nn \l_regex_one_or_group_tl { group }
    \regex_build_quantifier:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_group_:}
% \begin{macro}[aux]{\regex_build_group_submatches:NN}
%   When there is no quantifier, the group is simply inserted as is,
%   and we only need to track submatches.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_build_group_: }
  {
    \regex_build_group_submatches:NN
      \l_regex_state_left_int \l_regex_state_right_int
    \regex_build_transition_aux:NN
      \regex_action_free_move:nn \l_regex_state_right_int
  }
\cs_new_protected_nopar:Npn \regex_build_group_submatches:NN #1#2
  {
    \seq_pop:NN \l_regex_capturing_group_seq \l_regex_tmpb_tl
    \regex_toks_put_left:Nx #1
      { \regex_action_submatch:nn { \int_use:N #1 } { \l_regex_tmpb_tl < } }
    \regex_toks_put_left:Nx #2
      { \regex_action_submatch:nn { \int_use:N #2 } { \l_regex_tmpb_tl > } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_group_shift:N}
%   Most quantifiers require to add an extra state before the group.
%   This is done by shifting the current contents of the \cs{tex_toks:D}
%   \cs{l_regex_tmpa_int} to a new state.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_group_shift:N #1
  {
    \int_set_eq:NN \l_regex_tmpa_int \l_regex_state_left_int
    \regex_build_new_state:
    %^^A argh! first args of move:nn, copy:nn etc. are wrong below!
    \tex_toks:D \l_regex_state_right_int = \tex_toks:D \l_regex_tmpa_int
    \use:x
      {
        \tex_toks:D \l_regex_tmpa_int
          {
            % ^^A incorrect? Does "move" have to come after "copy"?
            #1
              { \int_use:N \l_regex_tmpa_int }
              { \int_use:N \l_regex_state_right_int }
          }
      }
    \regex_build_group_submatches:NN
      \l_regex_state_right_int \l_regex_state_left_int
    \int_set_eq:NN \l_regex_state_right_int \l_regex_state_left_int
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_group_qs_aux:NN}
% \begin{macro}[aux]{\regex_build_group_?:}
% \begin{macro}[aux]{\regex_build_group_??:}
% \begin{macro}[aux]{\regex_build_group_*:}
% \begin{macro}[aux]{\regex_build_group_*?:}
%   Shift the state at which the group begins using
%   \cs{regex_build_group_shift:N}, then add two transitions.
%   The first transition is taken once the group has been
%   traversed: in the case of \texttt{?} and \texttt{??},
%   we should exit by going to \cs{l_regex_state_right_int},
%   while for \texttt{*} and \texttt{*?} we loop by going to
%   \cs{l_regex_tmpa_int}.
%   The second transition corresponds to skipping the group;
%   it has lower priority (\texttt{put_right}) for greedy
%   operators, and higher priority (\texttt{put_left}) for
%   lazy operators.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_group_qs_aux:NN #1#2
  {
    \regex_build_group_shift:N \regex_action_free_copy:nn
    \regex_build_transition_aux:NN \regex_action_free_move:nn #1
    #2 \l_regex_tmpa_int
      {
        \regex_action_free_move:nn
          { \int_use:N \l_regex_tmpa_int }
          { \int_use:N \l_regex_state_right_int }
      }
  }
\cs_new_protected_nopar:cpn { regex_build_group_?: }
  {
    \regex_build_group_qs_aux:NN
      \l_regex_state_right_int \regex_toks_put_right:Nx
  }
\cs_new_protected_nopar:cpn { regex_build_group_??: }
  {
    \regex_build_group_qs_aux:NN
      \l_regex_state_right_int \regex_toks_put_left:Nx
  }
\cs_new_protected_nopar:cpn { regex_build_group_*: }
  {
    \regex_build_group_qs_aux:NN
      \l_regex_tmpa_int \regex_toks_put_right:Nx
  }
\cs_new_protected_nopar:cpn { regex_build_group_*?: }
  {
    \regex_build_group_qs_aux:NN
      \l_regex_tmpa_int \regex_toks_put_left:Nx
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_group_+:}
% \begin{macro}[aux]{\regex_build_group_+?:}
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { regex_build_group_+: }
  {
    \regex_build_group_submatches:NN
      \l_regex_state_left_int \l_regex_state_right_int
    \int_set_eq:NN \l_regex_tmpa_int \l_regex_state_left_int
    \regex_build_transitions_aux:NNNN
      \regex_action_free_copy:nn \l_regex_tmpa_int
      \regex_action_free_move:nn \l_regex_state_right_int
  }
\cs_new_protected_nopar:cpn { regex_build_group_+?: }
  {
    \regex_build_group_submatches:NN
      \l_regex_state_left_int \l_regex_state_right_int
    \int_set_eq:NN \l_regex_tmpa_int \l_regex_state_left_int
    \regex_build_transitions_aux:NNNN
      \regex_action_free_copy:nn \l_regex_state_right_int
      \regex_action_free_move:nn \l_regex_tmpa_int
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_group_n:}
% \begin{macro}[aux]{\regex_build_group_n?:}
%   These functions are called in case the syntax is
%   \texttt{\{\meta{int}\}}. Greedy and lazy operators
%   are identical, since the number of repetitions is fixed.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_group_n: #1
  {
    \regex_build_group_shift:N \regex_action_repeat_move:nn
    \regex_build_transition_aux:NN
      \regex_action_free_move:nn \l_regex_tmpa_int
    \use:x
      {
        \tex_toks:D \l_regex_tmpa_int
          {
            \exp_not:N \if_num:w #1 > \l_regex_repetition_int %^^A todo:define
              \tex_the:D \tex_toks:D \l_regex_tmpa_int
            \exp_not:N \else:
              \regex_action_no_repeat_move:nn
                { \int_use:N \l_regex_tmpa_int }
                { \int_use:N \l_regex_state_right_int }
            \exp_not:N \fi:
          }
      }
  }
\cs_new_eq:cN { regex_build_group_n?: } \regex_build_group_n:
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_build_group_nn:}
% \begin{macro}[aux]{\regex_build_group_nn?:}
%   These functions are called when the syntax is either
%   \texttt{\{\meta{int},\}} or \texttt{\{\meta{int},\meta{int}\}}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_build_group_nn: #1#2
  {
    \regex_build_group_shift:N \regex_action_repeat_move:nn
    \regex_build_transition_aux:NN
      \regex_action_free_move:nn \l_regex_tmpa_int
    \use:x
      {
        \tex_toks:D \l_regex_tmpa_int
          {
            \exp_not:N \if_num:w #1 > \l_regex_repetition_int %^^A todo:define
              \tex_the:D \tex_toks:D \l_regex_tmpa_int
            \exp_not:N \else:
              \exp_not:N \if_num:w #2 > \l_regex_repetition_int
                \tex_the:D \tex_toks:D \l_regex_tmpa_int
              \exp_not:N \fi:
              \regex_action_no_repeat_copy:nn
                { \int_use:N \l_regex_tmpa_int }
                { \int_use:N \l_regex_state_right_int }
            \exp_not:N \fi:
          }
      }
  }
\cs_new_protected_nopar:cpn { regex_build_group_nn?: } #1#2
  {
    \regex_build_group_shift:N \regex_action_repeat_move:nn
    \regex_build_transition_aux:NN
      \regex_action_free_move:nn \l_regex_tmpa_int
    \use:x
      {
        \tex_toks:D \l_regex_tmpa_int
          {
            \exp_not:N \if_num:w #1 > \l_regex_repetition_int %^^A todo:define
              \tex_the:D \tex_toks:D \l_regex_tmpa_int
            \exp_not:N \else:
              \regex_action_no_repeat_copy:nn
                { \int_use:N \l_regex_tmpa_int }
                { \int_use:N \l_regex_state_right_int }
              \exp_not:N \if_num:w #2 > \l_regex_repetition_int
                \tex_the:D \tex_toks:D \l_regex_tmpa_int
              \exp_not:N \fi:
            \exp_not:N \fi:
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Non-implemented features}
%
% \begin{macro}[aux]{\regex_build_.:}
%    \begin{macrocode}
  %^^A todo: make +, ?, * into errors when appearing on their own.
  %^^A todo: make unimplemented features into errors (e.g., \s, \n...)
%    \end{macrocode}
% \end{macro}
%
% \subsection{Matching}
%
% \subsubsection{Variables}
%
%    \begin{macrocode}
\cs_generate_variant:Nn \prop_pop:NnNF { No }
\cs_generate_variant:Nn \prop_del:Nn { No }
%    \end{macrocode}
%
%    \begin{macrocode}
\str_new:N \l_regex_query_str
\int_new:N \l_regex_Alast_index_int
\int_new:N \l_regex_Blast_index_int
\int_new:N \l_regex_current_thread_int
\int_new:N \l_regex_max_thread_int
\int_new:N \l_regex_current_state_int
\cs_new_eq:NN \regex_if_track_submatches:T \use_none:n
\bool_new:N \l_regex_obsolete_all_bool
\int_new:N  \l_regex_success_thread_int
\prop_new:N \l_regex_success_submatches_prop
\prop_new:N \l_regex_submatches_prop
\prop_new:N \l_regex_tmpa_prop
\seq_new:N  \g_regex_submatches_seq
\int_new:N  \l_regex_character_step_int
%    \end{macrocode}
%
% \subsubsection{User conditionals}
%
% \begin{macro}[TF]{\regex_match:nn}
% \begin{macro}[TF]{\regex_match_extract:nnN}
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \regex_match:nn #1#2 { T , F , TF }
  {
    \group_begin:
      \cs_set_eq:NN \regex_if_track_submatches:T \use_none:n
      \regex_build:n {#1}
      \regex_match:n {#2}
      \exp_after:wN
    \group_end:
    \if_num:w \l_regex_success_thread_int = \c_zero
      \prg_return_false:
    \else:
      \prg_return_true:
    \fi:
  }
\prg_new_protected_conditional:Npnn
    \regex_match_extract:nnN #1#2#3 { T , F , TF }
  {
    \group_begin:
      \cs_set_eq:NN \regex_if_track_submatches:T \use:n
      \regex_build:n {#1}
      \regex_match:n {#2}
      \exp_after:wN
    \group_end:
    \if_num:w \l_regex_success_thread_int = \c_zero
      \prg_return_false:
    \else:
      \seq_set_eq:NN #3 \g_regex_submatches_seq
      \prg_return_true:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[TF]{\regex_nfa_match:Nn}
% \begin{macro}[TF]{\regex_nfa_match_extract:NnN}
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \regex_nfa_match:Nn #1#2 { T , F , TF }
  {
    \exp_args:No \tl_if_head_eq_meaning:nNTF {#1} \regex_nfa:Nw
      {
        \group_begin:
          \cs_set_eq:NN \regex_if_track_submatches:T \use_none:n
          \exp_after:wN \use_none:nn #1
          \regex_match:n {#2}
          \exp_after:wN
        \group_end:
        \if_num:w \l_regex_success_thread_int = \c_zero
          \prg_return_false:
        \else:
          \prg_return_true:
        \fi:
      }
      {
        \msg_error:nn { regex } { not-nfa-var } { \token_to_str:N #1 }
        \prg_return_false:
      }
  }
\prg_new_protected_conditional:Npnn
    \regex_nfa_match_extract:NnN #1#2#3 { T , F , TF }
  {
    \exp_args:No \tl_if_head_eq_meaning:nNTF {#1} \regex_nfa:Nw
      {
        \group_begin:
          \cs_set_eq:NN \regex_if_track_submatches:T \use:n
          \exp_after:wN \use_none:nn #1
          \regex_match:n {#2}
          \exp_after:wN
        \group_end:
        \if_num:w \l_regex_success_thread_int = \c_zero
          \prg_return_false:
        \else:
          \seq_set_eq:NN #3 \g_regex_submatches_seq
          \prg_return_true:
        \fi:
      }
      {
        \msg_error:nn { regex } { not-nfa-var } { \token_to_str:N #1 }
        \prg_return_false:
      }
  }
\msg_new:nnn { regex } { not-nfa-var }
  { The~variable~#1~was~not~defined~through~\regex_nfa_new:Nn }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Use of \TeX{} registers when matching}
%
% The \cs{tex_toks:D} registers are already used to store
% the instructions for the NFA. For each state in the NFA,
% we use the corresponding \cs{tex_dimen:D} register to
% indicate whether that state has been visited or not.
%
% Finally, threads are kept as a list sorted in order of
% decreasing priority. Three informations are stored for
% each priority: the program step at which it currently is,
% the thread id having that priority, and some extra information
% about quantifier repetition. This is stored in a \cs{tex_skip:D}
% or \cs{tex_muskip:D} register, alternatively referred to as
% \enquote{A} or \enquote{B} registers. The \enquote{A}
% registers hold the list of threads before reading a character,
% and \enquote{B} registers hold the list after reading that
% character. Once the new list is built in the \enquote{B} registers,
% the meaning of \enquote{A} and \enquote{B} are exchanged. We then
% carry on reading the next character of the string.
%
% The main component of these registers gives the program step
% at which the thread is. The stretch component is the id of
% the thread which has that priority. The shrink component is
% the number of repetition currently done in the innermost
% repetition level.
%
% \begin{macro}{\regex_swap_AB:}
% \begin{macro}{\regex_setup_Bmu:,\regex_setup_Amu:}
%   The goal is to swap A and B with respect to skips and muskips.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_setup_Bmu:
  {
    %\cs_set:Npn \regex_Aset:nw ##1 { \tex_skip:D ##1 = }
    \cs_set:Npn \regex_Bset:nw ##1 { \tex_muskip:D ##1 = \etex_gluetomu:D }
    \cs_set_eq:NN \regex_Ause:w \tex_skip:D
    \cs_set:Npn   \regex_Buse:w { \etex_mutoglue:D \tex_muskip:D }
    \cs_set_eq:NN \regex_swap_AB: \regex_setup_Amu:
  }
\cs_new_protected_nopar:Npn \regex_setup_Amu:
  {
    %\cs_set:Npn \regex_Aset:nw ##1 { \tex_muskip:D ##1 = \etex_gluetomu:D }
    \cs_set:Npn \regex_Bset:nw ##1 { \tex_skip:D ##1 = }
    \cs_set:Npn   \regex_Ause:w { \etex_mutoglue:D \tex_muskip:D }
    \cs_set_eq:NN \regex_Buse:w \tex_skip:D
    \cs_set_eq:NN \regex_swap_AB: \regex_setup_Bmu:
  }
 %\cs_new_eq:NN \regex_Aset:nw ?
\cs_new_eq:NN \regex_Bset:nw ?
\cs_new_eq:NN \regex_Ause:w ?
\cs_new_eq:NN \regex_Buse:w ?
\cs_new_eq:NN \regex_swap_AB: ?
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_if_A_free:nTF}
% \begin{macro}[aux]{\regex_if_B_free:nTF}
%    \begin{macrocode}
\cs_new_protected:Npn \regex_if_A_free:nTF #1
  {
    \if_int_odd:w \tex_dimen:D #1 \scan_stop:
      \exp_after:wN \use_ii:nn
    \else:
      \exp_after:wN \use_i:nn
    \fi:
  }
\cs_new_protected:Npn \regex_if_B_free:nTF #1
  {
    \if_num:w \tex_dimen:D #1 > \c_one
      \exp_after:wN \use_ii:nn
    \else:
      \exp_after:wN \use_i:nn
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_Bput_thread_in_state:NnTF}
%   Add a new thread to the list, in a given state. If that
%   succeeded, then take the \meta{true branch}, otherwise,
%   the \meta{false branch}.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_Bput_thread_in_state:NnTF #1 #2
  {
    \regex_if_B_free:nTF {#2}
      {
        \tex_advance:D \tex_dimen:D #2 by \c_two sp \scan_stop:
        \int_incr:N \l_regex_Blast_index_int
        \regex_Bset:nw \l_regex_Blast_index_int
          #2 sp plus #1 sp \scan_stop:
        \use_i:nn
      }
      { \use_ii:nn }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_A_use_toks:N}
%   Use a given program instruction, unless it has already been
%   executed at this step.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_A_use_toks:N #1
  {
    \regex_if_A_free:nTF #1
      {
        \tex_advance:D \tex_dimen:D #1 by \c_one sp \scan_stop:
        \tex_the:D \tex_toks:D #1 \scan_stop:
      }
      {
%<trace> \regex_trace:x { Already~seen~state~\int_value:w #1. }
      } % ^^A should it be fail instead ?
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Matching: framework}
%
% \begin{macro}[int]{\regex_match:n}
%   First, reset a few variables and store the query
%   in \cs{l_regex_query_str}.
%   Then loop over the query string, running the automaton.
%   Finally, \cs{regex_match_end:} does the finishing code.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_match:n #1
  {
    \regex_match_setup:
    \str_set:Nn \l_regex_query_str {#1}
    \exp_after:wN \regex_match_loop:N \l_regex_query_str
    \q_recursion_tail \q_recursion_stop
    \regex_match_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_match_setup:}
% \begin{macro}[aux]{\regex_match_loop_setup:}
% \begin{macro}[aux]{\regex_match_loop_setup_aux:n}
%   Hopefully, we didn't forget to initialize anything here.
%   We expand \cs{prg_stepwise_function:nnnN} to an explicit
%   list of all the dimensions that must be taken to zero at
%   every character by \cs{regex_match_loop_setup:}. Otherwise,
%   we would need to expand it at every character, and the
%   \cs{prg_stepwise_\ldots{}} functions are rather slow.
%   The memory footprint only lasts until the end of the
%   regex operation anyways, but to minimize it, we do not
%   end the dimension assignments safely.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_match_setup:
  {
%<trace>    \regex_trace:x { Match~setup... }
    \regex_if_track_submatches:T { \prop_clear:N \l_regex_submatches_prop }
    \regex_setup_Bmu:
    \int_zero:N \l_regex_Blast_index_int
    \regex_Bput_thread_in_state:NnTF \c_one {1} { } { }
    \int_set_eq:NN \l_regex_max_thread_int \c_one
    \int_set_eq:NN \l_regex_character_step_int \c_minus_one
    % ^^A todo: check complete!
    \cs_set_protected_nopar:Npx \regex_match_loop_setup:
      {
        \prg_stepwise_function:nnnN
          {1} {1} { \l_regex_state_max_int }
          \regex_match_loop_setup_aux:n
        \scan_stop:
        \int_incr:N \l_regex_character_step_int
        \bool_set_false:N \l_regex_obsolete_all_bool
        \int_set_eq:NN \l_regex_Alast_index_int \l_regex_Blast_index_int
        \int_zero:N \l_regex_Blast_index_int
        \regex_swap_AB:
      }
  }
\cs_new_protected_nopar:Npn \regex_match_loop_setup: { }
\cs_new_protected_nopar:Npn \regex_match_loop_setup_aux:n #1
  { \tex_dimen:D #1 \c_zero pt }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_match_loop:N}
% \begin{macro}[aux]{\regex_match_one_index:n}
%   Setup what needs to be reset at every character,
%   then set \cs{l_regex_current_char_int} to the
%   character code of the character that is read
%   (and $-1$ for the end of the string), and loop
%   over the elements of the \texttt{A} array.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_match_loop:N #1
  {
    \regex_match_loop_setup:
    \token_if_eq_meaning:NNTF #1 \q_recursion_tail
      { \int_set_eq:NN \l_regex_current_char_int \c_minus_one }
      { \int_set:Nn \l_regex_current_char_int {`#1} }
%<trace>    \regex_trace:x { Read~'\token_to_str:N #1',
%<trace>      ~charcode~\int_use:N \l_regex_current_char_int . }
    \prg_stepwise_function:nnnN
      {1} {1} { \l_regex_Alast_index_int }
      \regex_match_one_index:n
    \quark_if_recursion_tail_stop:N #1
    \regex_match_loop:N
  }
\cs_new_protected_nopar:Npn \regex_match_one_index:n #1
  {
    \int_set:Nn \l_regex_current_state_int { \regex_Ause:w #1 }
    \int_set:Nn \l_regex_current_thread_int
      { \etex_gluestretch:D \regex_Ause:w #1 }
%<trace>    \regex_trace_ist:n {Begin~index~#1}
    \bool_if:NTF \l_regex_obsolete_all_bool
      { \regex_action_fail:n {?} } % ^^A ?
      { \regex_A_use_toks:N \l_regex_current_state_int }
%<trace>    \regex_trace_ist:n {End~index~#1}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Actions when matching}
%
% \begin{macro}[aux]{\regex_action_cost:nn}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_action_cost:nn #1#2
  {
%<trace> \regex_trace:x { Cost~t=\thread\ (s=\state\ ->~#2). }
    \regex_Bput_thread_in_state:NnTF \l_regex_current_thread_int {#2}
      { } { \regex_action_fail:n {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_action_fail:n}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_action_fail:n #1
  {
%<trace> \regex_trace:x { Fail~t=\thread\ in~s=#1. }
    \regex_if_track_submatches:T
      {
        % %^^A todo: move that to the "end-of-toks" marker!?
        % \prop_del:No \l_regex_submatches_prop
        %   { \int_use:N \l_regex_current_thread_int }
        % \prop_show:N \l_regex_submatches_prop
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_action_success:n}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_action_success:n #1
  {
%<trace>    \regex_trace:x { Success~(t=\thread,~s=#1). }
    \bool_set_true:N \l_regex_obsolete_all_bool
    \int_set_eq:NN \l_regex_success_thread_int \l_regex_current_thread_int
    \regex_if_track_submatches:T
      {
        \prop_pop:NoNF \l_regex_submatches_prop
          { \int_use:N \l_regex_current_thread_int }
          \l_regex_success_submatches_prop
          { \prop_clear:N \l_regex_success_submatches_prop }
%<trace>        \prop_show:N \l_regex_submatches_prop
%<trace>        \prop_show:N \l_regex_success_submatches_prop
      }
    % ^^A \regex_if_track_submatches:F { \use_none_delimit_by_q_stop:w }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_action_free_move:nn}
%   To move a thread, change the current program state,
%   but not the current thread.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_action_free_move:nn #1#2
  {
%<trace>    \regex_trace:x { Move~t=\thread\ (s=\state\ ->~#2). }
    \int_set:Nn \l_regex_current_state_int {#2}
    \bool_if:NTF \l_regex_obsolete_all_bool
      { \regex_action_fail:n {?} } % ^^A ?
      { \regex_A_use_toks:N \l_regex_current_state_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_action_free_copy:nn}
% \begin{macro}[aux]{\regex_action_free_copy_aux:}
%   To copy a thread, check whether the program state has already
%   been used at this character. If not, create a new thread
%   in that new state, copy submatches, and insert the instructions
%   for that state in the input stream.
%   Then restore the old values of \cs{l_regex_current_thread_int}
%   and \cs{l_regex_current_state_int}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_action_free_copy:nn #1#2
  {
%<trace> \regex_trace:x { Copy~t=\thread\ (s=\state\ ->~#2). }
    \bool_if:NTF \l_regex_obsolete_all_bool
      {
%<trace> \regex_trace:x { [Outshined~by~a~success.] }
        \regex_action_fail:n { ? }
      } % ^^A ?
      {
        \regex_if_A_free:nTF {#2}
          {
            \int_incr:N \l_regex_max_thread_int
            \use:x
              {
                \int_set:Nn \l_regex_current_state_int {#2}
                \int_set_eq:NN \l_regex_current_thread_int
                  \l_regex_max_thread_int
                \regex_action_free_copy_aux:n
                  { \int_use:N \l_regex_current_thread_int }
                \int_set:Nn \l_regex_current_state_int
                  { \int_use:N \l_regex_current_state_int }
                \int_set:Nn \l_regex_current_thread_int
                  { \int_use:N \l_regex_current_thread_int }
              }
          }
          {
%<trace> \regex_trace:x { [Ignored:~state~#2~already~encountered.] }
          } %^^A  should it be fail?
      }
  }
\cs_new_protected_nopar:Npn \regex_action_free_copy_aux:n #1
  {
    \regex_if_track_submatches:T
      {
        \prop_get:NoNT \l_regex_submatches_prop {#1} \l_regex_tmpb_tl
          {
            \prop_put:Noo \l_regex_submatches_prop
              { \int_use:N \l_regex_current_thread_int }
              { \l_regex_tmpb_tl }
          }
%<trace> \regex_trace:x { [New~thread~\thread] }
%<trace> \prop_show:N \l_regex_submatches_prop
      }
    \bool_if:NTF \l_regex_obsolete_all_bool
      { \regex_action_fail:n {?} } % ^^A ?
      { \regex_A_use_toks:N \l_regex_current_state_int }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\regex_action_submatch:nn}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_action_submatch:nn #1#2
  {
    \regex_if_track_submatches:T
      {
        \prop_pop:NoNF \l_regex_submatches_prop
          { \int_use:N \l_regex_current_thread_int }
          \l_regex_tmpa_prop
          { \prop_clear:N \l_regex_tmpa_prop }
        \prop_put:Nno \l_regex_tmpa_prop {#2}
          { \int_use:N \l_regex_character_step_int }
        \prop_put:Noo \l_regex_submatches_prop
          { \int_use:N \l_regex_current_thread_int }
          { \l_regex_tmpa_prop }
%<trace> \regex_trace:x { Submatch:~s=\state,~t=\thread,~m=#2,~c=\charstep. }
%<trace> \prop_show:N \l_regex_submatches_prop
      }
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_action_repeat_copy:nn { \ERROR }
\cs_new_protected_nopar:Npn \regex_action_repeat_move:nn { \ERROR }
\cs_new_protected_nopar:Npn \regex_action_no_repeat_copy:nn { \ERROR }
\cs_new_protected_nopar:Npn \regex_action_no_repeat_move:nn { \ERROR }
%    \end{macrocode}
%
% \subsubsection{Once the correct match is found}
%
% \begin{macro}[aux]{\regex_match_end:}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_match_end:
  {
    \regex_if_track_submatches:T
      {
        \seq_gclear:N \g_regex_submatches_seq
%<trace>        \prop_show:N \l_regex_success_submatches_prop
        \prg_stepwise_inline:nnnn
          {0} {1} { \l_regex_capturing_group_int }
          {
            \prop_pop:NnNTF
              \l_regex_success_submatches_prop
              { ##1 < }
              \l_regex_tmpb_tl
              {
                \prop_pop:NnNTF
                  \l_regex_success_submatches_prop
                  { ##1 > }
                  \l_regex_tmpc_tl
                  {
                    \seq_gput_right:Nx \g_regex_submatches_seq
                      {
                        \str_from_to:Nnn \l_regex_query_str
                          { \l_regex_tmpb_tl }
                          { \l_regex_tmpc_tl }
                      }
                  }
                  { \seq_gput_right:Nn \g_regex_submatches_seq { } }
              }
              { \seq_gput_right:Nn \g_regex_submatches_seq { } }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</package>
%<*ignored>
%    \end{macrocode}
%
% \subsection{Running the NFA}
%
% Once the NFA is built, we read the string one character at a time,
% and run all possible threads through the automaton in parallel.
%
% \begin{macro}{\l_regex_step_int}
%   Counts the number of characters that have been read in the string.
%    \begin{macrocode}
\int_new:N \l_regex_step_int
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_Athread:n,\regex_Anext:n}
%   Gets the thread and next step corresponding
%   to a given program step.
%    \begin{macrocode}
\cs_new:Npn \regex_Athread:n #1
  {
    \int_value:w \dim_eval:w
      1 \regex_Ause:w \int_eval:w #1 \int_eval_end:
    \dim_eval_end:
  }
\cs_new:Npn \regex_Anext:n #1
  {
    \int_value:w \dim_eval:w
      \etex_gluestretch:D \regex_Ause:w \int_eval:w #1 \int_eval_end:
    \dim_eval_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[TF]{\regex_B_if_used:n,\regex_A_if_used:n}
%   See discussion above on how to detect whether registers are free or not.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \regex_B_if_used:n #1 { F, TF }
  {
    \if_dim:w \etex_glueshrink:D \regex_Buse:w #1
        = \l_regex_step_int sp \scan_stop:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
\prg_new_protected_conditional:Npnn \regex_A_if_used:n #1 { T, F, TF }
  {
    \if_dim:w \etex_glueshrink:D \regex_Ause:w #1
        = \l_regex_step_int sp \scan_stop:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_A_make_used:n}
%   Marks the state as being used at this step.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_A_make_used:n #1
  {
    \regex_Aset:nw {#1}
      \regex_Athread:n {#1} sp
      plus \regex_Anext:n {#1} sp
      minus \l_regex_step_int sp
    \scan_stop:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_Bput_thread_in_state:nn}
%   Insert the last state--thread pair with a pointer to the new one:
%   the new pair then becomes the \enquote{last} one.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_Bput_thread_in_state:nn #1 #2
  {
    \regex_Bset:nw { \l_regex_last_state_int }
      \l_regex_last_thread_int sp
      plus \int_eval:n {#2} sp
      minus \l_regex_step_int sp
    \scan_stop:
    \int_set:Nn \l_regex_last_thread_int {#1}
    \int_set:Nn \l_regex_last_state_int {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_Aput_thread_in_state:nn}
%   This is quite different from the \enquote{B} counterpart.
%   Here, we shouldn't overwrite the pointer part of the
%   \enquote{A} register.
%   Set the thread part of a given \enquote{A} register,
%   without changing the pointer.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_Aput_thread_in_state:nn #1 #2
  {
    \regex_Aset:nw {#2}
      #1 sp
      plus  \etex_gluestretch:D \regex_Ause:w #2
      minus \l_regex_step_int sp
    \scan_stop:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Framework}
%
% \begin{macro}{\regex_run_automaton:}
%   Read the string one char at a time.
%    \begin{macrocode}
\int_new:N \l_regex_max_thread_int
\int_new:N \l_regex_last_thread_int
\int_new:N \l_regex_last_state_int
\int_new:N \l_regex_successful_thread_int
\prop_new:N \l_regex_submatch_prop
\prop_new:N \l_regex_tmpa_prop
\cs_new_protected_nopar:Npn \regex_run_automaton:
  {
    % all skips have been set to zero
    \regex_setup_Bmu:
    \int_zero:N \l_regex_step_int
    \regex_if_track_submatches:T { \prop_clear:N \l_regex_submatch_prop }
    \int_zero:N \l_regex_successful_thread_int
    \int_zero:N \l_regex_last_thread_int
    \int_zero:N \l_regex_last_state_int
    \int_set:Nn \l_regex_max_thread_int {1}
    \regex_Bput_thread_in_state:nn {1} {1}
    \exp_after:wN \regex_run_loop:N \l_regex_string_str
    \q_recursion_tail \q_recursion_stop
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_run_loop:N}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_run_loop:N #1
  {
    \regex_Bput_thread_in_state:nn {0} {0}
    \regex_swap_AB:
    \int_incr:N \l_regex_step_int
%<*trace>
    \int_zero:N \l_regex_trace_nesting_int
    \tl_clear:N \l_regex_trace_tl
    \int_set:Nn \l_regex_trace_int { \regex_Anext:n {0} }
    \bool_until_do:nn { \int_compare_p:n { \l_regex_trace_int = 0 } }
      {
        \tl_put_right:Nx \l_regex_trace_tl
          {
            Thread~ \regex_Athread:n {\l_regex_trace_int} ~
            in~ state~  \int_use:N \l_regex_trace_int .
            \exp_not:N \\
          }
        \int_set:Nn \l_regex_trace_int
          { \regex_Anext:n { \l_regex_trace_int } }
      }
    \regex_trace:x
      {
        \\ ---- ~ Before~step ~ \int_use:N \l_regex_step_int . ~ ----
        \\ \l_regex_trace_tl
        ---- ~ Read ~ char ~ '\token_to_str:N #1' . ~ ----
      }
%</trace>
    \int_zero:N \l_regex_last_thread_int
    \int_zero:N \l_regex_last_state_int
    \token_if_eq_meaning:NNTF \q_recursion_tail #1
      { \int_set:Nn \l_regex_current_char_int {-1} }
      { \int_set:Nn \l_regex_current_char_int {`#1} }
    \tex_toks:D 0 { \use_none_delimit_by_q_stop:w }
    \regex_state_use:n { \regex_Anext:n {0} }
    \q_stop
    \quark_if_recursion_tail_stop:N #1
    \regex_run_loop:N
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Let's run}
%
% \begin{macro}{\regex_state_use:n}
%   We make sure to expand \cs{regex_Anext:n} before doing all the stuff
%   in the toks register number \cs{l_regex_current_state_int}.
%    \begin{macrocode}
\int_new:N \l_regex_current_state_int
\cs_new_protected_nopar:Npn \regex_state_use:n #1
  {
    \int_set:Nn \l_regex_current_state_int {#1}
    \use:x
      {
        \regex_state_use_aux:nn
          { \int_use:N \l_regex_current_state_int }
          { \regex_Anext:n { \l_regex_current_state_int } }
      }
  }
\cs_new_protected_nopar:Npn \regex_state_use_aux:nn #1 #2
  {
%<*trace>
    \regex_A_if_used:nTF { \l_regex_current_state_int }
      { \regex_trace:x { State~#1~ignored. } }
      {
        \int_compare:nF { #1 = 0 }
          { \regex_trace:x { State~#1,~thread~\regex_Athread:n{#1}. } }
      }
    \int_incr:N \l_regex_trace_nesting_int
%</trace>
    \regex_A_if_used:nF { \l_regex_current_state_int }
      {
        \regex_A_make_used:n \l_regex_current_state_int
        \tex_the:D \tex_toks:D \l_regex_current_state_int
        \regex_end_of_current_toks:n { }
      }
%<trace>    \int_decr:N \l_regex_trace_nesting_int
    \regex_state_use:n {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Instructions}
%
% Four basic instructions:
% \begin{itemize}
% \item \cs{regex_thread_goto:nn} for arrows which \enquote{cost}
%   one character, coming from single characters or character classes;
% \item \cs{regex_thread_fail:n} when the current character
%   does not match the required character for costly arrows;
% \item \cs{regex_thread_obsolete:n} similar to fail, but when
%   a thread is clobbered by one with higher precedence.
% \item \cs{regex_thread_copy:nn} for \enquote{free} arrows,
%   coming from quantifiers such as |*| or from alternations;
% \item \cs{regex_thread_move:nn} similar to \enquote{copy},
%   but for cases where there is only one arrow, hence
%   no copying is needed;
% \item \cs{regex_success_thread:n} when reaching the end
%   of the regular expression.
% \end{itemize}
%
% \begin{macro}{\regex_thread_goto:nn}
%   Arguments: current state, new state. If the new state
%   has already appeared in a thread with higher priority,
%   do nothing, otherwise introduce the thread in the
%   \enquote{B} register corresponding to the state.
%    \begin{macrocode}
\int_new:N \l_regex_tmpa_int
\cs_new_protected_nopar:Npn \regex_thread_goto:nn #1 #2
  {
%<*trace>
    \regex_B_if_used:nTF {#2}
      { \regex_trace:x { skipped~'goto~#2' } }
      { \regex_trace:x { goto~#2 } }
%</trace>
    \regex_B_if_used:nF {#2}
      { \regex_Bput_thread_in_state:nn { \regex_Athread:n {#1} } {#2} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_thread_fail:n}
%   When we are not tracking submatches, nothing needs to be done
%   for failed threads.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_thread_fail:n #1
  {
%<trace>    \regex_trace:x { fail }
    \regex_if_track_submatches:T
      {
        \regex_put_at_end_of_current_toks:n
          {
            \exp_args:NNf \prop_pop:NnN \l_regex_submatch_prop
              { \regex_Athread:n {#1} } \l_regex_tmpb_tl
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_thread_obsolete:n}
%   ^^A for efficiency, we should reuse the thread number in copy.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_thread_obsolete:n #1
  {
%<trace>    \regex_trace:x { obsolete~thread~\regex_Athread:n{#1} }
    \regex_if_track_submatches:T
      {
        \exp_args:NNf \prop_pop:NnN \l_regex_submatch_prop
          { \regex_Athread:n {#1} } \l_regex_tmpb_tl
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_thread_copy:nn}
%   Arguments: \meta{current state}, \meta{new state}. If we have
%   already met a thread in the \meta{new state}, then going there
%   is now useless (since the earlier thread had higher precedence).
%   Otherwise, we should fail the current thread %^^A unfinished sentence
%   The new state may appear
%   later in the chained list, so we should not break the link
%   to the next step of the chain. First set the thread to a new
%   thread, do the action, and finally inhibit any later action
%   of that state.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_thread_copy:nn #1 #2
  {
%<*trace>
    \regex_A_if_used:nTF {#2}
      { \regex_trace:x { skipped~'copy~to~#2' } }
      {
        \regex_trace:x
          { create~thread~\int_eval:n { \l_regex_max_thread_int + 1 } }
      }
%</trace>
    \regex_A_if_used:nF {#2}
      {
        \if_dim:w \etex_glueshrink:D \regex_Ause:w #2
            = \int_eval:w \l_regex_step_int - 1 sp \scan_stop:
          \regex_thread_obsolete:n {#2}
        \fi:
        \int_incr:N \l_regex_max_thread_int
        \regex_Aput_thread_in_state:nn { \l_regex_max_thread_int } {#2}
        \regex_if_track_submatches:T
          {
            \use:x
              {
                \regex_thread_copy_submatch:nn
                  { \regex_Athread:n {#1} }
                  { \int_use:N \l_regex_max_thread_int }
              }
          }
%<trace>        \regex_trace_the_toks:n {#2}
%<!trace>        \tex_the:D \tex_toks:D #2 \scan_stop:
        \regex_end_of_current_toks:n { }
      }
  }
\cs_new_protected:Npn \regex_thread_copy_submatch:nn #1 #2
  {
    \prop_split:NnTF \l_regex_submatch_prop {#1}
      { \regex_thread_copy_submatch_aux:nnnnn {#1} {#2} }
      { }
  }
\cs_new_protected:Npn \regex_thread_copy_submatch_aux:nnnnn #1#2#3#4#5
  {
    \tl_set:Nn \l_regex_submatch_prop
      { #3 #1 \q_prop {#4} \q_prop #2 \q_prop {#4} \q_prop #5 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_thread_move:nn}
%   Similar to \cs{regex_thread_copy:nn} for the end of an alternation:
%   it is then useless to copy the thread, and we can simply move it
%   to the state at the end of the alternation, since there is only one
%   free transition.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_thread_move:nn #1 #2
  {
%<*trace>
    \regex_A_if_used:nTF {#2}
      { \regex_trace:x { skipped~'move~to~#2' } }
      { \regex_trace:x { move~to~#2 } }
%</trace>
    \regex_A_if_used:nF {#2}
      {
        \regex_Aput_thread_in_state:nn { \regex_Athread:n {#1} } {#2}
%<trace>        \regex_trace_the_toks:n {#2}
%<!trace>        \tex_the:D \tex_toks:D #2 \scan_stop:
        \regex_end_of_current_toks:n { }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_success_thread:n}
%   Mark the thread as successful, and forget any previous successful thread.
%^^A memory leak: using use_none_delimit_by_q_stop means that we
%^^A don't fail all subsequent threads.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_success_thread:n #1
  {
%<trace>    \regex_trace:x { success }
    \int_set:Nn \l_regex_successful_thread_int { \regex_Athread:n {#1} }
    \use_none_delimit_by_q_stop:w
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_put_at_end_of_current_toks:n}
% \begin{macro}{\regex_end_of_current_toks:n}
%   This is used to fail threads at the right place.
%    \begin{macrocode}
\cs_new:Npn \regex_put_at_end_of_current_toks:n
    #1 #2 \regex_end_of_current_toks:n #3
  {
    #2 \regex_end_of_current_toks:n { #3 #1 }
  }
\cs_new_eq:NN \regex_end_of_current_toks:n \use:n
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Extract submatches}
%
% \begin{macro}{\regex_thread_submatch:nn}
%   Nested props. Somewhat messy.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_thread_submatch:nn #1 #2
  {
    \use:x
      {
        \regex_thread_submatch_aux:nnn
          { \regex_Athread:n {#1} }
          {#2}
          { \int_eval:n { \l_regex_step_int - 1 } }
      }
  }
\cs_new_protected:Npn \regex_thread_submatch_aux:nnn #1 #2 #3
  {
%<trace>    \regex_trace:x { submatch~thread~#1~nesting~#2~char~#3 }
    \prop_split:NnTF \l_regex_submatch_prop {#1}
      { \regex_thread_submatch_aux_ii:nnnnnn {#1} {#2} {#3} }
      {
        \tl_put_right:Nn \l_regex_submatch_prop
          { #1 \q_prop { \q_prop #2 \q_prop {#3} \q_prop } \q_prop }
      }
  }
\cs_new_protected:Npn \regex_thread_submatch_aux_ii:nnnnnn #1#2#3#4#5#6
  {
    \tl_set:Nn \l_regex_tmpa_prop {#5}
    \prop_put:Nnn \l_regex_tmpa_prop {#2} {#3}
    \tl_set:Nx \l_regex_submatch_prop
      {
        \exp_not:n {#4}
        #1
        \exp_not:N \q_prop
        { \exp_not:o \l_regex_tmpa_prop }
        \exp_not:N \q_prop
        \exp_not:n {#6}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_extract_submatches:}
%    \begin{macrocode}
\seq_new:N \g_regex_submatches_seq
\cs_new_protected_nopar:Npn \regex_extract_submatches:
  {
    \seq_gclear:N \g_regex_submatches_seq
    \exp_args:NNV \prop_get:NnNT
      \l_regex_submatch_prop
      \l_regex_successful_thread_int
      \l_regex_tmpa_prop
      {
%<trace>        \prop_show:N \l_regex_tmpa_prop
        \prg_stepwise_inline:nnnn
          {0} {1} { \l_regex_capturing_group_int }
          {
            \prop_pop:NnNTF \l_regex_tmpa_prop { ##1 < } \l_regex_tmpb_tl
              {
                \prop_pop:NnNTF \l_regex_tmpa_prop { ##1 > } \l_regex_tmpc_tl
                  {
                    \seq_gput_right:Nx \g_regex_submatches_seq
                      {
                        \str_from_to:Nnn \l_regex_string_str
                          { \l_regex_tmpb_tl }
                          { \l_regex_tmpc_tl }
                      }
                  }
                  { \seq_gput_right:Nn \g_regex_submatches_seq { } }
              }
              { \seq_gput_right:Nn \g_regex_submatches_seq { } }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \textbf{Old and wrong.}%^^A This whole section is a mess.
%
% At the end of the day, if the pattern matches the string,
% we want to know how it matched, and extract the various
% parts of the pattern. There are often many ways of matching,
% only the \enquote{leftmost longest} is kept.\footnote{Todo: clarify.}
% Again, we go through the string one character at a time,
% keeping track of \enquote{threads}: each thread corresponds
% to one possible way of matching the partial string with
% the beginning of the pattern. Threads are kept synchronous
% in the string, but are at different states of the NFA.
% In fact, at each step in the string, we only need to keep
% one thread per state in the NFA: since we do not support
% back-references, the previous execution will not influence
% the match, and we can keep the thread with highest priority.
%
% What do we have to keep track of? Threads are organized
% as a simply chained list. Each thread must thus know
% \begin{itemize}
% \item what the next thread is,
% \item what NFA instruction it is at,
% \item what submatches it has found.
% \end{itemize}
% We also need to keep track at each step of which
% program instructions already have a thread. Lastly,
% the NFA itself must be stored.
%
% There are several channels to store data:
% \begin{itemize}
% \item \cs{dimen} registers,
% \item \cs{skip} registers,
% \item \cs{muskip} registers,
% \item \cs{toks} registers,
% \item sequences or property lists.
% \end{itemize}
% How we organize our data will of course influence the
% performance of the algorithm. Let us denote by $n$ the
% size of the NFA and $L$ the length of the string. The
% number of threads $t$ is always less than or equal to $n$,
% and changes at each step. The number $g$ of capturing groups
% is also less than $n$, and often much smaller.
%
% The NFA must be stored either in \cs{toks} registers
% (access in $O(1)$), or in a property list (access in $O(n)$).
% We have the same alternative for submatches, either
% toks in $O(g)$ or property list in $O(gt)$.
%
% For each character in the string, we loop over the chained list
% of threads. For each of those threads, we read the corresponding
% instruction of the program. If this is a \enquote{split}
% instruction, copies of the current thread are created and inserted
% in the chained list. Submatches found so far are also copied (maybe?).
% If this is a character instruction, the current character is tested,
% and if it matches, we move the thread to the next instruction in
% the program.
%
% Three main costs: looking up the program instruction,
% storing submatch information, and killing a thread
% (removing its submatch information is the slow bit).
%
% All the times below are wrong: I forgot the time to kill a thread
% and remove its submatch info. Let $l$ be the typical life-span
% of a thread. Then at each char $t/l$ threads die. Similarly, at
% each char, $gt/n$ threads require us to store submatch information,
% and the total amount of submatch information is $gt$.
% \begin{itemize}
% \item NFA as toks, submatches as prop.
%   Looking up the NFA costs $Lt$ in total.
%   Submatches storage costs $Lg^2t^2/n$.
%   Killing costs $Lgt^2/l$.
%   Copying costs $Lgt$.
% \item NFA as prop, submatches as toks.
%   [Impossible! the number of threads is unbounded.]
%   ^^A Looking up the NFA costs $Lnt$.
%   ^^A Submatches storage costs $Lg^2t/n$
%   ^^A Killing costs $Lgt/l$.
%   ^^A Copying costs $Lgt/l$.
% \item NFA as toks, submatches as toks, threadwise.
%   [Impossible! the number of threads is unbounded.]
%   ^^A Looking up the NFA costs $Lgt$.
%   ^^A Submatches storage costs $Lg^2t/n$
%   ^^A Killing costs $Lgt/l$
%   ^^A Copying costs $Lgt/l$
% \item NFA as toks, submatches at the corresponding program instruction.
%   Looking up the NFA costs $Lt$.
%   Submatches storage costs $Lgt^2/n$.
%   Killing costs $Lgt^2/l$.
%   Copying costs $Lgt^2/l$.
% \end{itemize}
% It looks as if the last one might be a faster option than the first,
% but it also looks quite messy, and requires to keep track of another
% list for each thread, so things are not too clear.
%
% I'll go for the first method, storing program instructions
% in \TeX{}'s toks registers, and submatch information
% in a property list. To each program instruction is associated:
% \begin{itemize}
% \item the thread number,
% \item the program instruction at which
%   the next thread in the chained list is.
% \end{itemize}
% This information is stored as the normal and stretch components
% of a \cs{skip} or \cs{muskip} register (alternating depending
% on the step).
%
% \subsection{Main commands}
%
% \begin{macro}[TF]{\regex_nfa_run:Nn}
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \regex_nfa_run:Nn #1#2 { T , F , TF }
  {
    \group_begin:
      \bool_set_true:N \l_regex_safe_bool
      #1
      \regex_nfa_run_aux:n {#2}
      \exp_after:wN
    \group_end:
    \if_num:w \l_regex_successful_thread_int = \c_zero
      \prg_return_false:
    \else:
      \prg_return_true:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[TF]{\regex_match:nn}
% \begin{macro}[TF]{\regex_match_extract:nnN}
%   Both conditionals defer their work to \cs{regex_match_aux:nn},
%   which builds the automaton, and does the matching within a group
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \regex_match:nn #1#2 { T , F , TF }
  {
    \group_begin:
      \bool_set_true:N \l_regex_safe_bool
      \cs_set_eq:NN \regex_if_track_submatches:T \use_none:n
      \str_set:Nn \l_regex_regex_str  {#1}
      \regex_build_automaton:
      \str_set:Nn \l_regex_string_str {#2}
      \regex_match_aux:
      \exp_after:wN
    \group_end:
    \if_num:w \l_regex_successful_thread_int = \c_zero
      \prg_return_false:
    \else:
      \prg_return_true:
    \fi:
  }
\prg_new_protected_conditional:Npnn
    \regex_match_extract:nnN #1#2#3 { T , F , TF }
  {
    \group_begin:
      \bool_set_true:N \l_regex_safe_bool
      \cs_set_eq:NN \regex_if_track_submatches:T \use:n
      \str_set:Nn \l_regex_regex_str  {#1}
      \regex_build_automaton:
      \str_set:Nn \l_regex_string_str {#2}
      \regex_match_aux:
      \exp_after:wN
    \group_end:
    \if_num:w \l_regex_successful_thread_int = \c_zero
      \prg_return_false:
    \else:
      \seq_set_eq:NN #3 \g_regex_submatches_seq
      \prg_return_true:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%   Matching
%    \begin{macrocode}
\cs_new_protected:Npn \regex_match_aux:
  {
%<trace>      \regex_trace_input:
      \regex_run_automaton:
      \regex_if_track_submatches:T { \regex_extract_submatches: }
%<trace>      \regex_trace_success:
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</ignored>
%    \end{macrocode}
%
% \section{Code specific to tracing}
%
%    \begin{macrocode}
%<*trace>
%    \end{macrocode}
%
% \begin{macro}{\l_regex_trace_tl,\l_regex_trace_nesting_int,\l_regex_trace_int}
%    \begin{macrocode}
 %^^A todo: check
\tl_new:N \l_regex_trace_tl
\int_new:N \l_regex_trace_int
\int_new:N \l_regex_trace_nesting_int
\tl_new:N \l_regex_trace_line_start_tl
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_trace:x}
%   Trace, adding \enquote{(regex)} to each new line,
%   and setting up the control space to produce a space.
%    \begin{macrocode}
\cs_new_protected:Npn \regex_trace:x #1
  {
    \group_begin:
      \cs_set_eq:NN \ \c_space_tl
      \cs_set:Npn \thread { \int_use:N \l_regex_current_thread_int }
      \cs_set:Npn \state  { \int_use:N \l_regex_current_state_int }
      \cs_set:Npn \charstep { \int_use:N \l_regex_character_step_int }
      \tl_set:Nx \l_regex_trace_line_start_tl
        {
          (regex) ~
          \prg_replicate:nn { \l_regex_trace_nesting_int } { \ \  }
        }
      \cs_set_nopar:Npx \\ { \iow_newline: \l_regex_trace_line_start_tl }
      \iow_term:x { \l_regex_trace_line_start_tl #1}
    \group_end:
  }
\cs_new_protected:Npn \regex_trace_wrap:nnx #1 #2 #3
  { \iow_wrap:xnnnN { #3 } { (regex)~ #1 } { 8 + #2 } { } \regex_trace:x }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_trace_the_toks:n}
%    \begin{macrocode}
% \cs_new_protected:Npn \regex_trace_the_toks:n #1
%   {
%     \regex_trace:x { State~#1,~thread~\regex_Athread:n{#1}. }
%     \int_incr:N \l_regex_trace_nesting_int
%     \tex_the:D \tex_toks:D #1 \scan_stop:
%     \int_decr:N \l_regex_trace_nesting_int
%   }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_trace_input:}
%    \begin{macrocode}
% \cs_new_protected_nopar:Npn \regex_trace_input:
%   {
%     \regex_trace:x
%       {
%         Task:~match~the~regex~'\l_regex_regex_str'\\
%         in~'\l_regex_string_str'.
%       }
%   }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\regex_trace_success:}
%   Used at one place to print which thread was successful.
%    \begin{macrocode}
% \cs_new_protected_nopar:Npn \regex_trace_success:
%   {
%     \int_zero:N \l_regex_trace_nesting_int
%     \regex_trace:x
%       { \\ Successful~thread:~ \int_use:N \l_regex_successful_thread_int }
%   }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Trace-related functions}
%
% \begin{macro}[aux]{\regex_trace_nfa:}
%    \begin{macrocode}
\cs_new_nopar:Npn \regex_trace_nfa:
  {
    \regex_trace:x
      {
        NFA~from~\l_regex_pattern_str\ has~
        \int_use:N \l_regex_state_max_int \ states:
      }
    \prg_stepwise_inline:nnnn {1} {1} {\l_regex_state_max_int}
      {
        \regex_trace_wrap:nnx { \ \ \ \ } {4}
          {
            \iow_char:N \{ ##1 \iow_char:N \}
            \ = \ \iow_char:N \{ \tex_the:D \tex_toks:D ##1 \iow_char:N \}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\regex_trace_ist:n}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \regex_trace_ist:n #1
  { \regex_trace:x { #1,~s=\state,~t=\thread. } }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</trace>
%    \end{macrocode}
%
% \end{implementation}
%
% \endinput
%^^A<*trace>
%^^A    \regex_trace:x { \\ Automaton~built~from:~\tl_to_str:N \l_regex_regex_str }
%^^A    \prg_stepwise_inline:nnnn {1} {1} {\l_regex_max_int}
%^^A      {
%^^A        \regex_trace_wrap:nnx { \ \ \ \ } {4}
%^^A          { ##1 ~ > ~ \tex_the:D \tex_toks:D ##1 ~ }
%^^A      }
%^^A</trace>
