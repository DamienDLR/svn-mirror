% \iffalse meta-comment
%
%% File: l3fp-basics.dtx Copyright (C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id: l3fp-basics.dtx 0000 0000-00-00 00:00:00Z bruno $
  {L3 Experimental floating-point arithmetic}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \tableofcontents
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{l3fp-basics} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Floating point expressions}
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
% \date{Released \filedate}
%
% \maketitle
%
% \begin{documentation}
%   \section{Internal storage of floating points numbers}
%   
%   The internal structure of floating point numbers is described in
%   \file{l3fp-convert.dtx}. A floating point number \meta{X} is stored as
%   \begin{quote}
%     \cs{s_fp} \cs{fp_use:w}
%     \meta{case} \meta{sign} \Arg{exponent} \meta{body} |;|
%   \end{quote}
%   Here, \meta{case} is 0 for zeros, 1 for normal numbers,
%   2 for infinities, and 3 for \texttt{NaN}s, and \meta{sign} is
%   $0$ for positive numbers, $1$ for \texttt{NaN}s, and $2$ for
%   negative numbers. The \meta{body} of normal numbers is
%   \Arg{X1} \Arg{X2} \Arg{X3} \Arg{X4}, with
%   \[
%   \meta{X}
%   = (-1)^{\meta{sign}} 10^{-\meta{exponent}}
%   \sum_i \meta{X\sb{i}} 10^{-4i}.
%   \]
%   Calculations are done in base $10000$, \emph{i.e.} one myriad.
%   The maximum \meta{exponent} is currently limited to $10000$ or so,
%   but this may change a bit: the main constraint is to be a valid
%   \TeX{} integer.^^A clarify
%
%   Additionally, positive and negative floating point numbers may only
%   be stored with $1000\leq\meta{X1}<10000$. This requirement is necessary
%   in order to preserve accuracy and speed. Not abiding by it will lead
%   to all sorts of trouble.
%
%   \section{Operations}
%
%   \begin{function}[EXP]{\fp_add:ff,\fp_add:ww}
%     \begin{syntax}
%       \cs{fp_add:ff} \Arg{X} \Arg{Y}
%       \cs{fp_add:ww} \meta{X} \meta{Y}
%     \end{syntax}
%     These functions f-expand to the sum \meta{X+Y}. Additionally,
%     \cs{fp_add:ww} expands the following token exactly once.
%   \end{function}
% 
% \begin{function}[EXP]{\fp_sub:ff,\fp_sub:ww}
%   \begin{syntax}
%     \cs{fp_sub:ff} \Arg{X} \Arg{Y}
%     \cs{fp_sub:ww} \meta{X} \meta{Y}
%   \end{syntax}
%   These functions f-expand to the difference \meta{X-Y}. Additionally,
%   \cs{fp_sub:ww} expands the following token exactly once.
% \end{function}
% 
% \begin{function}[EXP]{\fp_mul:ff,\fp_mul:ww}
%   \begin{syntax}
%     \cs{fp_mul:ff} \Arg{X} \Arg{Y}
%     \cs{fp_mul:ww} \meta{X} \meta{Y}
%   \end{syntax}
%   These functions f-expand to the product \meta{X*Y}. Additionally,
%   \cs{fp_mul:ww} expands the following token exactly once.
% \end{function}
%
% \end{documentation}
% 
% \begin{implementation}
%
% \section{Implementation}
%
%   We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
%</package>
%<*initex|package>
%    \end{macrocode}
%
% \subsection{Addition and subtraction}
%
% \subsubsection{User commands}
%
% Only a few commands are meant for external use (although none
% of them by end-users). The trailing \cs{prg_do_nothing:} in some
% commands catches the extra expansion that is done by design at
% the end of every calculation.
%
% \begin{macro}[EXP]{\fp_add:ff}
% \begin{macro}[aux,EXP]{\fp_basics_add_ff:NNwn,\fp_basics_add_ff:NNwNN}
%   The two arguments are f-expanded before being fed to 
%   \cs{fp_basics_add_cases:NN} in the correct form:
%   \begin{quote}
%     \cs{fp_basics_add_cases:NN}
%     \meta{case2} \meta{case1} \meta{sign2} \meta{sign1}
%     \meta{exp2}  \meta{body2} |;| \meta{exp1}  \meta{body1} |;|
%   \end{quote}
%    \begin{macrocode}
\cs_new:Npn \fp_add:ff #1 
  {
    \exp_after:wN \fp_basics_add_ff:NNwn
    \tex_romannumeral:D -`0 #1
  }
\cs_new:Npn \fp_basics_add_ff:NNwn \s_fp \fp_use:w #1 #2 #3 ; #4
  {
    \exp_after:wN \fp_basics_add_ff:NNwNN
    \exp_after:wN #1
    \exp_after:wN #2
    \tex_romannumeral:D -`0 #4
    #3 ;
    \prg_do_nothing:
  }
\cs_new:Npn \fp_basics_add_ff:NNwNN #1 #2 \s_fp \fp_use:w #3 #4
  { \fp_basics_add_cases:NN #3 #1 #4 #2 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\fp_sub:ff}
% \begin{macro}[aux,EXP]{\fp_basics_sub_ff:NNwn,\fp_basics_sub_ff:NNwNN}
%   The two arguments are f-expanded before being fed to
%   \cs{fp_basics_add_cases:NN} in the correct form:
%   with the two \meta{cases}, and the \meta{signs} collected up front.
%   The second sign must be flipped. This is done by replacing it by
%   $2-\meta{sign}$.
%    \begin{macrocode}
\cs_new:Npn \fp_sub:ff #1
  {
    \exp_after:wN \fp_basics_sub_ff:NNwn
    \tex_romannumeral:D -`0 #1
  }
\cs_new:Npn \fp_basics_sub_ff:NNwn \s_fp \fp_use:w #1 #2 #3 ; #4
  {
    \exp_after:wN \fp_basics_sub_ff:NNwNN
    \exp_after:wN #1
    \exp_after:wN #2
    \tex_romannumeral:D -`0 #4
    #3 ;
    \prg_do_nothing:
  }
\cs_new:Npn \fp_basics_sub_ff:NNwNN #1 #2 \s_fp \fp_use:w #3 #4
  {
    \exp_after:wN \fp_basics_add_cases:NN
    \exp_after:wN #3
    \exp_after:wN #1
    \tex_the:D \etex_numexpr:D 2 - #4 \tex_relax:D
    #2
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\fp_add:ww}
% \begin{macro}[EXP]{\fp_sub:ww}
%   Each argument is
%   \begin{quote}
%     \cs{s_fp} \cs{fp_use:w} \meta{case} \meta{sign}
%     \meta{exponent} \meta{body} |;|
%   \end{quote}
%   We setup for \cs{fp_basics_add_cases:NN}.
%    \begin{macrocode}
\cs_new:Npn \fp_add:ww \s_fp \fp_use:w #1 #2 #3 ; \s_fp \fp_use:w #4 #5
  { \fp_basics_add_cases:NN #1 #4 #2 #5 #3 ; }
\cs_new:Npn \fp_sub:ww \s_fp \fp_use:w #1 #2 #3 ; \s_fp \fp_use:w #4 #5
  {
    \exp_after:wN \fp_basics_add_cases:NN
    \exp_after:wN #1
    \exp_after:wN #4
    \exp_after:wN #2
    \tex_the:D \etex_numexpr:D 2 - #5 \tex_relax:D
    #3 ;
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% 
%
% \subsubsection{Sign, exponent, and special numbers}
%
% \begin{macro}[EXP,aux]{\fp_basics_add_cases:NN}
%   \begin{syntax}
%     \cs{fp_basics_add_cases:NN} \meta{case1} \meta{case2}
%     ~~\meta{sign1} \meta{sign2}
%     ~~\Arg{exp1}  \meta{body1} |;| \Arg{exp2} \meta{body2} |;|
%   \end{syntax}
%   This performs the addition. it also expands the following tokens
%   on the input stream once.
%
%   First filter out the cases where \meta{sign1} or \meta{sign2} is
%   other than |0| (positive normal numbers)
%   or |1| (negative normal numbers).
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_cases:NN #1 #2
  {
    \if_num:w #1 = #2 \exp_stop_f:
      \exp_after:wN \fp_basics_add_cases_eq:N
    \else:
      \if_num:w #1 < #2 \exp_stop_f:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_basics_add_cases_ii:NNNNnwnw
      \else:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_basics_add_cases_i:NNNNnwnw
      \fi:
      \exp_after:wN #1
    \fi:
    #2
  }
%    \end{macrocode}
% If the first \meta{case} is larger, then the first number remains
% untouched, while the second number is ignored. On the other hand,
% if the second \meta{case} is larger, the opposite happens: we retain
% the second number. In both cases, there needs to be one step of
% expansion after 
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_cases_i:NNNNnwnw #1#2 #3#4 #5#6; #7#8;
  { \fp_aux_exp_after_fp:wN \s_fp \fp_use:w #1 #3 {#5} #6; }
\cs_new:Npn \fp_basics_add_cases_ii:NNNNnwnw #1#2 #3#4 #5#6;
  { \fp_aux_exp_after_fp:wN \s_fp \fp_use:w #2 #4 }
%    \end{macrocode}
% We are then ready for the equality case: we split according
% to the \meta{case}.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_cases_eq:N #1
  {
    \if_case:w #1 \exp_stop_f:
         \exp_after:wN \fp_basics_add_zeros:NNnwnw
    \or: \exp_after:wN \fp_basics_add_normal:NNnwnw
    \or: \exp_after:wN \fp_basics_add_inf:NNnwnw
    \or: \exp_after:wN \fp_basics_add_nan:NNnwnw
    \fi:
  }
%    \end{macrocode}
% The case of two normal numbers is done separately.
% Three \cs{exp_after:wN} are needed to get out of the conditional,
% and add an extra step of expansion.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_zeros:NNnwnw #1#2 #3#4; #5#6;
  {
    \if_num:w #1 #2 > \c_twenty
      \exp_after:wN \exp_after:wN \exp_after:wN \c_minus_zero_fp
    \else:
      \exp_after:wN \exp_after:wN \exp_after:wN \c_plus_zero_fp
    \fi:
  }
\cs_new:Npn \fp_basics_add_inf:NNnwnw #1#2 #3#4; #5#6;
  {
    \if_num:w #1 #2 > \c_twenty
      \exp_after:wN \exp_after:wN \exp_after:wN \c_minus_inf_fp
    \else:
      \exp_after:wN \exp_after:wN \exp_after:wN \c_plus_inf_fp
    \fi:
  }
\cs_new:Npn \fp_basics_add_nan:NNnwnw #1#2 #3#4; #5#6;
  { \exp_after:wN \c_empty_qnan_fp }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_add_normal:NNnwnw}
%   \begin{syntax}
%     \cs{fp_basics_add_normal:NNnwnw} \meta{sign1} \meta{sign2}
%     ~~\Arg{exp1}  \meta{body1} |;| \Arg{exp2} \meta{body2} |;|
%   \end{syntax}
%   We now have two normal numbers to add, and we have to check signs
%   and exponents more carefully before performing the addition.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_normal:NNnwnw #1#2
  {
    \if:w #1#2
      \exp_after:wN \fp_basics_add_npos:Nnwnw
    \else:
      \exp_after:wN \fp_basics_sub_npos:Nnwnw
    \fi:
    #1
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Absolute addition}
%
% In this subsection, we perform the addition
% of two positive normal numbers.
%
% \begin{macro}[EXP]{\fp_basics_add_npos:Nnwnw}
%   \begin{syntax}
%     \cs{fp_basics_add_npos:Nnwnw} \meta{sign}
%     ~~\Arg{exp1}  \meta{body1} |;| \Arg{exp2} \meta{body2} |;|
%   \end{syntax}
%   Since we are doing an addition, \meta{sign} will be the final sign.
%   The only special case which may arise is the case of an overflow.
%   This will be checked by \cs{fp_basics_add_sanitize:wN} at the end of
%   the calculation. We start a \cs{etex_numexpr:D}, responsible for
%   computing the exponent, which may recieve a contribution of |+1|
%   in case of carries. It should be stopped by |;| followed by the
%   overall \meta{sign} for the sanitizing to work properly.
%
%   Grab and compare the exponents. The smaller number is decimated until
%   its exponent reaches that of the bigger number. We need to keep the
%   final sign around to do the rounding correctly.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_npos:Nnwnw #1 #2#3; #4
  {
    \exp_after:wN \fp_basics_add_sanitize:wN
    \tex_the:D \etex_numexpr:D
      \if_num:w #2 > #4 \exp_stop_f:
        #2
        \exp_after:wN \fp_basics_add_big_i:wNww \tex_number:D -
      \else:
        #4
        \exp_after:wN \fp_basics_add_big_ii:wNww \tex_number:D
      \fi:
      \etex_numexpr:D #4 - #2 ; #1 #3;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_add_sanitize:wN}
%   \begin{syntax}
%     \cs{fp_basics_add_sanitize:wN} \meta{exp} |;| \meta{sign} \Arg{body} |;|
%   \end{syntax}
%   We only need to check for overflow. This code is done after
%   the computation, and we don't need to perform the post-expansion.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_sanitize:wN #1 ; #2
  {
    \if_num:w #1 > \c_fp_max_exponent_int
      \exp_after:wN \fp_aux_overflow:NNNNw
    \fi:
    \s_fp \fp_use:w 1 #2 {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_add_big_i:wNww,
%     \fp_basics_add_big_ii:wNww}
%   \begin{syntax}
%     \cs{fp_basics_add_big_i:wNww} \meta{shift} |;| \meta{sign}
%     ~~\meta{body1} |;| \meta{body2} |;|
%   \end{syntax}
%   Shift the mantissa of the small number, and then add with
%   \cs{fp_basics_add_mantissa:NnnNnnnn}. Afterwards, check whether
%   there was a carry.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_big_i:wNww #1; #2 #3; #4;
  {
    \fp_aux_decimate:nNnnnn {#1}
      \fp_basics_add_mantissa:NnnNnnnn
      #4
    #2
    #3
  }
\cs_new:Npn \fp_basics_add_big_ii:wNww #1; #2 #3; #4;
  {
    \fp_aux_decimate:nNnnnn {#1}
      \fp_basics_add_mantissa:NnnNnnnn
      #3
    #2
    #4
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_add_mantissa:NnnNnnnn}
%   \begin{syntax}
%     \cs{fp_basics_add_mantissa:NnnNnnnn}
%     ~~\meta{rounding} \Arg{Y'1} \Arg{Y'2}
%     ~~\meta{final sign}
%     ~~\Arg{X1} \Arg{X2} \Arg{X3} \Arg{X4}
%   \end{syntax}
%
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_mantissa:NnnNnnnn #1 #2#3 #4 #5#6#7#8
  {
    \exp_after:wN \fp_basics_add_mantissa_aux:NNNNNNNw
    \exp_after:wN #1
    \exp_after:wN #4
    \tex_the:D \etex_numexpr:D 1#5#6 + #2 - 1 +
      \exp_after:wN \fp_basics_add_mantissa_round:wNN
      \tex_the:D \etex_numexpr:D 1#7#8 + #3 ; #1 #4
  }
%    \end{macrocode}
%   We round the result before and after checking for a carry. This
%   ensures that things work properly in the case where rounding causes
%   a carry ($0.99\cdots 95 \to 1.00\cdots 0$). However, rounding twice
%   would not be correct in the round-to-nearest mode (\emph{e.g.},
%   $0.\cdots 246 \to 0.\cdots 25 \to 0.\cdots 3$)\ldots{} It turns out
%   that we only need to know the \meta{rounding} digit to sort out the
%   special cases, so we keep it at the very front.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_mantissa_round:wNN #1; #2 #3
  {
    \exp_after:wN \fp_basics_add_mantissa_aux_ii:NNNNNw
    \tex_the:D \etex_numexpr:D
      #1 +
      \exp_after:wN \fp_aux_round:NNN
      \exp_after:wN #3
      \use_none:nnnnnnnn #1 #2
    \exp_after:wN ;
  }
%    \end{macrocode}
%
%   In case there is a carry, we will have to shift all digits, and
%   recompute a possible carry. As there is no way to ease the pain
%   in that case, we instead optimize for the case where there is no
%   carry, and wrap digits in braces.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_mantissa_aux_ii:NNNNNw #1 #2#3#4#5 #6;
  { #1 ; {#2#3#4#5} {#6} ; }
\cs_new:Npn \fp_basics_add_mantissa_aux:NNNNNNNw #1#2 #3 #4#5#6#7 #8;
  {
    \if:w 2 #3
      \fp_basics_add_carry:wNnnnn #1
    \fi:
    ; #2
    {#4#5#6#7} {#8}
  }
%    \end{macrocode}
%   If there is no carry, our result consists in four brace groups,
%   produced by the two \cs{fp_basics_add_mantissa_aux} functions.
%   The case of a carry is explained below.
% \end{macro}
%
% \begin{macro}{\fp_basics_add_carry:wNnnnn}
%   \begin{syntax}
%     \cs{fp_basics_add_carry:wNnnnn}
%     ~~\meta{rounding} \cs{fi:} |;| \meta{final sign}
%     ~~\Arg{Z1} \Arg{Z2} \Arg{Z3} \Arg{Z4} |;|
%   \end{syntax}
%   To take care of the carry, issue |+1|, to increase the exponent
%   by $1$: the exponent is currently being expanded with an
%   \cs{etex_numexpr:D}. Then shift digits, and compute the result
%   of rounding with one digit less.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_carry:wNnnnn #1 \fi: ; #2 #3#4#5#6 ;
  {
    \fi:
    + \c_one
    \exp_after:wN \exp_after:wN \exp_after:wN ;
    \exp_after:wN \exp_after:wN \exp_after:wN #2
    \exp_after:wN \fp_basics_add_carry_aux:NNNNNNNNw
    \tex_the:D \etex_numexpr:D 1 #3 #4
                      - 1 + \exp_after:wN \fp_basics_add_carry_aux_ii:NNNNw
    \tex_the:D \etex_numexpr:D 1 #5 \use_i_ii_iii:nnnn #6
      \exp_after:wN \fp_basics_add_carry_round:NNNN
      \exp_after:wN #2
      \use_none:nn #6 #1
    ; ;
  }
\cs_new:Npn \fp_basics_add_carry_aux:NNNNNNNNw #1#2#3#4 #5#6#7#8 #9;
  { {#1#2#3#4} {#5#6#7#8} {#9} }
\cs_new:Npn \fp_basics_add_carry_aux_ii:NNNNw #1#2#3#4 #5;
  { #1 \tex_relax:D #2#3#4 ; {#5} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_add_carry_round:NNNN}
%   \begin{syntax}
%     \cs{fp_basics_add_carry_round:NNNN} \meta{final sign}
%     \meta{digit1} \meta{digit2} \meta{rounding}
%   \end{syntax}
%   This expands to either |-\c_one| or |+\c_one|, or a variation thereof.
%   We simply round, except in the case where
%   the rounding mode is \enquote{round to nearest}, the \meta{digit2}
%   is $5$, and the \meta{rounding} digit is not $0$. In this special
%   case, rounding twice can lead to a (slightly) wrong result.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_carry_round:NNNN #1 #2 #3 #4
  {
    +
    \if:w 5 #3
      \fp_basics_add_carry_round_aux:N #4
    \fi:
    \fp_aux_round:NNN #1 #2 #3
  }
\cs_new:Npn \fp_basics_add_carry_round_aux:N #1
  {
      \if_num:w \l_fp_rounding_mode_int = \c_fp_rounding_mode_nearest_int
        \if:w 0 #1
          \exp_after:wN \use_none:nnnn
        \else:
          \if_num:w #1 < \c_five
            \c_one
          \fi:
        \fi:
        \exp_after:wN \exp_after:wN \exp_after:wN \use_none:nnnn
      \fi:
  }
%    \end{macrocode}
% \end{macro}
% 
%
% \subsubsection{Absolute subtraction}
%
% \begin{macro}[EXP]{\fp_basics_sub_npos:Nnwnw}
%   \begin{syntax}
%     \cs{fp_basics_sub_npos:Nnwnw} \meta{sign}
%     ~~\Arg{exp1}  \meta{body1} |;| \Arg{exp2} \meta{body2} |;|
%   \end{syntax}
%   Rounding properly in some modes requires to know what the sign
%   of the result will be. For addition, this was easy. Here, besides
%   comparing the exponents to know how to decimate, we need to
%   check carefully which number is bigger when they have the same
%   exponent.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_npos:Nnwnw #1 #2#3; #4 #5;
  {
    \exp_after:wN \fp_basics_sub_sanitize:wN
    \tex_the:D \etex_numexpr:D
      \if_num:w #2 > #4 \exp_stop_f:
        #2
        \exp_after:wN \fp_basics_sub_big_i:wNww \tex_number:D -
      \else:
        #4
        \if_num:w #2 = #4 \exp_stop_f:
          \fp_basics_sub_exponent_eq:nnnnnnnn #3 #5
        \else:
          \exp_after:wN \fp_basics_sub_big_ii:wNww \tex_number:D
        \fi:
      \fi:
      \etex_numexpr:D #4 - #2 ; #1 #3; #5;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_sanitize:wN}
%   \begin{syntax}
%     \cs{fp_basics_sub_sanitize:wN} \meta{exp} |;| \meta{sign} \Arg{body} |;|
%   \end{syntax}
%   We need to check for overflow, for underflow, and for exact zero.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_sanitize:wN #1 ; #2
  {
    \if_num:w #1 > \c_fp_max_exponent_int
      \exp_after:wN \fp_aux_overflow:NNNNw \tex_romannumeral:D
    \else:
      \if_num:w #1 < \c_fp_min_exponent_int
        \exp_after:wN \fp_aux_underflow:NNNNw \tex_romannumeral:D
      \else:
        \if:w 1 #2
          \exp_after:wN \fp_aux_exact_zero:NNNNw \tex_romannumeral:D
        \else:
          \tex_romannumeral:D
        \fi:
      \fi:
    \fi:
    \c_zero
    \s_fp \fp_use:w 1 #2 {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_exponent_eq:nnnnnnnn}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_exponent_eq:nnnnnnnn #1#2#3#4 #5#6#7#8
  {
    \if_num:w #1#2 > #5#6 \exp_stop_f:
      \exp_after:wN \fp_basics_sub_big_i:wNww \tex_number:D
    \else:
      \if_num:w #1#2 < #5#6 \exp_stop_f:
        \exp_after:wN \fp_basics_sub_big_ii:wNww \tex_number:D
      \else:
        \if_num:w #3#4 > #7#8 \exp_stop_f:
          \exp_after:wN \fp_basics_sub_big_i:wNww \tex_number:D
        \else:
          \if_num:w #3#4 < #7#8 \exp_stop_f:
            \exp_after:wN \fp_basics_sub_big_ii:wNww \tex_number:D
          \else:
            \exp_after:wN \fp_basics_sub_eq:wNww \tex_number:D
          \fi:
        \fi:
      \fi:
    \fi:
  }
\cs_new:Npn \fp_basics_sub_eq:wNww #1; #2 #3; #4; { ; 1 ; }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_big_i:wNww,\fp_basics_sub_big_ii:wNww}
%   \begin{syntax}
%     \cs{fp_basics_sub_big_i:wNww} \meta{shift} |;| \meta{sign}
%     ~~\meta{body1} |;| \meta{body2} |;|
%   \end{syntax}
%   Shift the mantissa of the small number, and then subtract with
%   \cs{fp_basics_sub_back_mantissa:NnnNnnnn}.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_big_i:wNww #1; #2 #3; #4;
  {
    \fp_aux_decimate:nNnnnn {#1}
      \fp_basics_sub_back_mantissa:NnnNnnnn
      #4
    #2
    #3
  }
\cs_new:Npn \fp_basics_sub_big_ii:wNww #1; #2 #3; #4;
  {
    \exp_after:wN \fp_basics_sub_big_i:wNww
    \tex_number:D #1 \exp_after:wN ;
    \tex_the:D \etex_numexpr:D 2 - #2 \tex_relax:D
    #4; #3;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_back_mantissa:NnnNnnnn}
%   \begin{syntax}
%     \cs{fp_basics_sub_back_mantissa:NnnNnnnn}
%     ~~\meta{rounding} \Arg{Y'1} \Arg{Y'2}
%     ~~\meta{final sign}
%     ~~\Arg{X1} \Arg{X2} \Arg{X3} \Arg{X4}
%   \end{syntax}
%   At this stage, we know that \meta{Y} is less than \meta{X},
%   and we know the final sign.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_mantissa:NnnNnnnn #1 #2#3 #4 #5#6#7#8
  {
    \exp_after:wN \fp_basics_sub_back_mantissa_aux:NNwNNNNwN
    \exp_after:wN #1
    \exp_after:wN #4
    \tex_the:D \etex_numexpr:D 2#5#6 - #2 - 2 + 
      \exp_after:wN \fp_basics_sub_back_mantissa_round:wNN
      \tex_the:D \etex_numexpr:D 2#7#8 - #3 ; #1 #4
  }
%    \end{macrocode}
% After the computation, we need to check whether the first digit of
% the result is zero. This can only happen if the two numbers had the
% same exponent, or exponents differing by $1$. In the latter case,
% the \meta{rounding} digit is not quite enough to let us retrieve
% the exact result (consider $\cdots25$ and $\cdots15$, both rounded
% to $\cdots2$ in the usual mode), so we also move the result of
% \cs{fp_aux_round_neg:NNN} upstream as the digit $0$ or $1$.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_mantissa_round:wNN #1; #2 #3
  {
    \exp_after:wN \fp_basics_sub_back_mantissa_aux_iii:N
    \tex_number:D
        \exp_after:wN \fp_aux_round_neg:NNN
        \exp_after:wN #3
        \use_none:nnnnnnnn #1 #2
      + #1
    \exp_after:wN ;
  }
\cs_new:Npn \fp_basics_sub_back_mantissa_aux_iii:N #1
  {
    \exp_after:wN \fp_basics_sub_back_mantissa_aux_ii:NNNNNNw
    \exp_after:wN #1
    \tex_the:D \etex_numexpr:D
      - #1
  }
\cs_new:Npn \fp_basics_sub_back_mantissa_aux_ii:NNNNNNw #1 #2 #3#4#5#6 #7;
  { #2 ; #1 {#3#4#5#6} {#7} ; }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_back_mantissa_aux:NNwNNNNwN}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_mantissa_aux:NNwNNNNwN #1#2 #3 #4#5#6#7 #8; #9
  {
    \if:w 0 #4
      \exp_after:wN \fp_basics_sub_back_carry:NNwNnnnn
      \exp_after:wN #1
      \exp_after:wN #9
    \fi:
    ; #3
    {#4#5#6#7} {#8}
  }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\fp_basics_sub_back_carry:NNwNnnnn}
%   \begin{syntax}
%     \cs{fp_basics_sub_back_carry:NNwNnnnn}
%     ~~\meta{rounding} \meta{0 or 1} |;| \meta{final sign}
%     ~~\Arg{Z1} \Arg{Z2} \Arg{Z3} \Arg{Z4} |;|
%   \end{syntax}
%   This function is called when $\meta{Z1}\leq 999$. We revert
%   the carry, which is given by \meta{0 or 1}, and subtract the
%   \meta{rounding} digit as appropriate, then feed the result,
%   of the form \meta{\leq 7d} |;| \meta{9d} |;| to
%   \cs{fp_basics_sub_back_carry_aux:wwN}. The result is always exact.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_carry:NNwNnnnn #1#2 ; #3 #4#5#6#7 ;
  {
    \exp_after:wN \fp_basics_sub_back_carry_aux:wwN
    \tex_number:D \etex_numexpr:D #4 #5 - 1 + \exp_after:wN \fp_aux_i_s:N
    \tex_number:D \etex_numexpr:D 1 #6 #7 0 + #1 0 - #2 ; #3
  }
%    \end{macrocode}
%   Unless the first block is zero, check how many digits is has,
%   and shift the exponent down by the corresponding amount. Then
%   pack digits into blocks of $4$ (there are between $10$ and $16$
%   digits in front of \cs{fp_basics_sub_back_carry_large:NNNNNNNNw}).
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_carry_aux:wwN #1 ;
  {
    \if:w 0 #1
      - 8
      \exp_after:wN \fp_basics_sub_back_carry_small:wN \tex_number:D
    \else:
      - \fp_basics_sub_back_carry_aux_ii:NNNNNNNNw #1 1234567;
      \exp_after:wN \fp_basics_sub_back_carry_large:NNNNNNNNw
    \fi:
    #1
  }
%    \end{macrocode}
%   The case where the number is non-zero is slightly easier.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_carry_aux_ii:NNNNNNNNw #1#2#3#4#5#6#7#8#9; {#8}
\cs_new:Npn \fp_basics_sub_back_carry_large:NNNNNNNNw #1#2#3#4 #5#6#7#8 #9;
  {
    \fp_basics_sub_back_carry_large_ii:NNNNNNNNw
    #9 000000 ; {#1#2#3#4} {#5#6#7#8}
  }
\cs_new:Npn \fp_basics_sub_back_carry_large_ii:NNNNNNNNw #1#2#3#4 #5#6#7#8 #9;
  { \fp_basics_sub_back_carry_large_iii:nnnnN {#1#2#3#4} {#5#6#7#8} }
\cs_new:Npn \fp_basics_sub_back_carry_large_iii:nnnnN #1#2 #3#4 #5
  { ; #5 {#3}{#4} {#1}{#2} ; }
%    \end{macrocode}
%   In the case of a \enquote{small} result, what comes after
%   \cs{fp_basics_sub_back_carry_small:wN} has between $1$
%   and $9$ digits, and is not zero.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_carry_small:wN #1;
  {
    - \exp_after:wN \fp_aux_use_i_until_s:Nw
      \use_none:nnnnnnnnn #1 012345678;
    \fp_basics_sub_back_carry_small_ii:NNNNNNNN #1 00000000 ;
  }
\cs_new:Npn \fp_basics_sub_back_carry_small_ii:NNNNNNNN #1#2#3#4 #5#6#7#8
  { \fp_basics_sub_back_carry_small_iii:nnNwN {#1#2#3#4} {#5#6#7#8} }
\cs_new:Npn \fp_basics_sub_back_carry_small_iii:nnNwN #1 #2 #3 #4; #5
  { ; #5 {#1} {#2} {#3000} {0000} ; }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Multiplication}
%
% \subsubsection{User commands}
% 
% Only a few commands are meant for external use (although none
% of them by end-users).
% \begin{macro}[EXP]{\fp_mul:ff}
% \begin{macro}[aux,EXP]{\fp_basics_mul_ff:NNwn,\fp_basics_mul_ff:NNwNN}
%   The two arguments are f-expanded before being fed to 
%   \cs{fp_basics_mul_cases:NN} in the form
%   \begin{quote}
%     \cs{fp_basics_mul_cases:NN}
%     \meta{case2} \meta{case1} \meta{sign2} \meta{sign1}
%     \meta{exp2}  \meta{body2} |;| \meta{exp1}  \meta{body1} |;|
%   \end{quote}
%    \begin{macrocode}
\cs_new:Npn \fp_mul:ff #1 
  {
    \exp_after:wN \fp_basics_mul_ff:NNwn
    \tex_romannumeral:D -`0 #1
  }
\cs_new:Npn \fp_basics_mul_ff:NNwn \s_fp \fp_use:w #1 #2 #3 ; #4
  {
    \exp_after:wN \fp_basics_mul_ff:NNwNN
    \exp_after:wN #1
    \exp_after:wN #2
    \tex_romannumeral:D -`0 #4
    #3 ;
    \prg_do_nothing:
  }
\cs_new:Npn \fp_basics_mul_ff:NNwNN #1 #2 \s_fp \fp_use:w #3 #4
  { \fp_basics_mul_cases:NN #3 #1 #4 #2 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\fp_mul:ww}
%   Each argument is
%   \begin{quote}
%     \cs{s_fp} \cs{fp_use:w} \meta{case} \meta{sign}
%     \meta{exponent} \meta{body} |;|
%   \end{quote}
%   We setup for \cs{fp_basics_mul_cases:NN}.
%    \begin{macrocode}
\cs_new:Npn \fp_mul:ww \s_fp \fp_use:w #1 #2 #3 ; \s_fp \fp_use:w #4 #5
  { \fp_basics_mul_cases:NN #1 #4 #2 #5 #3 ; }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Signs, and special numbers}
%
% \begin{macro}[EXP,aux]{\fp_basics_mul_cases:NN}
%   \begin{syntax}
%     \cs{fp_basics_mul_cases:NN} \meta{case1} \meta{case2}
%     ~~\meta{sign1} \meta{sign2} \Arg{exp1} \meta{body1} |;|
%     ~~\Arg{exp2} \meta{body2} |;|
%   \end{syntax}
%   Expands the following tokens on the input stream once.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_cases:NN #1 #2
  {
    \if_case:w \etex_numexpr:D \c_one +
            \if_num:w #1 = \c_one          #2 \tex_relax:D \fi:
            \if_num:w #2 = \c_one          #1 \tex_relax:D \fi:
            \if_num:w #1 = #2 \exp_stop_f: #1 \tex_relax:D \fi:
            \c_three \tex_relax:D
    \or: \exp_after:wN \fp_basics_mul_zero:NNnwnw
    \or: \exp_after:wN \fp_basics_mul_normal:NNnwnw
    \or: \exp_after:wN \fp_basics_mul_inf:NNnwnw
    \or: \exp_after:wN \fp_basics_mul_nan:NNnwnw
    \fi:
  }
%    \end{macrocode}
%   The special cases are quite easy.\footnote{NaN
%     is not treated properly yet!}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_zero:NNnwnw #1#2 #3#4; #5#6;
  {
    \if:w #1 #2
      \exp_after:wN \exp_after:wN \exp_after:wN \c_plus_zero_fp
    \else:
      \exp_after:wN \exp_after:wN \exp_after:wN \c_minus_zero_fp
    \fi:
  }
\cs_new:Npn \fp_basics_mul_inf:NNnwnw #1#2 #3#4; #5#6;
  {
    \if:w #1 #2
      \exp_after:wN \exp_after:wN \exp_after:wN \c_plus_inf_fp
    \else:
      \exp_after:wN \exp_after:wn \exp_after:wN \c_minus_inf_fp
    \fi:
  }
\cs_new:Npn \fp_basics_mul_nan:NNnwnw #1#2 #3#4; #5#6;
  { \exp_after:wN \c_empty_qnan_fp }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_mul_normal:NNnwnw}
%   \begin{syntax}
%     \cs{fp_basics_mul_normal:NNnwnw} \meta{sign1} \meta{sign2}
%     ~~\Arg{exp1}  \meta{body1} |;| \Arg{exp2} \meta{body2} |;|
%   \end{syntax}
%   We now have two normal numbers to multiply. Combine the signs.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_normal:NNnwnw #1#2
  {
    \if:w #1#2
      \exp_after:wN \fp_basics_mul_npos:Nnwnw
      \exp_after:wN 0
    \else:
      \exp_after:wN \fp_basics_mul_npos:Nnwnw
      \exp_after:wN 1
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Absolute multiplication}
%
% In this subsection, we perform the multiplication
% of two positive normal numbers.
%
% \begin{macro}[EXP]{\fp_basics_mul_npos:Nnwnw}
%   \begin{syntax}
%     \cs{fp_basics_mul_npos:Nnwnw} \meta{sign}
%     ~~\Arg{exp1}  \meta{body1} |;| \Arg{exp2} \meta{body2} |;|
%   \end{syntax}
%   As for addition, \meta{sign} is the final sign. After the computation,
%   \cs{fp_basics_mul_sanitize:wN} checks for overflow or underflow.
%   As before, \cs{etex_numexpr:D} computes the exponent, catching any
%   shift coming from the computation in the mantissa. Again, the
%   \meta{sign} is needed for rounding to be done properly, so we move
%   it around.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_npos:Nnwnw #1 #2#3; #4
  {
    \exp_after:wN \fp_basics_mul_sanitize:wN
    \tex_the:D \etex_numexpr:D
      #2 + #4
      \fp_basics_mul_mantissa:nnnnNnnnw
      #3 #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_mul_sanitize:wN}
%   \begin{syntax}
%     \cs{fp_basics_mul_sanitize:wN} \meta{exp} |;| \meta{sign} \Arg{body} |;|
%   \end{syntax}
%   Over- and underflow check.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_sanitize:wN #1 ; #2
  {
    \if_num:w #1 > \c_fp_max_exponent_int
      \exp_after:wN \fp_aux_overflow:NNNNw
      \if_num:w #1 < \c_fp_min_exponent_int
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_aux_underflow:NNNNw
      \fi:
    \fi:
    \s_fp \fp_use:w 1 #2 {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_mul_mantissa:nnnnNnnnw}
%   \begin{syntax}
%     \cs{fp_basics_mul_mantissa:nnnnNnnnw}
%     ~~\Arg{X1} \Arg{X2} \Arg{X3} \Arg{X4} \meta{sign}
%     ~~\Arg{Y1} \Arg{Y2} \Arg{Y3} \Arg{Y4} |;|
%   \end{syntax}
% \end{macro}
% 
% \begin{macro}[EXP]{\fp_basics_mul_mantissa:nnnnNnnnn}
%   Once more, the fifth argument is a function to call on
%   the raw result, namely on $5$ brace groups, the first of 
%   which may be zero. 
%
%   The following token after expansion must be a semicolon.
%   
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_mantissa:nnnnNnnnn #1#2#3#4 #5 #6#7#8#9
  {
    \exp_after:wN \fp_aux_i_noii_bfour_btail:nnnnnnw
    \exp_after:wN #5
    \tex_the:D \etex_numexpr:D        99990000 + #1*#6 + 
    \exp_after:wN \fp_aux_brace_tail:nnnnnw
    \tex_the:D \etex_numexpr:D        99990000 + #1*#7+#2*#6+ 
    \exp_after:wN \fp_aux_brace_tail:nnnnnw
    \tex_the:D \etex_numexpr:D        99990000 + #1*#8+#2*#7+#3*#6+ 
    \exp_after:wN \fp_aux_brace_tail_s:nnnnnw
    \tex_the:D \etex_numexpr:D       100000000 + #1*#9+#2*#8+#3*#7+#4*#6
                                               + (#2*#9+#3*#8+#4*#7)/10000
  }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\fp_basics_mul_mantissa_carry:n}
%   If the first coming brace group is zero, remove it and decrease the 
%   exponent by one. Otherwise, remove the fifth brace group.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_mantissa_carry:n #1 
  {
    \if_num:w #1 = \c_zero
      - \exp_after:wN \c_one
    \else:
      \fp_basics_mul_mantissa_carry_aux:nNnnnn {#1}
    \fi:
  }
\cs_new:Npn \fp_basics_mul_mantissa_carry_aux:nNnnnn #1 #2 #3#4#5#6 
  {
    #2{#1}{#3}{#4}{#5}
  }
%    \end{macrocode}
% \end{macro}
% 
% 
%
%
% \subsection{For other submodules}
% 
%
% \begin{macro}{\use_i_ii_iii:nnnn}
%    \begin{macrocode}
\cs_new:Npn \use_i_ii_iii:nnnn #1 #2 #3 #4 { #1 #2 #3 }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
%\PrintChanges
%
%\PrintIndex