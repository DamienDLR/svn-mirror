% \iffalse meta-comment
%
%% File: l3fp-basics.dtx Copyright (C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id: l3fp-basics.dtx 0000 0000-00-00 00:00:00Z bruno $
  {L3 Experimental floating-point arithmetic}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \tableofcontents
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{l3fp-basics} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Floating point expressions}
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
% \date{Released \filedate}
%
% \maketitle
%
% \begin{documentation}
%   \section{Internal storage of floating points numbers}
%   
%   The internal structure of floating point numbers is described in
%   \file{l3fp-convert.dtx}. A floating point number \meta{X} is stored as
%   \begin{quote}
%     \cs{s_fp} \cs{fp_use:w} \meta{case} \meta{sign} \meta{body} |;|
%   \end{quote}
%   Here, \meta{case} is 0 for $\pm 0$, 1 for normal numbers,
%   2 for $\pm \infty$, and 3 for \texttt{nan}, and \meta{sign} is
%   $0$ for positive numbers, $1$ for \texttt{nan}s, and $2$ for
%   negative numbers. The \meta{body} of normal numbers is
%   \Arg{exponent} \Arg{X1} \Arg{X2} \Arg{X3} \Arg{X4}, with
%   \[
%   \meta{X}
%   = (-1)^{\meta{sign}} 10^{-\meta{exponent}}
%   \sum_i \meta{X$\sb{i}$} 10^{-4i}.
%   \]
%   Calculations are done in base $10000$, \emph{i.e.} one myriad.
%   The \meta{exponent} lies in the range $[\cs{c_fp_min_exponent_int},
%   \cs{c_fp_max_exponent_int}]$, currently $ [ \int_use:N
%   \c_fp_min_exponent_int, \int_use:N \c_fp_max_exponent_int ] $
%   but this may change a bit: the main constraint is to be a valid
%   \TeX{} integer.
%
%   Additionally, positive and negative floating point numbers may only
%   be stored with $1000\leq\meta{X1}<10000$. This requirement is necessary
%   in order to preserve accuracy and speed. Not abiding by it will lead
%   to all sorts of trouble.
%
%   \section{Operations}
%
%   \begin{function}[EXP]{\fp_add:nn,\fp_add:NN}
%     \begin{syntax}
%       \cs{fp_add:nn} \meta{fp~str1} \Arg{fp~str2}
%       \cs{fp_add:NN} \meta{fp~var1} \meta{fp~var2}
%     \end{syntax}
%     These functions f-expand to the sum of the two floating
%     point numbers. The function \cs{fp_add:nn} passes both
%     arguments through \cs{fp_convert_from_str:n}. The function
%     \cs{fp_add:NN} expects two floating point variables, and is
%     faster. Both are built on top of \cs{fp_add:ww}, which
%     expands the token which follows exactly once.
%   \end{function}
% 
% \begin{function}[EXP]{\fp_sub:nn,\fp_sub:NN}
%   \begin{syntax}
%     \cs{fp_sub:nn} \Arg{fp~str1} \Arg{fp~str2}
%     \cs{fp_sub:NN} \meta{fp~var1} \meta{fp~var2}
%   \end{syntax}
%   These functions f-expand to the difference \meta{fp1-fp2}.
% \end{function}
% 
% \begin{function}[EXP]{\fp_mul:nn,\fp_mul:NN}
%   \begin{syntax}
%     \cs{fp_sub:nn} \Arg{fp~str1} \Arg{fp~str2}
%     \cs{fp_sub:NN} \meta{fp~var1} \meta{fp~var2}
%   \end{syntax}
%   These functions f-expand to the product \meta{fp1*fp2}.
% \end{function}
%
% \end{documentation}
% 
% \begin{implementation}
%
% \section{Implementation}
%
%   We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
%</package>
%<*initex|package>
%    \end{macrocode}
%
% \subsection{Addition and subtraction}
%
% \subsubsection{User commands}
%
% Only a few commands are meant for external use (although none
% of them by end-users). The trailing \cs{prg_do_nothing:} in some
% commands catches the extra expansion that is done by design at
% the end of every calculation. This extra expansion will be
% critical when parsing expressions.
%
% \begin{macro}[EXP]{\fp_add:nn}
% \begin{macro}[aux,EXP]{\fp_add_aux:NNwn,\fp_add_aux:NNwNN}
%   The two arguments are passed through \cs{fp_convert_from_str:n}
%   and f-expanded before being fed to \cs{fp_basics_add_cases:NN}
%   in the correct form:
%   \begin{quote}
%     \cs{fp_basics_add_cases:NN}
%     \meta{case2} \meta{case1} \meta{sign2} \meta{sign1}
%     \meta{exp2}  \meta{body2} |;| \meta{exp1}  \meta{body1} |;|
%   \end{quote}
%    \begin{macrocode}
\cs_new:Npn \fp_add:nn #1
  {
    \exp_after:wN \fp_add_aux:NNwn
    \tex_romannumeral:D -`0 \fp_convert_from_str:n {#1}
  }
\cs_new:Npn \fp_add_aux:NNwn \s_fp \fp_use:w #1 #2 #3 ; #4
  {
    \exp_after:wN \fp_add_aux:NNwNN
    \exp_after:wN #1
    \exp_after:wN #2
    \tex_romannumeral:D -`0 \fp_convert_from_str:n {#4}
    #3 ;
    \prg_do_nothing:
  }
\cs_new:Npn \fp_add_aux:NNwNN #1 #2 \s_fp \fp_use:w #3 #4
  { \fp_basics_add_cases:NN #3 #1 #4 #2 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\fp_sub:nn}
% \begin{macro}[aux,EXP]{\fp_sub_aux:NNwn,\fp_sub_aux:NNwNN}
%   The two arguments are passed through \cs{fp_convert_from_str:n}
%   and f-expanded before being fed to \cs{fp_basics_add_cases:NN}
%   in the correct form:
%   with the two \meta{cases}, and the \meta{signs} collected up front.
%   The second sign must be flipped. This is done by replacing it by
%   $2-\meta{sign}$.
%    \begin{macrocode}
\cs_new:Npn \fp_sub:nn #1
  {
    \exp_after:wN \fp_sub_aux:NNwn
    \tex_romannumeral:D -`0 \fp_convert_from_str:n {#1}
  }
\cs_new:Npn \fp_basics_sub_ff:NNwn \s_fp \fp_use:w #1 #2 #3 ; #4
  {
    \exp_after:wN \fp_sub_aux:NNwNN
    \exp_after:wN #1
    \exp_after:wN #2
    \tex_romannumeral:D -`0 \fp_convert_from_str:n {#4}
    #3 ;
    \prg_do_nothing:
  }
\cs_new:Npn \fp_sub_aux:NNwNN #1 #2 \s_fp \fp_use:w #3 #4
  {
    \exp_after:wN \fp_basics_add_cases:NN
    \exp_after:wN #3
    \exp_after:wN #1
    \int_use:N \int_eval:w 2 - #4 \int_eval_end:
    #2
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\fp_add:NN}
% \begin{macro}[EXP]{\fp_sub:NN}
%   Expand and feed the result to \cs{fp_add:ww} and \cs{fp_sub:ww}
%   below. Those auxiliary functions expand once after the computation,
%   hence the \cs{prg_do_nothing:}
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_add:NN #1 #2
  {
    \exp_after:wN \exp_after:wN
    \exp_after:wN \fp_add:ww
    \exp_after:wN #1 #2
    \prg_do_nothing:
  }
\cs_new_nopar:Npn \fp_sub:NN #1 #2
  {
    \exp_after:wN \exp_after:wN
    \exp_after:wN \fp_sub:ww
    \exp_after:wN #1 #2
    \prg_do_nothing:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\fp_add:ww}
% \begin{macro}[EXP]{\fp_sub:ww}
%   Each argument is
%   \begin{quote}
%     \cs{s_fp} \cs{fp_use:w} \meta{case} \meta{sign}
%     \meta{exponent} \meta{body} |;|
%   \end{quote}
%   We setup for \cs{fp_basics_add_cases:NN}.
%    \begin{macrocode}
\cs_new:Npn \fp_add:ww \s_fp \fp_use:w #1 #2 #3 ; \s_fp \fp_use:w #4 #5
  { \fp_basics_add_cases:NN #1 #4 #2 #5 #3 ; }
\cs_new:Npn \fp_sub:ww \s_fp \fp_use:w #1 #2 #3 ; \s_fp \fp_use:w #4 #5
  {
    \exp_after:wN \fp_basics_add_cases:NN
    \exp_after:wN #1
    \exp_after:wN #4
    \exp_after:wN #2
    \int_use:N \int_eval:w 2 - #5 \int_eval_end:
    #3 ;
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% 
%
% \subsubsection{Sign, exponent, and special numbers}
%
% \begin{macro}[EXP,aux]{\fp_basics_add_cases:NN}
%   \begin{syntax}
%     \cs{fp_basics_add_cases:NN} \meta{case1} \meta{case2}
%     ~~\meta{sign1} \meta{sign2}
%     ~~\Arg{exp1}  \meta{body1} |;| \Arg{exp2} \meta{body2} |;|
%   \end{syntax}
%   This performs the addition. it also expands the following tokens
%   on the input stream once.
%
%   Whenever \meta{case1} is different from \meta{case2}, the result
%   is simply the floating point number with the highest \meta{case}.
%   For instance, adding a normal number to a zero gives the normal
%   number, and adding a \texttt{nan} to any non-\texttt{nan} gives
%   that \texttt{nan}. Optimizing for addition of normal numbers,
%   we test for equality and then separate the \enquote{greater than}
%   and \enquote{less than} branches.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_cases:NN #1 #2
  {
    \if_num:w #1 = #2 \exp_stop_f:
      \exp_after:wN \fp_basics_add_cases_eq:N
    \else:
      \if_num:w #1 < #2 \exp_stop_f:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_basics_add_cases_ii:NNNNww
      \else:
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_basics_add_cases_i:NNNNww
      \fi:
      \exp_after:wN #1
    \fi:
    #2
  }
%    \end{macrocode}
%   If the first \meta{case} is larger, then the first number remains
%   untouched, while the second number is ignored. On the other hand,
%   if the second \meta{case} is larger, the opposite happens: we retain
%   the second number. In both cases, there needs to be one step of
%   expansion after.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_cases_i:NNNNww #1#2 #3#4 #5; #6;
  { \fp_aux_exp_after_fp:wN \s_fp \fp_use:w #1 #3 #5; }
\cs_new:Npn \fp_basics_add_cases_ii:NNNNww #1#2 #3#4 #5; #6;
  { \fp_aux_exp_after_fp:wN \s_fp \fp_use:w #2 #4 #6; }
%    \end{macrocode}
%   We are then ready for the equality case: we split according
%   to the \meta{case}.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_cases_eq:N #1
  {
    \if_case:w #1 \exp_stop_f:
         \exp_after:wN \fp_basics_add_zeros:NNww
    \or: \exp_after:wN \fp_basics_add_normal:NNww
    \or: \exp_after:wN \fp_basics_add_inf:NNww
    \or: \exp_after:wN \fp_basics_add_nan:NNww
    \fi:
  }
%    \end{macrocode}
%   Adding two zeros yields \cs{c_plus_zero_fp}, except if both
%   zeros were $-0$.\footnote{Bruno: this should depend on the
%     rounding mode.}
%   Three \cs{exp_after:wN} are needed to get out of the conditional,
%   and add an extra step of expansion.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_zeros:NNww #1#2 #3; #4;
  {
    \if_num:w #1 #2 = 22 \exp_stop_f:
      \exp_after:wN \exp_after:wN \exp_after:wN \c_minus_zero_fp
    \else:
      \exp_after:wN \exp_after:wN \exp_after:wN \c_plus_zero_fp
    \fi:
  }
%    \end{macrocode}
%   If both infinities have the same sign, just return that infinity,
%   otherwise, it is not a number.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_inf:NNww #1#2 #3; #4;
  {
    \if:w #1 #2
      \exp_after:wN \exp_after:wN \exp_after:wN \fp_aux_inf_fp:N
      \exp_after:wN \exp_after:wN \exp_after:wN #1
    \else:
      \exp_after:wN \fp_snan_inf_minus_inf:
    \fi:
  }
%    \end{macrocode}
%
%   When adding non-numbers, there is no test: simply concatenate
%   their messages.\footnote{Bruno: check that messages are kept.}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_nan:NNww #1#2 #3; #4;
  {
    \exp_after:wN \fp_aux_qnan_fp:N
    \cs:w
      fp_info: ~ %
        \fp_aux_extract_info:N #3
        \fp_aux_extract_info:N #4
      \exp_after:wN
    \cs_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_add_normal:NNww}
%   \begin{syntax}
%     \cs{fp_basics_add_normal:NNww} \meta{sign1} \meta{sign2}
%     ~~\Arg{exp1}  \meta{body1} |;| \Arg{exp2} \meta{body2} |;|
%   \end{syntax}
%   We now have two normal numbers to add, and we have to check signs
%   and exponents more carefully before performing the addition.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_normal:NNww #1#2
  {
    \if:w #1#2
      \exp_after:wN \fp_basics_add_npos:Nnwnw
    \else:
      \exp_after:wN \fp_basics_sub_npos:Nnwnw
    \fi:
    #1
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{Absolute addition}
%
% In this subsection, we perform the addition
% of two positive normal numbers.
%
% \begin{macro}[EXP]{\fp_basics_add_npos:Nnwnw}
%   \begin{syntax}
%     \cs{fp_basics_add_npos:Nnwnw} \meta{sign}
%     ~~\Arg{exp1}  \meta{body1} |;| \Arg{exp2} \meta{body2} |;|
%   \end{syntax}
%   Since we are doing an addition, \meta{sign} will be the final sign.
%   The only special case which may arise is the case of an overflow.
%   This will be checked by \cs{fp_basics_add_sanitize:wN} at the end of
%   the calculation. We start an \cs{int_eval:w}, responsible for
%   computing the exponent, which may receive a contribution of |+1|
%   in case of carry. The exponent should be stopped by |;| followed by
%   the overall \meta{sign} for the sanitizing to work properly.
%
%   Grab and compare the exponents. The smaller number is decimated until
%   its exponent reaches that of the bigger number. We need to bring the
%   final sign down in the midst of the calculation to do the rounding
%   correctly.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_npos:Nnwnw #1 #2#3; #4
  {
    \exp_after:wN \fp_basics_add_sanitize:Nw
    \exp_after:wN #1
    \int_use:N \int_eval:w
      \if_num:w #2 > #4 \exp_stop_f:
        #2
        \exp_after:wN \fp_basics_add_big_i:wNww \int_value:w -
      \else:
        #4
        \exp_after:wN \fp_basics_add_big_ii:wNww \int_value:w
      \fi:
      \int_eval:w #4 - #2 ; #1 #3;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_add_sanitize:Nw}
%   \begin{syntax}
%     \cs{fp_basics_add_sanitize:Nw} \meta{sign} \meta{exp} |;| \Arg{body} |;|
%   \end{syntax}
%   We only need to check for overflow. This code is done after
%   the computation, and we don't need to perform the post-expansion.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_sanitize:Nw #1 #2 ;
  {
    \if_num:w #2 > \c_fp_max_exponent_int
      \exp_after:wN \fp_aux_overflow:w
    \fi:
    \s_fp \fp_use:w 1 #1 {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_add_big_i:wNww,
%     \fp_basics_add_big_ii:wNww}
%   \begin{syntax}
%     \cs{fp_basics_add_big_i:wNww} \meta{shift} |;| \meta{sign}
%     ~~\meta{body1} |;| \meta{body2} |;|
%   \end{syntax}
%   Shift the mantissa of the small number, and then add with
%   \cs{fp_basics_add_mantissa:NnnnnnnN}.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_big_i:wNww #1; #2 #3; #4;
  {
    \fp_aux_decimate:nNnnnn {#1}
      \fp_basics_add_mantissa:NnnnnnnN
      #4
    #3
    #2
  }
\cs_new:Npn \fp_basics_add_big_ii:wNww #1; #2 #3; #4;
  {
    \fp_aux_decimate:nNnnnn {#1}
      \fp_basics_add_mantissa:NnnnnnnN
      #3
    #4
    #2
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_add_mantissa:NnnnnnnN}
%   \begin{syntax}
%     \cs{fp_basics_add_mantissa:NnnnnnnN}
%     ~~\meta{rounding}
%     ~~\Arg{Y'1} \Arg{Y'2}
%     ~~\Arg{X1} \Arg{X2} \Arg{X3} \Arg{X4}
%     ~~\meta{final sign}
%   \end{syntax}
%   To round properly, we must know at which digit the rounding
%   should occur. This requires to know whether the addition
%   produces an overall carry or not. Thus, we do the computation
%   now and check for a carry, then go back and do the rounding.
%   The rounding may cause a carry in very rare cases such as
%   $0.99\cdots 95 \to 1.00\cdots 0$, but this situation always
%   give an exact power of $10$, for which it is easy to correct
%   the result at the end.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_mantissa:NnnnnnnN #1 #2#3 #4#5#6#7
  {
    \exp_after:wN \fp_basics_add_mantissa_test:N
    \int_use:N \int_eval:w 1#4#5 + #2
      \exp_after:wN \fp_basics_add_mantissa_pack:NNNNNNN
      \int_use:N \int_eval:w 1#6#7 + #3 ; #1
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_mantissa_pack:NNNNNNN #1 #2#3#4#5#6#7
  {
    \if:w 2 #1
      + \c_one
    \fi:
    ; #2 #3 #4 #5 #6 #7 ;
  }
\cs_new:Npn \fp_basics_add_mantissa_test:N #1
  {
    \if:w 2 #1
      \exp_after:wN \fp_basics_add_mantissa_carry:wwNNNN
    \else:
      \exp_after:wN \fp_basics_add_mantissa_no_carry:wwNNNN
    \fi:
  }
%    \end{macrocode}
%
%   \begin{syntax}
%     \cs{fp_basics_add_mantissa_no_carry:wwNNNN}
%     ~~\meta{8d} |;| \meta{6d} |;| \meta{2d} |;|
%     ~~\meta{rounding} \meta{sign}
%   \end{syntax}
%   If there's no carry, grab all the digits again, and just
%   set the rounding correctly.\footnote{Bruno: an optimization
%     would be to compute whether we need rounding or not,
%     and only grab digits if there is rounding.}
%
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_mantissa_no_carry:wwNNNN
    #1; #2; #3#4 ; #5#6
  {
    \exp_after:wN \fp_basics_add_mantissa_no_carry_pack:NNNNNw
    \int_use:N \int_eval:w 1 #1
      \exp_after:wN \fp_basics_add_mantissa_no_carry_pack_ii:NNNNNw
      \int_use:N \int_eval:w 1 #2 #3#4
        + \fp_aux_round:NNN #6 #4 #5
        \exp_after:wN ;
  }
\cs_new:Npn \fp_basics_add_mantissa_no_carry_pack_ii:NNNNNw #1 #2#3#4#5 #6;
  {
    \if:w 2 #1
      + \c_one
    \fi:
    ; {#2#3#4#5} {#6} ;
  }
\cs_new:Npn \fp_basics_add_mantissa_no_carry_pack:NNNNNw #1 #2#3#4#5 #6;
  {
    \if:w 2 #1
      \fp_basics_add_mantissa_late_carry:w
    \fi:
    ; {#2#3#4#5} {#6}
  }
\cs_new:Npn \fp_basics_add_mantissa_late_carry:w \fi: ; #1
  { + \c_one ; {1000} } % |#1| should be |0000|
%    \end{macrocode}
%
%   The case where there is a carry is very similar: rounding can even
%   raise the first digit from $1$ to $2$ (but we don't need to check that).
%   \begin{syntax}
%     \cs{fp_basics_add_mantissa_carry:wwNNNN}
%     ~~\meta{8d} |;| \meta{6d} |;| \meta{2d} |;|
%     ~~\meta{rounding} \meta{sign}
%   \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_add_mantissa_carry:wwNNNN
    #1; #2; #3#4; #5#6
  {
    + \c_one
    \exp_after:wN \fp_basics_add_mantissa_carry_pack:NNNNNNNNw
    \int_use:N \int_eval:w 1 #1
      \exp_after:wN \fp_basics_add_mantissa_carry_pack_ii:NNNNw
      \int_use:N \int_eval:w 1 #2#3
        + \fp_aux_round:NNNN #6 #3 #4 #5
        \exp_after:wN ;
  }
\cs_new:Npn \fp_basics_add_mantissa_carry_pack_ii:NNNNw #1 #2#3#4 #5;
  {
    \if:w 2 #1
      + \c_one
    \fi:
    \int_eval_end:
    #2#3#4; {#5} ;
  }
\cs_new:Npn \fp_basics_add_mantissa_carry_pack:NNNNNNNNw
    #1#2#3#4 #5#6#7#8 #9; { ; {#1#2#3#4} {#5#6#7#8} {#9} }
%    \end{macrocode}
% \end{macro} 
%
% 
% \subsubsection{Absolute subtraction}
%
% \begin{macro}[EXP]{\fp_basics_sub_npos:Nnwnw}
%   \begin{syntax}
%     \cs{fp_basics_sub_npos:Nnwnw} \meta{sign}
%     ~~\Arg{exp1}  \meta{body1} |;| \Arg{exp2} \meta{body2} |;|
%   \end{syntax}
%   Rounding properly in some modes requires to know what the sign
%   of the result will be. For addition, this was easy. Here, besides
%   comparing the exponents to know how to decimate, we need to
%   check carefully which number is bigger when they have the same
%   exponent.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_npos:Nnwnw #1 #2#3; #4 #5;
  {
    \exp_after:wN \fp_basics_sub_sanitize:wN
    \int_use:N \int_eval:w
      \if_num:w #2 > #4 \exp_stop_f:
        #2
        \exp_after:wN \fp_basics_sub_big_i:wNww \int_value:w -
      \else:
        #4
        \if_num:w #2 = #4 \exp_stop_f:
          \fp_basics_sub_exponent_eq:nnnnnnnn #3 #5
        \else:
          \exp_after:wN \fp_basics_sub_big_ii:wNww \int_value:w
        \fi:
      \fi:
      \int_eval:w #4 - #2 ; #1 #3; #5;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_sanitize:wN}
%   \begin{syntax}
%     \cs{fp_basics_sub_sanitize:wN} \meta{exp} |;| \meta{sign} \Arg{body} |;|
%   \end{syntax}
%   We need to check for overflow, for underflow, and for exact zero.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_sanitize:wN #1 ; #2
  {
    \if_case:w \if_num:w #1 > \c_fp_max_exponent_int \c_one \else:
               \if_num:w #1 < \c_fp_min_exponent_int \c_two \else:
               \if:w 1 #2 \c_three \else: \c_zero \fi: \fi: \fi:
    \or: \exp_after:wN \fp_aux_overflow:w
    \or: \exp_after:wN \fp_aux_underflow:w
    \or: \exp_after:wN \fp_aux_exact_zero:w
    \fi:
    \s_fp \fp_use:w 1 #2 {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_exponent_eq:nnnnnnnn}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_exponent_eq:nnnnnnnn #1#2#3#4 #5#6#7#8
  {
    \if_num:w #1#2 > #5#6 \exp_stop_f:
      \exp_after:wN \fp_basics_sub_big_i:wNww \int_value:w
    \else:
      \if_num:w #1#2 < #5#6 \exp_stop_f:
        \exp_after:wN \fp_basics_sub_big_ii:wNww \int_value:w
      \else:
        \if_num:w #3#4 > #7#8 \exp_stop_f:
          \exp_after:wN \fp_basics_sub_big_i:wNww \int_value:w
        \else:
          \if_num:w #3#4 < #7#8 \exp_stop_f:
            \exp_after:wN \fp_basics_sub_big_ii:wNww \int_value:w
          \else:
            \exp_after:wN \fp_basics_sub_eq:wNww \int_value:w
          \fi:
        \fi:
      \fi:
    \fi:
  }
\cs_new:Npn \fp_basics_sub_eq:wNww #1; #2 #3; #4; { ; 1 ; }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_big_i:wNww,\fp_basics_sub_big_ii:wNww}
%   \begin{syntax}
%     \cs{fp_basics_sub_big_i:wNww} \meta{shift} |;| \meta{sign}
%     ~~\meta{body1} |;| \meta{body2} |;|
%   \end{syntax}
%   Shift the mantissa of the small number, and then subtract with
%   \cs{fp_basics_sub_back_mantissa:NnnNnnnn}.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_big_i:wNww #1; #2 #3; #4;
  {
    \fp_aux_decimate:nNnnnn {#1}
      \fp_basics_sub_back_mantissa:NnnNnnnn
      #4
    #2
    #3
  }
\cs_new:Npn \fp_basics_sub_big_ii:wNww #1; #2 #3; #4;
  {
    \exp_after:wN \fp_basics_sub_big_i:wNww
    \int_value:w #1 \exp_after:wN ;
    \int_use:N \int_eval:w 2 - #2 \int_eval_end:
    #4; #3;
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_back_mantissa:NnnNnnnn}
%   \begin{syntax}
%     \cs{fp_basics_sub_back_mantissa:NnnNnnnn}
%     ~~\meta{rounding} \Arg{Y'1} \Arg{Y'2}
%     ~~\meta{final sign}
%     ~~\Arg{X1} \Arg{X2} \Arg{X3} \Arg{X4}
%   \end{syntax}
%   At this stage, we know that \meta{Y} is less than \meta{X},
%   and we know the final sign.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_mantissa:NnnNnnnn #1 #2#3 #4 #5#6#7#8
  {
    \exp_after:wN \fp_basics_sub_back_mantissa_aux:NNwNNNNwN
    \exp_after:wN #1
    \exp_after:wN #4
    \int_use:N \int_eval:w 2#5#6 - #2 - 2 + 
      \exp_after:wN \fp_basics_sub_back_mantissa_round:wNN
      \int_use:N \int_eval:w 2#7#8 - #3 ; #1 #4
  }
%    \end{macrocode}
% After the computation, we need to check whether the first digit of
% the result is zero. This can only happen if the two numbers had the
% same exponent, or exponents differing by $1$. In the latter case,
% the \meta{rounding} digit is not quite enough to let us retrieve
% the exact result (consider $\cdots25$ and $\cdots15$, both rounded
% to $\cdots2$ in the usual mode), so we also move the result of
% \cs{fp_aux_round_neg:NNN} upstream as the digit $0$ or $1$.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_mantissa_round:wNN #1; #2 #3
  {
    \exp_after:wN \fp_basics_sub_back_mantissa_aux_iii:N
    \int_value:w
        \exp_after:wN \fp_aux_round_neg:NNN
        \exp_after:wN #3
        \use_none:nnnnnnnn #1 #2
      + #1
    \exp_after:wN ;
  }
\cs_new:Npn \fp_basics_sub_back_mantissa_aux_iii:N #1
  {
    \exp_after:wN \fp_basics_sub_back_mantissa_aux_ii:NNNNNNw
    \exp_after:wN #1
    \int_use:N \int_eval:w
      - #1
  }
\cs_new:Npn \fp_basics_sub_back_mantissa_aux_ii:NNNNNNw #1 #2 #3#4#5#6 #7;
  { #2 ; #1 {#3#4#5#6} {#7} ; }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_sub_back_mantissa_aux:NNwNNNNwN}
%   Here, |#3| should always be $2$, but we have to take is
%   as a normal undelimited argument since that would break
%   if |#2| is $2$.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_mantissa_aux:NNwNNNNwN #1#2 #3 #4#5#6#7 #8; #9
  {
    \if:w 0 #4
      \exp_after:wN \fp_basics_sub_back_carry:NNwNnnnn
      \exp_after:wN #1
      \exp_after:wN #9
    \fi:
    ; #2
    {#4#5#6#7} {#8}
  }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\fp_basics_sub_back_carry:NNwNnnnn}
%   \begin{syntax}
%     \cs{fp_basics_sub_back_carry:NNwNnnnn}
%     ~~\meta{rounding} \meta{0 or 1} |;| \meta{final sign}
%     ~~\Arg{Z1} \Arg{Z2} \Arg{Z3} \Arg{Z4} |;|
%   \end{syntax}
%   This function is called when $\meta{Z1}\leq 999$. We revert
%   the carry, which is given by \meta{0 or 1}, and subtract the
%   \meta{rounding} digit as appropriate, then feed the result,
%   of the form \meta{$\leq$ 7d} |;| \meta{9d} |;| to
%   \cs{fp_basics_sub_back_carry_aux:wwN}. The result is always exact.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_carry:NNwNnnnn #1#2 ; #3 #4#5#6#7 ;
  {
    \exp_after:wN \fp_basics_sub_back_carry_aux:wwN
    \int_use:N \int_eval:w #4 #5 - 1 + \exp_after:wN \fp_aux_i_s:N
    \int_use:N \int_eval:w 1 #6 #7 0 + #1 0 - #2 ; #3
  }
%    \end{macrocode}
%   Unless the first block is zero, check how many digits is has,
%   and shift the exponent down by the corresponding amount. Then
%   pack digits into blocks of $4$ (there are between $10$ and $16$
%   digits in front of \cs{fp_basics_sub_back_carry_large:NNNNNNNNw}).
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_carry_aux:wwN #1 ;
  {
    \if:w 0 #1
      - 8
      \exp_after:wN \fp_basics_sub_back_carry_small:wN \int_value:w
    \else:
      - \fp_basics_sub_back_carry_aux_ii:NNNNNNNNw #1 1234567;
      \exp_after:wN \fp_basics_sub_back_carry_large:NNNNNNNNw
    \fi:
    #1
  }
%    \end{macrocode}
%   The case where the number is non-zero is slightly easier.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_carry_aux_ii:NNNNNNNNw #1#2#3#4#5#6#7#8#9; {#8}
\cs_new:Npn \fp_basics_sub_back_carry_large:NNNNNNNNw #1#2#3#4 #5#6#7#8 #9;
  {
    \fp_basics_sub_back_carry_large_ii:NNNNNNNNw
    #9 000000 ; {#1#2#3#4} {#5#6#7#8}
  }
\cs_new:Npn \fp_basics_sub_back_carry_large_ii:NNNNNNNNw #1#2#3#4 #5#6#7#8 #9;
  { \fp_basics_sub_back_carry_large_iii:nnnnN {#1#2#3#4} {#5#6#7#8} }
\cs_new:Npn \fp_basics_sub_back_carry_large_iii:nnnnN #1#2 #3#4 #5
  { ; #5 {#3}{#4} {#1}{#2} ; }
%    \end{macrocode}
%   In the case of a \enquote{small} result, what comes after
%   \cs{fp_basics_sub_back_carry_small:wN} has between $1$
%   and $9$ digits, and is not zero.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_sub_back_carry_small:wN #1;
  {
    - \exp_after:wN \fp_aux_use_i_until_s:Nw
      \use_none:nnnnnnnnn #1 012345678;
    \fp_basics_sub_back_carry_small_ii:NNNNNNNN #1 00000000 ;
  }
\cs_new:Npn \fp_basics_sub_back_carry_small_ii:NNNNNNNN #1#2#3#4 #5#6#7#8
  { \fp_basics_sub_back_carry_small_iii:nnNwN {#1#2#3#4} {#5#6#7#8} }
\cs_new:Npn \fp_basics_sub_back_carry_small_iii:nnNwN #1 #2 #3 #4; #5
  { ; #5 {#1} {#2} {#3000} {0000} ; }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Multiplication}
%
% \subsubsection{User commands}
% 
% Only a few commands are meant for external use (although none
% of them by end-users).
% \begin{macro}[EXP]{\fp_mul:nn}
% \begin{macro}[aux,EXP]{\fp_basics_mul_ff:NNwn,\fp_basics_mul_ff:NNwNN}
%   The two arguments are f-expanded before being fed to 
%   \cs{fp_basics_mul_cases:NN} in the form
%   \begin{quote}
%     \cs{fp_basics_mul_cases:NN}
%     \meta{case2} \meta{case1} \meta{sign2} \meta{sign1}
%     \meta{exp2}  \meta{body2} |;| \meta{exp1}  \meta{body1} |;|
%   \end{quote}
%    \begin{macrocode}
\cs_new:Npn \fp_mul:nn #1 
  {
    \exp_after:wN \fp_basics_mul_ff:NNwn
    \tex_romannumeral:D -`0 #1
  }
\cs_new:Npn \fp_basics_mul_ff:NNwn \s_fp \fp_use:w #1 #2 #3 ; #4
  {
    \exp_after:wN \fp_basics_mul_ff:NNwNN
    \exp_after:wN #1
    \exp_after:wN #2
    \tex_romannumeral:D -`0 #4
    #3 ;
    \prg_do_nothing:
  }
\cs_new:Npn \fp_basics_mul_ff:NNwNN #1 #2 \s_fp \fp_use:w #3 #4
  { \fp_basics_mul_cases:NN #3 #1 #4 #2 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\fp_mul:ww}
%   Each argument is
%   \begin{quote}
%     \cs{s_fp} \cs{fp_use:w} \meta{case} \meta{sign}
%     \meta{exponent} \meta{body} |;|
%   \end{quote}
%   We setup for \cs{fp_basics_mul_cases:NN}.
%    \begin{macrocode}
\cs_new:Npn \fp_mul:ww \s_fp \fp_use:w #1 #2 #3 ; \s_fp \fp_use:w #4 #5
  { \fp_basics_mul_cases:NN #1 #4 #2 #5 #3 ; }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Signs, and special numbers}
%
% \begin{macro}[EXP,aux]{\fp_basics_mul_cases:NN}
%   \begin{syntax}
%     \cs{fp_basics_mul_cases:NN} \meta{case1} \meta{case2}
%     ~~\meta{sign1} \meta{sign2} \Arg{exp1} \meta{body1} |;|
%     ~~\Arg{exp2} \meta{body2} |;|
%   \end{syntax}
%   Expands the following tokens on the input stream once.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_cases:NN #1 #2
  {
    \if_case:w \int_eval:w \c_one +
            \if_num:w #1 = \c_one          #2 \int_eval_end: \fi:
            \if_num:w #2 = \c_one          #1 \int_eval_end: \fi:
            \if_num:w #1 = #2 \exp_stop_f: #1 \int_eval_end: \fi:
            \c_three \int_eval_end:
    \or: \exp_after:wN \fp_basics_mul_zero:NNnwnw
    \or: \exp_after:wN \fp_basics_mul_normal:NNnwnw
    \or: \exp_after:wN \fp_basics_mul_inf:NNnwnw
    \or: \exp_after:wN \fp_basics_mul_nan:NNnwnw
    \fi:
  }
%    \end{macrocode}
%   The special cases are quite easy.\footnote{The \texttt{nan}
%     are not treated properly yet!}
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_zero:NNnwnw #1#2 #3#4; #5#6;
  {
    \if:w #1 #2
      \exp_after:wN \exp_after:wN \exp_after:wN \c_plus_zero_fp
    \else:
      \exp_after:wN \exp_after:wN \exp_after:wN \c_minus_zero_fp
    \fi:
  }
\cs_new:Npn \fp_basics_mul_inf:NNnwnw #1#2 #3#4; #5#6;
  {
    \if:w #1 #2
      \exp_after:wN \exp_after:wN \exp_after:wN \c_plus_inf_fp
    \else:
      \exp_after:wN \exp_after:wn \exp_after:wN \c_minus_inf_fp
    \fi:
  }
\cs_new:Npn \fp_basics_mul_nan:NNnwnw #1#2 #3#4; #5#6;
  { \exp_after:wN \c_empty_qnan_fp }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_mul_normal:NNnwnw}
%   \begin{syntax}
%     \cs{fp_basics_mul_normal:NNnwnw} \meta{sign1} \meta{sign2}
%     ~~\Arg{exp1}  \meta{body1} |;| \Arg{exp2} \meta{body2} |;|
%   \end{syntax}
%   We now have two normal numbers to multiply. Combine the signs.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_normal:NNnwnw #1#2
  {
    \if:w #1#2
      \exp_after:wN \fp_basics_mul_npos:Nnwnw
      \exp_after:wN 0
    \else:
      \exp_after:wN \fp_basics_mul_npos:Nnwnw
      \exp_after:wN 1
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Absolute multiplication}
%
% In this subsection, we perform the multiplication
% of two positive normal numbers.
%
% \begin{macro}[EXP]{\fp_basics_mul_npos:Nnwnw}
%   \begin{syntax}
%     \cs{fp_basics_mul_npos:Nnwnw} \meta{sign}
%     ~~\Arg{exp1}  \meta{body1} |;| \Arg{exp2} \meta{body2} |;|
%   \end{syntax}
%   As for addition, \meta{sign} is the final sign. After the computation,
%   \cs{fp_basics_mul_sanitize:wN} checks for overflow or underflow.
%   As before, \cs{int_eval:w} computes the exponent, catching any
%   shift coming from the computation in the mantissa. Again, the
%   \meta{sign} is needed for rounding to be done properly, so we move
%   it around.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_npos:Nnwnw #1 #2#3; #4
  {
    \exp_after:wN \fp_basics_mul_sanitize:wN
    \int_use:N \int_eval:w
      #2 + #4
      \fp_basics_mul_mantissa:nnnnNnnnw
      #3 #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_mul_sanitize:wN}
%   \begin{syntax}
%     \cs{fp_basics_mul_sanitize:wN} \meta{exp} |;| \meta{sign} \Arg{body} |;|
%   \end{syntax}
%   Over- and underflow check.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_sanitize:wN #1 ; #2
  {
    \if_num:w #1 > \c_fp_max_exponent_int
      \exp_after:wN \fp_aux_overflow:w
      \if_num:w #1 < \c_fp_min_exponent_int
        \exp_after:wN \exp_after:wN
        \exp_after:wN \fp_aux_underflow:w
      \fi:
    \fi:
    \s_fp \fp_use:w 1 #2 {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_basics_mul_mantissa:nnnnNnnnw}
%   \begin{syntax}
%     \cs{fp_basics_mul_mantissa:nnnnNnnnw}
%     ~~\Arg{X1} \Arg{X2} \Arg{X3} \Arg{X4} \meta{sign}
%     ~~\Arg{Y1} \Arg{Y2} \Arg{Y3} \Arg{Y4} |;|
%   \end{syntax}
% \end{macro}
% 
% \begin{macro}[EXP]{\fp_basics_mul_mantissa:nnnnNnnnn}
%   Once more, the fifth argument is a function to call on
%   the raw result, namely on $5$ brace groups, the first of 
%   which may be zero. 
%
%   The following token after expansion must be a semicolon.
%   
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_mantissa:nnnnNnnnn #1#2#3#4 #5 #6#7#8#9
  {
    \exp_after:wN \fp_aux_i_noii_bfour_btail:nnnnnnw
    \exp_after:wN #5
    \int_use:N \int_eval:w        99990000 + #1*#6 + 
    \exp_after:wN \fp_aux_brace_tail:nnnnnw
    \int_use:N \int_eval:w        99990000 + #1*#7+#2*#6+ 
    \exp_after:wN \fp_aux_brace_tail:nnnnnw
    \int_use:N \int_eval:w        99990000 + #1*#8+#2*#7+#3*#6+ 
    \exp_after:wN \fp_aux_brace_tail_s:nnnnnw
    \int_use:N \int_eval:w       100000000 + #1*#9+#2*#8+#3*#7+#4*#6
                                               + (#2*#9+#3*#8+#4*#7)/10000
  }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\fp_basics_mul_mantissa_carry:n}
%   If the first coming brace group is zero, remove it and decrease the 
%   exponent by one. Otherwise, remove the fifth brace group.
%    \begin{macrocode}
\cs_new:Npn \fp_basics_mul_mantissa_carry:n #1 
  {
    \if_num:w #1 = \c_zero
      - \exp_after:wN \c_one
    \else:
      \fp_basics_mul_mantissa_carry_aux:nNnnnn {#1}
    \fi:
  }
\cs_new:Npn \fp_basics_mul_mantissa_carry_aux:nNnnnn #1 #2 #3#4#5#6 
  {
    #2{#1}{#3}{#4}{#5}
  }
%    \end{macrocode}
% \end{macro}
% 
% 
%
%
% \subsection{For other submodules}
% 
%
% \begin{macro}{\use_i_ii_iii:nnnn}
%    \begin{macrocode}
\cs_new:Npn \use_i_ii_iii:nnnn #1 #2 #3 #4 { #1 #2 #3 }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
%\PrintChanges
%
%\PrintIndex