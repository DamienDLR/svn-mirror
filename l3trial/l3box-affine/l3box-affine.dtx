% \iffalse meta-comment
% 
%% File: l3box-affine.dtx Copyright(C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3trial bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental box affine transformations}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
% 
% \title{^^A
%   The \textsf{l3box-affine} package\\ Box affine transformations^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%         
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
% 
% This is a stage area for additional box functions dealing with affine
% transformations (scaling, reflections and rotations). These are dealt with
% not by \TeX{} itself but at the driver level. The low-level driver material
% is not included here but is placed in the \pkg{l3drivers} module.
% 
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3box-affine} Implementation}
% 
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
\package_check_loaded_expl:
%</package>
%    \end{macrocode}
%    
%\subsection{Rotating boxes}
%
% The code here covers the driver-independent part of the rotation
% process. The driver-specific code is located in \pkg{l3engine}.
% 
% \begin{variable}{\l_box_angle_fp}
%   When rotating boxes, the angle itself may be needed by the
%   engine-dependent code. This is done using the \pkg{fp} module so
%   that the value is tidied up properly.
%    \begin{macrocode}
\fp_new:N \l_box_angle_fp
%    \end{macrocode}
% \end{variable}
% 
% \begin{variable}{\l_box_cos_fp, \l_box_sin_fp}
%   These are used to hold the calculated sine and cosine values while
%   carrying out a rotation.
%    \begin{macrocode}
\fp_new:N \l_box_cos_fp
\fp_new:N \l_box_sin_fp
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {\l_box_top_dim, \l_box_bottom_dim, \l_box_left_dim, \l_box_right_dim}
%   These are the positions of the four edges of a box before
%   manipulation.
%    \begin{macrocode}
\dim_new:N \l_box_top_dim
\dim_new:N \l_box_bottom_dim
\dim_new:N \l_box_left_dim
\dim_new:N \l_box_right_dim
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}
%  {
%    \l_box_top_new_dim,  \l_box_bottom_new_dim ,
%    \l_box_left_new_dim, \l_box_right_new_dim
%  }
%   These are the positions of the four edges of a box after
%   manipulation.
%    \begin{macrocode}
\dim_new:N \l_box_top_new_dim
\dim_new:N \l_box_bottom_new_dim
\dim_new:N \l_box_left_new_dim
\dim_new:N \l_box_right_new_dim
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_box_tmp_box, \l_box_tmp_fp}
%   Scratch space.
%    \begin{macrocode}
\box_new:N \l_box_tmp_box
\fp_new:N \l_box_tmp_fp
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_box_x_fp, \l_box_y_fp, \l_box_x_new_fp, \l_box_y_new_fp}
%   Used as the input and output values for a point when manipulation the
%   location.
%    \begin{macrocode}
\fp_new:N \l_box_x_fp
\fp_new:N \l_box_y_fp
\fp_new:N \l_box_x_new_fp
\fp_new:N \l_box_y_new_fp
%    \end{macrocode}
% \end{variable}
% 
% \begin{macro}{\box_rotate:Nn}
% \begin{macro}[aux]{\box_rotate_aux:N}
%   Rotation of a box starts with working out the relevant sine and
%   cosine. There is then a check to avoid doing any real work for the
%   trivial rotation.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \box_rotate:Nn #1#2
  {
    \group_begin: 
      \fp_set:Nn \l_box_angle_fp {#2}
      \box_rotate_set_sin_cos:
      \fp_compare:NNNTF \l_box_sin_fp = \c_zero_fp
        { 
         \fp_compare:NNNF \l_box_cos_fp = \c_one_fp
           { \box_use_rotated_aux:N #1 }
        }
        { \box_rotated_aux:N #1 }
    \group_end:
  }
%    \end{macrocode}
%   The edges of the box are then recorded: the left edge will
%   always be at zero. Rotation of the four edges then takes place: this is
%   most efficiently done on a quadrant by quadrant basis.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \box_rotate_aux:N #1
  {
    \dim_set:Nn \l_box_top_dim    {  \box_ht:N #1 }
    \dim_set:Nn \l_box_bottom_dim { -\box_dp:N #1 }
    \dim_set:Nn \l_box_right_dim  {  \box_wd:N #1 }
    \dim_zero:N \l_box_left_dim
    \fp_compare:NNNTF \l_box_sin_fp > \c_zero_fp
      {
        \fp_compare:NNNTF \l_box_cos_fp > \c_zero_fp
          { \box_rotate_quadrant_one: }
          { \box_rotate_quadrant_two: }
      }
      {
        \fp_compare:NNNTF \l_box_cos_fp < \c_zero_fp
          { \box_rotate_quadrant_three: }
          { \box_rotate_quadrant_four: }
      }
%    \end{macrocode}
%   The position of the box edges are now known, but the box at this
%   stage be misplaced relative to the current \TeX{} reference point. So the
%   content of the box is moved such that the reference point of the
%   rotated box will be in the same place as the original.
%    \begin{macrocode}
    \hbox_set:Nn \l_box_tmp_box { { \box_use:N #1 } }
    \hbox_set:Nn \l_box_tmp_box
      {
        \tex_kern:D -\l_box_left_new_dim
        \hbox_vshift:nn
          { 
            \driver_box_rotate_begin:
            \box_use:N \l_box_tmp_box
            \driver_box_rotate_end:
          }
          { -\l_box_bottom_new_dim }
      }
%    \end{macrocode}
%   Tidy up the size of the box so that the material is actually inside
%   the bounding box. The result can then be used to reset the original
%   box.
%    \begin{macrocode}
    \box_set_ht:Nn \l_box_tmp_box {  \l_box_top_new_dim }
    \box_set_dp:Nn \l_box_tmp_box { -\l_box_bottom_new_dim }
    \box_set_wd:Nn \l_box_tmp_box
      { \l_box_right_new_dim - \l_box_left_new_dim }
    \hbox_set:Nn #1 { \box_use:N \l_box_tmp_box }
  }
%    \end{macrocode}
% When loaded on top of \LaTeXe{} the \cs{rotatebox} function can be
% used. There is just a slight adjustment in the syntax.
%    \begin{macrocode}
%<*package>
\cs_set_protected_nopar:Npn \box_rotate:Nn #1#2
  {
    \hbox_set:Nn #1 \rotatebox {#2} { \box_use:N #1 }
  }
%</package>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\box_rotate_set_sin_cos:}
%   A simple conversion from degrees to radians followed by calculation
%   of the sine and cosine.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \box_rotate_set_sin_cos:
  {
    \fp_set_eq:NN \l_box_tmp_fp \l_box_angle_fp
    \fp_div:Nn \l_box_tmp_fp { 180 }
    \fp_mul:Nn \l_box_tmp_fp { \c_pi_fp }
    \fp_sin:Nn \l_box_sin_fp { \l_box_tmp_fp }
    \fp_cos:Nn \l_box_cos_fp { \l_box_tmp_fp }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\box_rotate_x:nnN, \box_rotate_y:nnN}
%   These functions take a general point $|#1|, |#2|$ and rotate its
%   location about the origin, using the previously-set sine and cosine
%   values. Each function gives only one component of the location of the
%   updated point. This is because for rotation of a box each step needs
%   only one value, and so performance is gained by avoiding working
%   out both $x'$ and $y'$ at the same time. Contrast this with
%   the equivalent function in the \pkg{l3coffins} module, where both parts
%   are needed.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \box_rotate_x:nnN #1#2#3
  {
    \fp_set_from_dim:Nn \l_box_x_fp {#1}
    \fp_set_from_dim:Nn \l_box_y_fp {#2}
    \fp_set_eq:NN \l_box_x_new_fp \l_box_x_fp
    \fp_set_eq:NN \l_box_tmp_fp   \l_box_y_fp
    \fp_mul:Nn \l_box_x_new_fp { \l_box_cos_fp }
    \fp_mul:Nn \l_box_tmp_fp   { \l_box_sin_fp }
    \fp_sub:Nn \l_box_x_new_fp { \l_box_tmp_fp }
    \dim_set:Nn #3 { \fp_to_dim:N \l_box_x_new_fp }
  }
\cs_new_protected_nopar:Npn \box_rotate_y:nnN #1#2#3
  {
    \fp_set_from_dim:Nn \l_box_x_fp {#1}
    \fp_set_from_dim:Nn \l_box_y_fp {#2}
    \fp_set_eq:NN \l_box_y_new_fp \l_box_y_fp
    \fp_set_eq:NN \l_box_tmp_fp   \l_box_x_fp
    \fp_mul:Nn \l_box_y_new_fp { \l_box_cos_fp }
    \fp_mul:Nn \l_box_tmp_fp   { \l_box_sin_fp }
    \fp_add:Nn \l_box_y_new_fp { \l_box_tmp_fp }
    \dim_set:Nn #3 { \fp_to_dim:N \l_box_y_new_fp }
}
%    \end{macrocode}
%\end{macro}
%
% \begin{macro}[aux]
%   {
%     \box_rotate_quadrant_one:,   \box_rotate_quadrant_two:,
%     \box_rotate_quadrant_three:, \box_rotate_quadrant_four:
%   }
%   Rotation of the edges is done using a different formula for each
%   quadrant. In every case, the top and bottom edges only need the
%   resulting $y$-values, whereas the left and right edges need the
%   $x$-values. Each case is a question of picking out which corner
%   ends up at with the maximum top, bottom, left and right value. Doing
%   this by hand means a lot less calculating and avoids lots of
%   comparisons.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \box_rotate_quadrant_one:
  {
    \box_rotate_y:nnN \l_box_right_dim \l_box_top_dim
      \l_box_top_new_dim
    \box_rotate_y:nnN \l_box_left_dim  \l_box_bottom_dim
      \l_box_bottom_new_dim
    \box_rotate_x:nnN \l_box_left_dim  \l_box_top_dim
      \l_box_left_new_dim
    \box_rotate_x:nnN \l_box_right_dim \l_box_bottom_dim
      \l_box_right_new_dim
  }
\cs_new_protected_nopar:Npn \box_rotate_quadrant_two:
  {
    \box_rotate_y:nnN \l_box_right_dim \l_box_bottom_dim
      \l_box_top_new_dim
    \box_rotate_y:nnN \l_box_left_dim  \l_box_top_dim
      \l_box_bottom_new_dim
    \box_rotate_x:nnN \l_box_right_dim  \l_box_top_dim
      \l_box_left_new_dim
    \box_rotate_x:nnN \l_box_left_dim   \l_box_bottom_dim
      \l_box_right_new_dim
  }
\cs_new_protected_nopar:Npn \box_rotate_quadrant_three:
  {
    \box_rotate_y:nnN \l_box_left_dim  \l_box_bottom_dim
      \l_box_top_new_dim
    \box_rotate_y:nnN \l_box_right_dim \l_box_top_dim
      \l_box_bottom_new_dim
    \box_rotate_x:nnN \l_box_right_dim \l_box_bottom_dim
      \l_box_left_new_dim
    \box_rotate_x:nnN \l_box_left_dim   \l_box_top_dim
      \l_box_right_new_dim
  }
\cs_new_protected_nopar:Npn \box_rotate_quadrant_four:
  {
    \box_rotate_y:nnN \l_box_left_dim  \l_box_top_dim
      \l_box_top_new_dim
    \box_rotate_y:nnN \l_box_right_dim \l_box_bottom_dim
      \l_box_bottom_new_dim
    \box_rotate_x:nnN \l_box_left_dim  \l_box_bottom_dim
      \l_box_left_new_dim
    \box_rotate_x:nnN \l_box_right_dim \l_box_top_dim
      \l_box_right_new_dim
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Resizing boxes}
%
% \begin{variable}{\l_box_scale_x_fp, \l_box_scale_y_fp}
%   Scaling is potentially-different in the two axes.
%    \begin{macrocode}
\fp_new:N \l_box_scale_x_fp
\fp_new:N \l_box_scale_y_fp
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\box_resize:Nnn}
% \begin{macro}[aux]{\box_resize_aux:Nnn}
%   Resizing a box starts by working out the various dimensions of the
%   existing box.
%    \begin{macrocode}
\cs_new_protected:Npn \box_resize:Nnn #1#2#3
  {
    \group_begin:
      \dim_set:Nn \l_box_top_dim    {  \box_ht:N #1 }
      \dim_set:Nn \l_box_bottom_dim { -\box_dp:N #1 }
      \dim_set:Nn \l_box_right_dim  {  \box_wd:N #1 }
      \dim_zero:N \l_box_left_dim
%    \end{macrocode}
%   The $x$-scaling and resulting box size is easy enough to work
%   out: the dimension is that given as |#2|, and the scale is simply the
%   new width divided by the old one.
%    \begin{macrocode}
      \fp_set_from_dim:Nn \l_box_scale_x_fp {#2}
      \fp_set_from_dim:Nn \l_box_tmp_fp { \l_box_right_dim }
      \fp_div:Nn \l_box_scale_x_fp { \l_box_tmp_fp }
%    \end{macrocode}
%   The $y$-scaling needs both the height and the depth of the current box.
%    \begin{macrocode}
      \fp_set_from_dim:Nn \l_box_scale_y_fp {#3}
      \fp_set_from_dim:Nn \l_box_tmp_fp
        { \l_box_top_dim + \l_box_bottom_dim }
      \fp_div:Nn \l_box_scale_y_fp { \l_box_tmp_fp }
%    \end{macrocode}
%   At this stage, check for trivial scaling. If both scalings are unity, then
%   the code does nothing. Otherwise, pass on to the auxiliary function to
%   find the new dimensions.
%    \begin{macrocode}
      \fp_compare:NNNTF \l_box_scale_x_fp = \c_one_fp
        { 
          \fp_compare:NNNF \l_box_scale_y_fp = \c_one_fp
            { \box_resize_aux:Nnn #1 {#2} {#3} }
        }
        { \box_resize_aux:Nnn #1 {#2} {#3} }
    \group_end:
  }
%    \end{macrocode}
%   With at least one real scaling to do, the next phase is to find the new
%   edge co-ordinates. In the $x$~direction this is relatively easy: just
%   scale the right edge. This is done using the absolute value of the
%   scale so that the new edge is in the correct place. In the $y$~direction,
%   both dimensions have to be scaled, and this again needs the absolute
%   scale value. Once that is all done, the common resize/rescale code can
%   be employed.
%    \begin{macrocode}
\cs_new_protected:Npn \box_resize_aux:Nnn #1#2#3
  {
    \dim_compare:nNnTF {#2} > \c_zero_dim
      { \dim_set:Nn \l_box_right_new_dim {#2} }
      { \dim_set:Nn \l_box_right_new_dim { - ( #2 ) } }
    \dim_compare:nNnTF {#3} > \c_zero_dim
      {
        \dim_set:Nn \l_box_top_new_dim
          { \fp_use:N \l_box_y_scale_fp \l_box_top_dim }
        \dim_set:Nn \l_box_bottom_new_dim
          { \fp_use:N \l_box_y_scale_fp \l_box_bottom_dim }
      }    
      {
      {
        \dim_set:Nn \l_box_top_new_dim
          { - \fp_use:N \l_box_y_scale_fp \l_box_top_dim }
        \dim_set:Nn \l_box_bottom_new_dim
          { - \fp_use:N \l_box_y_scale_fp \l_box_bottom_dim }
      } 
    \box_resize_common:N #1
  }
%    \end{macrocode}
%   When loaded on top of \LaTeXe{} the \cs{resizebox} function can be
%   used. There is just a slight adjustment in the syntax.
%    \begin{macrocode}
%<*package>
\cs_set_protected_nopar:Npn \box_resize:Nnn #1#2#3
  {
    \hbox_set:Nn #1
      {
        \resizebox * 
          { \etex_dimexpr:D #2 \scan_stop: }
          { \etex_dimexpr:D #3 \scan_stop: }
          { \box_use:N #1 }
      }
  }
%</package>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\box_resize_to_ht_plus_dp:Nn}
% \begin{macro}{\box_resize_to_wd:Nn}
%   Scaling to a total height or to a width is a simplified version of the main
%   resizing operation, with the scale simply copied between the two parts. The
%   internal auxiliary is called using the scaling value twice, as the sign for
%   both parts is needed (as this allows the same internal code to be used as
%   for the general case).
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \box_resize_to_ht_plus_dp:Nn #1#2
  {
    \group_begin:
      \dim_set:Nn \l_box_top_dim    {  \box_ht:N #1 }
      \dim_set:Nn \l_box_bottom_dim { -\box_dp:N #1 }
      \dim_set:Nn \l_box_right_dim  {  \box_wd:N #1 }
      \dim_zero:N \l_box_left_dim
      \fp_set_from_dim:Nn \l_box_scale_y_fp {#2}
      \fp_set_from_dim:Nn \l_box_tmp_fp
        { \l_box_top_dim + \l_box_bottom_dim }
      \fp_div:Nn \l_box_scale_y_fp { \l_box_tmp_fp }
      \fp_set_eq:NN\l_box_scale_x_fp \l_box_scale_y_fp
      \fp_compare:NNNF \l_box_scale_y_fp = \c_one_fp
        { \box_resize_aux:Nnn #1 {#2} {#2} }
    \group_end:
  }
\cs_new_protected_nopar:Npn \box_resize_to_wd:Nn #1#2
  {
    \group_begin:
      \dim_set:Nn \l_box_top_dim    {  \box_ht:N #1 }
      \dim_set:Nn \l_box_bottom_dim { -\box_dp:N #1 }
      \dim_set:Nn \l_box_right_dim  {  \box_wd:N #1 }
      \dim_zero:N \l_box_left_dim
      \fp_set_from_dim:Nn \l_box_scale_x_fp {#2}
      \fp_set_from_dim:Nn \l_box_tmp_fp { \l_box_right_dim }
      \fp_div:Nn \l_box_scale_x_fp { \l_box_tmp_fp }
      \fp_set_eq:NN\l_box_scale_y_fp \l_box_scale_x_fp
      \fp_compare:NNNF \l_box_scale_x_fp = \c_one_fp
        { \box_resize_aux:Nnn #1 {#2} {#2} }
    \group_end:
  }
%    \end{macrocode}
%   Again, in package mode the scaling can be handled by \cs{resizebox}.
%    \begin{macrocode}
%<*package>
\cs_set_protected_nopar:Npn \box_resize_to_ht_plus_dp:Nn #1#2
  {
    \hbox_set:Nn #1
      {
        \resizebox * { ! } { \etex_dimexpr:D #2 \scan_stop: } { \box_use:N #1 }
      }
  }
\cs_set_protected_nopar:Npn \box_resize_to_wd:Nn #1#2
  {
    \hbox_set:Nn #1
      {
        \resizebox * { \etex_dimexpr:D #2 \scan_stop: } { ! } { \box_use:N #1 }
      }
  }
%</package>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\box_scale:Nnn}
% \begin{macro}[aux]{\box_scale_aux:Nnn}
%   When scaling a box, setting the scaling itself is easy enough. The
%   new dimensions are also relatively easy to find, allowing only for
%   the need to keep them positive in all cases. Once that is done then
%   after a check for the trivial scaling a hand-off can be made to the
%   common code. The dimension scaling operations are carried out using
%   the \TeX{} mechanism as it avoids needing to use \texttt{fp}
%   operations.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \box_scale:Nnn #1#2#3
  {
    \group_begin:
      \fp_set:Nn \l_box_scale_x_fp {#2}
      \fp_set:Nn \l_box_scale_y_fp {#3}
      \dim_set:Nn \l_box_top_dim    {  \box_ht:N #1 }
      \dim_set:Nn \l_box_bottom_dim { -\box_dp:N #1 }
      \dim_set:Nn \l_box_right_dim  {  \box_wd:N #1 }
      \dim_zero:N \l_box_left_dim
      \fp_compare:NNNTF \l_box_scale_x_fp = \c_one_fp
        { 
          \fp_compare:NNNF \l_box_scale_y_fp = \c_one_fp
            { \box_scale_aux:Nnn #1 {#2} {#3} }
        }
        { \box_scale_aux:Nnn #1 {#2} {#3} }
    \group_end:
  }
\cs_new_protected_nopar:Npn \box_scale_aux:Nnn #1#2#3
  {
    \fp_compare:NNNTF \l_box_scale_y_fp > \c_zero_fp
      {
        \dim_set:Nn \l_box_top_new_dim    { #3 \l_box_top_dim }
        \dim_set:Nn \l_box_bottom_new_dim { #3 \l_box_bottom_dim }
      }
      {
        \dim_set:Nn  \l_box_top_new_dim    { -#3 \l_box_bottom_dim }
        \dim_set:Nn  \l_box_bottom_new_dim { -#3 \l_box_top_dim }
      }
    \fp_compare:NNNTF \l_box_scale_x_fp > \c_zero_fp
      { \l_box_right_new_dim #2 \l_box_right_dim }
      { \l_box_right_new_dim -#2 \l_box_right_dim }
    \box_resize_common:N #1
  }
%    \end{macrocode}
%   When loaded on top of \LaTeXe{} the \cs{scalebox} function can be
%   used. There is just a slight adjustment in the syntax.
%    \begin{macrocode}
%<*package>
\cs_set_protected_nopar:Npn \box_scale:Nnn #1#2#3
  { \hbox_set:Nn #1 { \scalebox {#2} [#3] { \box_use:N #1 } } }
%</package>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\box_resize_common:N}
%   The main resize function places in input into a box which will start
%   of with zero width, and includes the handles for engine rescaling.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \box_resize_common:N #1
  {
    \hbox_set:Nn \l_box_tmp_box
      {
        \driver_box_scale_begin:
        \hbox_overlap_right:n { \box_use:N #1 }
        \driver_box_scale_end:
      }
%    \end{macrocode}
%   The new height and depth can be applied directly.
%    \begin{macrocode}
    \box_set_ht:Nn \l_box_tmp_box { \l_box_top_new_dim }
    \box_set_dp:Nn \l_box_tmp_box { \l_box_bottom_new_dim }
%    \end{macrocode}
%   Things are not quite as obvious for the width, as the reference point
%   needs to remain unchanged. For positive scaling factors resizing the
%   box is all that is needed. However, for case of a negative scaling
%   the material must be shifted such that the reference point ends up in
%   the right place.
%    \begin{macrocode}
    \fp_compare:NNNTF \l_box_scale_x_fp < \c_zero_fp
      {
        \hbox_to_wd:nn { \l_box_right_new_dim }
          {
            \tex_kern:D \l_box_right_new_dim
            \box_use:N \l_box_tmp_box
            \tex_hss:D
          }
      }
      { \box_set_wd:Nn \l_box_tmp_box { \l_box_right_new_dim } }
    \hbox_set:Nn #1 { \box_use:N \l_box_tmp_box }
  }
%    \end{macrocode}
%\end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex