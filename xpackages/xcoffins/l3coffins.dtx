%
% \iffalse
%<*driver>
 \documentclass[cm-default]{l3doc}
 \begin{document}
 \DocInput{l3coffins.dtx}
 \end{document}
%</driver>
% \fi
%
% \GetFileInfo{l3coffins.dtx}
%
% \title{The \textsf{l3coffins} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{Frank Mittelbach\thanks{Based on ideas and code developed by David
%    Carlisle, Frank Mittelbach and Chris Rowley in some distent time in the
%    last millenium --- or as David would say ``in his former life''.}}
% \date{\filedate}
%  \maketitle
% 
% 
%
% \newenvironment{Arglist}{\small\itemize
%        \newcommand\Argitem[1]{\item[\texttt{\###1}]}}{\enditemize}
%
%
% \tableofcontents
%
%
% \section{Introduction}
%
%
% \section{Implementation}
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
\RequirePackage{expl3}
\GetIdInfo$Id$
  {coffins module}
%    \end{macrocode}
%    
%    \begin{macrocode}
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
%    \end{macrocode}
%
%
% \subsection{Temporary variables used in this module}
%
%
%
%
%  \begin{macro}{\l_coffin_tmp_box}
%    Scratch box register used to repack a vertical coffin to determine its
%    top baseline.
%    \begin{macrocode}
\box_new:N \l_coffin_tmp_box
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\l_coffin_tmpa_dim,
%                \l_coffin_tmpb_dim
%                }
%    Scratch length registers used in calulating offsets etc.
%    \begin{macrocode}
\dim_new:N \l_coffin_tmpa_dim 
\dim_new:N \l_coffin_tmpb_dim 
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\l_coffin_offset_x_dim,
%                \l_coffin_offset_y_dim
%                }
%    These next two are used to hold the offset between two coffins
%    when doing alignment (measuring the distance between the two reference
%    points of the two boxes).
%    \begin{macrocode}
\dim_new:N \l_coffin_offset_x_dim 
\dim_new:N \l_coffin_offset_y_dim 
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\l_coffin_tmpa_tl,
%                \l_coffin_tmpb_tl,
%                \l_coffin_tmpc_tl}
%    A few scratch token list registers used in many places.
%    \begin{macrocode}
\tl_new:N \l_coffin_tmpa_tl 
\tl_new:N \l_coffin_tmpb_tl 
\tl_new:N \l_coffin_tmpc_tl 
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\l_coffin_pole_tl}
%    Token list variable to exclusively hold a retrieved pole value (for more
%    than just a very short time).
%    \begin{macrocode}
\tl_new:N \l_coffin_pole_tl
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\l_coffin_align_coordinates_tl}
%    Token list variable in which we built up the two coordinate pairs that we
%    used in alignment.
%    \begin{macrocode}
\tl_new:N \l_coffin_align_coordinates_tl
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\_coffin_eval_pole_value:N}
%    A temporary command that is redefined on the fly to resolve pole values
%    that contain |##1| denoting the current coffin, e.g., |\box_wd:N ##1|.
%    \begin{macrocode}
\cs_new:Npn \_coffin_eval_pole_value:N #1 {}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
%
%
% \subsection{The default data structure for coffins}
%
%
%  \begin{macro}{\c_coffin_default_poles_prop}
%    This  property lists holds the default set of ``natural'' poles, i.e.,
%    those that can be defined just through information about the box
%    dimensions. The poles that relate to top and bottom baseline in a
%    vertical box gets their correct value when a coffin is filled via a coffin
%    operation like |\vcoffin_set:Nn| ---for now they are only added as
%    alternate names for \TeX's box reference point.
%
%    We declare the property list as aconstant as it is supposed to stay
%    unchanged once filled with data.
%    \begin{macrocode}
\prop_new:N   \c_coffin_default_poles_prop
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_put:Nnn \c_coffin_default_poles_prop {l} {{0pt} {0pt}         {0pt}{1pt}}
\prop_put:Nnn \c_coffin_default_poles_prop {hc}{{.5\box_wd:N#1}{0pt}{0pt}{1pt}}
\prop_put:Nnn \c_coffin_default_poles_prop {r} {{\box_wd:N#1}{0pt}  {0pt}{1pt}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\prop_put:Nnn \c_coffin_default_poles_prop {t} {{0pt}{\box_ht:N#1}  {1pt}{0pt}}
\prop_put:Nnn \c_coffin_default_poles_prop {vc}
                               {{0pt}{(\box_ht:N#1-\box_dp:N#1)/2}  {1pt}{0pt}}
\prop_put:Nnn \c_coffin_default_poles_prop {b} {{0pt}{-\box_dp:N#1} {1pt}{0pt}}
%    \end{macrocode}
%    
%    The horizontal position of the coffin reference point (i.e., its baseline)
%    is denoted by the code \texttt{H}. The codes \texttt{B} for bottom
%    baseline and \texttt{T} top baseline are added for vertical
%    coffins. Initially they are set to the same value, i.e., zero.
%    \begin{macrocode}
\prop_put:Nnn \c_coffin_default_poles_prop {H} {{0pt}{0pt} {1pt}{0pt}}
\prop_put:Nnn \c_coffin_default_poles_prop {B} {{0pt}{0pt} {1pt}{0pt}}
\prop_put:Nnn \c_coffin_default_poles_prop {T} {{0pt}{0pt} {1pt}{0pt}}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_gadd_structure:N}
%    
%    As the coffin data structure is supposed to be a local structure this
%    command should only be used when turning an ordinary box into a
%    coffin. There it is needed as the property lists themselves are globally
%    allocated.
%    \begin{macrocode}
\cs_new:Npn \coffin_gadd_structure:N #1 {
%    \end{macrocode}
%    
%    \begin{macrocode}
   \prop_new:c {l_coffin_poles_ \tex_number:D #1 _prop}
%    \end{macrocode}
%    We use a global assignments here as the allocation is also global.
%    \begin{macrocode}
   \prop_gset_eq:cN {l_coffin_poles_ \tex_number:D #1 _prop}
                    \c_coffin_default_poles_prop
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
% \subsection{Making coffins}
%
%
%
%  \begin{macro}{\coffin_new:N}
%    Declare a new coffin (which is a box and two property lists holding
%    information about the horizontal and vertical poles. Initially we use the
%    natural default poles.
%    \begin{macrocode}
\cs_new:Npn \coffin_new:N #1 {
   \box_new:N #1
   \coffin_gadd_structure:N #1
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_add_struture_if_needed:N}
%
%    Check if a box already has a coffin support data structure and if not add
%    it. Thus, this command turns an ordinary box into a coffin.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_add_struture_if_needed:N #1   { 
%    \end{macrocode}
%    A box is a coffin if it has the property lists for poles defined. If not we
%    define it assing it the default poles.
%    \begin{macrocode}
  \cs_if_free:cT {l_coffin_poles_ \tex_number:D #1 _prop}
                 { \coffin_gadd_structure:N #1 }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_add_or_reset_structure:N}
%
%    This command sets all poles of a box to the default poles. It should
%    be used whenever coffin (or box) is about to receive new content. After
%    all, poles from a previous coffin life should vanish at that point.
%
%    Works on boxes without being already coffins.
%    \begin{macrocode}
\cs_new:Npn \coffin_add_or_reset_structure:N #1   { 
%    \end{macrocode}
%    A box is a coffin if it has the property list for poles defined. If not we
%    define it assing it the default poles.
%    \begin{macrocode}
  \cs_if_free:cTF {l_coffin_poles_ \tex_number:D #1 _prop}
    {  \coffin_gadd_structure:N #1  }
%    \end{macrocode}
%    But if the data structure already exists (i.e., the normal case) we do
%    the setting locally.
%    \begin{macrocode}
    { \coffin_reset_structure:N #1 }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
% \subsection{Getting and setting poles}
%
% \subsubsection{Setting all poles}
%
%
%  \begin{macro}{\coffin_set_eq_structure:NN}
%    Set all poles of one coffin to the be the poles of another coffin.
%    \begin{macrocode}
\cs_new:Npn \coffin_set_eq_structure:NN #1#2 {
    \prop_set_eq:cc {l_coffin_poles_ \tex_number:D #1 _prop}
                    {l_coffin_poles_ \tex_number:D #2 _prop}
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\coffin_reset_structure:N}
%    Set all poles of one coffin to the default set of poles stored in
%    two property list constants.
%    \begin{macrocode}
\cs_new:Npn \coffin_reset_structure:N #1 {
    \prop_set_eq:cN {l_coffin_poles_ \tex_number:D #1 _prop}
                    \c_coffin_default_poles_prop
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
% \subsubsection{Setting a single pole}
%
%  \begin{macro}{\coffin_set_pole_coordinates:Nnn,
%                \coffin_set_pole_coordinates:NnV,
%                \coffin_set_pole_coordinates:NVV}
%   
%    This command sets the values for one pole.
% 
%    For speed reasons this command doesn't check if this is really a coffin,
%    i.e., has the pole property list being set up. For a slower but safe
%    version in user-level commands use |\coffin_set_pole_safe:Nnnn|.
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference to coffin
%    \Argitem{2} pole name
%    \Argitem{3} pole coordinates / formula
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_set_pole_coordinates:Nnn #1#2#3 {
%<*debug>
    \cs_display_args:Nnnn\coffin_set_pole_coordinates:Nnn {#1}{#2}{#3}
%</debug>
    \prop_put:cnn {l_coffin_poles_ \tex_number:D #1 _prop}{#2}{#3}
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_generate_variant:Nn \coffin_set_pole_coordinates:Nnn { NnV, NVV }
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\coffin_set_pole_safe:Nnnn}
%    This command provides a safe way to add or update a pole of some
%    coffin. In the pole values the commands |\width|, |\height|, and
%    |\depth| can be used to refer to the coffin dimensions.
%
%    The way it is now it is kind of a user function where the pole direction
%    is given as |h| or |v| to ease input.
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference to coffin
%    \Argitem{2} pole direction (h or v)
%    \Argitem{3} pole name
%    \Argitem{4} pole coordinate / formula
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn  \coffin_set_pole_safe:Nnnn #1#2#3#4 {
%    \end{macrocode}
%    If the command is used on a box without pole property, add it first.
%    \begin{macrocode}
  \coffin_add_struture_if_needed:N #1 
%    \end{macrocode}
%    Provide definitions for |\width| etc.\ for use in  the
%    coordinates.
%
%    Potential issue: this currently adds the box register, e.g., 
% |\box_wd:N \aaa| 
%    and not something like a more generic |\box_wd:N ##1|. So at least
%    something like copying coffins wouldn't quite work. So it might be better
%    to use |##1| instead.\footnote{Issue?}
%    \begin{macrocode}
  \cs_set:Npn\width{\box_wd:N#1}
  \cs_set:Npn\height{\box_ht:N#1}
  \cs_set:Npn\depth{\box_dp:N#1}
%    \end{macrocode}
%    
%    Potential issue: as we have no control over the data passed to us as
%    coordinates using full expansion isn't really the best
%    solution.\footnote{Issue? Needs probably changing!}
%    \begin{macrocode}
  \tl_if_eq:nnTF {#2}{h}
     { \tl_set:Nx \l_coffin_pole_tl { {0pt}{#4} {1pt}{0pt} } } 
     { \tl_set:Nx \l_coffin_pole_tl { {#4}{0pt} {0pt}{1pt} } } 
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*trace>
\typeout{set:~ \string#1(#2:#3)=\l_coffin_pole_tl}
%</trace>
%    \end{macrocode}
%    Update or add the pole:
%    \begin{macrocode}
  \coffin_set_pole_coordinates:NnV #1 {#3} \l_coffin_pole_tl
%    \end{macrocode}
%    This preserves some kind of invariant:
%    \begin{macrocode}
  \cs_undefine:N \width
  \cs_undefine:N \height
  \cs_undefine:N \depth
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_adjust_pole_safe:Nnnn,
%                \_coffin_adjust_pole_safe:nnnnnn}
%    
%    This command provides a safe way to update a pole of some coffin
%    relative to its current poision. In the pole values the commands
%    |\width|, |\height|, and |\depth| can be used to refer to the coffin
%    dimensions.
%
%    If the pole doesn't exist an error is signalled and the box reference
%    point will be used.
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference to coffin
%    \Argitem{2} pole direction (h or v)
%    \Argitem{3} pole name
%    \Argitem{4} pole coordinate / formula
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_adjust_pole_safe:Nnnn #1#2#3#4  {
%<*debug>
   \cs_display_args:Nnnnn \coffin_adjust_pole_safe:Nnnn {#1}{#2}{#3}{#4}
%</debug>
%    \end{macrocode}
%    If the command is used on a box without pole property, add it first.
%    \begin{macrocode}
  \coffin_add_struture_if_needed:N #1
%    \end{macrocode}
%    
%    \begin{macrocode}
  \cs_set:Npn\width {\box_wd:N#1}
  \cs_set:Npn\height{\box_ht:N#1}
  \cs_set:Npn\depth {\box_dp:N#1}
%    \end{macrocode}
%    Retrieve the pole coordinate and if non-existant signal an error. We do this on
%    foot here instead of using |\coffin_get_pole_coordinates:NnN| as we are interested
%    in the ``raw'' pole values.
%    \begin{macrocode}
  \prop_get:cnN {l_coffin_poles_ \tex_number:D #1 _prop} {#3} \l_coffin_pole_tl
  \quark_if_no_value:NT \l_coffin_pole_tl
     {
      \typeout{ERROR:~\tl_to_str:n{#1(#2:#3)}~ not~ set}
      \ERROR_pole_not_set
      \tl_set:Nn \l_coffin_pole_tl {{0pt}{0pt}{0pt}{1pt}}
     }
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*trace>
  \typeout{adjust:~ \string#1(#2,#3)~=~\l_coffin_pole_tl
           \space\space with~ \space (#4) }
%</trace>
%    \end{macrocode}
%    |\l_coffin_pole_tl| now contains four brace groups and we have to update
%    the right one depending on |#2| being |h| or |v|. We do this in a help
%    command after expanding |\l_coffin_pole_tl| so that the help sees six
%    arguments. 
%    \begin{macrocode}
   \exp_after:wN \_coffin_adjust_pole_safe:nnnnnn \l_coffin_pole_tl {#2}{#4}
%    \end{macrocode}
%    \ldots and then put it back:
%    \begin{macrocode}
   \coffin_set_pole_coordinates:NnV #1 {#3} \l_coffin_pole_tl
%    \end{macrocode}
%    
%    This preserves some kind of invariant:
%    \begin{macrocode}
  \cs_undefine:N \width
  \cs_undefine:N \height
  \cs_undefine:N \depth
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_new:Npn \_coffin_adjust_pole_safe:nnnnnn #1#2#3#4#5#6 {
   \tl_if_eq:nnTF {#5}{h}
%    \end{macrocode}
%    If a horizontal pole we update the y-coordinate, otherwise the
%    x-coordinate, the rest stays the same.
%    \begin{macrocode}
     { \tl_set:Nn \l_coffin_pole_tl { {#1}{#2 +(#6)}{#3}{#4} } }
     { \tl_set:Nn \l_coffin_pole_tl { {#1 +(#6)}{#2}{#3}{#4} } }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
% \subsubsection{Retrieving a pole value}
%
%
%  \begin{macro}{\coffin_get_pole_coordinates:NnN}
%    This command retrieves a pole value and stores it in a token list
%    variable given as forth argument. If the pole doesn't exist an error is
%    signaled and \verb=0pt= is returned.
%
%    The command can be used with boxes not having poles set up. In this
%    case the default poles are made available first.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference to coffin
%    \Argitem{2} pole name
%    \Argitem{3} token list variable to receive value
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_get_pole_coordinates:NnN #1#2#3 {
%<*debug>
   \cs_display_args:Nnnn \coffin_get_pole_coordinates:NnN {#1}{#2}{#3}
%</debug>
%    \end{macrocode}
%    First we ensure that the pole data structure is set up.
%    \begin{macrocode}
  \coffin_add_struture_if_needed:N #1
%    \end{macrocode}
%    Then we trieve the pole value.
%    \begin{macrocode}
  \prop_get:cnN {l_coffin_poles_ \tex_number:D #1 _prop} {#2} #3
%    \end{macrocode}
%    In case the pole name is unknown we will get a |\q_no_value| returned,
%    so we better distinguish this case.
%    \begin{macrocode}
  \quark_if_no_value:NTF #3
%    \end{macrocode}
%    If the pole was unknown we signal an error and use the box reference
%    point as a return value.
%    \begin{macrocode}
     {
      \typeout{ERROR:~\tl_to_str:n{#1(#2)}~ not~ set}
      \ERROR_pole_not_set
      \tl_set:Nn #3 {{0pt}{0pt}{0pt}{1pt}}
     }
%    \end{macrocode}
%    Otherwise the value is now stored in |#3|, but it may
%    contain a formula with dependencies to the coffin dimension (using |##1|
%    to refer to the coffin), so we need
%    to resolve those first. To do this we define the helper command
%    |\_coffin_eval_pole_value:N| with one argument and the pole value as
%    replacement text.\footnote{There must be a nicer way to set this up, right?}
%    \begin{macrocode}
     {
      \exp_after:wN
         \cs_set:Npn
      \exp_after:wN 
          \_coffin_eval_pole_value:N
      \exp_after:wN 
          ##
      \exp_after:wN
           1
      \exp_after:wN
          { #3 }
%    \end{macrocode}
%    Now we reset the value to make any box dimension dependencies explicit
%    (i.e., replace |##1| with a reference to the coffin name in |#1|).
%    \begin{macrocode}
      \tl_set:No #3 { \_coffin_eval_pole_value:N #1 }
     }
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*trace>
  \typeout {\string#1(#2) = #3}
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
%
% \subsection{Debugging and printing poles}
%
%
%
%  \begin{macro}{\coffin_show_structure:N}
%    Some simple tracing: show all poles defined for some coffin or box.
%    \begin{macrocode}
\cs_new:Npn \coffin_show_structure:N #1 {
  \typeout{Box~ sizes~ (#1):^^J
      \space\space ht=\dim_use:N \box_ht:N#1^^J
      \space\space dp=\dim_use:N \box_dp:N#1^^J
      \space\space wd=\dim_use:N \box_wd:N#1       }
  \typeout{Poles~ of~ coffin~ \token_to_str:N #1 (\tex_number:D #1):}
  \cs_if_free:cTF {l_coffin_poles_ \tex_number:D #1 _prop}
     { \typeout{---no~ poles---} }
     {
       \prop_display:c {l_coffin_poles_ \tex_number:D #1 _prop}
     }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\coffin_print_pole_values:Nn,
%                \_coffin_print_pole_values:Nnnnnnn}
%    Some simple attempt at pretty printing \ldots{} to be improved.
%    First argument is the box for which the poles should be printed and
%    second argument is a delimiter to be used after each pole, for example
%    |\\|.
%    \begin{macrocode}
\cs_new:Npn \coffin_print_pole_values:Nn #1#2 {
   \prop_map_inline:cn {l_coffin_poles_ \tex_number:D #1 _prop}
      {
        \_coffin_print_pole_values:Nnnnnnn #1  {##1} ##2 {#2}
      }
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_new:Npn \_coffin_print_pole_values:Nnnnnnn #1#2#3#4#5#6#7 {
    \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#3}
    \dim_set:Nn \l_coffin_tmpa_dim {\_coffin_eval_pole_value:N #1}
    \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#4}
    \dim_set:Nn \l_coffin_tmpb_dim {\_coffin_eval_pole_value:N #1}
%    \end{macrocode}
%    
%    \begin{macrocode}
    key(\token_to_str:N#2)=(\dim_use:N \l_coffin_tmpa_dim,
                            \dim_use:N \l_coffin_tmpb_dim, #5, #6)
    #7
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
%
% \subsection{Setting the content of a coffin}
%
%
%
%
%  \begin{macro}{\_latex_sbox:Nn}
%    Save away the original \LaTeX{} definition to make our life easier for now.
%    \begin{macrocode}
\cs_new_eq:NN \_latex_sbox:Nn \sbox
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\hcoffin_set:Nn}
%    
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} 
%    \Argitem{2} 
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_set:Npn \hcoffin_set:Nn #1 {
%    \end{macrocode}
%    Safeguard against using an ordinary box and reset the poles if the box
%    was previously used as a coffin:
%    \begin{macrocode}
   \coffin_add_or_reset_structure:N #1
%    \end{macrocode}
%    For now we simply call \LaTeX{}'s |\sbox| under a private name. This way
%    we can make |\sbox| point to |\hcoffin_set:Nn| if we wish to later.
%    \begin{macrocode}
   \_latex_sbox:Nn #1
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
%  \begin{macro}{\vcoffin_set:Nnn}
%    
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} 
%    \Argitem{2} 
%    \Argitem{3} 
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn\vcoffin_set:Nnn #1#2#3 {
%<*debug>
   \cs_display_args:Nnnn \vcoffin_set:Nnn {#1}{#2}{#3}
%</debug>
%    \end{macrocode}
%    Safeguard against using an ordinary box and reset the poles if the box
%    was previously used as a coffin:
%    \begin{macrocode}
   \coffin_add_or_reset_structure:N #1
%    \end{macrocode}
%    Set the content as a vertical box.\footnote{This will probably need
%    updating to properly support color etc etc.}
%    \begin{macrocode}
   \vbox_set:Nn #1 {\dim_set:Nn \hsize {#2}
                     #3
%                    \endgraf \showthe\prevgraf
                   }
%    \end{macrocode}
%    To calculate the top baseline we need to reset the box and measure its
%    new height:
%    \begin{macrocode}
   \vbox_set_top:Nn \l_coffin_tmp_box {\vbox_unpack:N #1}
   \dim_set:Nn \l_coffin_tmpa_dim 
               {\box_ht:N #1 - \box_ht:N \l_coffin_tmp_box  }
%    \end{macrocode}
%    We then use the new value to set up the \texttt{T} pole.
%    \begin{macrocode}
   \tl_set:Nx \l_coffin_tmpa_tl
              { {0pt}{\dim_use:N \l_coffin_tmpa_dim} {1pt}{0pt} }
   \coffin_set_pole_coordinates:NnV #1 {T} \l_coffin_tmpa_tl
%    \end{macrocode}
%    
%    The \texttt{B} pole is simpler, since it is the same as \texttt{H} and in
%    fact it should already be there in the default set.
%    \begin{macrocode}
%   \coffin_set_pole_coordinates:Nnn #1 {B} {{0pt}{0pt}{1pt}{0pt}}
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_set_eq:NN}
%    Copy the content of one coffin to the next. Both arguments are assumed to
%    be coffins, i.e., there is no checking.
%    \begin{macrocode}
\cs_new:Npn \coffin_set_eq:NN #1#2 {
    \box_set_eq:NN #1 #2
    \coffin_set_eq_structure:NN #1 #2
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\coffin_set_eq_clear:NN}
%    Move the content of one coffin to the next. Afterwards the box will be
%    void and the property list of poles are reset to the default list.
%    Both arguments are assumed to
%    be coffins, i.e., there is no checking.
%    \begin{macrocode}
\cs_new:Npn \coffin_set_eq_clear:NN #1#2 {
    \box_set_eq_clear:NN #1 #2
    \coffin_set_eq_structure:NN #1 #2
    \coffin_reset_structure:N #2
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
%
%
%
% \subsection{Aligning coffins}
%
%
%
%
%  \begin{macro}{\l_coffin_aligned_coffin}
%    This is a scratch coffin we use later to store intermediate results when
%    aligning coffins.
%    \begin{macrocode}
\coffin_new:N \l_coffin_aligned_coffin
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_align_boxes:nnnnNNnnN}
%
%    This helper command aligns two boxes (need not be coffins) given specific
%    specific alignment points (as offset from the normal reference point of
%    the box) and some x/y offset to use between the alignment points.
%
%    The bounding box of the whole construction is \ldots{} whatever it is
%    (height and depth are Ok, but all horizontal stuff is somewhat
%    arbitrary), thus this box register is not, typically, very useful without
%    further work on the horizontal positioning and size.  There are various
%    possibilities for these refinements, these are explored in the top-level
%    commands defined later on.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} x-offset box-A (can be a formula coming from a coffin
%                pole specification)
%    \Argitem{2} y-offset box-A (can be a formula)
%    \Argitem{3} x-offset box-B (can be a formula)
%    \Argitem{4} y-offset box-B (can be a formula)
%    \Argitem{5} box register reference for box-A (single token)
%    \Argitem{6} box register reference for box-B (single token)
%    \Argitem{7} x-offset between alignment points (can be a formula)
%    \Argitem{8} y-offset between alignment points (can be a formula)
%    \Argitem{9} box register reference for result box (single token)
%    \end{Arglist}
%    The result is stored in a new box (\#9) which is turned into a coffin and
%    add the original poles from box-A (with their formulas) available as
%    \texttt{\meta{pole}}. Other poles, referring to box-A and box-Bas
%    absolute coordinates (via \texttt{\meta{box-A}-\meta{pole}}) need to
%    wait until we know how the bounding box has been calculated.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_align_boxes:nnnnNNnnN #1#2 #3#4 #5#6 #7#8 #9 {
%<*trace>
   \cs_display_args:Nnnnnnnnnn \coffin_align_boxes:nnnnNNnnN 
                               {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}
%</trace>
%    \end{macrocode}
%    First calulate the final offset between the two box reference points used
%    by \TeX:
%    \begin{macrocode}
  \dim_set:Nn \l_coffin_offset_x_dim{(#1)+(#7)-(#3)}
  \dim_set:Nn \l_coffin_offset_y_dim{(#2)+(#8)-(#4)}
%    \end{macrocode}
%    Then put the aligned boes into the result box by\ldots
%    \begin{macrocode}
    \hbox_set:Nn #9 {
%    \end{macrocode}
%    \ldots first setting box-A and doing a backup by its width which brings
%    us back to the reference point of box-A.
%    \begin{macrocode}
      \box_use:N #5
      \tex_kern:D -\box_wd:N #5 
%    \end{macrocode}
%    Then move horizontally by the calulated x-offset and place box-B with its
%    reference point raised by the calulated y-offset. (The two horizontal
%    |\tex_kern:D| movements could be combined to save a bit space, but we
%    need the |\l_coffin_offset_x_dim| later again so we don't bother.
%    \begin{macrocode}
      \tex_kern:D \l_coffin_offset_x_dim
      \box_move_up:nn \l_coffin_offset_y_dim {\box_use:N #6 }
    }
%    \end{macrocode}
%    Final step is to turn the result box into a coffin with the right kind of
%    poles attached.
%
%    If the box is already a coffin we reset to default to get a clean state,
%    otherwise we add the defaults.
%    \begin{macrocode}
   \coffin_add_or_reset_structure:N #9
%    \end{macrocode}
%    What we can't yet do at this point is adding explicit poles that refer
%    back to the individual poles from box-A and box-B via
%    \texttt{\meta{box-B}-\meta{pole}}. This isn't possible, as we don't know
%    yet where the final reference point of the result box will lie as this
%    depends on they way we handle the bounding box later on. So we have have
%    to wait with this using the values of |\l_coffin_offset_x_dim| and
%    |\l_coffin_offset_y_dim| that we have calculated above. we will then also
%    recalculate \texttt{T} and \texttt{B} poles to denote the top and bottom
%    baseline positions.
%    \begin{macrocode}
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_align_two_coffins:NnnNnnnnN}
%    
%    This helper command alligns two coffins at their pole with a specific
%    offset between them and saves the result in a third coffin.
%    
%    Just like |\coffin_align_boxes:nnnnNNnnN| on which this is based the
%    bounding box is unusable without further correction.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \Argitem{9} target box register for saving
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_align_two_coffins:NnnNnnnnN #1#2#3#4#5#6#7#8#9 {
%<*debug>
   \cs_display_args:Nnnnnnnnnn \coffin_align_two_coffins:NnnNnnnnN
                               {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}
%</debug>
%    \end{macrocode}
%    First we retrieve the pole coordinates from the two poles of the first
%    box.
%    \begin{macrocode}
  \coffin_get_pole_coordinates:NnN #1{#3}\l_coffin_tmpa_tl
  \coffin_get_pole_coordinates:NnN #1{#2}\l_coffin_tmpb_tl
%    \end{macrocode}
%    Then we calculate the intersection and write the result into
%    |\l_coffin_align_coordinates_tl|. The coordinates of interesection is
%    later used to align the box.
%    \begin{macrocode}
  \coffin_calculate_intersection:NN \l_coffin_tmpa_tl \l_coffin_tmpb_tl
  \tl_set:Nx \l_coffin_align_coordinates_tl  
             { { \dim_use:N \l_coffin_intersect_x_dim }
               { \dim_use:N \l_coffin_intersect_y_dim } }
%    \end{macrocode}
%    Then we do the same with the second box.
%    \begin{macrocode}
  \coffin_get_pole_coordinates:NnN #4{#6}\l_coffin_tmpc_tl
  \coffin_get_pole_coordinates:NnN #4{#5}\l_coffin_tmpd_tl
  \coffin_calculate_intersection:NN\l_coffin_tmpc_tl \l_coffin_tmpd_tl
%    \end{macrocode}
%    But here we append the result to |\l_coffin_align_coordinates_tl|, thus
%    it is now holding four brace groups with the coordinates of both
%    intersections.
%    \begin{macrocode}
  \tl_put_right:Nx \l_coffin_align_coordinates_tl  
                   { { \dim_use:N \l_coffin_intersect_x_dim }
                     { \dim_use:N \l_coffin_intersect_y_dim } }

%    \end{macrocode}
%    By expanding |\l_coffin_align_coordinates_tl| prior to calling
%    |\coffin_align_boxes:nnnnNNnnN| this command will then see all
%    coordinates as its first four arguments:
%    \begin{macrocode}
  \exp_after:wN \coffin_align_boxes:nnnnNNnnN 
                      \l_coffin_align_coordinates_tl 
                      #1 #4 {#7} {#8} #9
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_align_confine_save:NnnNnnnnN}
%    
%    This commmand aligns two coffins at their poles with a certain offset
%    inbetween. The result is stored in a third coffin (with poles
%    from both coffins added as \texttt{\meta{box}-\meta{pole}}). Note that
%    the arguments are ordered differently compared to the internal helper
%    commands for coffin alignment
%
%    The resulting bounding box is clipped to the dimensions of the first
%    coffin (box-A), that is the second coffin may overlap surrounding text.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \Argitem{9} target box register for saving
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn\coffin_align_confine_save:NnnNnnnnN #1#2#3#4#5#6#7#8#9{%
%    \end{macrocode}
%    First we call the helper command to align the coffins.
%    \begin{macrocode}
  \coffin_align_two_coffins:NnnNnnnnN #1 {#2}{#3}  #4 {#5}{#6} {#7}{#8} #9 
%    \end{macrocode}
%    Then we correct the bounding box data, restricting it to the values from
%    box-A.\footnote{Issue: l3box doesn't have commands for setting box
%    dimensions, so for now we go low-level}.
%    \begin{macrocode}
  \box_ht:N #9 \box_ht:N #1
  \box_wd:N #9 \box_wd:N #1
  \box_dp:N #9 \box_dp:N #1
%    \end{macrocode}
%    Finally we also make the poles from the original coffins available: they
%    can be accessed using ``\meta{box-reference}-\meta{pole}'', for
%    example, |\aaa-T| if |\aaa| is the reference for one of the
%    coffins.
%
%    For this we have to shift the pole values by the offset used in the
%    alignment (stored by |\coffin_align_two_coffins:NnnnNnN| in two dimen
%    variables). We also change any formula used into real values, so that we
%    can free up the coffin content afterwards.
%
%    The first box doesn't have any offset.
%    \begin{macrocode}
   \coffin_save_pole_values_with_offset:NnnN #1 {0pt}{0pt} #9
%    \end{macrocode}
%    But the second one does:
%    \begin{macrocode}
   \coffin_save_pole_values_with_offset:NnnN #4 
                                             \l_coffin_offset_x_dim
                                             \l_coffin_offset_y_dim
                                             #9
%    \end{macrocode}
%    At this point we can now recalulate \texttt{T} and \texttt{B} poles for
%    the result box.
%    \begin{macrocode}
   \coffin_update_T_B_poles:NNN #1 #4 #9
%    \end{macrocode}
%    At this point  we could free up the coffin/box content of box-B (not done
%    yet).\footnote{Issue?}
%    \begin{macrocode}
%    \end{macrocode}
%    Finally show the resulting poles when tracing:
%    \begin{macrocode}
%<*trace>
   \coffin_show_structure:N #9
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\coffin_align_save:NnnNnnnnN}
%    
%    This commmand aligns two coffins at their poles with a certain offset
%    inbetween. The result is stored in a third coffin (with poles
%    from both coffins added as \texttt{\meta{box}-\meta{pole}}). Note that
%    the arguments are ordered differently compared to the internal helper
%    commands for coffin alignment
%
%    The resulting bounding box is clipped to the dimensions of the first
%    coffin (box-A), that is the second coffin may overlap surrounding text.
%
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \Argitem{9} target box register for saving
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn\coffin_align_save:NnnNnnnnN #1#2#3#4#5#6#7#8#9{
%<*debug>
   \cs_display_args:Nnnnnnnnnn \coffin_align_save:NnnNnnnnN
                               {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}
%</debug>
%    \end{macrocode}
%    First we call the helper command to align the coffins.
%    \begin{macrocode}
  \coffin_align_two_coffins:NnnNnnnnN #1 {#2}{#3}  #4 {#5}{#6} {#7}{#8} #9 
%    \end{macrocode}
%    Then we have to do a bit more than just changing the box dimensions: we
%    actually have to build a new box with additional kerns to the left and/or
%    right of, at least if we have to move the
%    reference point of the result box to the left of the reference point of
%    box-A (which happens if box-B sticks out to the left of box-A).
%    \begin{macrocode}
   \hbox_set:Nn #9 {
    \dim_compare:nNnT \l_coffin_offset_x_dim < \c_zero_dim
%    \end{macrocode}
%    Okay, so if |\l_coffin_offset_x_dim| is negative the reference point of
%    box-B is to the left of box-A. Thus by starting our box with a horizontal
%    shift of |-\l_coffin_offset_x_dim| we  effectively start with the
%    reference point at the left edge.
%    \begin{macrocode}
         { \tex_kern:D -\l_coffin_offset_x_dim }
%    \end{macrocode}
%    Then we unpack the box holding the aligned coffins (we can use unpacking
%    as that will not change the sizes but avoids one unnecessay box level).
%    \begin{macrocode}
    \hbox_unpack_clear:N #9
%    \end{macrocode}
%    To get the right side of the box correct we also may have to add some
%    kern. Right now our box ends at the right side of box-B. Thus, if box-A
%    extends further to the right we have to account for that. This can be
%    achieved by adding to |\l_coffin_offset_x_dim| the width of box-B (which
%    gives us the horizontal size of box |#9|) and substract the width of
%    box-A. If the result is negative this means that box-A sticks out  to the
%    right by that amount. Therefore we have to add a corresponding kern in
%    that case. Deep breath!
%    \begin{macrocode}
    \dim_set:Nn \l_coffin_tmpa_dim { \l_coffin_offset_x_dim 
                                      + \box_wd:N #4 - \box_wd:N #1 }
    \dim_compare:nNnT \l_coffin_tmpa_dim < \c_zero_dim
                      { \tex_kern:D -\l_coffin_tmpa_dim }
  }
%    \end{macrocode}
%    What remains to be done is to add the explicit poles to the inner
%    boxes. Now that we know whether or not the reference point of the result
%    box got moved or not we are ready to go. We just need to check again if
%    |\l_coffin_offset_x_dim| is negative. (It isn't possible to use the test
%    earlier inside the box construction as that would mean the pole updates
%    would only live until the end of the box contruction.)
%    \begin{macrocode}
  \dim_compare:nNnTF \l_coffin_offset_x_dim < \c_zero_dim
%    \end{macrocode}
%    Here the reference point got moved so we need to shift things to the
%    left:
%    \begin{macrocode}
         { 
           \coffin_save_pole_values_with_offset:NnnN
                  #1 {-\l_coffin_offset_x_dim} {0pt} #9
           \coffin_save_pole_values_with_offset:NnnN
                  #4 {0pt} \l_coffin_offset_y_dim    #9
         }
%    \end{macrocode}
%    And if the reference point for the result box doesn't change then we have
%    the following offsets to use:
%    \begin{macrocode}
         {
           \coffin_save_pole_values_with_offset:NnnN
                  #1 {0pt}{0pt} #9
           \coffin_save_pole_values_with_offset:NnnN
                  #4 \l_coffin_offset_x_dim
                     \l_coffin_offset_y_dim #9
         }
%    \end{macrocode}
%    At this point we can now recalulate \texttt{T} and \texttt{B} poles for
%    the result box.
%    \begin{macrocode}
   \coffin_update_T_B_poles:NNN #1 #4 #9
%    \end{macrocode}
%    At this point  we could free up the coffin/box content of box-B (not done
%    yet).\footnote{Issue?}
%    \begin{macrocode}
%    \end{macrocode}
%    Finally show the resulting poles when tracing:
%    \begin{macrocode}
%<*trace>
   \coffin_show_structure:N #9
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_save_pole_values_with_offset:NnnN}
%
%    This command takes the poles from box-A, calculates their numerical
%    value, offsets them by some x/y-offset and then writes a new pole with
%    the name \texttt{\meta{box-A}-\meta{pole}} and stores it as a pole
%    for box-B.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box-A reference used as source to build new pole list
%    \Argitem{2} x-offset
%    \Argitem{3} y-offset
%    \Argitem{4} box-B reference receiving updated poles
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_save_pole_values_with_offset:NnnN #1 #2#3 #4 {
%<*debug>
   \cs_display_args:Nnnnn \coffin_save_pole_values_with_offset:NnnN
                         {#1}{#2}{#3}{#4}
%</debug>
%    \end{macrocode}
%    We map some inline code over the pole property lists of box-A to
%    retrieve the poles and calculate the new ones.
%    \begin{macrocode}
   \prop_map_inline:cn {l_coffin_poles_ \tex_number:D #1 _prop}
      {
%    \end{macrocode}
%    The actual work is done by a helper command which receives all necessary
%    values as separate arguments. Horizontal poles get the y-offset added
%    (|#3|). 
%    \begin{macrocode}
        \coffin_save_pole_values_with_offset:NnnnnnnnN #1 {##1} ##2 {#2}{#3} #4
      }
%    \end{macrocode}
%    Some debugging code to verify the results:
%    \begin{macrocode}
%<*debug>
    \coffin_show_structure:N #4
%</debug>
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_save_pole_values_with_offset:NnnnnnnnN}
%    
%    This command takes explicit values for a single pole from box-A,
%    calculates the numerical 
%    values, offsets them by the x/y-offset and then writes a new pole with
%    the name \texttt{\meta{box-A}-\meta{pole}} stored  as a pole
%    for box-B.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box-A reference used as source to build new pole list
%    \Argitem{2} pole direction
%    \Argitem{3} pole name
%    \Argitem{4} pole value
%    \Argitem{5} extra offset
%    \Argitem{6} box-B reference receiving updated pole
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_save_pole_values_with_offset:NnnnnnnnN #1#2 #3#4#5#6 #7#8#9 {
%<*debug>
   \cs_display_args:Nnnnnnnnnn \coffin_save_pole_values_with_offset:NnnnnnnnN
                               {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}
%</debug>
%    \end{macrocode}
%    The value of the pole might involve a formula (such as |\box_wd:N ##1|), so
%    to calculate the numerical value we have to resolve this. This is done by
%    defining a scratch command with one argument (receiving the box-A) and
%    the pole ``formula'' as replacement text---if that replacement text is
%    already numerical, no harm will be done.
%    \begin{macrocode}
    \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#3}
%    \end{macrocode}
%    We then calculate the new absolute position for the pole as follows:
%    \begin{macrocode}
    \dim_set:Nn \l_coffin_tmpa_dim {\_coffin_eval_pole_value:N #1 + #7}
%    \end{macrocode}
%    Thus |\l_coffin_tmpa_dim| now hold the x-value including the offset.
%
%    In the same way we store in |\l_coffin_tmpb_dim| the new y-value:
%    \begin{macrocode}
    \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#4}
    \dim_set:Nn \l_coffin_tmpb_dim {\_coffin_eval_pole_value:N #1 + #8}
%    \end{macrocode}
%    In order to put the new values back into the pole, we need to combine
%    them with the direction vector |#5,#6| which stays unchanged.
%    \begin{macrocode}
    \tl_set:Nx \l_coffin_pole_tl { {\dim_use:N \l_coffin_tmpa_dim }
                                   {\dim_use:N \l_coffin_tmpb_dim }
                                   {#5}{#6}
                                 }
%    \end{macrocode}
%    To build the new pole name we have to distinuish two cases: a) this is
%    a native pole of box-A, either one of the default poles or one
%    explicitly build by the user and b) it is a derived pole which was
%    added to box-A as the result of aligning two coffins earlier.
%
%    In the latter case the name will be of the form
%    \texttt{\meta{somebox}-\meta{pole}} and in this cases we simply leave it
%    alone, otherwise we build the name as
%    \texttt{\meta{box-A}-\meta{pole}}. 
%
%    Consequence of this is that user defined pole names better not contain
%    a ``\texttt{-}'' and that one can't align the same coffin several times
%    to some other coffin without loosing the poles (as the second alignment
%    will overwrite the poles from the first). However, this approach makes
%    poles from inner coffins in alignment operations available later on
%    without any dependency on the order the alignment happened. If we would
%    unconditionally prepend \texttt{\meta{box-A}-} all poles would be
%    uniquely identifiable, but their name would depend on the order the
%    alignment happend which would be a very bad idea.
%    \begin{macrocode}
    \tl_if_in:nnTF {#2} {-} 
          { \tl_set:Nx \l_coffin_tmpa_tl { #2 }     }
          { \tl_set:Nx \l_coffin_tmpa_tl { #1-#2 }  }
%    \end{macrocode}
%    Now we are ready to put the new pole into box-B's property list.
%    \begin{macrocode}
    \coffin_set_pole_coordinates:NVV #9 
                  \l_coffin_tmpa_tl \l_coffin_pole_tl
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\coffin_update_T_B_poles:NNN}
%
%    This command calulates new values for \texttt{T} and \texttt{B} poles for
%    the result box by comparing the corresponding values the the coffins used
%    in an alignment and choosing the larger (or smaller) value, respectively.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference to box-A
%    \Argitem{2} reference to box-B
%    \Argitem{3} reference to result box
%    \end{Arglist}
%
%    The assumption is that the result box already contains the poles from
%    box-A and box-B in the form \texttt{\meta{box}-\meta{pole}}.
%    
%    \begin{macrocode}
\cs_new:Npn \coffin_update_T_B_poles:NNN #1#2#3 {
%    \end{macrocode}
%    Get the \texttt{T} poles for box-A and box-B out of the result box:
%    \begin{macrocode}
    \coffin_get_pole_coordinates:NnN #3 {#1-T} \l_coffin_tmpa_tl
    \coffin_get_pole_coordinates:NnN #3 {#2-T} \l_coffin_tmpb_tl

    \exp_after:wN \exp_after:wN \exp_after:wN
    \coffin_update_T_pole:nnnnnnnnN
            \exp_after:wN \l_coffin_tmpa_tl \l_coffin_tmpb_tl #3

    \coffin_get_pole_coordinates:NnN #3 {#1-B} \l_coffin_tmpa_tl
    \coffin_get_pole_coordinates:NnN #3 {#2-B} \l_coffin_tmpb_tl

    \exp_after:wN \exp_after:wN \exp_after:wN
    \coffin_update_B_pole:nnnnnnnnN
            \exp_after:wN \l_coffin_tmpa_tl \l_coffin_tmpb_tl #3
}

\cs_new:Npn \coffin_update_T_pole:nnnnnnnnN  #1#2#3#4#5#6#7#8#9 {
%    \end{macrocode}
%    Compare the values and if the one from box-B is larger use its value,
%    otherwise the one from box-A.
%    
%    Note that this gets rather arbitrary if the \texttt{T} poles are are no
%    longer horizontal. That could be checked and acted upon if deemed
%    necessary.\footnote{Issue?}
%    
%    \begin{macrocode}
    \dim_compare:nNnTF {#2} < {#6}
       { \tl_set:Nn \l_coffin_pole_tl { {0pt}{#6} {1pt}{0pt} } }
       { \tl_set:Nn \l_coffin_pole_tl { {0pt}{#2} {1pt}{0pt} } }
%    \end{macrocode}
%    Then record the new \texttt{T} pole value in the result box.
%    \begin{macrocode}
    \coffin_set_pole_coordinates:NnV #9 T \l_coffin_pole_tl 
}

\cs_new:Npn \coffin_update_B_pole:nnnnnnnnN  #1#2#3#4#5#6#7#8#9 {
%    \end{macrocode}
%    Same operation for \texttt{B} except that for the bottom baseline we have
%    to use the value from box-B if it is smaller.
%    \begin{macrocode}
    \dim_compare:nNnTF {#2} > {#6}
       { \tl_set:Nn \l_coffin_pole_tl { {0pt}{#6} {1pt}{0pt} } }
       { \tl_set:Nn \l_coffin_pole_tl { {0pt}{#2} {1pt}{0pt} } }
    \coffin_set_pole_coordinates:NnV #9 B \l_coffin_pole_tl 
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\coffin_align:NnNnnn}
%    
%    This commmand aligns two coffins at their poles with a certain offset
%    inbetween. The result is stored again in the first coffin (with poles
%    from both coffins added as \texttt{\meta{box}-\meta{pole}}).
%
%    The resulting bounding box is the enclosing box around both coffins.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \end{Arglist}
%
%    Note that the arguments are ordered differently compared to the internal
%    helper commands for coffin alignment.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_align:NnnNnnnn #1#2#3#4#5#6#7#8{
%<*debug>
   \cs_display_args:Nnnnnnnnn \coffin_align:NnnNnnnn {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}
%</debug>
%    \end{macrocode}
%    First we align the coffins and save them in a scratch coffin. This time
%    the version that doesn't confine the bounding box is being used.
%    \begin{macrocode}
  \coffin_align_save:NnnNnnnnN  #1{#2}{#3} #4{#5}{#6} {#7}{#8}
                               \l_coffin_aligned_coffin 
%    \end{macrocode}
%    Then we copy the scratch coffin back into box-A:
%    \begin{macrocode}
  \coffin_set_eq_clear:NN #1 \l_coffin_aligned_coffin
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_align_confine:NnnNnnnn}
%    
%    This commmand aligns two coffins at their poles with a certain offset
%    inbetween. The result is stored again in the first coffin (with poles
%    from both coffins added as \texttt{\meta{box}-\meta{pole}}).
%
%    The resulting bounding box is clipped to the dimensions of the first
%    coffin (box-A).
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \end{Arglist}
%
%    Note that the arguments are ordered differently compared to the internal
%    helper commands for coffin alignment.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_align_confine:NnnNnnnn #1 #2#3 #4 #5#6 #7#8{
%    \end{macrocode}
%    First we align the coffins and save them in a scratch coffin.
%    \begin{macrocode}
    \coffin_align_confine_save:NnnNnnnnN #1{#2}{#3} #4{#5}{#6} {#7}{#8}
                                         \l_coffin_aligned_coffin
%    \end{macrocode}
%    Then we copy the scratch coffin back into box-A:
%    \begin{macrocode}
  \coffin_set_eq_clear:NN #1 \l_coffin_aligned_coffin
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
% \subsection{Typesetting coffins}
%
%
%  \begin{macro}{\c_empty_coffin}
%    A permanently empty hbox coffin used in placing other coffins.
%    \begin{macrocode}
\coffin_new:N \c_empty_h_coffin
\hbox_set:Nn  \c_empty_h_coffin {} 
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\coffin_typeset:Nnnnn}
%    This command typeset a coffin aligning one pole of it with the current reference
%    point on the page with a certain x/y-offset. 
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference (single token)
%    \Argitem{2} h-pole of box to align with
%    \Argitem{3} v-pole of box to align with
%    \Argitem{4} x-offset to handle
%    \Argitem{5} y-offset to handle
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn\coffin_typeset:Nnnnn #1#2#3#4#5{
%    \end{macrocode}
%    We implement this by aligning the box with an permanently empty coffin
%    which is of zero size in all directions, i.e., all its reference points
%    would be at the current reference point on the page. That reduces the
%    problem to one of the commands already implemented:
%    \begin{macrocode}
  \coffin_align_save:NnnNnnnnN \c_empty_h_coffin {H}{l} #1{#2}{#3} {#4}{#5} 
                               \l_coffin_aligned_coffin 
%    \end{macrocode}
%    Of course this command does a bit too much: |\l_coffin_aligned_coffin|
%    will now unnecessarily contain all kind of poles which are never going
%    be to be used since we typeset the beast directly.
%    \begin{macrocode}
  \box_use_clear:N \l_coffin_aligned_coffin
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_typeset_confine:Nnnnn}
%    
%    This command typeset a coffin aligning one pole of it with the current reference
%    point on the page with a certain x/y-offset. 
%    
%    The reference point will not be changed so all material will overlap with
%    surrounding text.
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference (single token)
%    \Argitem{2} h-pole of box to align with
%    \Argitem{3} v-pole of box to align with
%    \Argitem{4} x-offset to handle
%    \Argitem{5} y-offset to handle
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_typeset_confine:Nnnnn #1#2#3#4#5 {
    \coffin_align_confine_save:NnnNnnnnN \c_empty_h_coffin  {H}{l} 
                                    #1{#2}{#3} 
                                    {#4}{#5} 
                                    \l_coffin_aligned_coffin 
  \box_use_clear:N \l_coffin_aligned_coffin
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\l_coffin_intersect_x_dim,
%                \l_coffin_intersect_y_dim}
%    X- and y-coordinates of the intersection between two poles as calculated
%    by |\coffin_calculate_intersection:NN|.
%    \begin{macrocode}
\dim_new:N \l_coffin_intersect_x_dim
\dim_new:N \l_coffin_intersect_y_dim
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\l_coffin_x_dir_A_int,
%                \l_coffin_y_dir_A_int,
%                \l_coffin_y_dir_B_int,
%                \l_coffin_y_dir_B_int}
%    Pole direction vectors are stored with dimension (but when calculating
%    interesections we need some of them unitless to avoid the need for using l3calc.
%    \begin{macrocode}
\int_new:N \l_coffin_x_dir_A_int
\int_new:N \l_coffin_y_dir_A_int
\int_new:N \l_coffin_x_dir_B_int
\int_new:N \l_coffin_y_dir_B_int
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\coffin_calculate_intersection:NN,
%                \coffin_calculate_intersection:nnnnnnnn}
%    
%    The comand takes two token list variables as argument which are expected
%    to contain four brace groups each (representing a pole), i.e., as you
%    will get out of |\coffin_get_pole_coordinates:NnN|. It calculates the
%    interesection between these poles and returns the result in the two dimen
%    variables |\l_coffin_intersect_x_dim| and |\l_coffin_intersect_y_dim|.
%
%    Right now it is not capable of calculating all cases which will be needed
%    with full rotation support.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_calculate_intersection:NN #1#2 {
%    \end{macrocode}
%    First we simply unpack the arguments.
%    \begin{macrocode}
      \exp_after:wN \exp_after:wN \exp_after:wN 
      \coffin_calculate_intersection:nnnnnnnn \exp_after:wN  #1#2 
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_new:Npn \coffin_calculate_intersection:nnnnnnnn #1#2#3#4 #5#6#7#8 { 
%<*debug>
   \cs_display_args:Nnnnnnnnn \coffin_calculate_intersection:nnnnnnnn
                              {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}
%</debug>
%    \end{macrocode}
%    Turn all components of the direction vectors to integers via conversion
%    vrom dimen to integers (number of scaled points). This way we can
%    multiply and divide them with other dimen values.
%    \begin{macrocode}
  \dim_set:Nn \l_coffin_tmpa_dim {#3}
  \int_set:Nn \l_coffin_x_dir_A_int {\l_coffin_tmpa_dim}
  \dim_set:Nn \l_coffin_tmpa_dim {#4}
  \int_set:Nn \l_coffin_y_dir_A_int {\l_coffin_tmpa_dim}
  \dim_set:Nn \l_coffin_tmpa_dim {#7}
  \int_set:Nn \l_coffin_x_dir_B_int {\l_coffin_tmpa_dim}
  \dim_set:Nn \l_coffin_tmpa_dim {#8}
  \int_set:Nn \l_coffin_y_dir_B_int {\l_coffin_tmpa_dim}
%    \end{macrocode}
%    There are a number of special cases we need to take into account when
%    calculating the intersection.
%
%    The simplest cases are those where the direction vectors are either
%    horizontal or vertical.
%    \begin{macrocode}
  \intexpr_compare:nNnTF \l_coffin_x_dir_A_int = 0
%    \end{macrocode}
%    If |\l_coffin_x_dir_A_int| is zero then the A-pole is vertical. Thus the
%    x-component of the intersection has to be at |#1|.
%    \begin{macrocode}
    {
      \dim_set:Nn \l_coffin_intersect_x_dim {#1}
%    \end{macrocode}
%    Now we test if the B-poleis also vertical and if so we complain. Of
%    course they may just lie on top of each other but that doesn't really
%    help us to find a single intersection.
%    \begin{macrocode}
      \intexpr_compare:nNnTF \l_coffin_x_dir_B_int = 0
        { \ERROR-no-intersection }
        {
%    \end{macrocode}
%    If not vertical it might be horizontal which would be the case if
%    |\l_coffin_y_dir_B_int| is zero.
%    \begin{macrocode}
          \intexpr_compare:nNnTF \l_coffin_y_dir_B_int = 0
%    \end{macrocode}
%    In that case the y-component of the intersection would simply be the
%    y-component of the B-pole, i.e., |#6| and we are done.
%    \begin{macrocode}
            {
             \dim_set:Nn \l_coffin_intersect_y_dim {#6}
            }
%    \end{macrocode}
%    If not, the y-component is given by the formula
%    \[
%           y = \frac{d}{c}(x - a) + b
%    \]
%    if $(a,b,c,d)$ is representing our pole. For $x$ we have to put in the
%    already calculated x-component |#1| which gives us
%    \begin{macrocode}
            {
             \dim_set:Nn \l_coffin_intersect_y_dim
                      { (#1 - #5) / \l_coffin_x_dir_B_int
                                  * \l_coffin_y_dir_B_int + #6  }
            }
        }
    }
%    \end{macrocode}
%    That concludes the case where the A-pole is vertical. If it wasn't then
%    we should check if it is horizontally oriented.
%    \begin{macrocode}
    {
      \intexpr_compare:nNnTF \l_coffin_y_dir_A_int = 0
      {
%    \end{macrocode}
%    If that's the case the the process is similar but with x- and y-
%    component exchanged, i.e, that determines now the y-component of the
%    intersection and we have to check the direction of the B-pole to see if
%    it too is  horizontal:
%    \begin{macrocode}
        \dim_set:Nn \l_coffin_intersect_y_dim {#2}
        \intexpr_compare:nNnTF \l_coffin_y_dir_B_int = 0
          { \ERROR-no-intersection }
%    \end{macrocode}
%    If not it might be vertical which now is the easy case.
%    \begin{macrocode}
          { \intexpr_compare:nNnTF \l_coffin_x_dir_B_int = 0
               {
                 \dim_set:Nn \l_coffin_intersect_x_dim { #5 }
               }
%    \end{macrocode}
%    An if it is neither vertical nor horizontal we the following formula this
%    time:
%    \[
%           a = \frac{c}{d}(y - b) + a
%    \]
%    Using |#2| for $y$ then gives:
%    \begin{macrocode}
               {
                 \dim_set:Nn \l_coffin_intersect_x_dim
                          { (#2 - #6) / \l_coffin_y_dir_B_int 
                                      * \l_coffin_x_dir_B_int
                            + #5 }
               }
          }
      }
%    \end{macrocode}
%    The most complicated case is the one where both direction vectors have a
%    direction other than horizontal or vertical.
%    \begin{macrocode}
      {
        \ERROR-not-yet-handled
      }
    }
%<*debug>
\typeout{Intersection~ at:~ 
         ( \dim_use:N\l_coffin_intersect_x_dim ,
           \dim_use:N\l_coffin_intersect_y_dim  ) }
%</debug>
}

%    \end{macrocode}
%  \end{macro}
%
%
%
% \subsection{Some needed external variants and additional commands}
% 
% We need a few variants and commands not in l3in2e.
%
% Looks like |\vtop| and friends are not set up at all so far.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \vbox_top:n {\tex_vtop:D \scan_stop:}
\cs_new_protected:Npn \vbox_set_top:Nn #1 { \tex_setbox:D #1 \tex_vtop:D }
%    \end{macrocode}
%
%
%    
%
%
%
% \subsection{Some temporal debugging commands}
% 
%    \begin{macrocode}
%<*debug>

%</debug>
\cs_new:Npn \cs_display_args:Nnnnnnnnnn #1 {
   \cs_display_cs_name:N #1
   \cs_display_args:nnnnnnnnn
}
\cs_new:Npn \cs_display_args:Nnnnnnnnn #1 {
   \cs_display_cs_name:N #1
   \cs_display_args:nnnnnnnn
}
\cs_new:Npn \cs_display_args:Nnnnnnn #1 {
   \cs_display_cs_name:N #1
   \cs_display_args:nnnnnn
}
\cs_new:Npn \cs_display_args:Nnnnn #1 {
   \cs_display_cs_name:N #1
   \cs_display_args:nnnn
}
\cs_new:Npn \cs_display_args:Nnnn #1 {
   \cs_display_cs_name:N #1
   \cs_display_args:nnn
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_new:Npn \cs_display_cs_name:N #1 {
   \typeout{ \detokenize{ #1 } }
}
\cs_new:Npn \cs_display_args:nnnnnnnnn #1#2#3#4#5#6#7#8#9 {
   \typeout{ \space\space \detokenize{ ~ ##1 ~=~ #1 } }
   \typeout{ \space\space \detokenize{ ~ ##2 ~=~ #2 } }
   \typeout{ \space\space \detokenize{ ~ ##3 ~=~ #3 } }
   \typeout{ \space\space \detokenize{ ~ ##4 ~=~ #4 } }
   \typeout{ \space\space \detokenize{ ~ ##5 ~=~ #5 } }
   \typeout{ \space\space \detokenize{ ~ ##6 ~=~ #6 } }
   \typeout{ \space\space \detokenize{ ~ ##7 ~=~ #7 } }
   \typeout{ \space\space \detokenize{ ~ ##8 ~=~ #8 } }
   \typeout{ \space\space \detokenize{ ~ ##9 ~=~ #9 } }
   \typeout{}
}
\cs_new:Npn \cs_display_args:nnnnnnnn #1#2#3#4#5#6#7#8 {
   \typeout{ \space\space \detokenize{ ~ ##1 ~=~ #1 } }
   \typeout{ \space\space \detokenize{ ~ ##2 ~=~ #2 } }
   \typeout{ \space\space \detokenize{ ~ ##3 ~=~ #3 } }
   \typeout{ \space\space \detokenize{ ~ ##4 ~=~ #4 } }
   \typeout{ \space\space \detokenize{ ~ ##5 ~=~ #5 } }
   \typeout{ \space\space \detokenize{ ~ ##6 ~=~ #6 } }
   \typeout{ \space\space \detokenize{ ~ ##7 ~=~ #7 } }
   \typeout{ \space\space \detokenize{ ~ ##8 ~=~ #8 } }
   \typeout{}
}
\cs_new:Npn \cs_display_args:nnnnnn #1#2#3#4#5#6 {
   \typeout{ \space\space \detokenize{ ~ ##1 ~=~ #1 } }
   \typeout{ \space\space \detokenize{ ~ ##2 ~=~ #2 } }
   \typeout{ \space\space \detokenize{ ~ ##3 ~=~ #3 } }
   \typeout{ \space\space \detokenize{ ~ ##4 ~=~ #4 } }
   \typeout{ \space\space \detokenize{ ~ ##5 ~=~ #5 } }
   \typeout{ \space\space \detokenize{ ~ ##6 ~=~ #6 } }
   \typeout{}
}
\cs_new:Npn \cs_display_args:nnnn #1#2#3#4 {
   \typeout{ \space\space \detokenize{ ~ ##1 ~=~ #1 } }
   \typeout{ \space\space \detokenize{ ~ ##2 ~=~ #2 } }
   \typeout{ \space\space \detokenize{ ~ ##3 ~=~ #3 } }
   \typeout{ \space\space \detokenize{ ~ ##4 ~=~ #4 } }
   \typeout{}
}
\cs_new:Npn \cs_display_args:nnn #1#2#3 {
   \typeout{ \space\space \detokenize{ ~ ##1 ~=~ #1 } }
   \typeout{ \space\space \detokenize{ ~ ##2 ~=~ #2 } }
   \typeout{ \space\space \detokenize{ ~ ##3 ~=~ #3 } }
   \typeout{}
}
%    \end{macrocode}
%
%    \begin{macrocode}
\endinput
%<*debug>
   \cs_display_args:Nnnnnnnnnn 
                               {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}
%</debug>

%<*debug>
   \cs_display_args:Nnnnnnnnn  {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}
%</debug>

%<*debug>
   \cs_display_args:Nnnnn  {#1}{#2}{#3}{#4}
%</debug>

%<*debug>
   \cs_display_args:Nnnn  {#1}{#2}{#3}
%</debug>

%</package>
%    \end{macrocode}
%
% \Finale
%
%
\endinput
