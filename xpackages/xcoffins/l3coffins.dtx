%
% \iffalse
%<*driver>
 \documentclass[cm-default]{l3doc}
 \begin{document}
 \DocInput{l3coffins.dtx}
 \end{document}
%</driver>
% \fi
%
% \GetFileInfo{l3coffins.dtx}
%
% \title{The \textsf{l3coffins} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{Frank Mittelbach\thanks{Based on ideas and code developed by David
%    Carlisle, Frank Mittelbach and Chris Rowley in some distent time in the
%    last millenium --- or as David would say ``in his former life''.}}
% \date{\filedate}
%  \maketitle
% 
% 
%
% \newenvironment{Arglist}{\small\itemize
%        \newcommand\Argitem[1]{\item[\texttt{\###1}]}}{\enditemize}
%
%
% \tableofcontents
%
%
% \section{Introduction}
%
%
% \section{Implementation}
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
\RequirePackage{expl3}
\GetIdInfo$Id$
  {coffins module}
%    \end{macrocode}
%    
%    \begin{macrocode}
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
%    \end{macrocode}
%
%
% \subsection{Temporary variables used in this module}
%
%
%
%
%  \begin{macro}{\l_coffin_tmp_box}
%    Scratch box register used to repack a vertical coffin to determine its
%    top baseline.
%    \begin{macrocode}
\box_new:N \l_coffin_tmp_box
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\l_coffin_tmpa_dim,
%                \l_coffin_tmpb_dim
%                }
%    Scratch length registers used in calulating offsets etc.
%    \begin{macrocode}
\dim_new:N \l_coffin_tmpa_dim 
\dim_new:N \l_coffin_tmpb_dim 
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\l_coffin_offset_x_dim,
%                \l_coffin_offset_y_dim
%                }
%    These next two are used to hold the offset between two coffins
%    when doing alignment (measuring the distance between the two reference
%    points of the two boxes).
%    \begin{macrocode}
\dim_new:N \l_coffin_offset_x_dim 
\dim_new:N \l_coffin_offset_y_dim 
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\l_coffin_tmpa_tl,
%                \l_coffin_tmpb_tl,
%                \l_coffin_tmpc_tl}
%    A few scratch token list registers used in many places.
%    \begin{macrocode}
\tl_new:N \l_coffin_tmpa_tl 
\tl_new:N \l_coffin_tmpb_tl 
\tl_new:N \l_coffin_tmpc_tl 
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\l_coffin_pole_tl}
%    Token list variable to exclusively hold a retrieved pole value (for more
%    than just a very short time).
%    \begin{macrocode}
\tl_new:N \l_coffin_pole_tl
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\_coffin_eval_pole_value:N}
%    A temporary command that is redefined on the fly to resolve pole values
%    that contain |##1| denoting the current coffin, e.g., |\box_wd:N ##1|.
%    \begin{macrocode}
\cs_new:Npn \_coffin_eval_pole_value:N #1 {}
%    \end{macrocode}
%  \end{macro}
%
%
%
%





%
%
%
% \subsection{The default set of poles}
%
%

%  \begin{macro}{\c_coffin_default_hpoles_prop,
%                \c_coffin_default_vpoles_prop}
%    These two propery lists hold the default set of ``natural'' poles, i.e.,
%    those that can be defined just through information about the box
%    dimensions. The poles that relate to top and bottom baseline in a
%    vertical box only get added when a coffin is filled bia a coffin
%    operation like |\vcoffin_set:Nn|.
%
%    We declare them as constants as they are supposed to stay unchanged once
%    filled with data.
%    \begin{macrocode}
\prop_new:N   \c_coffin_default_hpoles_prop
\prop_new:N   \c_coffin_default_vpoles_prop
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_put:Nnn \c_coffin_default_vpoles_prop {l} {0pt}          
\prop_put:Nnn \c_coffin_default_vpoles_prop {c} {.5\box_wd:N#1}
\prop_put:Nnn \c_coffin_default_vpoles_prop {r} {\box_wd:N#1}
%    \end{macrocode}
%    
%    \begin{macrocode}
\prop_put:Nnn \c_coffin_default_hpoles_prop {t} {\box_ht:N#1}
\prop_put:Nnn \c_coffin_default_hpoles_prop {c} {(\box_ht:N#1-\box_dp:N#1)/2}
\prop_put:Nnn \c_coffin_default_hpoles_prop {b} {-\box_dp:N#1}
%    \end{macrocode}
%    
%    The vertical position of the coffin reference point (i.e., its baseline)
%    is denoted by the code \texttt{H}. The codes \texttt{B} for bottom
%    baseline and \texttt{T} top baseline are added for vertical
%    coffins. Alternatively, we could make them both equal for horizontal
%    coffins.
%    \begin{macrocode}
\prop_put:Nnn \c_coffin_default_hpoles_prop {H} {0pt}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%





















%
%
%
%
% \subsection{Making coffins}
%
%
%
%  \begin{macro}{\coffin_new:N}
%    Declare a new coffin (which is a box and two property lista holding
%    information about the horizontal and vertical poles. Initially we use the
%    natural default poles.
%    \begin{macrocode}
\cs_new:Npn \coffin_new:N #1 {
   \box_new:N #1
   \prop_new:c {l_coffin_hpoles_ \tex_number:D #1 _prop}
   \prop_new:c {l_coffin_vpoles_ \tex_number:D #1 _prop}
%    \end{macrocode}
%    We use a global assignment here as the allocation is also global.
%    \begin{macrocode}
   \coffin_gset_poles_to_default:N #1
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_add_struture_if_needed:N}
%
%    Check if a box already has a coffin support data structure and if not add
%    it. Thus, this command turns an ordinary box into a coffin.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_add_struture_if_needed:N #1   { 
%    \end{macrocode}
%    A box is a coffin if it has the property lists for poles defined. If not we
%    define it assing it the default poles.
%    \begin{macrocode}
  \cs_if_free:cT {l_coffin_hpoles_ \tex_number:D #1 _prop}
    {
     \prop_new:c {l_coffin_hpoles_ \tex_number:D #1 _prop}
     \prop_new:c {l_coffin_vpoles_ \tex_number:D #1 _prop}
%    \end{macrocode}
%    The next line adds the default poles globally as the allocation of the
%    property lists is also global. Otherwise, the default setting would not
%    survive the end of the group, but next time the test would be false as
%    the property lists already exist.
%    \begin{macrocode}
     \coffin_gset_poles_to_default:N #1
    }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_add_or_reset_default_poles:N}
%
%    This command sets all poles of a box to the default poles. It should
%    be used whenever coffin (or box) is about to receive new content. After
%    all, poles from a previous coffin life should vanish at that point.
%
%    Works on boxes without being already coffins.
%    \begin{macrocode}
\cs_new:Npn \coffin_add_or_reset_default_poles:N #1   { 
%    \end{macrocode}
%    A box is a coffin if it has the property list for poles defined. If not we
%    define it assing it the default poles.
%    \begin{macrocode}
  \cs_if_free:cTF {l_coffin_hpoles_ \tex_number:D #1 _prop}
    {
     \prop_new:c {l_coffin_hpoles_ \tex_number:D #1 _prop}
     \prop_new:c {l_coffin_vpoles_ \tex_number:D #1 _prop}
%    \end{macrocode}
%    The next line adds the default poles globally as the allocation of the
%    property list is also global. Otherwise, the default setting would not
%    survive the end of the group, but next time the test would be false as
%    the propertylist already exist.
%    \begin{macrocode}
     \coffin_gset_poles_to_default:N #1
    }
%    \end{macrocode}
%    But if the data structure already exists (i.e., the normal case) we do
%    the setting locally.
%    \begin{macrocode}
    {\coffin_set_poles_to_default:N #1 }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
% \subsection{Getting and setting poles}
%
% \subsubsection{Setting all poles}
%
%
%  \begin{macro}{\coffin_set_eq_poles:NN}
%    Set all poles of one coffin to the be the poles of another coffin.
%    \begin{macrocode}
\cs_new:Npn \coffin_set_eq_poles:NN #1#2 {
    \prop_set_eq:cc {l_coffin_hpoles_ \tex_number:D #1 _prop}
                    {l_coffin_hpoles_ \tex_number:D #2 _prop}
    \prop_set_eq:cc {l_coffin_vpoles_ \tex_number:D #1 _prop}
                    {l_coffin_vpoles_ \tex_number:D #2 _prop}
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\coffin_set_poles_to_default:N}
%    Set all poles of one coffin to the default set of poles stored in
%    two property list constants.
%    \begin{macrocode}
\cs_new:Npn \coffin_set_poles_to_default:N #1 {
    \prop_set_eq:cN {l_coffin_hpoles_ \tex_number:D #1 _prop}
                    \c_coffin_default_hpoles_prop
    \prop_set_eq:cN {l_coffin_vpoles_ \tex_number:D #1 _prop}
                    \c_coffin_default_vpoles_prop
}
%    \end{macrocode}
%  \end{macro}
%
%



%
%
%
%  \begin{macro}{\coffin_gset_poles_to_default:N}
%    Set all poles of one coffin globally to the default set of poles stored in
%    property lists |\c_coffin_default_hpoles_prop| and |\c_coffin_default_vpoles_prop|.
%
%    As the coffin data structure is supposed to be a local structure this
%    command should only be used when turning an ordinary box into a
%    coffin. There it is needed as the property lists themselves are globally allocated.
%    \begin{macrocode}
\cs_new:Npn \coffin_gset_poles_to_default:N #1 {
    \prop_gset_eq:cN {l_coffin_hpoles_ \tex_number:D #1 _prop}
                     \c_coffin_default_hpoles_prop
    \prop_gset_eq:cN {l_coffin_vpoles_ \tex_number:D #1 _prop}
                     \c_coffin_default_vpoles_prop
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
% \subsubsection{Setting a single pole}
%
%  \begin{macro}{\coffin_set_pole_coordinates:Nnnn,
%                \coffin_set_pole_coordinates:NnnV,
%                \coffin_set_pole_coordinates:NnVV}
%   
%    This command sets the values for one pole.
% 
%    For speed reasons this command doesn't check if this is really a coffin,
%    i.e., has the pole property list being set up. For a slower but safe
%    version in user-level commands use |\coffin_set_pole_safe:Nnnn|.
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference to coffin
%    \Argitem{2} pole direction (h or v)
%    \Argitem{3} pole name
%    \Argitem{4} pole coordinate / formula
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_set_pole_coordinates:Nnnn #1#2 {
    \prop_put:cnn {l_coffin_ #2poles_ \tex_number:D #1 _prop}
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_generate_variant:Nn \coffin_set_pole_coordinates:Nnnn { NnnV, NnVV }
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\coffin_set_pole_safe:Nnnn}
%    This command provides a safe way to add or update a pole of some
%    coffin. In the pole values the commands |\width|, |\height|, and
%    |\depth| can be used to refer to the coffin dimensions
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference to coffin
%    \Argitem{2} pole direction (h or v)
%    \Argitem{3} pole name
%    \Argitem{4} pole coordinate / formula
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn  \coffin_set_pole_safe:Nnnn #1#2#3#4 {
%    \end{macrocode}
%    If the command is used on a box without pole property, add it first.
%    \begin{macrocode}
  \coffin_add_struture_if_needed:N #1 
%    \end{macrocode}
%    Provide definitions for |\width| etc.\ for use in  the
%    coordinates.
%
%    Potential issue: this currently adds the box register, e.g., |\box_wd:N \aaa|
%    and not something like a more generic |\box_wd:N ##1|. So at least something
%    like copying coffins wouldn't quite work. So it might be better to use
%    |##1| instead.\footnote{Issue?}
%    \begin{macrocode}
  \cs_set:Npn\width{\box_wd:N#1}
  \cs_set:Npn\height{\box_ht:N#1}
  \cs_set:Npn\depth{\box_dp:N#1}
%    \end{macrocode}
%    
%    Potential issue: as we have no control over the data passed to us as
%    coordinates using full expansion isn't really the best
%    solution.\footnote{Issue? Needs probably changing!}
%    \begin{macrocode}
  \tl_set:Nx \l_coffin_pole_tl { #4 } % dangerous "x"
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*trace>
\typeout{set:~ \string#1(#2,#3)=\l_coffin_pole_tl}
%</trace>
%    \end{macrocode}
%    Update or add the pole:
%    \begin{macrocode}
  \coffin_set_pole_coordinates:NnnV #1 #2 {#3} \l_coffin_pole_tl
%    \end{macrocode}
%    This preserves some kind of invariant:
%    \begin{macrocode}
  \cs_undefine:N \width
  \cs_undefine:N \height
  \cs_undefine:N \depth
}
%    \end{macrocode}
%  \end{macro}
%

%
%
%
%
%  \begin{macro}{\coffin_adjust_pole_safe:Nnnn}
%    
%    This command provides a safe way to update a pole of some coffin
%    relative to its current poision. In the pole values the commands
%    |\width|, |\height|, and |\depth| can be used to refer to the coffin
%    dimensions.
%
%    If the pole doesn't exist an error is signalled and the box reference
%    point will be used.
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference to coffin
%    \Argitem{2} pole direction (h or v)
%    \Argitem{3} pole name
%    \Argitem{4} pole coordinate / formula
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_adjust_pole_safe:Nnnn #1#2#3#4  {
%    \end{macrocode}
%    If the command is used on a box without pole property, add it first.
%    \begin{macrocode}
  \coffin_add_struture_if_needed:N #1
%    \end{macrocode}
%    
%    \begin{macrocode}
  \cs_set:Npn\width {\box_wd:N#1}
  \cs_set:Npn\height{\box_ht:N#1}
  \cs_set:Npn\depth {\box_dp:N#1}
%    \end{macrocode}
%    Retrieve the pole coordinate and if non-existant signal an error. We do this on
%    foot here instead of using |\coffin_get_pole_coordinates:NnN| as we are interested
%    in the ``raw'' pole value.
%    \begin{macrocode}
  \prop_get:cnN {l_coffin_#2poles_ \tex_number:D #1 _prop} {#3} \l_coffin_pole_tl
  \quark_if_no_value:NT \l_coffin_pole_tl
     {
      \ERROR_pole_not_set
      \tl_set:Nn \l_coffin_pole_tl {0pt}
     }
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*trace>
  \typeout{adjust:~ \string#1(#2,#3)~=~\l_coffin_pole_tl
           \space\space with~ \space (#4) }
%</trace>
%    \end{macrocode}
%    \begin{macrocode}
   \tl_put_right:Nn \l_coffin_pole_tl { + (#4) }
%    \end{macrocode}
%    \ldots and then put it back:
%    \begin{macrocode}
   \coffin_set_pole_coordinates:NnnV #1 {#2} {#3} \l_coffin_pole_tl
%    \end{macrocode}
%    
%    This preserves some kind of invariant:
%    \begin{macrocode}
  \cs_undefine:N \width
  \cs_undefine:N \height
  \cs_undefine:N \depth
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
% \subsubsection{Retrieving a pole value}
%
%
%  \begin{macro}{\coffin_get_pole_coordinates:NnnN}
%    This command retrieves a pole value and stores it in a token list
%    variable given as forth argument. If the pole doesn't exist an error is
%    signaled and \verb=0pt= is returned.
%
%    The command can be used with boxes not having poles set up. In this
%    case the default poles are made available first.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference to coffin
%    \Argitem{2} pole direction (h or v)
%    \Argitem{3} pole name
%    \Argitem{4} token list variable to receive value
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_get_pole_coordinates:NnnN #1#2#3#4 {
%    \end{macrocode}
%    First we ensure that the pole data structure is set up.
%    \begin{macrocode}
  \coffin_add_struture_if_needed:N #1
%    \end{macrocode}
%    Then we trieve the pole value.
%    \begin{macrocode}
  \prop_get:cnN {l_coffin_#2poles_ \tex_number:D #1 _prop} {#3} #4
%    \end{macrocode}
%    In case the pole name is unknown we will get a |\q_no_value| returned,
%    so we better distinguish this case.
%    \begin{macrocode}
  \quark_if_no_value:NTF #4
%    \end{macrocode}
%    If the pole was unknown we signal an error and use the box reference
%    point as a return value.
%    \begin{macrocode}
     {
      \ERROR_pole_not_set
      \tl_set:Nn #4 {0pt}
     }
%    \end{macrocode}
%    Otherwise the value is now stored in |#4|, but it may
%    contain a formula with dependencies to the coffin dimension (using |##1|
%    to refer to the coffin), so we need
%    to resolve those first. To do this we define the helper command
%    |\_coffin_eval_pole_value:N| with one argument and the pole value as
%    replacement text.\footnote{There must be a nicer way to set this up, right?}
%    \begin{macrocode}
     {
      \exp_after:wN
         \cs_set:Npn
      \exp_after:wN 
          \_coffin_eval_pole_value:N
      \exp_after:wN 
          ##
      \exp_after:wN
           1
      \exp_after:wN
          { #4 }
%    \end{macrocode}
%    Now we reset the value to make any box dimension dependencies explicit
%    (i.e., replace |##1| with a reference to the coffin name in |#1|).
%    \begin{macrocode}
      \tl_set:No #4 { \_coffin_eval_pole_value:N #1 }
     }
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*trace>
  \typeout {\string#1(#2,#3) = #4}
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%



%
%
%
% \subsection{Debugging and printing poles}
%
%
%
%  \begin{macro}{\coffin_show_poles:N}
%    Some simple tracing: show all poles defined for some coffin or box.
%    \begin{macrocode}
\cs_new:Npn \coffin_show_poles:N #1 {
  \typeout{Poles~ of~ coffin~ \string #1 (\tex_number:D #1):}
  \cs_if_free:cTF {l_coffin_hpoles_ \tex_number:D #1 _prop}
     { \typeout{---no~ poles---} }
     {
       \prop_display:c {l_coffin_hpoles_ \tex_number:D #1 _prop}
       \prop_display:c {l_coffin_vpoles_ \tex_number:D #1 _prop}
     }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\coffin_print_pole_values:Nn,
%                \_coffin_print_pole_values:Nnnnn}
%    Some simple attempt at pretty printing \ldots{} to be improved.
%    First argument is the box for which the poles should be printed and
%    second argument is a delimiter to be used after each pole, for example
%    |\\|.
%    \begin{macrocode}
\cs_new:Npn \coffin_print_pole_values:Nn #1#2 {
   \prop_map_inline:cn {l_coffin_hpoles_ \tex_number:D #1 _prop}
      {
        \_coffin_print_pole_values:Nnnnn #1 {h} {##1} {##2} {#2}
      }
   \prop_map_inline:cn {l_coffin_vpoles_ \tex_number:D #1 _prop}
      {
        \_coffin_print_pole_values:Nnnnn #1 {v} {##1} {##2} {#2}
      }
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_new:Npn \_coffin_print_pole_values:Nnnnn #1#2#3#4 #5 {
    \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#4}
    \dim_set:Nn \l_coffin_tmpa_dim {\_coffin_eval_pole_value:N #1}
%    \end{macrocode}
%    
%    \begin{macrocode}
    key(#2->\token_to_str:N #3)=(\dim_use:N \l_coffin_tmpa_dim)
    #5
}
%    \end{macrocode}
%  \end{macro}
%




%
%
%
%
%
% \subsection{Setting the content of a coffin}
%
%
%
%
%  \begin{macro}{\_latex_sbox:Nn}
%    Save away the original \LaTeX{} definition to make our life easier for now.
%    \begin{macrocode}
\cs_new_eq:NN \_latex_sbox:Nn \sbox
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\hcoffin_set:Nn}
%    
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} 
%    \Argitem{2} 
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_set:Npn \hcoffin_set:Nn #1 {
%    \end{macrocode}
%    Safeguard against using an ordinary box and reset the poles if the box
%    was previously used as a coffin:
%    \begin{macrocode}
   \coffin_add_or_reset_default_poles:N #1
%    \end{macrocode}
%    For now we simply call \LaTeX{}'s |\sbox| under a private name. This way
%    we can make |\sbox| point to |\hcoffin_set:Nn| if we wish to later.
%    \begin{macrocode}
   \_latex_sbox:Nn #1
}
%    \end{macrocode}
%  \end{macro}
%
%
%




%
%
%  \begin{macro}{\vcoffin_set:Nnn}
%    
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} 
%    \Argitem{2} 
%    \Argitem{3} 
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn\vcoffin_set:Nnn #1#2#3 {
%    \end{macrocode}
%    Safeguard against using an ordinary box and reset the poles if the box
%    was previously used as a coffin:
%    \begin{macrocode}
   \coffin_add_or_reset_default_poles:N #1
%    \end{macrocode}
%    Set the content as a vertical box.\footnote{This will probably need
%    updating to properly support color etc etc.}
%    \begin{macrocode}
   \vbox_set:Nn #1 {\dim_set:Nn \hsize {#2}
                     #3
%                    \endgraf \showthe\prevgraf
                   }
%    \end{macrocode}
%    To calculate the top baseline we need to reset the box and measure its
%    new height:
%    \begin{macrocode}
   \vbox_set_top:Nn \l_coffin_tmp_box {\vbox_unpack:N #1}
   \dim_set:Nn \l_coffin_tmpa_dim {\box_ht:N #1 - \box_ht:N \l_coffin_tmp_box } 
%    \end{macrocode}
%    We then use the new value to set up the \texttt{T} code.
%    \begin{macrocode}
   \coffin_set_pole_coordinates:NnnV #1 {h} {T} \l_coffin_tmpa_dim
%    \end{macrocode}
%    
%    The \texttt{B} code is simpler since it is the same as \texttt{H}.
%    \begin{macrocode}
   \coffin_set_pole_coordinates:Nnnn #1 {h} {B} {0pt}
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_set_eq:NN}
%    Copy the content of one coffin to the next. Both arguments are assumed to
%    be coffins, i.e., there is no checking.
%    \begin{macrocode}
\cs_new:Npn \coffin_set_eq:NN #1#2 {
    \box_set_eq:NN #1 #2
    \coffin_set_eq_poles:NN #1 #2
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\coffin_set_eq_clear:NN}
%    Move the content of one coffin to the next. Afterwards the box will be
%    void and the property list of poles are reset to the default list.
%    Both arguments are assumed to
%    be coffins, i.e., there is no checking.
%    \begin{macrocode}
\cs_new:Npn \coffin_set_eq_clear:NN #1#2 {
    \box_set_eq_clear:NN #1 #2
    \coffin_set_eq_poles:NN #1 #2
    \coffin_set_poles_to_default:N #2
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%


%
%
%
%
%
% \subsection{Aligning coffins}
%
%
%
%
%  \begin{macro}{\l_coffin_aligned_coffin}
%    This is a scratch coffin we use later to store intermediate results when
%    aligning coffins.
%    \begin{macrocode}
\coffin_new:N \l_coffin_aligned_coffin
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_align_boxes:nnnnNNnnN}
%
%    This helper command aligns two boxes (need not be coffins) given specific
%    specific alignment points (as offset from the normal reference point of
%    the box) and some x/y offset to use between the alignment points.
%
%    The bounding box of the whole construction is \ldots{} whatever it is
%    (height and depth are Ok, but all horizontal stuff is somewhat
%    arbitrary), thus this box register is not, typically, very useful without
%    further work on the horizontal positioning and size.  There are various
%    possibilities for these refinements, these are explored in the top-level
%    commands defined later on.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} x-offset box-A (can be a formula coming from a coffin
%                pole specification)
%    \Argitem{2} y-offset box-A (can be a formula)
%    \Argitem{3} x-offset box-B (can be a formula)
%    \Argitem{4} y-offset box-B (can be a formula)
%    \Argitem{5} box register reference for box-A (single token)
%    \Argitem{6} box register reference for box-B (single token)
%    \Argitem{7} x-offset between alignment points (can be a formula)
%    \Argitem{8} y-offset between alignment points (can be a formula)
%    \Argitem{9} box register reference for result box (single token)
%    \end{Arglist}
%    The result is stored in a new box (\#9) which is turned into a coffin and
%    add the original poles from box-A (with their formulas) available as
%    \texttt{\meta{pole}}. Other poles, referring to box-A and box-Bas
%    absolute coordinates (via \texttt{\meta{box-A}-\meta{pole}}) need to
%    wait until we know how the bounding box has been calculated.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_align_boxes:nnnnNNnnN #1#2 #3#4 #5#6 #7#8 #9 {
%<*trace>
   \cs_display_args:Nnnnnnnnnn \coffin_align_boxes:nnnnNNnnN 
                               {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}
%</trace>
%    \end{macrocode}
%    First calulate the final offset between the two box reference pointsused
%    by \TeX:
%    \begin{macrocode}
  \dim_set:Nn \l_coffin_offset_x_dim{(#1)+(#7)-(#3)}
  \dim_set:Nn \l_coffin_offset_y_dim{(#2)+(#8)-(#4)}
%    \end{macrocode}
%    Then put the aligned boes into the result box by\ldots
%    \begin{macrocode}
    \hbox_set:Nn #9 {
%    \end{macrocode}
%    \ldots first setting box-A and doing a backup by its width which brings
%    us back to the reference point of box-A.
%    \begin{macrocode}
      \box_use:N #5
      \tex_kern:D -\box_wd:N #5 
%    \end{macrocode}
%    Then move horizontally by the calulated x-offset and place box-B with its
%    reference point raised by the calulated y-offset. (The two horizontal
%    |\tex_kern:D| movements could be combined to save a bit space, but we
%    need the |\l_coffin_offset_x_dim| later again so we don't bother.
%    \begin{macrocode}
      \tex_kern:D \l_coffin_offset_x_dim
      \box_move_up:nn \l_coffin_offset_y_dim {\box_use:N #6 }
    }
%    \end{macrocode}
%    Final step is to turn the result box into a coffin with the right kind of
%    poles attached.
%
%    First we check if the coffin data structure is already present:
%    \begin{macrocode}
   \coffin_add_struture_if_needed:N #9
%    \end{macrocode}
%    Then we copy a default set of poles to get a clean state. For this we
%    use the poles from box-A. Note that the final box may have new
%    dimensions and thus poles may change places (being typically relative
%    to the box dimensions. This is arguably wrong and one may have to move
%    this code until after the dimensions have been determined (with or
%    without confining the bounding box).\footnote{Issue?}
%    However, we normally want to preserve poles for \texttt{T} and we can
%    do this only by ``calculating/copying'' them from the box poles involved.
%    \begin{macrocode}
   \coffin_set_eq_poles:NN #9 #5
%    \end{macrocode}
%    What we can't yet do at this point is adding explicit poles that refer
%    back to the individual poles from box-A and box-B via
%    \texttt{\meta{box-B}-\meta{pole}}. This isn't possible, as we don't
%    know yet where the final reference point of the result box will lie as
%    this depends on they way we handle the bounding box later on. So we have have to wait
%    with this using the values of |\l_coffin_offset_x_dim| and
%    |\l_coffin_offset_y_dim| that we have calculated above.
%    \begin{macrocode}
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_align_two_coffins:NnnNnnnnN}
%    
%    This helper command alligns two coffins at their pole with a specific
%    offset between them and saves the result in a third coffin.
%    
%    Just like |\coffin_align_boxes:nnnnNNnnN| on which this is based the
%    bounding box is unusable without further correction.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \Argitem{9} target box register for saving
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_align_two_coffins:NnnNnnnnN #1#2#3#4#5#6#7#8#9 {
%    \end{macrocode}
%    First we retrieve the pole coordinates from the two poles.
%    \begin{macrocode}
  \coffin_get_pole_coordinates:NnnN #1{v}{#3}\l_coffin_tmpa_tl
  \coffin_get_pole_coordinates:NnnN #1{h}{#2}\l_coffin_tmpb_tl
  \coffin_get_pole_coordinates:NnnN #4{v}{#6}\l_coffin_tmpc_tl
  \coffin_get_pole_coordinates:NnnN #4{h}{#5}\l_coffin_tmpd_tl
%    \end{macrocode}
%    The next operation results in |\l_coffin_tmpa_tl| holding four brace
%    groups with the coordinates of both poles.
%    \begin{macrocode}
  \tl_set:Nx \l_coffin_tmpa_tl { { \l_coffin_tmpa_tl } { \l_coffin_tmpb_tl }
                                 { \l_coffin_tmpc_tl } { \l_coffin_tmpd_tl } }
%    \end{macrocode}
%    By expanding |\l_coffin_tmpa_tl| prior to calling
%    |\coffin_align_boxes:nnnnNNnnN| this command will then see all pole
%    coordinates as its first four arguments:
%    \begin{macrocode}
  \exp_after:wN \coffin_align_boxes:nnnnNNnnN \l_coffin_tmpa_tl 
                                              #1 #4 {#7} {#8} #9
}
%    \end{macrocode}
%  \end{macro}
%
%
%


%
%  \begin{macro}{\coffin_align_confine_save:NnnNnnnnN}
%    
%    This commmand aligns two coffins at their poles with a certain offset
%    inbetween. The result is stored in a third coffin (with poles
%    from both coffins added as \texttt{\meta{box}-\meta{pole}}). Note that
%    the arguments are ordered differently compared to the internal helper
%    commands for coffin alignment
%
%    The resulting bounding box is clipped to the dimensions of the first
%    coffin (box-A), that is the second coffin may overlap surrounding text.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \Argitem{9} target box register for saving
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn\coffin_align_confine_save:NnnNnnnnN #1#2#3#4#5#6#7#8#9{%
%    \end{macrocode}
%    First we call the helper command to align the coffins.
%    \begin{macrocode}
  \coffin_align_two_coffins:NnnNnnnnN #1 {#2}{#3}  #4 {#5}{#6} {#7}{#8} #9 
%    \end{macrocode}
%    Then we correct the bounding box data, restricting it to the values from
%    box-A.\footnote{Issue: l3box doesn't have commands for setting box
%    dimensions, so for now we go low-level}.
%    \begin{macrocode}
  \box_ht:N #9 \box_ht:N #1
  \box_wd:N #9 \box_wd:N #1
  \box_dp:N #9 \box_dp:N #1
%    \end{macrocode}
%    Finally we also make the poles from the original coffins available: they
%    can be accessed using ``\meta{box-reference}-\meta{pole}'', for
%    example, |\aaa-T| if |\aaa| is the reference for one of the
%    coffins.
%
%    For this we have to shift the pole values by the offset used in the
%    alignment (stored by |\coffin_align_two_coffins:NnnnNnN| in two dimen
%    variables). We also change any formula used into real values, so that we
%    can free up the coffin content afterwards.
%
%    The first box doesn't have any offset.
%    \begin{macrocode}
   \coffin_save_pole_values_with_offset:NnnN #1 {0pt}{0pt} #9
%    \end{macrocode}
%    But the second one does:
%    \begin{macrocode}
   \coffin_save_pole_values_with_offset:NnnN #4 
                                             \l_coffin_offset_x_dim
                                             \l_coffin_offset_y_dim
                                             #9
%    \end{macrocode}
%    At this point  we could free up the coffin/box content of box-B (not done
%    yet).\footnote{Issue?}
%    \begin{macrocode}
%    \end{macrocode}
%    Finally show the resulting poles when tracing:
%    \begin{macrocode}
%<*trace>
   \coffin_show_poles:N #9
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%

%
%  \begin{macro}{\coffin_align_save:NnnNnnnnN}
%    
%    This commmand aligns two coffins at their poles with a certain offset
%    inbetween. The result is stored in a third coffin (with poles
%    from both coffins added as \texttt{\meta{box}-\meta{pole}}). Note that
%    the arguments are ordered differently compared to the internal helper
%    commands for coffin alignment
%
%    The resulting bounding box is clipped to the dimensions of the first
%    coffin (box-A), that is the second coffin may overlap surrounding text.
%
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \Argitem{9} target box register for saving
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn\coffin_align_save:NnnNnnnnN #1#2#3#4#5#6#7#8#9{
%    \end{macrocode}
%    First we call the helper command to align the coffins.
%    \begin{macrocode}
  \coffin_align_two_coffins:NnnNnnnnN #1 {#2}{#3}  #4 {#5}{#6} {#7}{#8} #9 
%    \end{macrocode}
%    Then we have to do a bit more than just changing the box dimensions: we
%    actually have to build a new box with additional kerns to the left and/or
%    right of, at least if we have to move the
%    reference point of the result box to the left of the reference point of
%    box-A (which happens if box-B sticks out to the left of box-A).
%    \begin{macrocode}
   \hbox_set:Nn #9 {
    \dim_compare:nNnT \l_coffin_offset_x_dim < \c_zero_dim
%    \end{macrocode}
%    Okay, so if |\l_coffin_offset_x_dim| is negative the reference point of
%    box-B is to the left of box-A. Thus by starting our box with a horizontal
%    shift of |-\l_coffin_offset_x_dim| we  effectively start with the
%    reference point at the left edge.
%    \begin{macrocode}
         { \tex_kern:D -\l_coffin_offset_x_dim }
%    \end{macrocode}
%    Then we unpack the box holding the aligned coffins (we can use unpacking
%    as that will not change the sizes but avoids one unnecessay box level).
%    \begin{macrocode}
    \hbox_unpack_clear:N #9
%    \end{macrocode}
%    To get the right side of the box correct we also may have to add some
%    kern. Right now our box ends at the right side of box-B. Thus, if box-A
%    extends further to the right we have to account for that. This can be
%    achieved by adding to |\l_coffin_offset_x_dim| the width of box-B (which
%    gives us the horizontal size of box |#9|) and substract the width of
%    box-A. If the result is negative this means that box-A sticks out  to the
%    right by that amount. Therefore we have to add a corresponding kern in
%    that case. Deep breath!
%    \begin{macrocode}
    \dim_set:Nn \l_coffin_tmpa_dim { \l_coffin_offset_x_dim 
                                      + \box_wd:N #4 - \box_wd:N #1 }
    \dim_compare:nNnT \l_coffin_tmpa_dim < \c_zero_dim
                      { \tex_kern:D -\l_coffin_tmpa_dim }
  }
%    \end{macrocode}
%    What remains to be done is to add the explicit poles to the inner
%    boxes. Now that we know whether or not the reference point of the result
%    box got moved or not we are ready to go. We just need to check again if
%    |\l_coffin_offset_x_dim| is negative. (It isn't possible to use the test
%    earlier inside the box construction as that would mean the pole updates
%    would only live until the end of the box contruction.)
%    \begin{macrocode}
  \dim_compare:nNnTF \l_coffin_offset_x_dim < \c_zero_dim
%    \end{macrocode}
%    Here the reference point got moved so we need to shift things to the
%    left:
%    \begin{macrocode}
         { 
           \coffin_save_pole_values_with_offset:NnnN
                  #1 {-\l_coffin_offset_x_dim} {0pt} #9
           \coffin_save_pole_values_with_offset:NnnN
                  #4 {0pt} \l_coffin_offset_y_dim    #9
         }
%    \end{macrocode}
%    And if the reference point for the result box doesn't change then we have
%    the following offsets to use:
%    \begin{macrocode}
         {
           \coffin_save_pole_values_with_offset:NnnN
                  #1 {0pt}{0pt} #9
           \coffin_save_pole_values_with_offset:NnnN
                  #4 \l_coffin_offset_x_dim
                     \l_coffin_offset_y_dim #9
         }
%    \end{macrocode}
%    At this point  we could free up the coffin/box content of box-B (not done
%    yet).\footnote{Issue?}
%    \begin{macrocode}
%    \end{macrocode}
%    Finally show the resulting poles when tracing:
%    \begin{macrocode}
%<*trace>
   \coffin_show_poles:N #9
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%


%
%
%  \begin{macro}{\coffin_save_pole_values_with_offset:NnnN}
%
%    This command takes the poles from box-A, calculates their numerical
%    value, offsets them by some x/y-offset and then writes a new pole with
%    the name \texttt{\meta{box-A}-\meta{pole}} and stores it as a pole
%    for box-B.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box-A reference used as source to build new pole list
%    \Argitem{2} x-offset
%    \Argitem{3} y-offset
%    \Argitem{4} box-B reference receiving updated poles
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_save_pole_values_with_offset:NnnN #1 #2#3 #4 {
%    \end{macrocode}
%    We map some inline code over the pole property lists of box-A to
%    retrieve the poles and calculate the new ones.
%    \begin{macrocode}
   \prop_map_inline:cn {l_coffin_hpoles_ \tex_number:D #1 _prop}
      {
%    \end{macrocode}
%    The actual work is done by a helper command which receives all necessary
%    values as separate arguments. Horizontal poles get the y-offset added
%    (|#3|). 
%    \begin{macrocode}
        \coffin_save_pole_values_with_offset:NnnnnN #1 {h} {##1} {##2} {#3} #4
      }
%    \end{macrocode}
%    Now we do the same for the vertical poles where we have to add the x-offset:
%    \begin{macrocode}
   \prop_map_inline:cn {l_coffin_vpoles_ \tex_number:D #1 _prop}
      {
        \coffin_save_pole_values_with_offset:NnnnnN #1 {v} {##1} {##2} {#2} #4
      }
%    \end{macrocode}
%    Some debugging code to verify the results:
%    \begin{macrocode}
%<*debug>
    \coffin_show_poles:N #4
%</debug>
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_save_pole_values_with_offset:NnnnnN}
%    
%    This command takes explicit values for a single pole from box-A,
%    calculates the numerical 
%    values, offsets them by the x/y-offset and then writes a new pole with
%    the name \texttt{\meta{box-A}-\meta{pole}} stored  as a pole
%    for box-B.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box-A reference used as source to build new pole list
%    \Argitem{2} pole direction
%    \Argitem{3} pole name
%    \Argitem{4} pole value
%    \Argitem{5} extra offset
%    \Argitem{6} box-B reference receiving updated pole
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_save_pole_values_with_offset:NnnnnN #1 #2#3 #4 #5 #6 {
%    \end{macrocode}
%    The value of the pole might involve a formula (such as |\box_wd:N ##1|), so
%    to calculate the numerical value we have to resolve this. This is done by
%    defining a scratch command with one argument (receiving the box-A) and
%    the pole ``formula'' as replacement text---if that replacement text is
%    already numerical, no harm will be done.
%    \begin{macrocode}
    \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#4}
%    \end{macrocode}
%    We then calculate the new absolute position for the pole as follows:
%    \begin{macrocode}
    \dim_set:Nn \l_coffin_tmpa_dim {\_coffin_eval_pole_value:N #1 + #5}
%    \end{macrocode}
%    To build the new pole name we have to distinuish two cases: a) this is
%    a native pole of box-A, either one of the default poles or one
%    explicitly build by the user and b) it is a derived pole which was
%    added to box-A as the result of aligning two coffins earlier.
%
%    In the latter case the name will be of the form
%    \texttt{\meta{somebox}-\meta{pole}} and in this cases we simply leave it
%    alone, otherwise we build the name as
%    \texttt{\meta{box-A}-\meta{pole}}. 
%
%    Consequence of this is that user defined pole names better not contain
%    a ``\texttt{-}'' and that one can't align the same coffin several times
%    to some other coffin without loosing the poles (as the second alignment
%    will overwrite the poles from the first). However, this approach makes
%    poles from inner coffins in alignment operations available later on
%    without any dependency on the order the alignment happened. If we would
%    unconditionally prepend \texttt{\meta{box-A}-} all poles would be
%    uniquely identifiable, but their name would depend on the order the
%    alignment happend which would be a very bad idea.
%    \begin{macrocode}
    \tl_if_in:nnTF {#3} {-} 
          { \tl_set:Nx \l_coffin_tmpa_tl { #3 }     }
          { \tl_set:Nx \l_coffin_tmpa_tl { #1-#3 }  }
%    \end{macrocode}
%    Now we are ready to put the new pole into box-B's property list.
%    \begin{macrocode}
    \coffin_set_pole_coordinates:NnVV #6 {#2}
                  \l_coffin_tmpa_tl \l_coffin_tmpa_dim
}
%    \end{macrocode}
%  \end{macro}
%
%

%
%  \begin{macro}{\coffin_align:NnNnnn}
%    
%    This commmand aligns two coffins at their poles with a certain offset
%    inbetween. The result is stored again in the first coffin (with poles
%    from both coffins added as \texttt{\meta{box}-\meta{pole}}).
%
%    The resulting bounding box is the enclosing box around both coffins.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \end{Arglist}
%
%    Note that the arguments are ordered differently compared to the internal
%    helper commands for coffin alignment.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_align:NnnNnnnn #1#2#3#4#5#6#7#8{
%    \end{macrocode}
%    First we align the coffins and save them in a scratch coffin. This time
%    the version that doesn't confine the bounding box is being used.
%    \begin{macrocode}
  \coffin_align_save:NnnNnnnnN  #1{#2}{#3} #4{#5}{#6} {#7}{#8}
                               \l_coffin_aligned_coffin 
%    \end{macrocode}
%    Then we copy the scratch coffin back into box-A:
%    \begin{macrocode}
  \coffin_set_eq_clear:NN #1 \l_coffin_aligned_coffin
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_align_confine:NnnNnnnn}
%    
%    This commmand aligns two coffins at their poles with a certain offset
%    inbetween. The result is stored again in the first coffin (with poles
%    from both coffins added as \texttt{\meta{box}-\meta{pole}}).
%
%    The resulting bounding box is clipped to the dimensions of the first
%    coffin (box-A).
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \end{Arglist}
%
%    Note that the arguments are ordered differently compared to the internal
%    helper commands for coffin alignment.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_align_confine:NnnNnnnn #1 #2#3 #4 #5#6 #7#8{
%    \end{macrocode}
%    First we align the coffins and save them in a scratch coffin.
%    \begin{macrocode}
    \coffin_align_confine_save:NnnNnnnnN #1{#2}{#3} #4{#5}{#6} {#7}{#8}
                                         \l_coffin_aligned_coffin
%    \end{macrocode}
%    Then we copy the scratch coffin back into box-A:
%    \begin{macrocode}
  \coffin_set_eq_clear:NN #1 \l_coffin_aligned_coffin
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
% \subsection{Typesetting coffins}
%




%
%
% \subsection{Some needed external variants and additional commands}
% 
% We need a few variants and commands not in l3in2e.
%
% Looks like |\vtop| and friends are not set up at all so far.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \vbox_top:n {\tex_vtop:D \scan_stop:}
\cs_new_protected:Npn \vbox_set_top:Nn #1 { \tex_setbox:D #1 \tex_vtop:D }
%    \end{macrocode}
%
%
%    
%    \begin{macrocode}
\cs_new:Npn \cs_display_args:Nnnnnnnnnn #1 {
   \cs_display_cs_name:N #1
   \cs_display_args:nnnnnnnnn
}
\cs_new:Npn \cs_display_cs_name:N #1 {
   \typeout{ \detokenize{ #1 <- } }
}
\cs_new:Npn \cs_display_args:nnnnnnnnn #1#2#3#4#5#6#7#8#9 {
   \typeout{ \space\space \detokenize{ ~ ##1 ~=~ #1 } }
   \typeout{ \space\space \detokenize{ ~ ##2 ~=~ #2 } }
   \typeout{ \space\space \detokenize{ ~ ##3 ~=~ #3 } }
   \typeout{ \space\space \detokenize{ ~ ##4 ~=~ #4 } }
   \typeout{ \space\space \detokenize{ ~ ##5 ~=~ #5 } }
   \typeout{ \space\space \detokenize{ ~ ##6 ~=~ #6 } }
   \typeout{ \space\space \detokenize{ ~ ##7 ~=~ #7 } }
   \typeout{ \space\space \detokenize{ ~ ##8 ~=~ #8 } }
   \typeout{ \space\space \detokenize{ ~ ##9 ~=~ #9 } }
}
\cs_new:Npn \cs_display_args:nnnnnn #1#2#3#4#5#6 {
   \typeout{ \space\space \detokenize{ ~ ##1 ~=~ #1 } }
   \typeout{ \space\space \detokenize{ ~ ##2 ~=~ #2 } }
   \typeout{ \space\space \detokenize{ ~ ##3 ~=~ #3 } }
   \typeout{ \space\space \detokenize{ ~ ##4 ~=~ #4 } }
   \typeout{ \space\space \detokenize{ ~ ##5 ~=~ #5 } }
   \typeout{ \space\space \detokenize{ ~ ##6 ~=~ #6 } }
}
%    \end{macrocode}



%    \begin{macrocode}
\endinput
%</package>
%    \end{macrocode}
%
% \Finale
%
%
\endinput
