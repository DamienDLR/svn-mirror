%
% \iffalse
%<*driver>
 \documentclass[cm-default]{l3doc}
 \begin{document}
 \DocInput{l3coffins.dtx}
 \end{document}
%</driver>
% \fi
%
% \GetFileInfo{l3coffins.dtx}
%
% \title{The \textsf{l3coffins} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{Frank Mittelbach\thanks{Based on ideas and code developed by David
%    Carlisle, Frank Mittelbach and Chris Rowley in some distent time in the
%    last millenium --- or as David would say ``in his former life''.}}
% \date{\filedate}
%  \maketitle
% 
% 
%
% \newenvironment{Arglist}{\small\itemize
%        \newcommand\Argitem[1]{\item[\texttt{\###1}]}}{\enditemize}
%
%
% \tableofcontents
%
%
% \section{Introduction}
%
%
% \section{Open items implementation}
%
% \begin{itemize}
% \item Use sin/cos implementation of fp module
% \item Maintain the ``real bounding box'' values when turning a complex object
% \item
% \item
% \item
% \end{itemize}
%
% \section{Implementation}
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
\RequirePackage{expl3}
\GetIdInfo$Id$
  {coffins module}
%    \end{macrocode}
%    
%    \begin{macrocode}
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
%    \end{macrocode}
%
%    \begin{macrocode}
\RequirePackage{graphicx}   % for now at least
%    \end{macrocode}
%
%
%
% \subsection{To-Dos}
%
% \begin{itemize}
% \item sort out use of |\l_coffin_intersect_x_dim| viz.\
%    |\l_coffin_offset_x_dim|
% \item sort our rotation bug: 135 and higher rotates handles and poles wrong,
%    but two rotations, e.g. 45+90=135 work
% \end{itemize}
%
%
%
%
%
%
% \subsection{Temporary variables used in this module}
%
%
%
%
%  \begin{macro}{\l_coffin_tmp_box}
%    Scratch box register used to repack a vertical coffin to determine its
%    top baseline.
%    \begin{macrocode}
\box_new:N \l_coffin_tmp_box
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\l_coffin_tmpa_dim,
%                \l_coffin_tmpb_dim
%                }
%    Scratch length registers used in calulating offsets etc.
%    \begin{macrocode}
\dim_new:N \l_coffin_tmpa_dim 
\dim_new:N \l_coffin_tmpb_dim 
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\l_coffin_offset_x_dim,
%                \l_coffin_offset_y_dim
%                }
%    These next two are used to hold the offset between two coffins
%    when doing alignment (measuring the distance between the two reference
%    points of the two boxes).
%    \begin{macrocode}
\dim_new:N \l_coffin_offset_x_dim 
\dim_new:N \l_coffin_offset_y_dim 
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\l_coffin_tmpa_tl,
%                \l_coffin_tmpb_tl,
%                \l_coffin_tmpc_tl}
%    A few scratch token list registers used in many places.
%    \begin{macrocode}
\tl_new:N \l_coffin_tmpa_tl 
\tl_new:N \l_coffin_tmpb_tl 
\tl_new:N \l_coffin_tmpc_tl 
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\l_coffin_pole_tl}
%    Token list variable to exclusively hold a retrieved pole value (for more
%    than just a very short time).
%    \begin{macrocode}
\tl_new:N \l_coffin_pole_tl
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\l_coffin_align_coordinates_tl}
%    Token list variable in which we built up the two coordinate pairs that we
%    used in alignment.
%    \begin{macrocode}
\tl_new:N \l_coffin_align_coordinates_tl
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\_coffin_eval_pole_value:N}
%    A temporary command that is redefined on the fly to resolve pole values
%    that contain |##1| denoting the current coffin, e.g., |\box_wd:N ##1|.
%    \begin{macrocode}
\cs_new:Npn \_coffin_eval_pole_value:N #1 {}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
%
%
% \subsection{The default data structure for coffins}
%
%
%  \begin{macro}{\c_coffin_default_poles_prop}
%    This  property lists holds the default set of ``natural'' poles, i.e.,
%    those that can be defined just through information about the box
%    dimensions. The poles that relate to top and bottom baseline in a
%    vertical box gets their correct value when a coffin is filled via a coffin
%    operation like |\vcoffin_set:Nn| ---for now they are only added as
%    alternate names for \TeX's box reference point.
%
%    We declare the property list as aconstant as it is supposed to stay
%    unchanged once filled with data.
%    \begin{macrocode}
\prop_new:N   \c_coffin_default_poles_prop
%    \end{macrocode}
%
%    \begin{macrocode}
\prop_put:Nnn \c_coffin_default_poles_prop {l} {{0pt} {0pt}         {0sp}{1000sp}}
\prop_put:Nnn \c_coffin_default_poles_prop {hc}{{.5\box_wd:N#1}{0pt}{0sp}{1000sp}}
\prop_put:Nnn \c_coffin_default_poles_prop {r} {{\box_wd:N#1}{0pt}  {0sp}{1000sp}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\prop_put:Nnn \c_coffin_default_poles_prop {t} {{0pt}{\box_ht:N#1}  {1000sp}{0sp}}
\prop_put:Nnn \c_coffin_default_poles_prop {vc}
                               {{0pt}{(\box_ht:N#1-\box_dp:N#1)/2}  {1000sp}{0sp}}
\prop_put:Nnn \c_coffin_default_poles_prop {b} {{0pt}{-\box_dp:N#1} {1000sp}{0sp}}
%    \end{macrocode}
%    
%    The horizontal position of the coffin reference point (i.e., its baseline)
%    is denoted by the code \texttt{H}. The codes \texttt{B} for bottom
%    baseline and \texttt{T} top baseline are added for vertical
%    coffins. Initially they are set to the same value, i.e., zero.
%    \begin{macrocode}
\prop_put:Nnn \c_coffin_default_poles_prop {H} {{0pt}{0pt} {1000sp}{0sp}}
\prop_put:Nnn \c_coffin_default_poles_prop {B} {{0pt}{0pt} {1000sp}{0sp}}
\prop_put:Nnn \c_coffin_default_poles_prop {T} {{0pt}{0pt} {1000sp}{0sp}}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\c_coffin_default_handles_prop}
%    In addition to the poles we maintain a number of default handles which
%    are points on the coffin. By default these are the bounding box
%    coordinates. The |outer_BB| points are those from the bounding box as
%    \TeX{} sees it, the other bounding box values are those that represent
%    the real corners of the box (which will differ if the box got rotated by
%    some angle).
%
%    \begin{macrocode}
\prop_new:N   \c_coffin_default_handles_prop
%    \end{macrocode}
%    
%    \begin{macrocode}
\prop_put:Nnn \c_coffin_default_handles_prop {BB_tl} {{0pt}{0pt}}
\prop_put:Nnn \c_coffin_default_handles_prop {BB_tr} {{0pt}{0pt}}
\prop_put:Nnn \c_coffin_default_handles_prop {BB_br} {{0pt}{0pt}}
\prop_put:Nnn \c_coffin_default_handles_prop {BB_bl} {{0pt}{0pt}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\prop_put:Nnn \c_coffin_default_handles_prop {outer_BB_tl} {{0pt}{0pt}}
\prop_put:Nnn \c_coffin_default_handles_prop {outer_BB_tr} {{0pt}{0pt}}
\prop_put:Nnn \c_coffin_default_handles_prop {outer_BB_br} {{0pt}{0pt}}
\prop_put:Nnn \c_coffin_default_handles_prop {outer_BB_bl} {{0pt}{0pt}}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\coffin_gadd_structure:N}
%    
%    As the coffin data structure is supposed to be a local structure this
%    command should only be used when turning an ordinary box into a
%    coffin. There it is needed as the property lists themselves are globally
%    allocated.
%    \begin{macrocode}
\cs_new:Npn \coffin_gadd_structure:N #1 {
%    \end{macrocode}
%    Per coffin we have a property list that holds the poles and one that
%    holds any computed handles.
%    \begin{macrocode}
   \prop_new:c {l_coffin_poles_ \tex_number:D #1 _prop}
   \prop_new:c {l_coffin_handles_ \tex_number:D #1 _prop}
%    \end{macrocode}
%    We use a global assignments here as the allocation is also global.
%    \begin{macrocode}
   \prop_gset_eq:cN {l_coffin_poles_ \tex_number:D #1 _prop}
                    \c_coffin_default_poles_prop
   \prop_gset_eq:cN {l_coffin_handles_ \tex_number:D #1 _prop}
                    \c_coffin_default_handles_prop
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
% \subsection{Making coffins}
%
%
%
%  \begin{macro}{\coffin_new:N}
%    Declare a new coffin (which is a box and two property lists holding
%    information about the horizontal and vertical poles. Initially we use the
%    natural default poles.
%    \begin{macrocode}
\cs_new:Npn \coffin_new:N #1 {
   \box_new:N #1
   \coffin_gadd_structure:N #1
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_add_struture_if_needed:N}
%
%    Check if a box already has a coffin support data structure and if not add
%    it. Thus, this command turns an ordinary box into a coffin.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_add_struture_if_needed:N #1   { 
%    \end{macrocode}
%    A box is a coffin if it has the property lists for poles defined. If not we
%    define it assing it the default poles.
%    \begin{macrocode}
  \cs_if_free:cT {l_coffin_poles_ \tex_number:D #1 _prop}
                 { \coffin_gadd_structure:N #1 }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_add_or_reset_structure:N}
%
%    This command sets all poles of a box to the default poles. It should
%    be used whenever coffin (or box) is about to receive new content. After
%    all, poles from a previous coffin life should vanish at that point.
%
%    Works on boxes without being already coffins.
%    \begin{macrocode}
\cs_new:Npn \coffin_add_or_reset_structure:N #1   { 
%    \end{macrocode}
%    A box is a coffin if it has the property list for poles defined. If not we
%    define it assing it the default poles.
%    \begin{macrocode}
  \cs_if_free:cTF {l_coffin_poles_ \tex_number:D #1 _prop}
    {  \coffin_gadd_structure:N #1  }
%    \end{macrocode}
%    But if the data structure already exists (i.e., the normal case) we do
%    the setting locally.
%    \begin{macrocode}
    { \coffin_reset_structure:N #1 }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
% \subsection{Getting and setting poles}
%
% \subsubsection{Setting all poles}
%
%
%  \begin{macro}{\coffin_set_eq_structure:NN}
%    Set all poles and handles of one coffin to the be the poles handles of
%    another coffin.
%    \begin{macrocode}
\cs_new:Npn \coffin_set_eq_structure:NN #1#2 {
    \prop_set_eq:cc {l_coffin_poles_ \tex_number:D #1 _prop}
                    {l_coffin_poles_ \tex_number:D #2 _prop}

    \prop_set_eq:cc {l_coffin_handles_ \tex_number:D #1 _prop}
                    {l_coffin_handles_ \tex_number:D #2 _prop}
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\coffin_reset_structure:N}
%    Set all poles and handles of one coffin to the default set stored in
%    two property list constants.
%    \begin{macrocode}
\cs_new:Npn \coffin_reset_structure:N #1 {
    \prop_set_eq:cN {l_coffin_poles_ \tex_number:D #1 _prop}
                    \c_coffin_default_poles_prop
%    \end{macrocode}
%    
%    \begin{macrocode}
    \prop_set_eq:cN {l_coffin_handles_ \tex_number:D #1 _prop}
                    \c_coffin_default_handles_prop
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
% \subsubsection{Setting a single pole}
%
%  \begin{macro}{\coffin_set_pole_coordinates:Nnn,
%                \coffin_set_pole_coordinates:NnV,
%                \coffin_set_pole_coordinates:NVV}
%   
%    This command sets the values for one pole.
% 
%    For speed reasons this command doesn't check if this is really a coffin,
%    i.e., has the pole property list being set up. For a slower but safe
%    version in user-level commands use |\coffin_set_pole_safe:Nnnn|.
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference to coffin
%    \Argitem{2} pole name
%    \Argitem{3} pole coordinates / formula
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_set_pole_coordinates:Nnn #1#2#3 {
%<*debug>
    \cs_display_args:Nnnn\coffin_set_pole_coordinates:Nnn {#1}{#2}{#3}
%</debug>
    \prop_put:cnn {l_coffin_poles_ \tex_number:D #1 _prop}{#2}{#3}
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_generate_variant:Nn \coffin_set_pole_coordinates:Nnn { NnV, NVV }
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\coffin_set_pole_safe:Nnnn}
%    This command provides a safe way to add or update a pole of some
%    coffin. In the pole values the commands |\width|, |\height|, and
%    |\depth| can be used to refer to the coffin dimensions.
%
%    The way it is now it is kind of a user function where the pole direction
%    is given as |h| or |v| to ease input.
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference to coffin
%    \Argitem{2} pole direction (h or v)
%    \Argitem{3} pole name
%    \Argitem{4} pole coordinate / formula
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn  \coffin_set_pole_safe:Nnnn #1#2#3#4 {
%    \end{macrocode}
%    If the command is used on a box without pole property, add it first.
%    \begin{macrocode}
  \coffin_add_struture_if_needed:N #1 
%    \end{macrocode}
%    Provide definitions for |\width| etc.\ for use in  the
%    coordinates.
%
%    Potential issue: this currently adds the box register, e.g., 
% |\box_wd:N \aaa| 
%    and not something like a more generic |\box_wd:N ##1|. So at least
%    something like copying coffins wouldn't quite work. So it might be better
%    to use |##1| instead.\footnote{Issue?}
%    \begin{macrocode}
  \cs_set:Npn\width{\box_wd:N#1}
  \cs_set:Npn\height{\box_ht:N#1}
  \cs_set:Npn\depth{\box_dp:N#1}
%    \end{macrocode}
%    
%    Potential issue: as we have no control over the data passed to us as
%    coordinates using full expansion isn't really the best
%    solution.\footnote{Issue? Needs probably changing!}
%    \begin{macrocode}
  \str_if_eq:nnTF {#2}{h}
     { \tl_set:Nx \l_coffin_pole_tl { {0pt}{#4} {1000sp}{0sp} } } 
     { \tl_set:Nx \l_coffin_pole_tl { {#4}{0pt} {0sp}{1000sp} } } 
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*trace>
\typeout{set:~ \string#1(#2:#3)=\l_coffin_pole_tl}
%</trace>
%    \end{macrocode}
%    Update or add the pole:
%    \begin{macrocode}
  \coffin_set_pole_coordinates:NnV #1 {#3} \l_coffin_pole_tl
%    \end{macrocode}
%    This preserves some kind of invariant:
%    \begin{macrocode}
  \cs_undefine:N \width
  \cs_undefine:N \height
  \cs_undefine:N \depth
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_adjust_pole_safe:Nnnn,
%                \_coffin_adjust_pole_safe:nnnnnn}
%    
%    This command provides a safe way to update a pole of some coffin
%    relative to its current poision. In the pole values the commands
%    |\width|, |\height|, and |\depth| can be used to refer to the coffin
%    dimensions.
%
%    If the pole doesn't exist an error is signalled and the box reference
%    point will be used.
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference to coffin
%    \Argitem{2} pole direction (h or v)
%    \Argitem{3} pole name
%    \Argitem{4} pole coordinate / formula
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_adjust_pole_safe:Nnnn #1#2#3#4  {
%<*debug>
   \cs_display_args:Nnnnn \coffin_adjust_pole_safe:Nnnn {#1}{#2}{#3}{#4}
%</debug>
%    \end{macrocode}
%    If the command is used on a box without pole property, add it first.
%    \begin{macrocode}
  \coffin_add_struture_if_needed:N #1
%    \end{macrocode}
%    
%    \begin{macrocode}
  \cs_set:Npn\width {\box_wd:N#1}
  \cs_set:Npn\height{\box_ht:N#1}
  \cs_set:Npn\depth {\box_dp:N#1}
%    \end{macrocode}
%    Retrieve the pole coordinate and if non-existant signal an error. We do
%    this on foot here instead of using |\coffin_get_pole_coordinates:NnN| as
%    we are interested in the ``raw'' pole values.
%    \begin{macrocode}
  \prop_get:cnN {l_coffin_poles_ \tex_number:D #1 _prop} {#3} \l_coffin_pole_tl
  \quark_if_no_value:NT \l_coffin_pole_tl
     {
      \typeout{ERROR:~\tl_to_str:n{#1(#2:#3)}~ not~ set}
      \ERROR_pole_not_set
      \tl_set:Nn \l_coffin_pole_tl {{0pt}{0pt}{0sp}{1000sp}}
     }
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*trace>
  \typeout{adjust:~ \string#1(#2,#3)~=~\l_coffin_pole_tl
           \space\space with~ \space (#4) }
%</trace>
%    \end{macrocode}
%    |\l_coffin_pole_tl| now contains four brace groups and we have to update
%    the right one depending on |#2| being |h| or |v|. We do this in a help
%    command after expanding |\l_coffin_pole_tl| so that the help sees six
%    arguments.
%    \begin{macrocode}
   \exp_last_unbraced:No \_coffin_adjust_pole_safe:nnnnnn 
                         \l_coffin_pole_tl {#2}{#4}
%    \end{macrocode}
%    \ldots and then put it back:
%    \begin{macrocode}
   \coffin_set_pole_coordinates:NnV #1 {#3} \l_coffin_pole_tl
%    \end{macrocode}
%    
%    This preserves some kind of invariant:
%    \begin{macrocode}
  \cs_undefine:N \width
  \cs_undefine:N \height
  \cs_undefine:N \depth
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_new:Npn \_coffin_adjust_pole_safe:nnnnnn #1#2#3#4#5#6 {
   \str_if_eq:nnTF {#5}{h}
%    \end{macrocode}
%    If a horizontal pole we update the y-coordinate, otherwise the
%    x-coordinate, the rest stays the same.
%    \begin{macrocode}
     { \tl_set:Nn \l_coffin_pole_tl { {#1}{#2 +(#6)}{#3}{#4} } }
     { \tl_set:Nn \l_coffin_pole_tl { {#1 +(#6)}{#2}{#3}{#4} } }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
% \subsubsection{Retrieving a pole value}
%
%
%  \begin{macro}{\coffin_get_pole_coordinates:NnN}
%    This command retrieves a pole value and stores it in a token list
%    variable given as forth argument. If the pole doesn't exist an error is
%    signaled and \verb=0pt= is returned.
%
%    The command can be used with boxes not having poles set up. In this
%    case the default poles are made available first.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference to coffin
%    \Argitem{2} pole name
%    \Argitem{3} token list variable to receive value
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_get_pole_coordinates:NnN #1#2#3 {
%<*debug>
   \cs_display_args:Nnnn \coffin_get_pole_coordinates:NnN {#1}{#2}{#3}
%</debug>
%    \end{macrocode}
%    First we ensure that the pole data structure is set up.
%    \begin{macrocode}
  \coffin_add_struture_if_needed:N #1
%    \end{macrocode}
%    Then we retrieve the pole value.
%    \begin{macrocode}
  \prop_get:cnN {l_coffin_poles_ \tex_number:D #1 _prop} {#2} #3
%    \end{macrocode}
%    In case the pole name is unknown we will get a |\q_no_value| returned,
%    so we better distinguish this case.
%    \begin{macrocode}
  \quark_if_no_value:NTF #3
%    \end{macrocode}
%    If the pole was unknown we signal an error and use the box reference
%    point as a return value.
%    \begin{macrocode}
     {
      \typeout{ERROR:~\tl_to_str:n{#1(#2)}~ not~ set}
      \ERROR_pole_not_set
      \tl_set:Nn #3 {{0pt}{0pt}{0sp}{1000sp}}
     }
%    \end{macrocode}
%    Otherwise the value is now stored in |#3|, but it may
%    contain a formula with dependencies to the coffin dimension (using |##1|
%    to refer to the coffin), so we need
%    to resolve those first. To do this we define the helper command
%    |\_coffin_eval_pole_value:N| with one argument and the pole value as
%    replacement text.\footnote{There must be a nicer way to set this up, right?}
%    \begin{macrocode}
     {
      \exp_after:wN
         \cs_set:Npn
      \exp_after:wN 
          \_coffin_eval_pole_value:N
      \exp_after:wN 
          ##
      \exp_after:wN
           1
      \exp_after:wN
          { #3 }
%    \end{macrocode}
%    Now we reset the value to make any box dimension dependencies explicit
%    (i.e., replace |##1| with a reference to the coffin name in |#1|).
%    \begin{macrocode}
      \tl_set:No #3 { \_coffin_eval_pole_value:N #1 }
     }
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*trace>
  \typeout {\string#1(#2) = #3}
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
%
% \subsection{Debugging and printing poles}
%
%
%
%  \begin{macro}{\coffin_show_structure:N}
%    Some simple tracing: show all poles and handles defined for some coffin or box.
%    \begin{macrocode}
\cs_new_eq:NN \l_coffin_show_toks \l_tmpa_toks
\cs_new_protected_nopar:Npn \coffin_show_structure:N #1 {
  \iow_term:x 
    { 
      \iow_newline:
      Size~of~coffin~\token_to_str:N #1 : \iow_newline:
      > ~ ht~=~\dim_use:N \box_ht:N #1 \iow_newline:
      > ~ dp~=~\dim_use:N \box_dp:N #1 \iow_newline:
      > ~ wd~=~\dim_use:N \box_wd:N #1 \iow_newline:
    }
  \toks_clear:N \l_coffin_show_toks
  \cs_if_free:cTF { l_coffin_handles_ \tex_number:D #1 _prop }
    { 
      \iow_term:x { ---~No~handles~found~--- }
      \toks_put_right:Nn \l_coffin_show_toks 
        { Is~this~really~a~coffin? }
    }
    {
      \iow_term:x { Handles~of~coffin~\token_to_str:N #1 : }
      \prop_map_inline:cn { l_coffin_handles_ \tex_number:D #1 _prop }
        {
          \toks_if_empty:NF \l_coffin_show_toks  
            { 
              \toks_put_right:Nx \l_coffin_show_toks 
                { \iow_newline: > ~ } 
            }
          \toks_put_right:Nx \l_coffin_show_toks  
            { ~ \exp_not:n {##1} \c_space_tl => ~ \exp_not:n {##2} }
        }  
      \toks_put_right:Nx \l_coffin_show_toks 
        {
          \iow_newline:
          \iow_newline:
          Poles~of~coffin~\token_to_str:N #1 : 
        }
      \prop_map_inline:cn { l_coffin_poles_ \tex_number:D #1 _prop }
        {
          \toks_if_empty:NF \l_coffin_show_toks  
            { 
              \toks_put_right:Nx \l_coffin_show_toks 
                { \iow_newline: > ~ } 
            }
          \toks_put_right:Nx \l_coffin_show_toks  
            { ~ \exp_not:n {##1} \c_space_tl => ~ \exp_not:n {##2} }
        } 
    }
  \toks_show:N \l_coffin_show_toks
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\coffin_print_pole_values:Nn,
%                \_coffin_print_pole_values:Nnnnnnn}
%    Some simple attempt at pretty printing \ldots{} to be improved.
%    First argument is the box for which the poles should be printed and
%    second argument is a delimiter to be used after each pole, for example
%    |\\|.
%    \begin{macrocode}
\cs_new:Npn \coffin_print_pole_values:Nn #1#2 {
   \prop_map_inline:cn {l_coffin_poles_ \tex_number:D #1 _prop}
      {
        \_coffin_print_pole_values:Nnnnnnn #1  {##1} ##2 {#2}
      }
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_new:Npn \_coffin_print_pole_values:Nnnnnnn #1#2#3#4#5#6#7 {
    \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#3}
    \dim_set:Nn \l_coffin_tmpa_dim {\_coffin_eval_pole_value:N #1}
    \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#4}
    \dim_set:Nn \l_coffin_tmpb_dim {\_coffin_eval_pole_value:N #1}
%    \end{macrocode}
%    
%    \begin{macrocode}
    key(\token_to_str:N#2)=(\dim_use:N \l_coffin_tmpa_dim,
                            \dim_use:N \l_coffin_tmpb_dim, #5, #6)
    #7
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\l_coffin_spot_pole_coffin}
%    Coffin holding a small sqare dot (or a label for a handle). It is used to
%    display coffin pole intersections.
%    \begin{macrocode}
\coffin_new:N   \l_coffin_spot_pole_coffin 
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\l_coffin_display_tmp_coffin}
%    When adding labels and pole intersection points we use the allignment
%    commands to add the |\l_coffin_spot_pole_coffin| in the right place. But
%    this changes the pole information in the box we attach the label to. So
%    we need to keep the coffin data structure of that box in a save place. A
%    simple solution to do that is to park it in another coffin which is going
%    to be this one.
%    \begin{macrocode}
\coffin_new:N \l_coffin_display_tmp_coffin
%    \end{macrocode}
%  \end{macro}

%
%
%  \begin{macro}{\coffin_display_pole:Nnnn}
%    
%    This command adds a small square dot at a pole position and labels it
%    with its name. Most likely only useful for documenting pole code so may
%    get removed and put into the documentation one day.
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box reference
%    \Argitem{2} handle x-part
%    \Argitem{3} handle y-part
%    \Argitem{4} color name to use on pole spot
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_display_pole:Nnnn #1#2#3#4 {
%<*debug>
   \cs_display_args:Nnnnn \coffin_display_pole:Nnnn
                          {#1}{#2}{#3}{#4}
%</debug>
%    \end{macrocode}
%    First we store away the current coffin data structures so that after
%    alignment we can retrieve it (the labels shouldn't change the structure).
%    \begin{macrocode}
    \coffin_set_eq_structure:NN \l_coffin_display_tmp_coffin #1
%    \end{macrocode}
%    The we explicitly built the coffin holding the square dot
%    \begin{macrocode}
    \hcoffin_set:Nn \l_coffin_spot_pole_coffin 
                    { \color{#4}\rule{1pt}{1pt} }
%    \end{macrocode}
%    The we align both coffins at the pole intersection that we want to mark.
%    \begin{macrocode}
    \coffin_align_confine:NnnNnnnn #1 {#2}{#3}
                                  \l_coffin_spot_pole_coffin {vc}{hc} 
                                  {0pt} {0pt}
%    \end{macrocode}
%    To avoid any change to the data structue of the initial coffin (other
%    having added the ``spot'' we copy the saved data structure back.
%    \begin{macrocode}
    \coffin_set_eq_structure:NN #1 \l_coffin_display_tmp_coffin
%    \end{macrocode}
%    Then built a coffin holding the label.
%    \begin{macrocode}
    \hcoffin_set:Nn \l_coffin_spot_pole_coffin 
                    { \color{#4} \l_coffin_display_font_tl
                     (\tl_to_str:n{#2,#3}) }
%    \end{macrocode}
%    While the dot was simple to place (dead center onto the spot) the label
%    needs to go near but not directly on top. The question is where do we
%    best place it. The approach currently chosen is to retrieve settings for
%    every standard pole from a predefined spot and use those. Perhaps this
%    gets extended somehow in the future depending on the documentation needs.
%    \begin{macrocode}

    \prop_get:NnN \l_coffin_display_handle_prop {#2#3} \l_coffin_tmpa_tl
    \quark_if_no_value:NTF \l_coffin_tmpa_tl
%    \end{macrocode}
%    If nothing is defined there use a default setting of |vc,l|.
%    \begin{macrocode}
       {
         \coffin_align_confine:NnnNnnnn #1 {#2}{#3}
                             \l_coffin_spot_pole_coffin {vc}{l}
                             {1pt} {0pt}
       }
%    \end{macrocode}
%    Otherwise use the values from there:
%    \begin{macrocode}
       {
         \tl_put_left:Nn \l_coffin_tmpa_tl
                 { \coffin_align_confine:NnnNnnnn #1 {#2}{#3}
                             \l_coffin_spot_pole_coffin
                 }
         \l_coffin_tmpa_tl
       }
%    \end{macrocode}
%    Finally reset the poles for |#1| once more in case the alignment action
%    has made any changes to them.
%    \begin{macrocode}
    \coffin_set_eq_structure:NN #1 \l_coffin_display_tmp_coffin
}
%    \end{macrocode}
%  \end{macro}
%

%  \begin{macro}{\l_coffin_display_font_tl}
%    
%    \begin{macrocode}
\tl_new:N  \l_coffin_display_font_tl
\tl_set:Nn \l_coffin_display_font_tl {\sffamily\tiny}
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\l_coffin_display_offset_tl}
%    
%    \begin{macrocode}
\tl_new:N  \l_coffin_display_offset_tl
\tl_set:Nn \l_coffin_display_offset_tl {1pt}
%    \end{macrocode}
%  \end{macro}

%  \begin{macro}{\l_coffin_display_handle_prop}
%    Here is the set of default placement setting for the labels.
%    \begin{macrocode}
\prop_new:N \l_coffin_display_handle_prop
%    \end{macrocode}
%    
%    \begin{macrocode}
\prop_put:Nnn \l_coffin_display_handle_prop {tl}
              {{b}{r} {-\l_coffin_display_offset_tl}{\l_coffin_display_offset_tl}}
\prop_put:Nnn \l_coffin_display_handle_prop {thc}
              {{b}{hc} {0pt}{\l_coffin_display_offset_tl}}
\prop_put:Nnn \l_coffin_display_handle_prop {tr}
              {{b}{l} {\l_coffin_display_offset_tl}{\l_coffin_display_offset_tl}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\prop_put:Nnn \l_coffin_display_handle_prop {bl}
              {{t}{r} {-\l_coffin_display_offset_tl}{-\l_coffin_display_offset_tl}}
\prop_put:Nnn \l_coffin_display_handle_prop {bhc}
              {{t}{hc} {0pt}{-\l_coffin_display_offset_tl}}
\prop_put:Nnn \l_coffin_display_handle_prop {br}
              {{t}{l} {\l_coffin_display_offset_tl}{-\l_coffin_display_offset_tl}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\prop_put:Nnn \l_coffin_display_handle_prop {Tl}
              {{t}{r} {-\l_coffin_display_offset_tl}{-\l_coffin_display_offset_tl}}
\prop_put:Nnn \l_coffin_display_handle_prop {Thc}
              {{t}{hc} {0pt}{-\l_coffin_display_offset_tl}}
\prop_put:Nnn \l_coffin_display_handle_prop {Tr}
              {{t}{l} {\l_coffin_display_offset_tl}{-\l_coffin_display_offset_tl}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\prop_put:Nnn \l_coffin_display_handle_prop {Bl}
              {{t}{r} {-\l_coffin_display_offset_tl}{-\l_coffin_display_offset_tl}}
\prop_put:Nnn \l_coffin_display_handle_prop {Bhc}
              {{t}{hc} {0pt}{-\l_coffin_display_offset_tl}}
\prop_put:Nnn \l_coffin_display_handle_prop {Br}
              {{t}{l} {\l_coffin_display_offset_tl}{-\l_coffin_display_offset_tl}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\prop_put:Nnn \l_coffin_display_handle_prop {Hl}
              {{t}{r} {-\l_coffin_display_offset_tl}{-\l_coffin_display_offset_tl}}
\prop_put:Nnn \l_coffin_display_handle_prop {Hhc}
              {{t}{hc} {0pt}{-\l_coffin_display_offset_tl}}
\prop_put:Nnn \l_coffin_display_handle_prop {Hr}  {{t}{l}
              {\l_coffin_display_offset_tl}{-\l_coffin_display_offset_tl}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\prop_put:Nnn \l_coffin_display_handle_prop {vcl}
              {{b}{r} {-\l_coffin_display_offset_tl}{\l_coffin_display_offset_tl}}
\prop_put:Nnn \l_coffin_display_handle_prop {vchc}
              {{b}{hc} {0pt}{\l_coffin_display_offset_tl}}
\prop_put:Nnn \l_coffin_display_handle_prop {vcr}
              {{b}{l} {\l_coffin_display_offset_tl}{\l_coffin_display_offset_tl}}
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\l_coffin_display_prop}
%    
%    \begin{macrocode}
\prop_new:N \l_coffin_display_prop
%    \end{macrocode}
%  \end{macro}

%  \begin{macro}{\coffin_display_poles:Nn}
%    
%    This command adds a small square dot at all pole positions. As it uses
%    the coffins alignment mechanism to add all labels it will take notiable
%    time to execute.
%
%    Most likely only useful for documenting pole code so may get removed
%    and put into the documentation one day.
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box reference
%    \Argitem{2} color name to use on pole spots
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_display_poles:Nn #1#2 {
%    \end{macrocode}
%    First we save away the coffin data structure so that we can copy it back
%    later on after adding the labels.
%    \begin{macrocode}
    \coffin_set_eq_structure:NN \l_coffin_display_tmp_coffin #1
%    \end{macrocode}
%    The we make a copy of of the pole property list in and save it in
%    |\l_coffin_display_prop|.
%    \begin{macrocode}
    \prop_set_eq:Nc \l_coffin_display_prop
                    {l_coffin_poles_ \tex_number:D#1 _prop}
%    \end{macrocode}
%    We now have to built all intersections of all pole combinations that we
%    are interested in. We don't want the bounding box poles as they are
%    really only there for internal purposes:
%    \begin{macrocode}
    \prop_del:Nn \l_coffin_display_prop {bb:t}
    \prop_del:Nn \l_coffin_display_prop {bb:l}
    \prop_del:Nn \l_coffin_display_prop {bb:r}
    \prop_del:Nn \l_coffin_display_prop {bb:b}
%    \end{macrocode}
%    We also like to suppress |T|, |B|, and |b| poles if they all lie on top
%    of each other. We make life simple and just look if they are the same as
%    the |H| pole (which isn't exactly the same, but will work often enough
%    and if not, tough \ldots{} just built the documentation manually via
%    |\coffin_display_pole:Nnnn| in such a case).
%
%    We first retrieve the |H| pole and save it in |\l_coffin_pole_tl|. Then
%    we retrieve the pole to compare it with and save that in
%    |\l_coffin_tmpa_tl|. If they are identical we remove the pole from
%    consideration by deleting it from |\l_coffin_display_prop|
%    \begin{macrocode}
    \coffin_get_pole_coordinates:NnN #1 {H} \l_coffin_pole_tl
    \coffin_get_pole_coordinates:NnN #1 {T} \l_coffin_tmpa_tl
    \tl_if_eq:NNT \l_coffin_pole_tl \l_coffin_tmpa_tl
                  { \prop_del:Nn \l_coffin_display_prop {T} }
    \coffin_get_pole_coordinates:NnN #1 {B} \l_coffin_tmpa_tl
    \tl_if_eq:NNT \l_coffin_pole_tl \l_coffin_tmpa_tl
                  { \prop_del:Nn \l_coffin_display_prop {B} }
    \coffin_get_pole_coordinates:NnN #1 {b} \l_coffin_tmpa_tl
    \tl_if_eq:NNT \l_coffin_pole_tl \l_coffin_tmpa_tl
                  { \prop_del:Nn \l_coffin_display_prop {b} }
%    \end{macrocode}
%    To generate the labels we loop over the list of poles have now and for
%    each of these poles we run an inner loop of the same set of poles.
%    However that would unnecessarily give us all intersections twice, once as
%    $a,b$ and once as $b,a$. So to avoid that unnecessary work we shorten our
%    temporary pole property list each time so that less and less combinations
%    are tried. There are still too many as some of the combinations have no
%    intersection (e.g., |t,b|) but we deal with these cases later.
%    \begin{macrocode}
    \prop_map_inline:Nn \l_coffin_display_prop
      {
        \prop_del:Nn \l_coffin_display_prop {##1}
        \_coffin_display_poles:Nnnnnnn #1 {#2} {##1} ##2
      }
}
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{\l_coffin_x_dir_A_int,
%                \l_coffin_y_dir_A_int,
%                \l_coffin_y_dir_B_int,
%                \l_coffin_y_dir_B_int}
%    Pole direction vectors are stored with dimension (but when calculating
%    interesections we need some of them unitless to avoid the need for using l3calc.
%    \begin{macrocode}
\int_new:N \l_coffin_x_dir_A_int
\int_new:N \l_coffin_y_dir_A_int
\int_new:N \l_coffin_x_dir_B_int
\int_new:N \l_coffin_y_dir_B_int
%    \end{macrocode}
%  \end{macro}
%

%  \begin{macro}{\_coffin_display_poles:Nnnnnnn}
%    This command runs the inner loop for generating the pole combinations.
%    \begin{macrocode}
\cs_new:Npn \_coffin_display_poles:Nnnnnnn #1#2#3 #4#5#6#7 {
  \prop_map_inline:Nn \l_coffin_display_prop
    {
%    \end{macrocode}
%    The last four arguments are the vector values for the pole chosen in the
%    outer loop. We are interested in the values of the direction vector,
%    i.e., |#6| and |#7|, as we need those later on to decide of the second
%    pole chosen is parallel to the first one. As we have already too many
%    arguments we save the values (converted to integers) in two registers.
%    \begin{macrocode}
       \cs_set:Npn \_coffin_eval_pole_value:N ####1 {#6}
       \dim_set:Nn \l_coffin_tmpa_dim {\_coffin_eval_pole_value:N #1}
       \int_set:Nn \l_coffin_x_dir_A_int {\l_coffin_tmpa_dim}
       \cs_set:Npn \_coffin_eval_pole_value:N ####1 {#7}
       \dim_set:Nn \l_coffin_tmpa_dim {\_coffin_eval_pole_value:N #1}
       \int_set:Nn \l_coffin_y_dir_A_int {\l_coffin_tmpa_dim}
%    \end{macrocode}
%    The we call yet another helper which finally does the work. Its last four
%    arguments are the vector coordinates from the pole chosen by the inner
%    loop (as |##2|).
%    \begin{macrocode}
       \_coffin_display_poles:Nnnnnnnnn #1 {#2} {#3}{##1}  ##2
    }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
%
%  \begin{macro}{\_coffin_display_poles:Nnnnnnnnn}
%    
%    \begin{macrocode}
\cs_new:Npn \_coffin_display_poles:Nnnnnnnnn  #1#2 #3#4 #5#6#7#8 {
%    \end{macrocode}
%    Same game as before, we store the $x$ and $y$ component of the direction
%    vector in integer registers.
%    \begin{macrocode}
  \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#7}
  \dim_set:Nn \l_coffin_tmpa_dim {\_coffin_eval_pole_value:N #1}
  \int_set:Nn \l_coffin_x_dir_B_int {\l_coffin_tmpa_dim}
  \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#8}
  \dim_set:Nn \l_coffin_tmpa_dim {\_coffin_eval_pole_value:N #1}
  \int_set:Nn \l_coffin_y_dir_B_int {\l_coffin_tmpa_dim}
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*debug>
\typeout{ display=#3|#4:
         \int_use:N \l_coffin_x_dir_A_int,
         \int_use:N \l_coffin_y_dir_A_int,
         \int_use:N \l_coffin_x_dir_B_int,
         \int_use:N \l_coffin_y_dir_B_int}
%</debug>
%    \end{macrocode}
%    Now for the final part. We check if the two poles actually interesect
%    with each other and if not we ignore the combination. That would be the
%    case if the $x$ components of both vectors are $0$, or if the $y$
%    components of both vectors are $0$, or if the $y$ components are both
%    non-zero and the ratio of $x/y$ is identical for both
%    vectors.\footnote{something wrong with this boolean ... doesn't seem to
%    work in all cases - check, perhaps the known issue with "!" ... yes looks
%    like it, using the command form works ... needs fixing in kernel}
%    \begin{macrocode}
  \bool_if:nTF
     { 
          (   \intexpr_compare_p:nNn \l_coffin_x_dir_A_int = 0 
           && \intexpr_compare_p:nNn \l_coffin_x_dir_B_int = 0 )
       || (   \intexpr_compare_p:nNn \l_coffin_y_dir_A_int = 0 
           && \intexpr_compare_p:nNn \l_coffin_y_dir_B_int = 0 )
       || (    \bool_not_p:n{ \intexpr_compare_p:nNn \l_coffin_y_dir_A_int = 0 }
            && \bool_not_p:n{ \intexpr_compare_p:nNn \l_coffin_y_dir_B_int = 0 }
            && \intexpr_compare_p:nNn
               { \l_coffin_x_dir_A_int / \l_coffin_y_dir_A_int } =
               { \l_coffin_x_dir_B_int / \l_coffin_y_dir_B_int }
          )
     }
%    \end{macrocode}
%    If they interesect then we add a square dot (and potentially a
%    label). Two strategies, the commented out version just adds a dot and the
%    one currently used simply calls |\coffin_display_pole:Nnnn| so that adds
%    both dot and label.
%    \begin{macrocode}
     { \typeout{...ignored} }
     { \typeout{...typeset}
%      \hcoffin_set:Nn \l_coffin_spot_pole_coffin 
%                      { \color{#2}\rule{1pt}{1pt} }
%      \coffin_align_confine:NnnNnnnn #1 {#3}{#4}
%                       \l_coffin_spot_pole_coffin {vc}{hc} 
%                       {0pt} {0pt}
%      \coffin_set_eq_structure:NN #1 \l_coffin_display_tmp_coffin
       \coffin_display_pole:Nnnn #1{#3}{#4}{#2}
     }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
%
%
% \subsection{Handles}
%
%
% \subsubsection{Setting and retrieving handles}
%
%
%  \begin{macro}{\coffin_set_handle_coordinates:Nnn}
%    Store away the coordinates for a handle.
%    \begin{macrocode}
\cs_new:Npn \coffin_set_handle_coordinates:Nnn #1 #2 #3 {
%<*debug>
   \cs_display_args:Nnnn \coffin_set_handle_coordinates:Nnn {#1}{#2}{#3}
%</debug>
   \prop_put:cnn {l_coffin_handles_ \tex_number:D #1 _prop}
		 {#2} {#3}
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_generate_variant:Nn \coffin_set_handle_coordinates:Nnn { Nnx, NVV }
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{\coffin_get_handle_coordinates:NnN}
%    Retrieve the value for a handle or return |\q_no_value| if nothing is
%    present. Thus this command should always be followed by
%    |\quark_if_no_value:NTF| or else you might find yourself in a tight loop.
%    \begin{macrocode}
\cs_new:Npn \coffin_get_handle_coordinates:NnN #1  {
   \prop_get:cnN {l_coffin_handles_ \tex_number:D #1 _prop} 
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\coffin_get_existing_handle_coordinates:NnN}
%    Retrieve a handle value under the assumption something is stored. If not
%    bail out.
%    \begin{macrocode}
\cs_new:Npn \coffin_get_existing_handle_coordinates:NnN #1 #2 #3 {
   \coffin_get_handle_coordinates:NnN #1 {#2} #3
   \quark_if_no_value:NT #3 {\FATAL \tl_set:Nn #3 {{0pt}{0pt}}}
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\coffin_get_handle_xy_coordinates:Nn}
%    Yet another version: retrieve the value for a handle but return it
%    implicitly in |\l_coffin_offset_x_dim| and |\l_coffin_offset_y_dim|.
%    \begin{macrocode}
\cs_new:Npn \coffin_get_handle_xy_coordinates:Nn #1 #2  {
   \prop_get:cnN {l_coffin_handles_ \tex_number:D #1 _prop} {#2} 
                 \l_coffin_handle_tl 
   \quark_if_no_value:NT \l_coffin_handle_tl 
                         {\FATAL  
                          \tl_set:Nn \l_coffin_handle_tl {{0pt}{0pt}}}
   \exp_last_unbraced:No \coffin_set_x_y_dim:nn \l_coffin_handle_tl
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\coffin_set_x_y_dim:nn}
%    Simple helper to put the x/y components of a handles into two dimen
%    variables used all over the place as return values.
%    \begin{macrocode}
\cs_new:Npn \coffin_set_x_y_dim:nn #1#2 {
     \dim_set:Nn \l_coffin_intersect_x_dim {#1}
     \dim_set:Nn \l_coffin_intersect_y_dim {#2}
}      
%    \end{macrocode}
%  \end{macro}
%
% \subsubsection{Bounding box handles}
%
%
%  \begin{macro}{\coffin_update_outer_BB_handles:N}
%    Update the outer bounding box handles to the dimensions of the box. This
%    is used when rotating a box (the inner BB-handles then stay unchanged).
%    \begin{macrocode}
\cs_new:Npn  \coffin_update_outer_BB_handles:N #1 {
   \coffin_set_handle_coordinates:Nnx #1
		 {outer_BB_tl} {{0pt}{\dim_use:N\box_ht:N#1}}
   \coffin_set_handle_coordinates:Nnx #1
		 {outer_BB_tr} {{\dim_use:N \box_wd:N#1}{\dim_use:N\box_ht:N#1}}
   \coffin_set_handle_coordinates:Nnx #1
		 {outer_BB_br} {{\dim_use:N \box_wd:N#1}{-\dim_use:N\box_dp:N#1}}
   \coffin_set_handle_coordinates:Nnx #1
		 {outer_BB_bl} {{0pt}{-\dim_use:N\box_dp:N#1}}
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\coffin_update_BB_handles:N}
%    Update the outer and inner bounding box handles to the dimensions of the box.
%    \begin{macrocode}
\cs_new:Npn  \coffin_update_BB_handles:N #1 {
   \coffin_set_handle_coordinates:Nnx #1 
		 {BB_tl} {{0pt}{\dim_use:N \box_ht:N#1}}
   \coffin_set_handle_coordinates:Nnx #1
		 {BB_tr} {{\dim_use:N \box_wd:N#1}{\dim_use:N\box_ht:N#1}}
   \coffin_set_handle_coordinates:Nnx #1
		 {BB_br} {{\dim_use:N \box_wd:N#1}{-\dim_use:N\box_dp:N#1}}
   \coffin_set_handle_coordinates:Nnx #1
		 {BB_bl} {{0pt}{-\dim_use:N\box_dp:N#1}}
%    \end{macrocode}
%    For the outer ones we have already made a command.
%    \begin{macrocode}
   \coffin_update_outer_BB_handles:N #1
}
%    \end{macrocode}
%  \end{macro}
%
%
% \subsubsection{Tracing bounding box handles}
%
%
%  \begin{macro}{\coffin_display_BB:N}
%    
%    \begin{macrocode}
\cs_new:Npn \coffin_display_BB:N #1 {
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {BB_tl} \l_coffin_tmpa_tl
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {BB_tr} \l_coffin_tmpb_tl
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {BB_br} \l_coffin_tmpc_tl
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {BB_bl} \l_coffin_tmpd_tl
%<*trace>
  \typeout{Inner~BB:}
  \typeout{ \space tl= \l_coffin_tmpa_tl }
  \typeout{ \space tr= \l_coffin_tmpb_tl }
  \typeout{ \space br= \l_coffin_tmpc_tl }
  \typeout{ \space bl= \l_coffin_tmpd_tl }
%</trace>
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {outer_BB_tl} \l_coffin_tmpa_tl
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {outer_BB_tr} \l_coffin_tmpb_tl
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {outer_BB_br} \l_coffin_tmpc_tl
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {outer_BB_bl} \l_coffin_tmpd_tl
%<*trace>
  \typeout{Outer~BB:}
  \typeout{ \space tl= \l_coffin_tmpa_tl }
  \typeout{ \space tr= \l_coffin_tmpb_tl }
  \typeout{ \space br= \l_coffin_tmpc_tl }
  \typeout{ \space bl= \l_coffin_tmpd_tl }
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%
%

%  \begin{macro}{\coffin_print_BB:N}
%    
%    \begin{macrocode}
\cs_new:Npn \coffin_print_BB:N #1 {
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {BB_tl} \l_coffin_tmpa_tl
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {BB_tr} \l_coffin_tmpb_tl
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {BB_br} \l_coffin_tmpc_tl
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {BB_bl} \l_coffin_tmpd_tl

 \par\noindent\textbf{Inner~BB:}\\
  \hspace*{1em} \space tl= \l_coffin_tmpa_tl \\
  \hspace*{1em} \space tr= \l_coffin_tmpb_tl \\
  \hspace*{1em} \space br= \l_coffin_tmpc_tl \\
  \hspace*{1em} \space bl= \l_coffin_tmpd_tl 

  \coffin_get_existing_handle_coordinates:NnN
                  #1 {outer_BB_tl} \l_coffin_tmpa_tl
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {outer_BB_tr} \l_coffin_tmpb_tl
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {outer_BB_br} \l_coffin_tmpc_tl
  \coffin_get_existing_handle_coordinates:NnN
                  #1 {outer_BB_bl} \l_coffin_tmpd_tl

  \par\noindent\textbf{Outer~BB:}\\
  \hspace*{1em} \space tl= \l_coffin_tmpa_tl \\
  \hspace*{1em} \space tr= \l_coffin_tmpb_tl \\
  \hspace*{1em} \space br= \l_coffin_tmpc_tl \\
  \hspace*{1em} \space bl= \l_coffin_tmpd_tl 
  \par
}
%    \end{macrocode}
%  \end{macro}
%
%
% \subsection{Setting the content of a coffin}
%
%
%
%
%  \begin{macro}{\_latex_sbox:Nn}
%    Save away the original \LaTeX{} definition to make our life easier for now.
%    \begin{macrocode}
\cs_new_eq:NN \_latex_sbox:Nn \sbox
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\hcoffin_set:Nn}
%    
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} 
%    \Argitem{2} 
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_set:Npn \hcoffin_set:Nn #1#2 {
%    \end{macrocode}
%    Safeguard against using an ordinary box and reset the poles if the box
%    was previously used as a coffin:
%    \begin{macrocode}
   \coffin_add_or_reset_structure:N #1
%    \end{macrocode}
%    For now we simply call \LaTeX{}'s |\sbox| under a private name. This way
%    we can make |\sbox| point to |\hcoffin_set:Nn| if we wish to later.
%    \begin{macrocode}
   \_latex_sbox:Nn #1 {#2}
%    \end{macrocode}
%    Once we have set the content of the box we have to update the handles
%    pointing to the bounding box corners.
%    \begin{macrocode}
   \coffin_update_BB_handles:N #1
}
%    \end{macrocode}
%  \end{macro}
%

%
%
%  \begin{macro}{\vcoffin_set:Nnn}
%    
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} 
%    \Argitem{2} 
%    \Argitem{3} 
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn\vcoffin_set:Nnn #1#2#3 {
%<*debug>
   \cs_display_args:Nnnn \vcoffin_set:Nnn {#1}{#2}{#3}
%</debug>
%    \end{macrocode}
%    Safeguard against using an ordinary box and reset the poles if the box
%    was previously used as a coffin:
%    \begin{macrocode}
   \coffin_add_or_reset_structure:N #1
%    \end{macrocode}
%    Set the content as a vertical box.\footnote{This will probably need
%    updating to properly support color etc etc.}
%    \begin{macrocode}
   \vbox_set:Nn #1 {\dim_set:Nn \hsize {#2}
                     #3
%                    \endgraf \showthe\prevgraf
                   }
%    \end{macrocode}
%    Update the bounding box handles as necessary:
%    \begin{macrocode}
   \coffin_update_BB_handles:N #1
%    \end{macrocode}
%    To calculate the top baseline we need to reset the box and measure its
%    new height:
%    \begin{macrocode}
   \vbox_set_top:Nn \l_coffin_tmp_box {\vbox_unpack:N #1}
   \dim_set:Nn \l_coffin_tmpa_dim 
               {\box_ht:N #1 - \box_ht:N \l_coffin_tmp_box  }
%    \end{macrocode}
%    We then use the new value to set up the \texttt{T} pole.
%    \begin{macrocode}
   \tl_set:Nx \l_coffin_tmpa_tl
              { {0pt}{\dim_use:N \l_coffin_tmpa_dim} {1000sp}{0sp} }
   \coffin_set_pole_coordinates:NnV #1 {T} \l_coffin_tmpa_tl
%    \end{macrocode}
%    
%    The \texttt{B} pole is simpler, since it is the same as \texttt{H} and in
%    fact it should already be there in the default set.
%    \begin{macrocode}
%   \coffin_set_pole_coordinates:Nnn #1 {B} {{0pt}{0pt}{1000sp}{0sp}}
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_set_eq:NN}
%    Copy the content of one coffin to the next. Both arguments are assumed to
%    be coffins, i.e., there is no checking.
%    \begin{macrocode}
\cs_new:Npn \coffin_set_eq:NN #1#2 {
    \box_set_eq:NN #1 #2
    \coffin_set_eq_structure:NN #1 #2
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\coffin_set_eq_clear:NN}
%    Move the content of one coffin to the next. Afterwards the box will be
%    void and the property list of poles are reset to the default list.
%    Both arguments are assumed to
%    be coffins, i.e., there is no checking.
%    \begin{macrocode}
\cs_new:Npn \coffin_set_eq_clear:NN #1#2 {
    \box_set_eq_clear:NN #1 #2
    \coffin_set_eq_structure:NN #1 #2
    \coffin_reset_structure:N #2
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
% \subsection{Calculating the intersection between poles}
%
%
%
%
%
%
%
%  \begin{macro}{\l_coffin_intersect_x_dim,
%                \l_coffin_intersect_y_dim}
%    X- and y-coordinates of the intersection between two poles as calculated
%    by |\coffin_calculate_intersection:NN|.
%    \begin{macrocode}
\dim_new:N \l_coffin_intersect_x_dim
\dim_new:N \l_coffin_intersect_y_dim
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\l_coffin_x_A_fp,
%                \l_coffin_y_A_fp,
%                \l_coffin_y_B_fp,
%                \l_coffin_y_B_fp,
%                \l_coffin_x_dir_A_fp,
%                \l_coffin_y_dir_A_fp,
%                \l_coffin_y_dir_B_fp,
%                \l_coffin_y_dir_B_fp,
%                \l_coffin_result_fp,
%                \l_coffin_tmpa_fp,
%                \l_coffin_tmpb_fp}               }
%    To make the calculation of the intersection as accurate as possible we
%    convert the vector dimensions to fps.
%    \begin{macrocode}
\fp_new:N \l_coffin_x_A_fp
\fp_new:N \l_coffin_y_A_fp
\fp_new:N \l_coffin_x_B_fp
\fp_new:N \l_coffin_y_B_fp
\fp_new:N \l_coffin_x_dir_A_fp
\fp_new:N \l_coffin_y_dir_A_fp
\fp_new:N \l_coffin_x_dir_B_fp
\fp_new:N \l_coffin_y_dir_B_fp
%    \end{macrocode}
%    In |\l_coffin_result_fp| we collect the calculation result. The other two
%    variables are needed in formulas that in sub-formulas that we need to
%    precalculate prior to adding them up. 
%    \begin{macrocode}
\fp_new:N \l_coffin_result_fp
\fp_new:N \l_coffin_tmpa_fp
\fp_new:N \l_coffin_tmpb_fp
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_calculate_intersection:NN,
%                \coffin_calculate_intersection:nnnnnnnn}
%    
%    The comand takes two token list variables as argument which are expected
%    to contain four brace groups each (representing a pole), i.e., as you
%    will get out of |\coffin_get_pole_coordinates:NnN|. It calculates the
%    interesection between these poles and returns the result in the two dimen
%    variables |\l_coffin_intersect_x_dim| and |\l_coffin_intersect_y_dim|.
%
%    Right now it is not capable of calculating cases other than on 45 degree
%    values due to the fact that \TeX{} internal arithmetic is being used
%    (with too much rounding errors for other angles to be of any use.
%    For this one needs some proper fp support that does the calculations a
%    bit more precise.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_calculate_intersection:NN #1#2 {
%    \end{macrocode}
%    First we simply unpack the arguments.
%    \begin{macrocode}
      \exp_two_last_unbraced:Noo
      \coffin_calculate_intersection:nnnnnnnn #1#2 
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_new:Npn \coffin_calculate_intersection:nnnnnnnn #1#2#3#4 #5#6#7#8 { 
%<*debug>
   \cs_display_args:Nnnnnnnnn \coffin_calculate_intersection:nnnnnnnn
                              {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}
%</debug>
%    \end{macrocode}
%    Turn all components of the direction vectors to floating points via conversion
%    from dimen to |fp|s. This way we can
%    multiply and divide them with other dimen values.
%    \begin{macrocode}
  \fp_set_from_dim:Nn \l_coffin_x_dir_A_fp {#3}
  \fp_set_from_dim:Nn \l_coffin_y_dir_A_fp {#4}
  \fp_set_from_dim:Nn \l_coffin_x_dir_B_fp {#7}
  \fp_set_from_dim:Nn \l_coffin_y_dir_B_fp {#8}
%    \end{macrocode}
%    There are a number of special cases we need to take into account when
%    calculating the intersection.
%
%    The simplest cases are those where the direction vectors are either
%    horizontal or vertical.
%    \begin{macrocode}
  \fp_if_zero:NTF \l_coffin_x_dir_A_fp
%    \end{macrocode}
%    If |\l_coffin_x_dir_A_fp| is zero then the A-pole is vertical. Thus the
%    x-component of the intersection has to be at |#1|.
%    \begin{macrocode}
    {
      \dim_set:Nn \l_coffin_intersect_x_dim {#1}
%    \end{macrocode}
%    Now we test if the B-pole is also vertical and if so we complain. Of
%    course they may just lie on top of each other but that doesn't really
%    help us to find a single intersection.
%    \begin{macrocode}
      \fp_if_zero:NTF \l_coffin_x_dir_B_fp
        { \ERROR-no-intersection }
        {
%    \end{macrocode}
%    If not vertical it might be horizontal which would be the case if
%    |\l_coffin_y_dir_B_int| is zero.
%    \begin{macrocode}
          \fp_if_zero:NTF \l_coffin_y_dir_B_fp
%    \end{macrocode}
%    In that case the y-component of the intersection would simply be the
%    y-component of the B-pole, i.e., |#6| and we are done.
%    \begin{macrocode}
            {
             \dim_set:Nn \l_coffin_intersect_y_dim {#6}
            }
%    \end{macrocode}
%    If not, the y-component is given by the formula
%    \begin{equation}
%           y = \frac{d}{c}(x - a) + b \label{eq:y}
%    \end{equation}
%    if $(a,b,c,d)$ is representing our pole. For $x$ we have to put in the
%    already calculated x-component |#1| which gives us
%    \begin{macrocode}
            {
             \fp_set_from_dim:Nn \l_coffin_result_fp {#1}
             \fp_set_from_dim:Nn \l_coffin_x_B_fp {#5}
             \fp_set_from_dim:Nn \l_coffin_y_B_fp {#6}

             \fp_sub:Nn  \l_coffin_result_fp \l_coffin_x_B_fp
             \fp_div:Nn  \l_coffin_result_fp \l_coffin_x_dir_B_fp
             \fp_mul:Nn \l_coffin_result_fp \l_coffin_y_dir_B_fp
             \fp_add:Nn  \l_coffin_result_fp \l_coffin_y_B_fp

             \dim_set:Nn \l_coffin_intersect_y_dim
                         {\fp_use:N \l_coffin_result_fp pt}
            }
        }
    }
%    \end{macrocode}
%    That concludes the case where the A-pole is vertical. If it wasn't then
%    we should check if it is horizontally oriented.
%    \begin{macrocode}
    {
      \fp_if_zero:NTF \l_coffin_y_dir_A_fp
      {
%    \end{macrocode}
%    If that's the case the the process is similar but with x- and y-
%    component exchanged, i.e, that determines now the y-component of the
%    intersection and we have to check the direction of the B-pole to see if
%    it too is  horizontal:
%    \begin{macrocode}
        \dim_set:Nn \l_coffin_intersect_y_dim {#2}
        \fp_if_zero:NTF \l_coffin_y_dir_B_fp
          { \ERROR-no-intersection }
%    \end{macrocode}
%    If not it might be vertical which now is the easy case.
%    \begin{macrocode}
          { \fp_if_zero:NTF \l_coffin_x_dir_B_fp
               {
                 \dim_set:Nn \l_coffin_intersect_x_dim { #5 }
               }
%    \end{macrocode}
%    An if it is neither vertical nor horizontal we the following formula this
%    time:
%    \begin{equation}
%           x = \frac{c}{d}(y - b) + a    \label{eq:x}
%    \end{equation}
%    Using |#2| for $y$ then gives:
%    \begin{macrocode}
               {
                \fp_set_from_dim:Nn \l_coffin_result_fp {#2}
                \fp_set_from_dim:Nn \l_coffin_x_B_fp {#5}
                \fp_set_from_dim:Nn \l_coffin_y_B_fp {#6}

                \fp_sub:Nn  \l_coffin_result_fp \l_coffin_y_B_fp
                \fp_div:Nn  \l_coffin_result_fp \l_coffin_y_dir_B_fp
                \fp_mul:Nn \l_coffin_result_fp \l_coffin_x_dir_B_fp
                \fp_add:Nn  \l_coffin_result_fp \l_coffin_x_B_fp
 
                \dim_set:Nn \l_coffin_intersect_x_dim
                            {\fp_use:N \l_coffin_result_fp pt}
               }
          }
      }
%    \end{macrocode}
%    The most complicated case is the one where both direction vectors have a
%    direction other than horizontal or vertical.
%
%    But so far we only know that A is somewhat diagonal.
%    \begin{macrocode}
      {
%    \end{macrocode}
%    So let's test if B is vertical and if so use the same kind of formula as
%    above, i.e., equation~\ref{eq:y} with $x=\texttt{\#5}$.
%    \begin{macrocode}
        \fp_if_zero:NTF \l_coffin_x_dir_B_fp
          {
            \dim_set:Nn \l_coffin_intersect_x_dim { #5 }

            \fp_set_from_dim:Nn \l_coffin_x_A_fp {#1}
            \fp_set_from_dim:Nn \l_coffin_y_A_fp {#2}
            \fp_set_from_dim:Nn \l_coffin_result_fp {#5}

            \fp_sub:Nn  \l_coffin_result_fp \l_coffin_x_A_fp
            \fp_div:Nn  \l_coffin_result_fp \l_coffin_x_dir_A_fp
            \fp_mul:Nn \l_coffin_result_fp \l_coffin_y_dir_A_fp
            \fp_add:Nn  \l_coffin_result_fp \l_coffin_y_A_fp

            \dim_set:Nn \l_coffin_intersect_y_dim
                        {\fp_use:N \l_coffin_result_fp pt}
          }
          {
%    \end{macrocode}
%    Otherwise it might be horizontal and if so we use \ref{eq:x} with
%    $y=\texttt{\#6}$.
%    \begin{macrocode}
           \fp_if_zero:NTF \l_coffin_y_dir_B_fp
	    {
	      \dim_set:Nn \l_coffin_intersect_y_dim { #6 }

              \fp_set_from_dim:Nn \l_coffin_x_A_fp {#1}
              \fp_set_from_dim:Nn \l_coffin_y_A_fp {#2}
              \fp_set_from_dim:Nn \l_coffin_result_fp {#6}

              \fp_sub:Nn  \l_coffin_result_fp \l_coffin_y_A_fp
              \fp_div:Nn  \l_coffin_result_fp \l_coffin_y_dir_A_fp
              \fp_mul:Nn \l_coffin_result_fp \l_coffin_x_dir_A_fp
              \fp_add:Nn  \l_coffin_result_fp \l_coffin_x_A_fp

              \dim_set:Nn \l_coffin_intersect_x_dim
                          {\fp_use:N \l_coffin_result_fp pt}
	    }
            {
%    \end{macrocode}
%    If not, we have the case that neither vector is horizontal or
%    vertical. But it is still possible that both vectors are parallel in
%    which case we have no intersection (or the lines are on top of each
%    other). This is the case when
% \begin{equation}
%      \frac{d}{c} - \frac{d'}{c'} = 0
% \end{equation}
%    So let's store the left hand side in an fp register and then check
%    if it is zero. If so we signal another error, otherwise we use that
%    calculated value later in the final formula for $x$.
%    \begin{macrocode}
              \fp_set_eq:NN \l_coffin_tmpa_fp \l_coffin_y_dir_A_fp
              \fp_div:Nn    \l_coffin_tmpa_fp \l_coffin_x_dir_A_fp

              \fp_set_eq:NN \l_coffin_result_fp \l_coffin_y_dir_B_fp
              \fp_div:Nn    \l_coffin_result_fp \l_coffin_x_dir_B_fp

              \fp_sub:Nn \l_coffin_tmpa_fp \l_coffin_result_fp

              \fp_if_zero:NTF \l_coffin_tmpa_fp
                 { \ERROR-no-intersection }
%    \end{macrocode}
%    \begin{equation}
%  x = \frac { a \frac{d}{c} - a'\frac{d'}{c'} - b + b' }
%            { \frac{d}{c} - \frac{d'}{c'} }
%     \end{equation}
%    \begin{macrocode}
                 {
		   \fp_set_from_dim:Nn \l_coffin_result_fp {#1}
		   \fp_set_from_dim:Nn \l_coffin_y_A_fp {#2}
		   \fp_set_from_dim:Nn \l_coffin_x_B_fp {#5}
		   \fp_set_from_dim:Nn \l_coffin_y_B_fp {#6}

                   \fp_div:Nn  \l_coffin_result_fp \l_coffin_x_dir_A_fp
                   \fp_mul:Nn \l_coffin_result_fp \l_coffin_y_dir_A_fp

                   \fp_set_eq:NN \l_coffin_tmpb_fp \l_coffin_x_B_fp
                   \fp_div:Nn    \l_coffin_tmpb_fp \l_coffin_y_dir_B_fp
                   \fp_mul:Nn   \l_coffin_tmpb_fp \l_coffin_x_dir_B_fp

                   \fp_sub:Nn  \l_coffin_result_fp \l_coffin_tmpb_fp
                   \fp_add:Nn  \l_coffin_result_fp \l_coffin_y_B_fp
                   \fp_sub:Nn  \l_coffin_result_fp \l_coffin_y_A_fp

                   \fp_div:Nn  \l_coffin_result_fp \l_coffin_tmpa_fp

		   \dim_set:Nn \l_coffin_intersect_x_dim
                               {\fp_use:N \l_coffin_result_fp pt}
%    \end{macrocode}
%    The $y$ part is again given by equation~\ref{eq:y} with
%    |\l_coffin_intersect_x_dim| used as $x$ value.
%    \begin{macrocode}

                   \fp_sub:Nn  \l_coffin_result_fp \l_coffin_x_B_fp
                   \fp_div:Nn  \l_coffin_result_fp \l_coffin_x_dir_B_fp
                   \fp_mul:Nn  \l_coffin_result_fp \l_coffin_y_dir_B_fp
                   \fp_add:Nn  \l_coffin_result_fp \l_coffin_y_B_fp

		   \dim_set:Nn \l_coffin_intersect_y_dim
                               {\fp_use:N \l_coffin_result_fp pt}
                 }
            }
          }
      }
    }
%<*debug>
\typeout{Intersection~ at:~ 
         ( \dim_use:N\l_coffin_intersect_x_dim ,
           \dim_use:N\l_coffin_intersect_y_dim  ) }
%</debug>
}

%    \end{macrocode}
%  \end{macro}
%
%
%
% \subsection{Aligning coffins}
%
%
%
%
%  \begin{macro}{\l_coffin_aligned_coffin}
%    This is a scratch coffin we use later to store intermediate results when
%    aligning coffins.
%    \begin{macrocode}
\coffin_new:N \l_coffin_aligned_coffin
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_align_boxes:nnnnNNnnN}
%
%    This helper command aligns two boxes (need not be coffins) given specific
%    specific alignment points (as offset from the normal reference point of
%    the box) and some x/y offset to use between the alignment points.
%
%    The bounding box of the whole construction is \ldots{} whatever it is
%    (height and depth are Ok, but all horizontal stuff is somewhat
%    arbitrary), thus this box register is not, typically, very useful without
%    further work on the horizontal positioning and size.  There are various
%    possibilities for these refinements, these are explored in the top-level
%    commands defined later on.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} x-offset box-A (can be a formula coming from a coffin
%                pole specification)
%    \Argitem{2} y-offset box-A (can be a formula)
%    \Argitem{3} x-offset box-B (can be a formula)
%    \Argitem{4} y-offset box-B (can be a formula)
%    \Argitem{5} box register reference for box-A (single token)
%    \Argitem{6} box register reference for box-B (single token)
%    \Argitem{7} x-offset between alignment points (can be a formula)
%    \Argitem{8} y-offset between alignment points (can be a formula)
%    \Argitem{9} box register reference for result box (single token)
%    \end{Arglist}
%    The result is stored in a new box (\#9) which is turned into a coffin and
%    add the original poles from box-A (with their formulas) available as
%    \texttt{\meta{pole}}. Other poles, referring to box-A and box-Bas
%    absolute coordinates (via \texttt{\meta{box-A}-\meta{pole}}) need to
%    wait until we know how the bounding box has been calculated.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_align_boxes:nnnnNNnnN #1#2 #3#4 #5#6 #7#8 #9 {
%<*trace>
   \cs_display_args:Nnnnnnnnnn \coffin_align_boxes:nnnnNNnnN 
                               {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}
%</trace>
%    \end{macrocode}
%    First calulate the final offset between the two box reference points used
%    by \TeX:
%    \begin{macrocode}
  \dim_set:Nn \l_coffin_offset_x_dim{(#1)+(#7)-(#3)}
  \dim_set:Nn \l_coffin_offset_y_dim{(#2)+(#8)-(#4)}
%    \end{macrocode}
%    Then put the aligned boes into the result box by\ldots
%    \begin{macrocode}
    \hbox_set:Nn #9 {
%    \end{macrocode}
%    \ldots first setting box-A and doing a backup by its width which brings
%    us back to the reference point of box-A.
%    \begin{macrocode}
      \box_use:N #5
      \tex_kern:D -\box_wd:N #5 
%    \end{macrocode}
%    Then move horizontally by the calulated x-offset and place box-B with its
%    reference point raised by the calulated y-offset. (The two horizontal
%    |\tex_kern:D| movements could be combined to save a bit space, but we
%    need the |\l_coffin_offset_x_dim| later again so we don't bother.
%    \begin{macrocode}
      \tex_kern:D \l_coffin_offset_x_dim
      \box_move_up:nn \l_coffin_offset_y_dim {\box_use:N #6 }
    }
%    \end{macrocode}
%    Final step is to turn the result box into a coffin with the right kind of
%    poles attached.
%
%    If the box is already a coffin we reset to default to get a clean state,
%    otherwise we add the defaults.
%    \begin{macrocode}
   \coffin_add_or_reset_structure:N #9
%    \end{macrocode}
%    What we can't yet do at this point is adding explicit poles that refer
%    back to the individual poles from box-A and box-B via
%    \texttt{\meta{box-B}-\meta{pole}}. This isn't possible, as we don't know
%    yet where the final reference point of the result box will lie as this
%    depends on they way we handle the bounding box later on. So we have have
%    to wait with this using the values of |\l_coffin_offset_x_dim| and
%    |\l_coffin_offset_y_dim| that we have calculated above. we will then also
%    recalculate \texttt{T} and \texttt{B} poles to denote the top and bottom
%    baseline positions.
%    \begin{macrocode}
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_align_two_coffins:NnnNnnnnN}
%    
%    This helper command alligns two coffins at their pole with a specific
%    offset between them and saves the result in a third coffin.
%    
%    Just like |\coffin_align_boxes:nnnnNNnnN| on which this is based the
%    bounding box is unusable without further correction.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \Argitem{9} target box register for saving
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_align_two_coffins:NnnNnnnnN #1#2#3#4#5#6#7#8#9 {
%<*debug>
   \cs_display_args:Nnnnnnnnnn \coffin_align_two_coffins:NnnNnnnnN
                               {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}
%</debug>
%    \end{macrocode}
%    
%    \begin{macrocode}
  \coffin_retrieve_or_calculate_intersection:Nnn #1 {#2}{#3}
  \tl_set:Nx \l_coffin_align_coordinates_tl  
             { { \dim_use:N \l_coffin_intersect_x_dim }
               { \dim_use:N \l_coffin_intersect_y_dim } }
%    \end{macrocode}
%    Then we do the same with the second box.
%    \begin{macrocode}
  \coffin_retrieve_or_calculate_intersection:Nnn #4 {#5}{#6}
%    \end{macrocode}
%    But here we append the result to |\l_coffin_align_coordinates_tl|, thus
%    it is now holding four brace groups with the coordinates of both
%    intersections.
%    \begin{macrocode}
  \tl_put_right:Nx \l_coffin_align_coordinates_tl  
                   { { \dim_use:N \l_coffin_intersect_x_dim }
                     { \dim_use:N \l_coffin_intersect_y_dim } }

%    \end{macrocode}
%    By expanding |\l_coffin_align_coordinates_tl| prior to calling
%    |\coffin_align_boxes:nnnnNNnnN| this command will then see all
%    coordinates as its first four arguments:
%    \begin{macrocode}
  \exp_last_unbraced:No
  \coffin_align_boxes:nnnnNNnnN 
                      \l_coffin_align_coordinates_tl 
                      #1 #4 {#7} {#8} #9
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_retrieve_or_calculate_intersection:Nnn}
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference box
%    \Argitem{2} pole name A
%    \Argitem{3} pole name B
%    \end{Arglist}
%
%    Look if we have a handle formed from the two poles precompiled and if not
%    calculate the intersection between the poles and save it as a new handle.
%    Return the intersection x/y components in the two dimen variables
%    |\l_coffin_offset_x_dim| and |\l_coffin_offset_y_dim|.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_retrieve_or_calculate_intersection:Nnn #1#2#3 {
%<*debug>
   \cs_display_args:Nnnn \coffin_retrieve_or_calculate_intersection:Nnn {#1}{#2}{#3}
%</debug>
%    \end{macrocode}
%    If we can get at the intersection as a precompiled handle we use that
%    otherwise we compile the intersection and save it as a new handle.
%    \begin{macrocode}
  \coffin_get_handle_coordinates:NnN #1{#2#3}\l_coffin_handle_tl
  \quark_if_no_value:NTF \l_coffin_handle_tl
     {
%    \end{macrocode}
%    No handle around so we compile:
%    First we retrieve the pole coordinates from the two poles from the box.
%    \begin{macrocode}
      \coffin_get_pole_coordinates:NnN #1{#3}\l_coffin_tmpa_tl
      \coffin_get_pole_coordinates:NnN #1{#2}\l_coffin_tmpb_tl
%    \end{macrocode}
%    Then we calculate the intersection and write the result into
%    |\l_coffin_align_coordinates_tl|. The coordinates of interesection is
%    later used to align the box.
%    \begin{macrocode}
     \coffin_calculate_intersection:NN \l_coffin_tmpa_tl
                                       \l_coffin_tmpb_tl
%    \end{macrocode}
%    This now brings us into a position to save away the result as a new handle
%    \begin{macrocode}
     \coffin_set_handle_coordinates:Nnx#1 {#2#3}
                { { \dim_use:N\l_coffin_intersect_x_dim }
                  { \dim_use:N\l_coffin_intersect_y_dim } }
    }
%    \end{macrocode}
%    If the handle is there all we need to do is to take its value apart and
%    save in our return dimen variables.
%    \begin{macrocode}
    {
      \exp_last_unbraced:No
      \coffin_set_x_y_dim:nn \l_coffin_handle_tl
    }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
%
%
%
%  \begin{macro}{\coffin_align_confine_save:NnnNnnnnN}
%    
%    This commmand aligns two coffins at their poles with a certain offset
%    inbetween. The result is stored in a third coffin (with poles
%    from both coffins added as \texttt{\meta{box}-\meta{pole}}). Note that
%    the arguments are ordered differently compared to the internal helper
%    commands for coffin alignment
%
%    The resulting bounding box is clipped to the dimensions of the first
%    coffin (box-A), that is the second coffin may overlap surrounding text.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \Argitem{9} target box register for saving
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn\coffin_align_confine_save:NnnNnnnnN #1#2#3#4#5#6#7#8#9{%
%    \end{macrocode}
%    First we call the helper command to align the coffins.
%    \begin{macrocode}
  \coffin_align_two_coffins:NnnNnnnnN #1 {#2}{#3}  #4 {#5}{#6} {#7}{#8} #9 
%    \end{macrocode}
%    Then we correct the bounding box data, restricting it to the values from
%    box-A.\footnote{Issue: l3box doesn't have commands for setting box
%    dimensions, so for now we go low-level}.
%    \begin{macrocode}
  \box_ht:N #9 \box_ht:N #1
  \box_wd:N #9 \box_wd:N #1
  \box_dp:N #9 \box_dp:N #1
%    \end{macrocode}
%    Finally we also make the poles from the original coffins available: they
%    can be accessed using ``\meta{box-reference}-\meta{pole}'', for
%    example, |\aaa-T| if |\aaa| is the reference for one of the
%    coffins.
%
%    For this we have to shift the pole values by the offset used in the
%    alignment (stored by |\coffin_align_two_coffins:NnnnNnN| in two dimen
%    variables). We also change any formula used into real values, so that we
%    can free up the coffin content afterwards.
%
%    The first box doesn't have any offset.
%    \begin{macrocode}
   \coffin_save_structure_values_with_offset:NnnN #1 {0pt}{0pt} #9
%    \end{macrocode}
%    But the second one does:
%    \begin{macrocode}
   \coffin_save_structure_values_with_offset:NnnN #4 
                                             \l_coffin_offset_x_dim
                                             \l_coffin_offset_y_dim
                                             #9
%    \end{macrocode}
%    At this point we can now recalulate \texttt{T} and \texttt{B} poles for
%    the result box.
%    \begin{macrocode}
   \coffin_update_T_B_poles:NNN #1 #4 #9
%    \end{macrocode}
%    
%    At this point  we could free up the coffin/box content of box-B (not done
%    yet).\footnote{Issue?}
%    \begin{macrocode}
%    \end{macrocode}
%    Finally show the resulting poles when tracing:
%    \begin{macrocode}
%<*trace>
   \coffin_show_structure:N #9
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\coffin_align_save:NnnNnnnnN}
%    
%    This commmand aligns two coffins at their poles with a certain offset
%    inbetween. The result is stored in a third coffin (with poles
%    from both coffins added as \texttt{\meta{box}-\meta{pole}}). Note that
%    the arguments are ordered differently compared to the internal helper
%    commands for coffin alignment
%
%    The resulting bounding box is clipped to the dimensions of the first
%    coffin (box-A), that is the second coffin may overlap surrounding text.
%
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \Argitem{9} target box register for saving
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn\coffin_align_save:NnnNnnnnN #1#2#3#4#5#6#7#8#9{
%<*debug>
   \cs_display_args:Nnnnnnnnnn \coffin_align_save:NnnNnnnnN
                               {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}
%</debug>
%    \end{macrocode}
%    First we call the helper command to align the coffins.
%    \begin{macrocode}
  \coffin_align_two_coffins:NnnNnnnnN #1 {#2}{#3}  #4 {#5}{#6} {#7}{#8} #9 
%    \end{macrocode}
%    Then we have to do a bit more than just changing the box dimensions: we
%    actually have to build a new box with additional kerns to the left and/or
%    right of, at least if we have to move the
%    reference point of the result box to the left of the reference point of
%    box-A (which happens if box-B sticks out to the left of box-A).
%    \begin{macrocode}
   \hbox_set:Nn #9 {
    \dim_compare:nNnT \l_coffin_offset_x_dim < \c_zero_dim
%    \end{macrocode}
%    Okay, so if |\l_coffin_offset_x_dim| is negative the reference point of
%    box-B is to the left of box-A. Thus by starting our box with a horizontal
%    shift of |-\l_coffin_offset_x_dim| we  effectively start with the
%    reference point at the left edge.
%    \begin{macrocode}
         { \tex_kern:D -\l_coffin_offset_x_dim }
%    \end{macrocode}
%    Then we unpack the box holding the aligned coffins (we can use unpacking
%    as that will not change the sizes but avoids one unnecessay box level).
%    \begin{macrocode}
    \hbox_unpack_clear:N #9
%    \end{macrocode}
%    To get the right side of the box correct we also may have to add some
%    kern. Right now our box ends at the right side of box-B. Thus, if box-A
%    extends further to the right we have to account for that. This can be
%    achieved by adding to |\l_coffin_offset_x_dim| the width of box-B (which
%    gives us the horizontal size of box |#9|) and substract the width of
%    box-A. If the result is negative this means that box-A sticks out  to the
%    right by that amount. Therefore we have to add a corresponding kern in
%    that case. Deep breath!
%    \begin{macrocode}
    \dim_set:Nn \l_coffin_tmpa_dim { \l_coffin_offset_x_dim 
                                      + \box_wd:N #4 - \box_wd:N #1 }
    \dim_compare:nNnT \l_coffin_tmpa_dim < \c_zero_dim
                      { \tex_kern:D -\l_coffin_tmpa_dim }
  }
%    \end{macrocode}
%    What remains to be done is to add the explicit poles to the inner
%    boxes. Now that we know whether or not the reference point of the result
%    box got moved or not we are ready to go. We just need to check again if
%    |\l_coffin_offset_x_dim| is negative. (It isn't possible to use the test
%    earlier inside the box construction as that would mean the pole updates
%    would only live until the end of the box contruction.)
%    \begin{macrocode}
  \dim_compare:nNnTF \l_coffin_offset_x_dim < \c_zero_dim
%    \end{macrocode}
%    Here the reference point got moved so we need to shift things to the
%    left:
%    \begin{macrocode}
         { 
           \coffin_save_structure_values_with_offset:NnnN
                  #1 {-\l_coffin_offset_x_dim} {0pt} #9
           \coffin_save_structure_values_with_offset:NnnN
                  #4 {0pt} \l_coffin_offset_y_dim    #9
         }
%    \end{macrocode}
%    And if the reference point for the result box doesn't change then we have
%    the following offsets to use:
%    \begin{macrocode}
         {
           \coffin_save_structure_values_with_offset:NnnN
                  #1 {0pt}{0pt} #9
           \coffin_save_structure_values_with_offset:NnnN
                  #4 \l_coffin_offset_x_dim
                     \l_coffin_offset_y_dim #9
         }
%    \end{macrocode}
%    At this point we can now recalulate \texttt{T} and \texttt{B} poles for
%    the result box.
%    \begin{macrocode}
   \coffin_update_T_B_poles:NNN #1 #4 #9
%    \end{macrocode}
%    At this point  we could free up the coffin/box content of box-B (not done
%    yet).\footnote{Issue?}
%    \begin{macrocode}
%    \end{macrocode}
%    Finally show the resulting poles when tracing:
%    \begin{macrocode}
%<*trace>
   \coffin_show_structure:N #9
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_save_structure_values_with_offset:NnnN}
%
%    This command takes the poles from box-A, calculates their numerical
%    value, offsets them by some x/y-offset and then writes a new pole with
%    the name \texttt{\meta{box-A}-\meta{pole}} and stores it as a pole
%    for box-B.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box-A reference used as source to build new structure values
%    (poles and handles)
%    \Argitem{2} x-offset
%    \Argitem{3} y-offset
%    \Argitem{4} box-B reference receiving updated poles and handles
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_save_structure_values_with_offset:NnnN #1 #2#3 #4 {
%<*debug>
   \cs_display_args:Nnnnn \coffin_save_structure_values_with_offset:NnnN
                         {#1}{#2}{#3}{#4}
%</debug>
%    \end{macrocode}
%    We map some inline code over the pole property lists of box-A to
%    retrieve the poles and calculate the new ones.
%    \begin{macrocode}
   \prop_map_inline:cn {l_coffin_poles_ \tex_number:D #1 _prop}
      {
%    \end{macrocode}
%    The actual work is done by a helper command which receives all necessary
%    values as separate arguments. Horizontal poles get the y-offset added
%    (|#3|). 
%    \begin{macrocode}
        \coffin_save_pole_values_with_offset:NnnnnnnnN #1 {##1} ##2 {#2}{#3} #4
      }
%    \end{macrocode}
%    
%    \begin{macrocode}
   \prop_map_inline:cn {l_coffin_handles_ \tex_number:D #1 _prop}
      {
        \coffin_save_handle_values_with_offset:NnnnnnN #1 {##1} ##2 {#2}{#3} #4
      }
%    \end{macrocode}
%    Some debugging code to verify the results:
%    \begin{macrocode}
%<*debug>
    \coffin_show_structure:N #4
%</debug>
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_save_pole_values_with_offset:NnnnnnnnN}
%    
%    This command takes explicit values for a single pole from box-A,
%    calculates the numerical 
%    values, offsets them by the x/y-offset and then writes a new pole with
%    the name \texttt{\meta{box-A}-\meta{pole}} stored  as a pole
%    for box-B.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box-A reference used as source to build new pole list
%    \Argitem{2} pole direction
%    \Argitem{3} pole name
%    \Argitem{4} pole value
%    \Argitem{5} extra offset
%    \Argitem{6} box-B reference receiving updated pole
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_save_pole_values_with_offset:NnnnnnnnN #1#2 #3#4#5#6 #7#8#9 {
%<*debug>
   \cs_display_args:Nnnnnnnnnn \coffin_save_pole_values_with_offset:NnnnnnnnN
                               {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}
%</debug>
%    \end{macrocode}
%    The value of the pole might involve a formula (such as |\box_wd:N ##1|), so
%    to calculate the numerical value we have to resolve this. This is done by
%    defining a scratch command with one argument (receiving the box-A) and
%    the pole ``formula'' as replacement text---if that replacement text is
%    already numerical, no harm will be done.
%    \begin{macrocode}
    \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#3}
%    \end{macrocode}
%    We then calculate the new absolute position for the pole as follows:
%    \begin{macrocode}
    \dim_set:Nn \l_coffin_tmpa_dim {\_coffin_eval_pole_value:N #1 + #7}
%    \end{macrocode}
%    Thus |\l_coffin_tmpa_dim| now hold the x-value including the offset.
%
%    In the same way we store in |\l_coffin_tmpb_dim| the new y-value:
%    \begin{macrocode}
    \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#4}
    \dim_set:Nn \l_coffin_tmpb_dim {\_coffin_eval_pole_value:N #1 + #8}
%    \end{macrocode}
%    In order to put the new values back into the pole, we need to combine
%    them with the direction vector |#5,#6| which stays unchanged.
%    \begin{macrocode}
    \tl_set:Nx \l_coffin_pole_tl { {\dim_use:N \l_coffin_tmpa_dim }
                                   {\dim_use:N \l_coffin_tmpb_dim }
                                   {#5}{#6}
                                 }
%    \end{macrocode}
%    To build the new pole name we have to distinuish two cases: a) this is
%    a native pole of box-A, either one of the default poles or one
%    explicitly build by the user and b) it is a derived pole which was
%    added to box-A as the result of aligning two coffins earlier.
%
%    In the latter case the name will be of the form
%    \texttt{\meta{somebox}-\meta{pole}} and in this cases we simply leave it
%    alone, otherwise we build the name as
%    \texttt{\meta{box-A}-\meta{pole}}. 
%
%    Consequence of this is that user defined pole names better not contain
%    a ``\texttt{-}'' and that one can't align the same coffin several times
%    to some other coffin without loosing the poles (as the second alignment
%    will overwrite the poles from the first). However, this approach makes
%    poles from inner coffins in alignment operations available later on
%    without any dependency on the order the alignment happened. If we would
%    unconditionally prepend \texttt{\meta{box-A}-} all poles would be
%    uniquely identifiable, but their name would depend on the order the
%    alignment happend which would be a very bad idea.
%    \begin{macrocode}
    \tl_if_in:nnTF {#2} {-} 
          { \tl_set:Nx \l_coffin_tmpa_tl { #2 }     }
          { \tl_set:Nx \l_coffin_tmpa_tl { #1-#2 }  }
%    \end{macrocode}
%    Now we are ready to put the new pole into box-B's property list.
%    \begin{macrocode}
    \coffin_set_pole_coordinates:NVV #9 
                  \l_coffin_tmpa_tl \l_coffin_pole_tl
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_save_handle_values_with_offset:NnnnnnN}
%    
%    \begin{macrocode}
\cs_new:Npn \coffin_save_handle_values_with_offset:NnnnnnN #1#2 #3#4 #5#6#7 {
   \cs_display_args:Nnnnnnnn \coffin_save_handle_values_with_offset:NnnnnnN
                               {#1}{#2}{#3}{#4}{#5}{#6}{#7}

% there should be no need to eval for handles !!! - check

    \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#3}
    \dim_set:Nn \l_coffin_tmpa_dim {\_coffin_eval_pole_value:N #1 + #5}
    \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#4}
    \dim_set:Nn \l_coffin_tmpb_dim {\_coffin_eval_pole_value:N #1 + #6}
    \tl_set:Nx \l_coffin_pole_tl { {\dim_use:N \l_coffin_tmpa_dim }
                                   {\dim_use:N \l_coffin_tmpb_dim }
                                  
                                 }
    \tl_if_in:nnTF {#2} {-}
          { \tl_set:Nx \l_coffin_tmpa_tl { #2 }     }
          { \tl_set:Nx \l_coffin_tmpa_tl { #1-#2 }  }
    \coffin_set_handle_coordinates:NVV #7
                  \l_coffin_tmpa_tl \l_coffin_pole_tl
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%  \begin{macro}{\coffin_update_T_B_poles:NNN}
%
%    This command calulates new values for \texttt{T} and \texttt{B} poles for
%    the result box by comparing the corresponding values the the coffins used
%    in an alignment and choosing the larger (or smaller) value, respectively.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} reference to box-A
%    \Argitem{2} reference to box-B
%    \Argitem{3} reference to result box
%    \end{Arglist}
%
%    The assumption is that the result box already contains the poles from
%    box-A and box-B in the form \texttt{\meta{box}-\meta{pole}}.
%    
%    \begin{macrocode}
\cs_new:Npn \coffin_update_T_B_poles:NNN #1#2#3 {
%    \end{macrocode}
%    Get the \texttt{T} poles for box-A and box-B out of the result box:
%    \begin{macrocode}
    \coffin_get_pole_coordinates:NnN #3 {#1-T} \l_coffin_tmpa_tl
    \coffin_get_pole_coordinates:NnN #3 {#2-T} \l_coffin_tmpb_tl

    \exp_two_last_unbraced:Noo
    \coffin_update_T_pole:nnnnnnnnN
             \l_coffin_tmpa_tl \l_coffin_tmpb_tl #3

    \coffin_get_pole_coordinates:NnN #3 {#1-B} \l_coffin_tmpa_tl
    \coffin_get_pole_coordinates:NnN #3 {#2-B} \l_coffin_tmpb_tl

    \exp_two_last_unbraced:Noo
    \coffin_update_B_pole:nnnnnnnnN
             \l_coffin_tmpa_tl \l_coffin_tmpb_tl #3
}

\cs_new:Npn \coffin_update_T_pole:nnnnnnnnN  #1#2#3#4#5#6#7#8#9 {
%    \end{macrocode}
%    Compare the values and if the one from box-B is larger use its value,
%    otherwise the one from box-A.
%    
%    Note that this gets rather arbitrary if the \texttt{T} poles are are no
%    longer horizontal. That could be checked and acted upon if deemed
%    necessary.\footnote{Issue?}
%    
%    \begin{macrocode}
    \dim_compare:nNnTF {#2} < {#6}
       { \tl_set:Nn \l_coffin_pole_tl { {0pt}{#6} {1000sp}{0sp} } }
       { \tl_set:Nn \l_coffin_pole_tl { {0pt}{#2} {1000sp}{0sp} } }
%    \end{macrocode}
%    Then record the new \texttt{T} pole value in the result box.
%    \begin{macrocode}
    \coffin_set_pole_coordinates:NnV #9 T \l_coffin_pole_tl 
}

\cs_new:Npn \coffin_update_B_pole:nnnnnnnnN  #1#2#3#4#5#6#7#8#9 {
%    \end{macrocode}
%    Same operation for \texttt{B} except that for the bottom baseline we have
%    to use the value from box-B if it is smaller.
%    \begin{macrocode}
    \dim_compare:nNnTF {#2} > {#6}
       { \tl_set:Nn \l_coffin_pole_tl { {0pt}{#6} {1000sp}{0sp} } }
       { \tl_set:Nn \l_coffin_pole_tl { {0pt}{#2} {1000sp}{0sp} } }
    \coffin_set_pole_coordinates:NnV #9 B \l_coffin_pole_tl 
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\coffin_align:NnNnnn}
%    
%    This commmand aligns two coffins at their poles with a certain offset
%    inbetween. The result is stored again in the first coffin (with poles
%    from both coffins added as \texttt{\meta{box}-\meta{pole}}).
%
%    The resulting bounding box is the enclosing box around both coffins.
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \end{Arglist}
%
%    Note that the arguments are ordered differently compared to the internal
%    helper commands for coffin alignment.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_align:NnnNnnnn #1#2#3#4#5#6#7#8{
%<*debug>
   \cs_display_args:Nnnnnnnnn \coffin_align:NnnNnnnn {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}
%</debug>
%    \end{macrocode}
%    First we align the coffins and save them in a scratch coffin. This time
%    the version that doesn't confine the bounding box is being used.
%    \begin{macrocode}
  \coffin_align_save:NnnNnnnnN  #1{#2}{#3} #4{#5}{#6} {#7}{#8}
                               \l_coffin_aligned_coffin 
%    \end{macrocode}
%    Then we copy the scratch coffin back into box-A:
%    \begin{macrocode}
  \coffin_set_eq_clear:NN #1 \l_coffin_aligned_coffin
%    \end{macrocode}
%    \begin{macrocode}
   \coffin_update_BB_handles:N #1
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\coffin_align_confine:NnnNnnnn}
%    
%    This commmand aligns two coffins at their poles with a certain offset
%    inbetween. The result is stored again in the first coffin (with poles
%    from both coffins added as \texttt{\meta{box}-\meta{pole}}).
%
%    The resulting bounding box is clipped to the dimensions of the first
%    coffin (box-A).
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference for box-A (single token)
%    \Argitem{2} h-pole of box-A to align with
%    \Argitem{3} v-pole of box-A to align with
%    \Argitem{4} box register reference for box-B (single token)
%    \Argitem{5} h-pole of box-A to align with
%    \Argitem{6} v-pole of box-A to align with
%    \Argitem{7} x-offset between poles
%    \Argitem{8} y-offset between poles
%    \end{Arglist}
%
%    Note that the arguments are ordered differently compared to the internal
%    helper commands for coffin alignment.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_align_confine:NnnNnnnn #1 #2#3 #4 #5#6 #7#8{
%    \end{macrocode}
%    First we align the coffins and save them in a scratch coffin.
%    \begin{macrocode}
    \coffin_align_confine_save:NnnNnnnnN #1{#2}{#3} #4{#5}{#6} {#7}{#8}
                                         \l_coffin_aligned_coffin
%    \end{macrocode}
%    Then we copy the scratch coffin back into box-A:
%    \begin{macrocode}
  \coffin_set_eq_clear:NN #1 \l_coffin_aligned_coffin
%    \end{macrocode}
%    \begin{macrocode}
   \coffin_update_BB_handles:N #1
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
% \subsection{Typesetting coffins}
%
%
%  \begin{macro}{\c_empty_coffin}
%    A permanently empty hbox coffin used in placing other coffins.
%    \begin{macrocode}
\coffin_new:N \c_empty_h_coffin
\hbox_set:Nn  \c_empty_h_coffin {} 
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\coffin_typeset:Nnnnn}
%    This command typeset a coffin aligning one pole of it with the current reference
%    point on the page with a certain x/y-offset. 
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference (single token)
%    \Argitem{2} h-pole of box to align with
%    \Argitem{3} v-pole of box to align with
%    \Argitem{4} x-offset to handle
%    \Argitem{5} y-offset to handle
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn\coffin_typeset:Nnnnn #1#2#3#4#5{
%    \end{macrocode}
%    We implement this by aligning the box with an permanently empty coffin
%    which is of zero size in all directions, i.e., all its reference points
%    would be at the current reference point on the page. That reduces the
%    problem to one of the commands already implemented:
%    \begin{macrocode}
  \coffin_align_save:NnnNnnnnN \c_empty_h_coffin {H}{l} #1{#2}{#3} {#4}{#5} 
                               \l_coffin_aligned_coffin 
%    \end{macrocode}
%    Of course this command does a bit too much: |\l_coffin_aligned_coffin|
%    will now unnecessarily contain all kind of poles which are never going
%    be to be used since we typeset the beast directly.
%    \begin{macrocode}
  \box_use_clear:N \l_coffin_aligned_coffin
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_typeset_confine:Nnnnn}
%    
%    This command typeset a coffin aligning one pole of it with the current reference
%    point on the page with a certain x/y-offset. 
%    
%    The reference point will not be changed so all material will overlap with
%    surrounding text.
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box register reference (single token)
%    \Argitem{2} h-pole of box to align with
%    \Argitem{3} v-pole of box to align with
%    \Argitem{4} x-offset to handle
%    \Argitem{5} y-offset to handle
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_typeset_confine:Nnnnn #1#2#3#4#5 {
    \coffin_align_confine_save:NnnNnnnnN \c_empty_h_coffin  {H}{l} 
                                    #1{#2}{#3} 
                                    {#4}{#5} 
                                    \l_coffin_aligned_coffin 
  \box_use_clear:N \l_coffin_aligned_coffin
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
% \subsection{Rotation}
%
%
%
% \subsubsection{Calculating sine and cosine}
%
%    For rotation we need to calculate sine and cosine values of angles.  Right
%    now we do this the easy way: we store the values in a property list and
%    simply retrieve it from there. For angles not precalulated we return an
%    error. At some point in the future we can extend this with some code that
%    does a proper calulation (and adds missing values as necessary).
%
%
%  \begin{macro}{\g_math_sin_prop,\g_math_cos_prop}
%    Property lists holding precalulated values for sine and cosine.
%    \begin{macrocode}
\prop_new:N \g_math_sin_prop
\prop_new:N \g_math_cos_prop
%    \end{macrocode}
%    
%    \begin{macrocode}
\prop_put:Nnn \g_math_sin_prop {0}   {0}
\prop_put:Nnn \g_math_sin_prop {10}  {0.173648178}
\prop_put:Nnn \g_math_sin_prop {30}  {0.5}
\prop_put:Nnn \g_math_sin_prop {45}  {0.707106781}
\prop_put:Nnn \g_math_sin_prop {90}  {1}
\prop_put:Nnn \g_math_sin_prop {135} {0.707106781}
\prop_put:Nnn \g_math_sin_prop {180} {0}
\prop_put:Nnn \g_math_sin_prop {225} {-0.707106781}
\prop_put:Nnn \g_math_sin_prop {270} {-1}
\prop_put:Nnn \g_math_sin_prop {315} {-0.707106781}
%    \end{macrocode}
%    
%    \begin{macrocode}
\prop_put:Nnn \g_math_cos_prop {0}   {1}
\prop_put:Nnn \g_math_cos_prop {10}  {0.984807753}
\prop_put:Nnn \g_math_cos_prop {30}  {0.866025404}
\prop_put:Nnn \g_math_cos_prop {45}  {0.707106781}
\prop_put:Nnn \g_math_cos_prop {90}  {0}
\prop_put:Nnn \g_math_cos_prop {135} {-0.707106781}
\prop_put:Nnn \g_math_cos_prop {180} {-1}
\prop_put:Nnn \g_math_cos_prop {225} {0.707106781}
\prop_put:Nnn \g_math_cos_prop {270} {0}
\prop_put:Nnn \g_math_cos_prop {315} {0.707106781}
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\math_get_sin:nN,\math_get_cos:nN}
%    Retrieve sine or cosine value for angle in a token list. If not
%    precalulated set some arbitrary value and return error.
%    \begin{macrocode}
\cs_new:Npn \math_get_sin:nN #1 #2 {
  \prop_get:NnN \g_math_sin_prop {#1} #2
  \quark_if_no_value:NT #2
     { \typeout{Error:~ sin~ missing~for~ #1}\ERROR
       \tlp_set:Nn #2 {1}
     }
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_new:Npn \math_get_cos:nN #1 #2 {
  \prop_get:NnN \g_math_cos_prop {#1} #2
  \quark_if_no_value:NT #2
     { \typeout{Error:~ cos~ missing~for~ #1}\ERROR
       \tlp_set:Nn #2 {1}
     }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
% \subsubsection{Shifting a handle or pole}
%
%
%
%  \begin{macro}{\coffin_shift_vector:Nnnnn}
%    
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} 
%    \Argitem{2} 
%    \Argitem{3} 
%    \Argitem{4} 
%    \Argitem{5} 
%    \end{Arglist}
%
%    
%
%    \begin{macrocode}
\cs_new:Npn \coffin_shift_vector:Nnnnn #1 #2#3 #4#5 {
  \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#2}
  \dim_set:Nn \l_coffin_offset_x_dim {\_coffin_eval_pole_value:N #1 - #4}
  \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#3}
  \dim_set:Nn \l_coffin_offset_y_dim {\_coffin_eval_pole_value:N #1 - #5}
}
%    \end{macrocode}
%  \end{macro}
%
%


%  \begin{macro}{\coffin_shift_handle:Nnnn}
%    
%    \begin{macrocode}
\cs_new:Npn \coffin_shift_handle:Nnnn #1 #2 #3 #4{
  \coffin_get_existing_handle_coordinates:NnN #1 {#2} \l_coffin_tmpa_tl

  \tl_put_left:Nn  \l_coffin_tmpa_tl {\coffin_shift_vector:Nnnnn #1 }
  \l_coffin_tmpa_tl {#3}{#4}
  \coffin_set_handle_coordinates:Nnx #1 {#2}
                { { \dim_use:N\l_coffin_offset_x_dim }
                  { \dim_use:N\l_coffin_offset_y_dim } }      
}

%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{\coffin_shift_handle:Nnnnnn}
%    
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box reference
%    \Argitem{2} pole name 
%    \Argitem{3} x-component vector
%    \Argitem{4} y-component vector
%    \Argitem{5} x-shift
%    \Argitem{6} y-shift
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_shift_handle:Nnnnnn #1 #2 #3#4 #5#6 {
  \coffin_shift_vector:Nnnnn #1 {#3}{#4} {#5}{#6}
  \coffin_set_handle_coordinates:Nnx #1 {#2}
                { { \dim_use:N\l_coffin_offset_x_dim }
                  { \dim_use:N\l_coffin_offset_y_dim } }      
}

%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\coffin_shift_pole:Nnnnnnnn}
%    
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box reference
%    \Argitem{2} pole name 
%    \Argitem{3} x-component base-vector
%    \Argitem{4} y-component base vector
%    \Argitem{5} x-component direction-vector
%    \Argitem{6} y-component direction-vector
%    \Argitem{7} x-shift
%    \Argitem{8} y-shift
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_shift_pole:Nnnnnnnn #1 #2 #3#4#5#6 #7#8 {
%<*debug>
   \cs_display_args:Nnnnnnnnn \coffin_shift_pole:Nnnnnnn
                             {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}
%</debug>

  \coffin_shift_vector:Nnnnn #1 {#3}{#4}{#7}{#8}

  \tl_set:Nx \l_coffin_pole_tl 
             { { \dim_use:N\l_coffin_offset_x_dim }
               { \dim_use:N\l_coffin_offset_y_dim }
               {#5}{#6}}

  \coffin_set_pole_coordinates:NnV #1 {#2} \l_coffin_pole_tl
}
%    \end{macrocode}
%  \end{macro}



%
% \subsubsection{Rotating a vector}
%
%
%  \begin{macro}{\l_coffin_sin_tl,\l_coffin_cos_tl}
%    
%    \begin{macrocode}
\tl_new:N \l_coffin_sin_tl
\tl_new:N \l_coffin_cos_tl
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\coffin_rotate_vector:Nnnn}
%
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box reference (from which the vector originates)
%    \Argitem{2} x-component
%    \Argitem{3} y-component
%    \Argitem{4} angle of rotation
%    \end{Arglist}
%
%    Rotate vector $(x,y)$ by angle |#4| and return the resulting vector in
%    the dtwo dimen registers |\l_coffin_offset_x_dim| and
%    |\l_coffin_offset_y_dim|.
%
%    With the current implementation we also need to pass the originating box
%    so that indirect vector values like ``with of box'' can be changed to
%    real values.\footnote{Issue: it is about time to consider storing only
%    real values and doing the calculations up front instead.}
%    
%    \begin{macrocode}
\cs_new:Npn \coffin_rotate_vector:Nnnn #1 #2 #3 #4 { 
%    \end{macrocode}
%    First get both sine and cosine for the angle given in |#4|
%    \begin{macrocode}
  \math_get_sin:nN {#4} \l_coffin_sin_tl
  \math_get_cos:nN {#4} \l_coffin_cos_tl
%    \end{macrocode}
%    Turn the vector values in explicit lengths (resolve references to the box
%    sizes (if any).
%    \begin{macrocode}
  \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#2}
  \dim_set:Nn \l_coffin_tmpa_dim {\_coffin_eval_pole_value:N #1}
  \cs_set:Npn \_coffin_eval_pole_value:N ##1 {#3}
  \dim_set:Nn \l_coffin_tmpb_dim {\_coffin_eval_pole_value:N #1}
%    \end{macrocode}
%    Apply the transformation matrix
%    \begin{macrocode}
  \dim_set:Nn \l_coffin_offset_x_dim { \l_coffin_cos_tl \l_coffin_tmpa_dim - 
                                       \l_coffin_sin_tl \l_coffin_tmpb_dim }
%    \end{macrocode}
%
%    \begin{macrocode}
  \dim_set:Nn \l_coffin_offset_y_dim { \l_coffin_sin_tl \l_coffin_tmpa_dim + 
                                       \l_coffin_cos_tl \l_coffin_tmpb_dim }
%<*trace>
\typeout{Rotate~ vector~
         ( #2, #3)~ by ~ #4  ~->~ ( \dim_use:N\l_coffin_offset_x_dim ,
                                    \dim_use:N\l_coffin_offset_y_dim  ) }
}
%</trace>
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
%
%
% \subsubsection{Rotating a handle}
%
%
%
%
%  \begin{macro}{\coffin_rotate_handle:Nnnnn}
%    
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box reference
%    \Argitem{2} rotation
%    \Argitem{3} handle name
%    \Argitem{4} x-component vector
%    \Argitem{5} y-component vector
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_rotate_handle:Nnnnn #1 #2 #3 #4#5{

  \coffin_rotate_vector:Nnnn #1 {#4}{#5} {#2}

  \coffin_set_handle_coordinates:Nnx #1 {#3} 
                { { \dim_use:N\l_coffin_offset_x_dim }
                  { \dim_use:N\l_coffin_offset_y_dim } }      
}   
%    \end{macrocode}
%  \end{macro}
%
%
%
%
% \subsubsection{Rotating a pole}
%
%
%

%  \begin{macro}{\coffin_rotate_pole:Nnnnnnn}
%    
%    
%    Arguments:
%    \begin{Arglist}
%    \Argitem{1} box reference
%    \Argitem{2} rotation
%    \Argitem{3} pole name
%    \Argitem{4} x-component base-vector
%    \Argitem{5} y-component base vector
%    \Argitem{6} x-component direction-vector
%    \Argitem{7} y-component direction-vector
%    \end{Arglist}
%
%    \begin{macrocode}
\cs_new:Npn \coffin_rotate_pole:Nnnnnnn #1 #2 #3 #4#5#6#7 {

  \coffin_rotate_vector:Nnnn #1 {#4}{#5} {#2}

  \tl_set:Nx \l_coffin_pole_tl 
             { { \dim_use:N\l_coffin_offset_x_dim }
               { \dim_use:N\l_coffin_offset_y_dim } }

  \coffin_rotate_vector:Nnnn #1 {#6}{#7} {#2}

  \tl_put_right:Nx \l_coffin_pole_tl 
            { { \dim_use:N\l_coffin_offset_x_dim }
              { \dim_use:N\l_coffin_offset_y_dim } }

  \coffin_set_pole_coordinates:NnV #1 {#3} \l_coffin_pole_tl
}
%    \end{macrocode}
%  \end{macro}

%
%
% \subsubsection{Rotating and shifting all poles and handles}
%
%  \begin{macro}{\coffin_rotate_poles_and_handles:Nn}
%    Rotate all handles and poles of a given coffin by some degrees.
%
%    \begin{macrocode}
\cs_new:Npn \coffin_rotate_poles_and_handles:Nn #1 #2{
%    \end{macrocode}
%    
%    \begin{macrocode}
  \prop_map_inline:cn {l_coffin_poles_ \tex_number:D #1 _prop}
     { \coffin_rotate_pole:Nnnnnnn #1 {#2} {##1} ##2 }
%    \end{macrocode}
%    
%    \begin{macrocode}
  \prop_map_inline:cn {l_coffin_handles_ \tex_number:D #1 _prop}
     { \coffin_rotate_handle:Nnnnn #1 {#2} {##1} ##2 }
}
%    \end{macrocode}
%  \end{macro}

%
%
%
%
%  \begin{macro}{\coffin_shift_poles_and_handles:Nnn}
%    
%    \begin{macrocode}
\cs_new:Npn \coffin_shift_poles_and_handles:Nnn #1 #2#3 {
  \prop_map_inline:cn {l_coffin_poles_ \tex_number:D #1 _prop}
     {
       \coffin_shift_pole:Nnnnnnnn #1 {##1} ##2 
                   {#2}{#3}
     }
  \prop_map_inline:cn {l_coffin_handles_ \tex_number:D #1 _prop}
     {
       \coffin_shift_handle:Nnnnnn #1 {##1} ##2 
                   {#2}{#3}
     }
}
%    \end{macrocode}
%  \end{macro}
%
%

%
%
%
%
% \subsubsection{Rotating a coffin}
%
%
%
%  \begin{macro}{\coffin_rotate}
%    Rotate a coffin by a certain angle.
%    \begin{macrocode}
\cs_new:Npn \coffin_rotate:Nn #1#2 {
%<*debug>
  \coffin_display_BB:N #1
%</debug>
%    \end{macrocode}
%    First thing we do is to rotate all poles and handles that belong to the
%    coffin.
%    \begin{macrocode}
  \coffin_rotate_poles_and_handles:Nn #1 {#2}
%<*debug>
  \coffin_display_BB:N #1 
%</debug>
%    \end{macrocode}
%    Then we re-calculate the bounding box data for the rotated box.
%    \begin{macrocode}
  \coffin_calculate_BB_data:Nn #1
%    \end{macrocode}
%    This sets a number of dimen variables that we need when rotating the
%    actual coffin content and putting it into a new box of the right size.
%
%    First we rotate the box itself.
%    \begin{macrocode}
  \hbox_set:Nn #1 {\rotatebox{#2}{\box_use:N #1}}
%    \end{macrocode}
%    That will shift the reference point and makes the bounding box get larger
%    than it should be.
%
%    What we want to happen is that the new bounding box sits tightly around
%    the rotated box and that the reference point is at its bottom.
%    But if the box was rotated already before then the inner bounding box
%    corners are in a different place than the outer bounding box
%    corners. After further rotation that might result horizontal white space
%    within the box
%    
%    We therefore move the reference point horizontally by the difference
%    between the outer and inner BB x-coordinates and the also move the
%    rotated box down by its depth which brings the reference point to the
%    lower left corner.
%    \begin{macrocode}
  \hbox_set:Nn #1 {\tex_kern:D   \l_coffin_outer_BB_hstart_dim 
                   \tex_kern:D - \l_coffin_BB_hstart_dim
                   \box_move_down:nn \l_coffin_BB_dp_dim
                                     {\box_use:N #1 }
                  }
%<*debug>
  \typeout{Box~ sizes~ (#1):^^J
      \space\space ht=\dim_use:N \box_ht:N#1^^J
      \space\space dp=\dim_use:N \box_dp:N#1^^J
      \space\space wd=\dim_use:N \box_wd:N#1       }
%</debug>
%    \end{macrocode}
%    We still have to correct the sizing, but that is fairly easy now: the
%    hight should be height and depth of the inner bounding box and for the
%    width we have to substract the distance to the left edge (which will in
%    fact increase the value as |\l_coffin_BB_hstart_dim| will be negative
%    being the x-measure from the former reference point to the farmost left
%    corner of the rotated box).
%    \begin{macrocode}
  \dim_sub:Nn \l_coffin_BB_ht_dim \l_coffin_BB_dp_dim
  \dim_sub:Nn \l_coffin_BB_wd_dim \l_coffin_BB_hstart_dim
  \box_ht:N #1 = \l_coffin_BB_ht_dim
  \box_dp:N #1 = 0pt
  \box_wd:N #1 = \l_coffin_BB_wd_dim
%<*debug>
  \typeout{Box~ sizes~ (#1):^^J
      \space\space ht=\dim_use:N \box_ht:N#1^^J
      \space\space dp=\dim_use:N \box_dp:N#1^^J
      \space\space wd=\dim_use:N \box_wd:N#1       }
%</debug>
%    \end{macrocode}
%    But all the BB correction means that our poles and handles needs shifting
%    too as they are supposed to be measured from the reference point of the
%    box, i.e.,
%    \begin{macrocode}
  \coffin_shift_poles_and_handles:Nnn #1 
                                   \l_coffin_BB_hstart_dim
                                   \l_coffin_BB_dp_dim
%    \end{macrocode}
%    Finally we actually to undo some of the handle changes above, since now
%    that we have the box rotated the |outer_BB| handles are supposed to point
%    to the four corners of the new box (while the are currently pointing to
%    the rotated old corners). So we explicitly set them using the new box
%    sizes.  This means that we could save processing time by keeping the
%    outer BB handles in a separate place instead of shifting them and then
%    overwriting their value again.\footnote{Issue?}
%    \begin{macrocode}
  \coffin_update_outer_BB_handles:N #1

%<*debug>
%  \coffin_print_BB:N #1
%  \coffin_show_structure:N #1
%</debug>
 
}
%    \end{macrocode}
%  \end{macro}
%
% 
%
%
%
%  \begin{macro}{\coffin_calculate_BB_data:Nn}
%    To be able to properly move the reference point and set the bounding box
%    for the rotated box correctly we need to find out how the real box lies
%    in space after rotation (in relation to the reference point used by
%    \TeX{}). More precisely we want to calculate the following values:
%    \begin{itemize}
%    \item top point of the rotated box (|\l_coffin_BB_ht_dim|) which is
%          the maximum of all y-values of the inner bounding box handles
%    \item bottom point of the rotated box (|\l_coffin_BB_dp_dim|) which is
%          the minimum of all y-values of the inner bounding box handles
%    \item left point of the rotated box (|\l_coffin_BB_hstart_dim|) which is
%          the minimum of all x-values
%    \item left point of the rotated box (|\l_coffin_BB_wd_dim|) which is
%          the maximum of all x-values
%    \item left point of the outer bounding box of the rotated box
%          (|l_coffin_outer_BB_hstart_dim|) which is 
%          the minimum of all x-values of the outer BB handles. This one is
%          needed to shift the reference point correctly and the only reason
%          why we need to keep track of the outer BB positions.
%    \end{itemize}
%
%
%    \begin{macrocode}
\cs_new:Npn \coffin_calculate_BB_data:Nn #1  {
%    \end{macrocode}
%    Getting to the above minima and maxima is done by retrieving the handle
%    values and then successively updating the parameter if we find a value
%    that is smaller or larger, respectively. We start by assuming that the
%    first handle gives us the correct answer already
%    \begin{macrocode}
   \coffin_get_handle_xy_coordinates:Nn #1 {BB_tl} 
     \dim_set:Nn \l_coffin_BB_ht_dim     \l_coffin_intersect_y_dim
     \dim_set:Nn \l_coffin_BB_dp_dim     \l_coffin_intersect_y_dim
     \dim_set:Nn \l_coffin_BB_hstart_dim \l_coffin_intersect_x_dim
     \dim_set:Nn \l_coffin_BB_wd_dim     \l_coffin_intersect_x_dim
%    \end{macrocode}
%    From now on we update the variables if we find something being smaller or
%    larger.
%    \begin{macrocode}
   \coffin_get_handle_xy_coordinates:Nn #1 {BB_tr} 
     \dim_set_max:Nn \l_coffin_BB_ht_dim     \l_coffin_intersect_y_dim
     \dim_set_min:Nn \l_coffin_BB_dp_dim     \l_coffin_intersect_y_dim
     \dim_set_min:Nn \l_coffin_BB_hstart_dim \l_coffin_intersect_x_dim
     \dim_set_max:Nn \l_coffin_BB_wd_dim     \l_coffin_intersect_x_dim
%    \end{macrocode}
%    
%    \begin{macrocode}
   \coffin_get_handle_xy_coordinates:Nn #1 {BB_bl} 
     \dim_set_max:Nn \l_coffin_BB_ht_dim     \l_coffin_intersect_y_dim
     \dim_set_min:Nn \l_coffin_BB_dp_dim     \l_coffin_intersect_y_dim
     \dim_set_min:Nn \l_coffin_BB_hstart_dim \l_coffin_intersect_x_dim
     \dim_set_max:Nn \l_coffin_BB_wd_dim     \l_coffin_intersect_x_dim
%    \end{macrocode}
%    
%    \begin{macrocode}
   \coffin_get_handle_xy_coordinates:Nn #1 {BB_br} 
     \dim_set_max:Nn \l_coffin_BB_ht_dim     \l_coffin_intersect_y_dim
     \dim_set_min:Nn \l_coffin_BB_dp_dim     \l_coffin_intersect_y_dim
     \dim_set_min:Nn \l_coffin_BB_hstart_dim \l_coffin_intersect_x_dim
     \dim_set_max:Nn \l_coffin_BB_wd_dim     \l_coffin_intersect_x_dim
%    \end{macrocode}
%    Same game for the single value that we need from the outer BB handles:
%    \begin{macrocode}
   \coffin_get_handle_xy_coordinates:Nn #1 {outer_BB_tl} 
   \dim_set:Nn \l_coffin_outer_BB_hstart_dim \l_coffin_intersect_x_dim
   \coffin_get_handle_xy_coordinates:Nn #1 {outer_BB_tr} 
   \dim_set_min:Nn \l_coffin_outer_BB_hstart_dim \l_coffin_intersect_x_dim
   \coffin_get_handle_xy_coordinates:Nn #1 {outer_BB_bl} 
   \dim_set_min:Nn \l_coffin_outer_BB_hstart_dim \l_coffin_intersect_x_dim
   \coffin_get_handle_xy_coordinates:Nn #1 {outer_BB_br} 
   \dim_set_min:Nn \l_coffin_outer_BB_hstart_dim \l_coffin_intersect_x_dim
}
%    \end{macrocode}
%  \end{macro}
%
%
% 
%
%
%
%
%
%  \begin{macro}{\l_coffin_BB_ht_dim,
%                \l_coffin_BB_dp_dim,
%                \l_coffin_BB_wd_dim,
%                \l_coffin_BB_hstart_dim,
%                \l_coffin_outer_BB_hstart_dim}
%    
%    \begin{macrocode}
\dim_new:N \l_coffin_BB_ht_dim
\dim_new:N \l_coffin_BB_dp_dim
\dim_new:N \l_coffin_BB_wd_dim
\dim_new:N \l_coffin_BB_hstart_dim
\dim_new:N \l_coffin_outer_BB_hstart_dim
%    \end{macrocode}
%  \end{macro}
% 
%
%
%
%
%
% 
%
%
%
%
%
% 
%
%
%
%
% \subsection{Some needed external variants and additional commands}
% 
% We need a few variants and commands not in l3in2e.
%
%
%  \begin{macro}{\dim_set_min:Nn,\dim_set_max:Nn}
%    In-place min/max updates.
%
%    Those are now around, but for now I keep the ones with debugging code.
%    \begin{macrocode}
\cs_set:Npn \dim_set_min:Nn #1 #2 {
  \dim_compare:nNnT #1 > {#2} { \dim_set:Nn #1{#2} }
%<*debug>
  \typeout{min(#1,#2)=\dim_use:N #1}
%</debug>
}
\cs_set:Npn \dim_set_max:Nn #1 #2 {
  \dim_compare:nNnT #1 < {#2} { \dim_set:Nn #1{#2} }
%<*debug>
  \typeout{max(#1,#2)=\dim_use:N #1}
%</debug>
}
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{\exp_last_unbraced:No}
%    This one exists by now but the definition below is faster
%    \begin{macrocode}
\cs_set:Npn \exp_last_unbraced:No #1 #2 {
  \exp_after:wN #1 #2
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\exp_two_last_unbraced:Noo}
%    \begin{macrocode}
\cs_new:Npn \exp_two_last_unbraced:Noo #1 #2 #3{
  \exp_after:wN \exp_after:wN \exp_after:wN #1 \exp_after:wN #2 #3
}
%    \end{macrocode}
%  \end{macro}

%
%  \begin{macro}{}
%    
%    \begin{macrocode}
%\cs_generate_variant:Nn \prop_put:Nnn { cnx }
%    \end{macrocode}
%  \end{macro}
%    
%  \begin{macro}{\prop_del_aux:w}
%    Temporary bug fix: |\prop_del:Nn| currently doesn't support |#1| etc in
%    the value argument. The approach here is not a correct solution, it is
%    just one that works for |#1| there!
%
%    \begin{macrocode}
\cs_set_protected:Npn \prop_del_aux:w #1#2#3#4#5{
  \cs_set_nopar:Npn \prop_tmp:w ##1{#4}
  \tl_set:No \prop_tmp:w {\prop_tmp:w !}
  \quark_if_no_value:NF \prop_tmp:w {
    \cs_set_nopar:Npn \prop_tmp:w ##1\q_prop#2\q_prop\q_no_value {#1{#3##1}}
    \prop_tmp:w #5
  }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
% \subsection{Some temporal debugging commands}
% 
%    \begin{macrocode}
%<*debug>

%</debug>
\cs_new:Npn \cs_display_args:Nnnnnnnnnn #1 {
   \cs_display_cs_name:N #1
   \cs_display_args:nnnnnnnnn
}
\cs_new:Npn \cs_display_args:Nnnnnnnnn #1 {
   \cs_display_cs_name:N #1
   \cs_display_args:nnnnnnnn
}
\cs_new:Npn \cs_display_args:Nnnnnnnn #1 {
   \cs_display_cs_name:N #1
   \cs_display_args:nnnnnnn
}
\cs_new:Npn \cs_display_args:Nnnnnnn #1 {
   \cs_display_cs_name:N #1
   \cs_display_args:nnnnnn
}
\cs_new:Npn \cs_display_args:Nnnnn #1 {
   \cs_display_cs_name:N #1
   \cs_display_args:nnnn
}
\cs_new:Npn \cs_display_args:Nnnn #1 {
   \cs_display_cs_name:N #1
   \cs_display_args:nnn
}
\cs_new:Npn \cs_display_args:Nnn #1 {
   \cs_display_cs_name:N #1
   \cs_display_args:nn
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\cs_new:Npn \cs_display_cs_name:N #1 {
   \typeout{ \detokenize{ #1 } }
}
\cs_new:Npn \cs_display_args:nnnnnnnnn #1#2#3#4#5#6#7#8#9 {
   \typeout{ \space\space \detokenize{ ~ ##1 ~=~ #1 } }
   \typeout{ \space\space \detokenize{ ~ ##2 ~=~ #2 } }
   \typeout{ \space\space \detokenize{ ~ ##3 ~=~ #3 } }
   \typeout{ \space\space \detokenize{ ~ ##4 ~=~ #4 } }
   \typeout{ \space\space \detokenize{ ~ ##5 ~=~ #5 } }
   \typeout{ \space\space \detokenize{ ~ ##6 ~=~ #6 } }
   \typeout{ \space\space \detokenize{ ~ ##7 ~=~ #7 } }
   \typeout{ \space\space \detokenize{ ~ ##8 ~=~ #8 } }
   \typeout{ \space\space \detokenize{ ~ ##9 ~=~ #9 } }
   \typeout{}
}
\cs_new:Npn \cs_display_args:nnnnnnnn #1#2#3#4#5#6#7#8 {
   \typeout{ \space\space \detokenize{ ~ ##1 ~=~ #1 } }
   \typeout{ \space\space \detokenize{ ~ ##2 ~=~ #2 } }
   \typeout{ \space\space \detokenize{ ~ ##3 ~=~ #3 } }
   \typeout{ \space\space \detokenize{ ~ ##4 ~=~ #4 } }
   \typeout{ \space\space \detokenize{ ~ ##5 ~=~ #5 } }
   \typeout{ \space\space \detokenize{ ~ ##6 ~=~ #6 } }
   \typeout{ \space\space \detokenize{ ~ ##7 ~=~ #7 } }
   \typeout{ \space\space \detokenize{ ~ ##8 ~=~ #8 } }
   \typeout{}
}
\cs_new:Npn \cs_display_args:nnnnnnn #1#2#3#4#5#6#7 {
   \typeout{ \space\space \detokenize{ ~ ##1 ~=~ #1 } }
   \typeout{ \space\space \detokenize{ ~ ##2 ~=~ #2 } }
   \typeout{ \space\space \detokenize{ ~ ##3 ~=~ #3 } }
   \typeout{ \space\space \detokenize{ ~ ##4 ~=~ #4 } }
   \typeout{ \space\space \detokenize{ ~ ##5 ~=~ #5 } }
   \typeout{ \space\space \detokenize{ ~ ##6 ~=~ #6 } }
   \typeout{ \space\space \detokenize{ ~ ##7 ~=~ #7 } }
   \typeout{}
}
\cs_new:Npn \cs_display_args:nnnnnn #1#2#3#4#5#6 {
   \typeout{ \space\space \detokenize{ ~ ##1 ~=~ #1 } }
   \typeout{ \space\space \detokenize{ ~ ##2 ~=~ #2 } }
   \typeout{ \space\space \detokenize{ ~ ##3 ~=~ #3 } }
   \typeout{ \space\space \detokenize{ ~ ##4 ~=~ #4 } }
   \typeout{ \space\space \detokenize{ ~ ##5 ~=~ #5 } }
   \typeout{ \space\space \detokenize{ ~ ##6 ~=~ #6 } }
   \typeout{}
}
\cs_new:Npn \cs_display_args:nnnn #1#2#3#4 {
   \typeout{ \space\space \detokenize{ ~ ##1 ~=~ #1 } }
   \typeout{ \space\space \detokenize{ ~ ##2 ~=~ #2 } }
   \typeout{ \space\space \detokenize{ ~ ##3 ~=~ #3 } }
   \typeout{ \space\space \detokenize{ ~ ##4 ~=~ #4 } }
   \typeout{}
}
\cs_new:Npn \cs_display_args:nnn #1#2#3 {
   \typeout{ \space\space \detokenize{ ~ ##1 ~=~ #1 } }
   \typeout{ \space\space \detokenize{ ~ ##2 ~=~ #2 } }
   \typeout{ \space\space \detokenize{ ~ ##3 ~=~ #3 } }
   \typeout{}
}
\cs_new:Npn \cs_display_args:nn #1#2 {
   \typeout{ \space\space \detokenize{ ~ ##1 ~=~ #1 } }
   \typeout{ \space\space \detokenize{ ~ ##2 ~=~ #2 } }
   \typeout{}
}
%    \end{macrocode}
%
%    \begin{macrocode}
\endinput
%<*debug>
   \cs_display_args:Nnnnnnnnnn 
                               {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}
%</debug>

%<*debug>
   \cs_display_args:Nnnnnnnnn
                              {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}
%</debug>

%<*debug>
   \cs_display_args:Nnnnnnnn
                             {#1}{#2}{#3}{#4}{#5}{#6}{#7}
%</debug>

%<*debug>
   \cs_display_args:Nnnnn 
                          {#1}{#2}{#3}{#4}
%</debug>

%<*debug>
   \cs_display_args:Nnnn  {#1}{#2}{#3}
%</debug>

%<*debug>
   \cs_display_args:Nnn  {#1}{#2}
%</debug>

%</package>
%    \end{macrocode}
%
% \Finale
%
%
\endinput
