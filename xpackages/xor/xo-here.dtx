% \iffalse
%%
%% (C) Copyright 1999-2000 Frank Mittelbach, David Carlisle, Chris Rowley
%% All rights reserved.
%%
%% Not for general distribution. In its present form it is not allowed
%% to put this package onto CD or an archive without consulting the
%% the authors.
%% 
% \fi
%
%    \begin{macrocode}
\def\@tempa#1: #2.dtx,v #3 #4 #5 #6 #7${
  \ProvidesPackage{#2}[#4 #3 #5 #6]}
\@tempa$Id$
%    \end{macrocode}
%
% Ignore white space in this package.
%    \begin{macrocode}
\IgnoreWhiteSpace
%    \end{macrocode}
%
%
% Most of the code in this file is temporary in the sense that the
% interfaces are not fixed or the intended functionality is not fully
% implemented. It is sort of the proof of concept stuff.
%
%
%
% \begin{macro}{\requirespace}
%    The |\requirespace| command is an interface function for other
%    parts of a class file. It issues a here point which ensures
%    that there is at least |#1| amount of space still available in
%    the current column. If not it results in carrying the here point,
%    including the previous line(s), to the next column. This could,
%    for example, be used by a heading to ensure that there is a
%    certain amount of minimal space following it.
%
%    The precise (?) definition of ``previous line(s)'' is as follows:
%    the internal algorithm will split the so far collected column material
%    trying reach the latest possible break point before the here
%    point. It is theoretically possible to construct examples where
%    \TeX{} decides to take an earlier split point but it is
%    guaranteed the the here point is not losing contact with the
%    material directly preceeding it (unless a legal breakpoint was
%    added in front of it).
%    If the here point was added via |\vadjust| in horizontal mode,
%    this means that the line immediately before it will be after the
%    split (since there will be no other legal break point inbetween).
%    \begin{macrocode}
\def\requirespace #1 {
  \ifhmode
    \@bsphack
  \fi
  \xor_pop_float:NNTF \g_xor_floats_free_seq \g_xor_curr_float_box_tlp
                      {}{}
%    \end{macrocode}
%    We are only interested in the type really:
%    \begin{macrocode}
  \global\toks\g_xor_curr_float_box_tlp{{}{}
                        {}
                        {}
                        {}
                        {rspace}
                        {}
   }
  \xor_add_here_point:Nn\g_xor_curr_float_box_tlp{#1}     
  \@ignorefalse
  \@esphack
}
%    \end{macrocode}
% \end{macro}   
%
%    
% \begin{macro}{\marginpar}
%    The current implementation of the document command |\marginpar|
%    is only a proof of concept draft. It doesn't cover the full
%    flexibility of the \LaTeXe{} version yet (and perhaps one wants
%    even an extension of that).
%    \begin{macrocode}
\def\marginpar #1 {
  \ifhmode
    \@bsphack
  \fi
  \xor_pop_float:NNTF \g_xor_curr_float_box_tlp\g_xor_floats_free_seq{}{}
  \@savemarbox\g_xor_curr_float_box_tlp{#1}
%    \end{macrocode}
%    We are only interested in the type really:
%    \begin{macrocode}
  \global\toks\g_xor_curr_float_box_tlp{{}{}
                        {}
                        {}
                        {}
                        {mpar}
                        {}
   }
%    \end{macrocode}
%    How far is a marginpar allowed to move past the bottom of the
%    text area? Or say it differently: how much space does a marginpar
%    need to reserve on the page?
%
%    The code below works differently than the \LaTeXe{} one: it will
%    move the marginpar including the line it was issued on to the
%    next column if its text will otherwise fall more than a
%    baselineskip below the page bottom.
%    \begin{macrocode}
  \dim_set:Nn \l_tmpa_dim {\ht\g_xor_curr_float_box_tlp}
  \dim_add:Nn \l_tmpa_dim {\dp\g_xor_curr_float_box_tlp}
  \dim_sub:Nn \l_tmpa_dim \baselineskip   % allow to run long
  \ifdim\l_tmpa_dim < \z@ 
      \dim_zero:N \l_tmpa_dim
  \fi
  \xor_add_here_point:Nn\g_xor_curr_float_box_tlp{\dim_use:N \l_tmpa_dim}     
  \@ignorefalse
  \@esphack
}
%    \end{macrocode}
% \end{macro}   
%
%    
%    
%    
%    
%    
%    
%    
% \begin{macro}{\typeset@a@marginpar}
%    The |\typeset@a@marginpar| code is called when a marginpar is
%    finally added to the current page (either in a trial or in the
%    final run).
%
%    It should be templated!
%
%    Current code is only working for two column setup (!) and lacks
%    any modification possibilities depending on the final position
%    for the marginpar.
%
%    \begin{macrocode}
\def \typeset@a@marginpar{
 \kern-\pagedepth
 \vtop to\pagedepth{\baselineskip\pagedepth
     \dim_zero:N \lineskip
     \vss
     \dim_set:Nn \l_tmpa_dim {\dp\g_xor_curr_float_box_tlp}
  \ifnum \g_xor_curr_col_int = \@ne
%    \end{macrocode}
%    Since this perhaps only a trial setting we have to |\copy| and
%    not to |\box|!\footnote{FIX: Should clear those boxes somewhere
%    else to save space!}
%    \begin{macrocode}
     \llap{\copy\g_xor_curr_float_box_tlp\kern\marginparsep}
  \else
     \ifnum \g_xor_curr_col_int = \g_xor_cols_int
       \rlap{\kern\columnwidth\kern\marginparsep\copy\g_xor_curr_float_box_tlp}
     \else
       \ERROR-NOT-SUPPORTED
     \fi
  \fi
  \kern-\l_tmpa_dim
  \null}
}
%    \end{macrocode}
% \end{macro}   
%
%    
%    
%    
%
% \begin{macro}{\check@and@typeset@a@here@float}
%
%    When we reach |\check@and@typeset@a@here@float| we are trying to
%    place a float from the active list into some area and have
%    encountered a here point while grabbing the column text for this
%    trial placement. In |\check@and@typeset@a@here@float| we check if
%    the type of the here point is the same as the current float and
%    if so whether or not it would conflict with that trial
%    placement. This is the case if
%    \begin{itemize}
%    \item
%      the here float and the float under trial have the same type
%    \item
%      and their ordering gets out of sync.
%    \end{itemize}
%    \begin{macrocode}
\def\check@and@typeset@a@here@float{
%<*trace>
  \@tracepush{check@and@typeset@a@here@float}
%</trace>
%    \end{macrocode}
%    If we don't run with floats then no check are necessary (in fact,
%    the checks would produce incorrect results), so we skip them and
%    immediately typeset the here float.
%    \begin{macrocode}
  \if_xor_trial_with_floats:
%    \end{macrocode}
%    If the current float under trial has the same sequence class as the here
%    object we have to look at the spatial relationship in more detail.
%    \begin{macrocode}
    \ifx\g_xor_here_class_tlp\g_xor_this_class_tlp
%<*trace>
      \tr@ce{here:~ g_xor_here_class_tlp~ =~ this@class~ =~ \g_xor_this_class_tlp}
%</trace>
%    \end{macrocode}
%    If the float under trial has a larger sequence number than the
%    here float we have to ensure that the area we place it in follows
%    the here point, i.e., is either a later column or if it is in the
%    same column comes at the bottom.
%    \begin{macrocode}
      \ifnum \g_xor_this_flseq_num > \g_xor_here_flseq_tlp \relax
%<*trace>
        \tr@ce{here:~ target~ area~ should~ be~ after~ here~ point!}
%</trace>
%    \end{macrocode}
%    Like in the case of checking call-out relations we use the column
%    number returned in |\l_xor_returned_float_col_num| by |\xor_calculate_float_col:|
%    rather than always using the start column of the area.
%    \begin{macrocode}
        \xor_calculate_float_col:
        \ifnum \l_xor_returned_float_col_num > \g_xor_curr_col_int
%<*trace>
          \tr@ce{OK:~ target~ area column~ later}
%</trace>
        \else
          \ifnum \l_xor_returned_float_col_num = \g_xor_curr_col_int
%<*trace>
            \tr@ce{??:~ target~ area~ target~ column~ identical}
%</trace>
%    \end{macrocode}
%    So in case we are in the same column at the top we fail the trial.
%    \begin{macrocode}
            \if t \g_xor_this_area_type_tlp
%<*trace>
              \tr@ce{Fail:~ target~ area~ is~ before~ here~ point}
%</trace>
              \xor_trial_failed_true:
%<*trace>
            \else
              \tr@ce{OK:~ target~ area~ is~ after~ here~ point}
%</trace>
            \fi
          \else
%    \end{macrocode}
%    And we fail the trial if we tried to place the float into an
%    earlier column.
%    \begin{macrocode}
%<*trace>
            \tr@ce{Fail:~ target~ area~  column~ earlier~
                   (\num_use:N \l_xor_returned_float_col_num < \int_use:N\g_xor_curr_col_int)}
%</trace>
            \xor_trial_failed_true:
          \fi
        \fi
%    \end{macrocode}
%    If the float sequence number of the current float is smaller than
%    the one of the here float then we should always handle it via
%    flushing the float out. So the |\else| case is really only there
%    for debugging
%    \begin{macrocode}
%<*debug>
      \else
        \tr@ce{here:~ target~ area~ should~ be~ before~ here~ point!}
        \ifnum \g_xor_this_area_col_tlp > \g_xor_curr_col_int
          \tr@ce{Problem:~ target~ area~  column~ after~ here~ point
                 (\g_xor_this_area_col_tlp > \int_use:N\g_xor_curr_col_int)}
        \else
          \ifnum \g_xor_this_area_col_tlp = \g_xor_curr_col_int
            \tr@ce{??:~ target~ area~ target~ column~ identical}
            \if t \g_xor_this_area_type_tlp
              \tr@ce{OK:~ target~ area~ is~ before~ here~ point}
            \else
              \tr@ce{Problem:~ target~ area~ is~ after~ here~ point}
            \fi
          \else
            \tr@ce{OK:~ target~ area~ is~ before~ here~ point}
          \fi
        \fi
%</debug>
      \fi
    \fi
  \fi
  \if_xor_trial_failed:
%    \end{macrocode}
%    If the test above failed we report progress claiming that the
%    reason is due to the current float being placed before the here
%    float. As mentioned above this should be the only possibility why
%    things fail.
%    \begin{macrocode}
%<*progress>
    \progress@failed{\g_xor_this_area_name_tlp \space before~here~float~
                 (\g_xor_here_type_tlp\space \g_xor_here_flseq_tlp)~
                 in~ column~ \int_use:N \g_xor_curr_col_int}
%</progress>
    \int_gset:Nn \g_xor_curr_col_int \g_xor_cols_int
%<*trace>
    \tr@ce{Failed:~ here~ float~ out~ of~ sync}
%</trace>
  \else
    \typeset@a@here@float
  \fi
%<*trace>
  \@tracepop{check@and@typeset@a@here@float}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%    
%    
%    
% \begin{macro}{\typeset@a@here@float}
%    The |\typeset@a@here@float| is called when a here float is
%    finally added to the current page (either in a trial or in the
%    final run).
%
%    The caption is attached by the usual method where the here
%    area is denoted by |h|\meta{col}|1|. This allows to have
%    different caption placements depending, for example, on the
%    column being near the one of outer margins.
%
%    The float is separated from preceeding and following text by the
%    current value of |\g_xor_float_inline_skip| as defined in the
%    page setup template plus or minus a certain amount to allow
%    grid-based typesetting  if desired.
%    \begin{macrocode}
\def \typeset@a@here@float{
%<*trace>
  \@tracepush{typeset@a@here@float}
%</trace>
%    \end{macrocode}
%    Attach the caption to the float body and store the result in
%    |\g_xor_this_captioned_float_box|.
%    \begin{macrocode}
 \append@here@caption@to@float
%    \end{macrocode}
%    If we are not doing grid typesetting we simply put
%    |\g_xor_float_inline_skip| before and after the formatted
%    float.
%    \begin{macrocode}
 \ifdim \pagesetup@grid@point@sep = \z@
   \skip_set:Nn \l_tmpa_skip \g_xor_float_inline_skip
 \else
%    \end{macrocode}
%    Otherwise we have to work a little harder since now we need to
%    put exactly the right amount of space before and after the float
%    to stay within the grid. So we measure the size of the formatted
%    float and store the value in |\l_tmpa_dim|.
%    \begin{macrocode}
   \dim_set:Nn \l_tmpa_dim {\ht\g_xor_this_captioned_float_box}
   \dim_add:Nn \l_tmpa_dim {\dp\g_xor_this_captioned_float_box}
%    \end{macrocode}
%    To this we add twice |\g_xor_float_inline_skip| which gives us
%    the target size for whole object including surrounding space.
%    \begin{macrocode}
   \dim_add:Nn \l_tmpa_dim {\tw@\g_xor_float_inline_skip}
%    \end{macrocode}
%    Calculate the difference to the nearest grid point\ldots
%    \begin{macrocode}
   \snap@to@grid \l_tmpa_dim  \pagesetup@grid@point@sep 
%    \end{macrocode}
%    \ldots and decide which grid point is closest. If the smaller one
%    is closer use it if we are allowed to shrink the white space by
%    the necessary amount.
%    \begin{macrocode}
   \ifdim \returned@lower@delta@size < \returned@delta@size \relax
     \ifdim \returned@lower@delta@size < 2\g_xor_float_inline_shrink_dim
%    \end{macrocode}
%    Note that for the lower delta size we have to use the
%    negation since we want to backup by this amount and delta sizes
%    are always given in absolute values.
%    \begin{macrocode}
       \xdef \returned@delta@size {-\returned@lower@delta@size }
     \fi
   \fi
%    \end{macrocode}
%    Now set up the amount of white space we need around the float by
%    starting with the |\returned@delta@size| divided by two (i.e.,
%    equal amount contributed to both sides of the float and then add
%    |\g_xor_float_inline_skip|. Notice, that we used a skip
%    register for the calculation so that any minus or plus parts will
%    survive. This is useful in case we are not doing grid typesetting
%    and want to allow for some flexibility.\footnote{This needs perhaps
%    rethinking it the light of extended grid implementation concept!}
%    \begin{macrocode}
   \skip_set:Nn \l_tmpa_skip \returned@delta@size
   \divide  \l_tmpa_skip \tw@
   \skip_add:Nn \l_tmpa_skip \g_xor_float_inline_skip
%<*trace>
   \tr@ce{GRID:~ here~float:~ use~ \skip_use:N \l_tmpa_skip \space above~ and~ below}
%</trace>
 \fi
%    \end{macrocode}
%    Finally typeset the float and its surrounding space which is by
%    now stored in |\l_tmpa_skip|.\footnote{Perhaps make the space
%    above and below specifiable individually. One day, perhaps!}
%    \begin{macrocode}
 \vskip\l_tmpa_skip
 \box\g_xor_this_captioned_float_box
 \vskip\l_tmpa_skip
%<*trace>
  \@tracepop{typeset@a@here@float}
%</trace>
}
%    \end{macrocode}
% \end{macro}   
%
%
% \begin{macro}{\setup@here@float}
%    Absolutely temp!!!!!\footnote{FIX!!!!}
%    \begin{macrocode}
\def \setup@here@float {
%<*trace>
  \@tracepush{setup@here@float}
%</trace>
 \skip_set:Nn \l_tmpa_skip {2\g_xor_float_inline_skip}    %FMi arbitrary value TMP
 \skip_add:Nn \l_tmpa_skip {\ht\g_xor_curr_float_box_tlp} %FMi arbitrary value TMP
 \skip_add:Nn \l_tmpa_skip {\dp\g_xor_curr_float_box_tlp} %FMi arbitrary value TMP
 \skip_add:Nn \l_tmpa_skip {5\baselineskip}               %FMi arbitrary value TMP
 \xor_add_here_point:Nn \g_xor_curr_float_box_tlp {\skip_use:N \l_tmpa_skip}     
%<*trace>
  \@tracepop{setup@here@float}
%</trace>
}
%    \end{macrocode}
% \end{macro}   
%
%    
%    
%
% \endinput
\endinput
%
% $Log$
% Revision 1.7  2004/10/30 18:45:59  mittelba
% further cleanup using expl3 concepts
% first attempt at balancing (unfinished)
%
% Revision 1.6  2004/10/12 21:40:39  mittelba
% updates up to p29
%
% Revision 1.5  2004/10/03 22:44:22  mittelba
% more updates ... still not getting closer ...
%
% Revision 1.4  2004/10/03 15:35:56  mittelba
% more cleanup ... tedious ...
%
% Revision 1.3  2004/10/01 21:46:33  mittelba
% many further updates, still a lot to do
%
% Revision 1.2  2004/09/27 20:06:13  mittelba
% in the middle of normalizing to expl3 syntax
%
% Revision 1.1  2001/07/26 19:55:12  latex3
% original web distrib
%
% Revision 1.12  2000/08/11 07:14:21  latex3
% added header
%
% Revision 1.11  2000/08/04 10:19:09  latex3
% added init of here floats (temp version)
%
% Revision 1.10  2000/07/19 16:05:41  latex3
% introduced float sequence class concept
%
% Revision 1.9  2000/07/10 19:13:34  latex3
% template here floats and support grid typesetting for them.
%
% Revision 1.8  2000/06/29 17:18:44  latex3
% introduced \xor_this_area_setup:o
%
% Revision 1.7  2000/06/18 14:58:32  latex3
% use \xor_calculate_float_col: to determine the target column
% check if here float and current float are in sync
%
% Revision 1.6  2000/06/15 15:23:05  latex3
% untabify
%
% Revision 1.5  2000/06/13 20:45:47  latex3
% docu updates
%
% Revision 1.4  2000/05/03 18:58:56  latex3
% provide caption template support
%
% Revision 1.3  2000/04/27 19:51:45  latex3
% bug fix: need to copy boxes in trials :-)
% moved \check@and@typeset@a@here@float to this file
%
% Revision 1.2  2000/04/21 19:01:13  latex3
% added documentation
%
% Revision 1.1  2000/04/21 10:19:07  latex3
% Initial revision
%
