% \iffalse
%% File xo-new.dtx (C) Copyright 1999-2000 Frank Mittelbach, David Carlisle, Chris Rowley
%%                 (C) Copyright 2003 Piet van Oostrum, David Kastrup
%%                 (C) Copyright 2004-2007 Frank Mittelbach, LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xor bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
\RequirePackage{l3names}
\GetIdInfo $Id$
          {xo-new (part of xor)}
\ProvidesExplPackage{\filename}
  {\filedate}{\fileversion}{\filedescription}
% \fi
%
%
% This package is available for test overwrites that need integration
% into the main packages at some point
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% new attempt at balancing
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \section{Balancing}
%
% \begin{macro}{\g_xor_best_trial_col_hts_balance_NUM_tlp}
%    For balance point |NUM| (which is 0, 1,\ldots) this macro holds
%    the column heights for all columns (parts) that we will need for
%    getting a balanced result.
%    \begin{macrocode}
\tlp_new:c {g_xor_best_trial_col_hts_balance_0_tlp}
%    \end{macrocode}
% \end{macro}
%



% \begin{macro}{\g_xor_balance_delta_dim}
% \begin{macro}{\g_xor_saved_balance_delta_dim}
%     Nominal amount of space not used in all columns when trial balancing. The
%     actual amount might be smaller due to bottom floats in a column
%    \begin{macrocode}
\dim_new:N \g_xor_balance_delta_dim
\dim_new:N \g_xor_saved_balance_delta_dim
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\g_xor_balance_failed_bool}
%    Boolean to indicate that the current balancing trial has failed.
%    \begin{macrocode}
\bool_new:N \g_xor_balance_failed_bool
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_balance_finish_bool}
%    Indicate that we are really finished balancing.\footnote{logic should be
%    checked why do we need two booleans here?}
%    \begin{macrocode}
\bool_new:N \g_xor_balance_finish_bool
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_balance_point_expected_bool}
%    Boolean to indicate that we expect the grab column routine to see a
%    balance point at the end of its last column (if not we have not picked up
%    enough material).
%    \begin{macrocode}
\bool_new:N \g_xor_balance_point_expected_bool
%    \end{macrocode}
% \end{macro}



%
% \begin{macro}{\g_xor_balance_NUM_last_float_num}
%    \begin{macrocode}
\num_new:c{g_xor_balance_0_last_float_num}
\num_new:c{g_xor_balance_1_last_float_num}
\num_new:c{g_xor_balance_2_last_float_num}
\num_new:c{g_xor_balance_3_last_float_num}
%    \end{macrocode}
% \end{macro}


% \begin{macro}{\g_xor_collect_balance_seen_num}
%    Number of balance points encountered during collection
%    \begin{macrocode}
\num_new:N \g_xor_collect_balance_seen_num
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\g_xor_trial_balance_seen_num}
%    Number of balance points encountered in a trial (or when
%    generating the final columns) so far.
%    \begin{macrocode}
\num_new:N \g_xor_trial_balance_seen_num
%    \end{macrocode}
% \end{macro}



% \begin{macro}{\g_xor_trial_balance_done_num}
%    Number of balance blocks we already know the column heights for
%    in the current trial.
%    \begin{macrocode}
\num_new:N \g_xor_trial_balance_done_num
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\g_xor_best_balance_done_num}
%    Number of balance blocks we already know the column heights for
%    in the nest trial so far.
%    \begin{macrocode}
\num_new:N \g_xor_best_balance_done_num
%    \end{macrocode}
% \end{macro}



% \subsection{Grab Column Output Routine}
%
%
%
% \begin{macro}{\xor_OR_trial_grab_balance_setup:}
%    \begin{macrocode}
\def_new:Npn  \xor_OR_trial_grab_balance_setup:  {
%<*trace>
  \@tracepush{xor_OR_trial_grab_balance_setup:}
%</trace>
%    \end{macrocode}
%    In case there is a flush penalty in the collection we have to
%    find out if we see it again during the trial. So we record the
%    number of flush points we see during the trial. Same happens for
%    here and balance points.
%    \begin{macrocode}
  \num_gzero:N \g_xor_trial_flush_seen_num
  \num_gzero:N \g_xor_trial_here_seen_num
  \num_gzero:N \g_xor_trial_balance_seen_num
%<*trace>
  \tr@ce{BALANCE:~ g_xor_trial_balance_seen_num ~<-~
                    \num_use:N \g_xor_trial_balance_seen_num}
  \tr@ce{BALANCE:~ g_xor_trial_balance_done_num ~==~
                    \num_use:N \g_xor_trial_balance_done_num}
%</trace>


  \int_gzero:N \g_xor_curr_col_int

  \if_xor_grab_for_balance_done:TF
     {
%<*trace>
      \tr@ce{BALANCE:~ fast~ regrabbing~ balanced blocks}
%</trace>
      \global\vsize\maxdimen
      \global\output{\xor_OR_regrab_balanced_material:}
     }
     {
      \global\output{\xor_OR_grab_trial_cols:}
      \xor_OR_trial_grab_next_col_setup:
     }
%<*trace>
  \@tracepop{xor_OR_trial_grab_balance_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \begin{macro}{\xor_OR_regrab_balanced_material:}
%    \begin{macrocode}
\def_new:Npn \xor_OR_regrab_balanced_material: {
%<*trace>
  \@tracepush{xor_OR_regrab_balanced_material:}
  \tr@ce{output~pen:~ \the\outputpenalty}
  \tr@ce{vsize:~ \the\vsize;~ pagegoal:~ \the\pagegoal}
%</trace>
  \box_gclear:N \c_twohundred_fifty_five
  \box_gclear:N \footins

  \int_compare:nNnTF \outputpenalty={-\c_xor_output_balance_penalty}
    {
     \num_gincr:N \g_xor_trial_balance_seen_num
     \int_compare:nNnT \g_xor_trial_balance_seen_num =
                       \g_xor_trial_balance_done_num
        {
         \global\output{\xor_OR_grab_trial_cols:}
%<*trace>
         \tr@ce{BALANCE:~ setting~ up~ new~ col~ hts:~
                \tlp_to_str:N \g_xor_balance_trial_col_hts_tlp}
%</trace>
         \g_xor_balance_trial_col_hts_tlp

         \int_gzero:N \g_xor_curr_col_int
         \xor_OR_trial_grab_next_col_setup:
        }
    }
%    \end{macrocode}
%    If it is not a balance point it might be a here or a flush point in which
%    case we record that fact and carry on. Otherwise we simply ignore the penalty.
%    \begin{macrocode}
    {
     \int_compare:nNnTF \outputpenalty={-\c_xor_output_here_float_penalty}
       { \num_gincr:N \g_xor_trial_here_seen_num }
       {
         \int_compare:nNnT \outputpenalty={-\c_xor_output_flush_float_penalty}
          { \num_gincr:N \g_xor_trial_flush_seen_num }
       }
    }
%<*trace>
  \@tracepop{xor_OR_regrab_balanced_material:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\if_xor_grab_for_balance_done:TF}
% \begin{macro}{\if_xor_grab_for_balance_done:T}
%    \begin{macrocode}
\def_new:Npn \if_xor_grab_for_balance_done:TF {
  \if_num:w \g_xor_trial_balance_seen_num 
             < \g_xor_trial_balance_done_num \scan_stop:
%<*trace>
     \tr@ce{BALANCE:~ doing~ existing~ block~
            \num_use:N \g_xor_trial_balance_seen_num <
            \num_use:N \g_xor_trial_balance_done_num
        }
%</trace>
     \exp_after:NN \use_arg_i:nn
   \else:
%<*trace>
     \tr@ce{BALANCE:~ working~ on~ new~ block}
%</trace>
     \exp_after:NN \use_arg_ii:nn
   \fi:
}
\def_new:Npn \if_xor_grab_for_balance_done:T {
  \if_num:w \g_xor_trial_balance_seen_num 
            < \g_xor_trial_balance_done_num \scan_stop:
%<*trace>
     \tr@ce{BALANCE:~ doing~ existing~ block~
            \num_use:N \g_xor_trial_balance_seen_num <
            \num_use:N \g_xor_trial_balance_done_num
        }
%</trace>
     \exp_after:NN \use_arg_i:n
   \else:
     \exp_after:NN \use_none:n
   \fi:
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\xor_OR_trial_balance:NN}
%
%    \begin{macrocode}
%
% #1 what to do next if balancing failed
% #2 what to do next if balancing succeeded (not used right now)
%
\def_new:Npn \xor_OR_trial_balance:NN #1 #2 {
%<*trace>
  \@tracepush{xor_OR_trial_balance:NN~  \exp_not:n{(#1 #2)}}
  \tr@ce{BALANCE:~ balance~ point~ seen~ again}
%</trace>
  \remove@guard@box@from@cclv
%    \end{macrocode}
%    Doing balancing in earnest on a newly detected balancing point. Look how
%    good we are with this trial, if necessary adjust
%    |\g_xor_balance_delta_dim| and recourse.
%    
%    First some safety measure: if the current |\vsize| gets really small we
%    better stop any balancing attempt immediatly.
%    \begin{macrocode}
  \dim_compare:nNnT \vsize < {2\baselineskip}
    { \bool_gset_true:N \g_xor_balance_finish_bool }
%    \end{macrocode}
%    This is a temp solution for crude balancing. Once we shortend the vize so
%    much that we didn't got to the balancing point we retreat to the last
%    good solution and give up. \textbf{To be replaced by something more
%    granular using multicols methods one day.}
%    \begin{macrocode}
  \bool_if:NF \g_xor_balance_finish_bool
   {
    \int_compare:nNnTF \g_xor_curr_col_int < \g_xor_cols_int
      {
%<*trace>
       \tr@ce{BALANCE:~ point~ too~ early;~ aborting}
%</trace>
%    \end{macrocode}
%    Save the old delta in case we have to use it after all.
%    \begin{macrocode}
       \dim_gset:Nn \g_xor_saved_balance_delta_dim \g_xor_balance_delta_dim 
%    \end{macrocode}
%    
%    \begin{macrocode}
       \dim_set:Nn \l_tmpa_dim {\vsize/\g_xor_cols_int}
       \dim_gadd:Nn \g_xor_balance_delta_dim {.5\l_tmpa_dim}
%       \xor_snap_to_grid:nn \g_xor_balance_delta_dim \pagesetup@grid@point@sep
%%B
%<*trace>
       \tr@ce{BALANCE:~ delta~ <-~ \dim_use:N\g_xor_balance_delta_dim}
%</trace>
       \bool_gset_true:N \g_xor_balance_failed_bool
       \bool_gset_true:N \g_xor_balance_point_expected_bool
%<*trace>
       \tr@ce{BALANCE:~ g_xor_balance_point_expected_bool~ <-~ true}
%</trace>
      }
% we are in the last column but the result may look bad
      {
       \vbox_set:Nn \l_tmpa_box 
                    {\vbox_unpack_clear:N \c_twohundred_fifty_five
                     \ifvoid\footins   \else
                       \vskip \skip\footins
                       \vbox_unpack_clear:N \footins
                     \fi
                    }
%    \end{macrocode}
%    
%    \begin{macrocode}
       \dim_compare:nNnT {\vsize - \box_ht:N\l_tmpa_box} > 
                         {\baselineskip}
          {
%<*trace>
           \tr@ce{BALANCE:~ not~ nicely~ balanced;~ retry}
%</trace>
           \bool_gset_true:N \g_xor_balance_failed_bool
           \bool_gset_true:N \g_xor_balance_point_expected_bool
%<*trace>
       \tr@ce{BALANCE:~ g_xor_balance_point_expected_bool~ <-~ true}
%</trace>
           \dim_gset:Nn \g_xor_saved_balance_delta_dim \g_xor_balance_delta_dim 
           \dim_gadd:Nn \g_xor_balance_delta_dim \baselineskip
%           \xor_snap_to_grid:nn \g_xor_balance_delta_dim \pagesetup@grid@point@sep
          }
      }
    }

    \bool_if:NTF \g_xor_balance_failed_bool
      {
%<*trace>
        \tr@ce{BALANCE:~ fail;~ abort}
 %</trace>
        \bool_gset_false:N \g_xor_balance_failed_bool
        \box_gclear:N \c_twohundred_fifty_five
        \box_gclear:N \footins
        \xor_OR_cleanup_setup:N \xor_trial_get_balance_loop:
       
      }
      {

% if too much space left over do something  (not done .. pretend ok)

%<*trace>
        \tr@ce{BALANCE:~ success;~ delta~ used:~ \dim_use:N \g_xor_balance_delta_dim}
%</trace>
        \tlp_gclear:N \g_tmpa_tlp

%%B
        \tlp_gclear:N \g_xor_balance_trial_col_hts_tlp


        \xor_forall_columns:n
          {
           \dim_set:Nc \l_tmpa_dim
                       {g_xor_ht_col_
                        \int_use:N \g_xor_curr_col_int
                        _dim}
% calculate the real delta that was used in this column (actually could be
% saved rather than calculated twice

           \xor_calculate_delta_to_use:N \l_tmpb_dim
           \dim_sub:Nn \l_tmpa_dim \l_tmpb_dim

           \tlp_gput_right:Nx \g_tmpa_tlp
            {
             \exp_not:N \dim_gset:Nn
             \exp_not:c  {g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim}
             {\dim_use:N \l_tmpa_dim }
            }
% next actually should be the remaining space (which it isn't if
% floats are allocated!)

%%B
\iftrue
%%XXX
          \tlp_gput_right:Nx \g_xor_balance_trial_col_hts_tlp
           {
            \exp_not:N \dim_gset:Nn
            \exp_not:c  {g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim}
             {\dim_use:N \l_tmpb_dim }
           }
\fi
          }
        \tlp_gset_eq:cN {g_xor_best_trial_col_hts_balance_
                         \num_use:N \g_xor_trial_balance_seen_num
                         _tlp}
                        \g_tmpa_tlp

%<*trace>
        \tr@ce{BALANCE:~ g_xor_best_trial_col_hts_balance_
                      \num_use:N \g_xor_trial_balance_seen_num
                      _tlp ~=~ \tlp_to_str:N \g_tmpa_tlp }
%</trace>
        \num_gincr:N \g_xor_trial_balance_done_num
%<*trace>
        \tr@ce{BALANCE:~ g_xor_trial_balance_done_num ~<-~
                     \num_use:N \g_xor_trial_balance_done_num}
        \tr@ce{BALANCE:~ solution~ found;~ restart~ cutting~ remaining~ columns}
%</trace>
% restart main trial
        \dim_gzero:N \g_xor_balance_delta_dim

%    \end{macrocode}
%     Finished with balancing so not expecting to see a balance point
%     again\footnote{FIX: we can probably just use a single boolean not two}
%    \begin{macrocode}
        \bool_gset_false:N \g_xor_balance_point_expected_bool
        \bool_gset_false:N \g_xor_balance_finish_bool
%<*trace>
        \tr@ce{BALANCE:~ g_xor_balance_point_expected_bool~ <-~ false}
%</trace>

        \box_gclear:N \c_twohundred_fifty_five
        \box_gclear:N \footins
%    \end{macrocode}
%    We have stored the column heights for the rest of the columns in
%    |\g_xor_balance_trial_col_hts_tlp| and can now restart cutting column
%    material normally (restarting with column 1).
%    \begin{macrocode}
%<*trace>
        \tr@ce{BALANCE:~ new~ col~ heights:~ \tlp_to_str:N\g_xor_balance_trial_col_hts_tlp}
%</trace>
        \g_xor_balance_trial_col_hts_tlp

        \int_gzero:N \g_xor_curr_col_int

% BUG: something is resetting balance_seen to 0

        \xor_OR_trial_grab_next_col_setup:
      }
%<*trace>
  \@tracepop{xor_OR_trial_balance:NN}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%

%
% \begin{macro}{\xor_trial_get_balance_loop:}
%    Place the galley box back on the MVL. Needs to be done via the
%    special output routine call |\xmark_OR_restore_state:n| to ensure that
%    \TeX's primitive marks reflect the `logical' previous page rather
%    than the previous actual output routine call.
%    \begin{macrocode}
\def_new:Npn \xor_trial_get_balance_loop: {
%<*trace>
  \@tracepush{xor_trial_get_balance_loop:}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
  \deadcycles\c_zero
  \glet:NN \xor_floats_active_seq_if_empty_action: \xor_OR_best_cols_setup:
  \glet:NN \pretests@success@action \xor_OR_trial_grab_cols_setup:
%    \end{macrocode}
%
%    |\xmark_OR_restore_state:n| state is a special output routine those
%    only purpose is to reinitialise the state of the mark
%    mechanism. Its argument is executed at the of that OR and must
%    (!) set up a new OR else we find ourselves in trouble.
%    \begin{macrocode}
  \xmark_OR_restore_state:n{
%    \end{macrocode}
%    Initialising the grabbing trials means putting the saved material
%    back onto the MVL and reinitialising the here float list.
%    \begin{macrocode}
    \vbox_unpack:N \g_xor_hold_page_box
%    \end{macrocode}
%    To be able to identify the end of the material for trials for
%    cutting the galley we mark it with a special penalty.
%    \begin{macrocode}
    \xor_add_badly_guarded_penalty:N \c_xor_output_collect_penalty 

    \seq_gset_eq:NN \g_xor_floats_here_seq \g_xor_saved_floats_here_seq
%    \end{macrocode}
%
%    The we can start the actual loop: if we run with floats we go to \\
%    |\xor_trial_place_float_inner_loop:| otherwise we immediately setup the grab
%    column OR.\footnote{fix docu}
%    \begin{macrocode}
%%B
%    \bool_if:NTF \g_xor_trial_with_floats_bool
%    { \xor_trial_place_float_inner_loop: }
%    { \xor_OR_trial_grab_cols_setup: }

     \xor_OR_trial_grab_balance_setup:

    }
%<*trace>
  \@tracepop{xor_trial_get_balance_loop:}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_OR_best_balance_setup:}
%    \begin{macrocode}
\def_new:Npn  \xor_OR_best_balance_setup:  {

   \global\output{\xor_OR_grab_best_cols:}

% next line already set if entering from
% \xor_OR_trial_grab_cols_setup:
% init needs to be cleaned up between the two!

  \int_gzero:N \g_xor_curr_col_int

  \if_xor_grab_for_balance_done:T
  {
%<*trace>
    \tr@ce{BALANCE:~ regrabbing~ columns~ for~ block~
                     \num_use:N \g_xor_trial_balance_seen_num}
%</trace>
    \tlp_use:c {g_xor_best_trial_col_hts_balance_
                \num_use:N \g_xor_trial_balance_seen_num
                _tlp}
  }
  \xor_OR_best_next_col_setup:
}
%    \end{macrocode}
% \end{macro}
%
%



%
% \begin{macro}{\xor_set_best_trial_col_hts:n}
%    Sets |\g_xor_best_trial_col_hts_tlp| with each column getting the height
%    specified in the argument (|\g_xor_curr_col_int| is the current column
%    number and can be used in the argument).
%
%   Calling |\g_xor_best_trial_col_hts_tlp| doesn't change the current
%   |\vsize| but sets for each column |\g_xor_ht_col_NUM_dim| to hold a new height
%   which can then be assigned to |\vsize| when cutting the galley for the column NUM.
%    \begin{macrocode}
\def_new:Npn \xor_set_best_trial_col_hts:n #1 {
  \tlp_gclear:N \g_xor_best_trial_col_hts_tlp
  \xor_forall_columns:n{
    \tlp_gput_right:Nx \g_xor_best_trial_col_hts_tlp
       {
        \exp_not:N \dim_gset:Nn
        \exp_not:c  {g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim}
                    { #1 }
      }
  }
%<*trace>
  \tr@ce{Saving~ column~ heights:}
  \tr@ce{g_xor_best_trial_col_hts_tlp ~:=~\tlp_to_str:N \g_xor_best_trial_col_hts_tlp}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% STUFF THAT CHANGES CHRIS' xo-final (from 2000 or thereabouts)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%    \begin{macrocode}

\flushbottom


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%changes to xo-final
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iftrue %  using Frank's changes built on 1.15








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% my new xo-final stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

                                % traditional LaTeX marks PvO
\DeclareMarkType{leftmark}
\DeclareMarkType{rightmark}
\def\markboth#1#2{%
  \group_begin:
    \let\label\relax \let\index\relax \let\glossary\relax
    \unrestored@protected@xdef\@tempa{#1}%
    \exp_after:NN\@markleft\exp_after:NN{\@tempa}%
    \unrestored@protected@xdef\@tempa{#2}%
    \exp_after:NN\@markright\exp_after:NN{\@tempa}%
  \group_end:
  \if@nobreak\ifvmode\nobreak\fi\fi}
\def\markright#1{%
  \group_begin:
    \let\label\relax \let\index\relax \let\glossary\relax
    \unrestored@protected@xdef\@tempa{#1}%
    \exp_after:NN\@markright\exp_after:NN{\@tempa}%
  \group_end:
  \if@nobreak\ifvmode\nobreak\fi\fi}
\def\@markleft#1{\PutMark{leftmark}{#1}}
\def\@markright#1{\PutMark{rightmark}{#1}}
\def\leftmark{\LastMark{leftmark}}
\def\rightmark{\FirstMark{rightmark}}

                                % Traditional LaTeX headers and footers  PvO
\def\@thehead{\@oddhead} % initialization
\def\@thefoot{\@oddfoot}

\def \myfinalpage {
  \if@twoside
    \ifodd\c@page \let\@thehead\@oddhead \let\@thefoot\@oddfoot
         \let\pagebodylefthpos\oddsidemargin
    \else \let\@thehead\@evenhead
       \let\@thefoot\@evenfoot \let\pagebodylefthpos\evensidemargin
    \fi
  \else
    \let\pagebodylefthpos\oddsidemargin
  \fi
    \mbox@addtopage (\pagebodylefthpos, -\headsep)
       {\hbox to \textwidth{\@thehead}}
%    \end{macrocode}
%
%    \begin{macrocode}
%    Init |\dimen|1,2,3,\ldots as vertical current point per column
%    (don't forget in Chris's (sorry, Don's) universum zero is at the
%    top).
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_forall_columns:n{
     \dimen \int_use:N\g_xor_curr_col_int
            \c_zero_dim
  }
%    \end{macrocode}
%    Now mount all top areas looping through an ordered list of top
%    areas.
%    \begin{macrocode}
  \exp_after:NN\mount@top@areas@loop
      \top@areas
      \relax\relax\relax
%    \end{macrocode}
%    Next mount the text columns.
%    \begin{macrocode}
  \xor_forall_columns:n{

% temp solution: add the amount of top floats to the real size of text material
% so that below the bottom floats are correctly mounted
% needs a totally different approach!!!

\advance \csname g_xor_best_ht_col_ \int_use:N\g_xor_curr_col_int
                 _dim\endcsname 
by \dimen\g_xor_curr_col_int \relax

%<*trace>
     \tr@ce{GRID (delta):~ column~\int_use:N\g_xor_curr_col_int t:~
        \tlp_use:c {g_xor_t_delta_col_ \int_use:N\g_xor_curr_col_int _tlp}
        \space used}
%</trace>
%%% dangerous scratch registers ... FIX
     \advance \dimen \int_use:N\g_xor_curr_col_int
              by %NEEDED!!!!!
              \csname g_xor_t_delta_col_ \int_use:N\g_xor_curr_col_int _tlp\endcsname

     \advance \dimen \int_use:N\g_xor_curr_col_int
              \csname g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim\endcsname


    \setlength \l_tmpa_dim
        {\pagebodylefthpos - \columndisplacement
                           + \columndisplacement * \g_xor_curr_col_int }


    \mbox@addtopage ( \dim_use:N \l_tmpa_dim ,\the \dimen\g_xor_curr_col_int  )
         { \box_use_clear:c {g_xor_col_ \int_use:N\g_xor_curr_col_int _box} }

% here we adjust for the fact that the text column size is rubbish if
% balancing was involved!

\dimen\g_xor_curr_col_int = \csname g_xor_best_ht_col_ \int_use:N\g_xor_curr_col_int _dim\endcsname

%<*trace>
    \tr@ce{GRID (delta):~ column~\int_use:N\g_xor_curr_col_int b:~
        \tlp_use:c {g_xor_b_delta_col_ \int_use:N\g_xor_curr_col_int _tlp}
        \space used}
%</trace>
     \advance \dimen \int_use:N\g_xor_curr_col_int
              by %NEEDED!!!!!
              \csname g_xor_b_delta_col_ \int_use:N\g_xor_curr_col_int _tlp\endcsname
  }
%    \end{macrocode}
%    Then mount the bottom floats.
%    \begin{macrocode}
  \def\col@of@focus{0}               % temp solution see below
  \exp_after:NN\mount@bot@areas@loop
      \bot@areas
      \relax\relax\relax
%    \end{macrocode}
%
%    Next thing is absolutely temp: mount a marginal area on the right
%    (bottom) to allow footnotes there (this is just for testing).
%    \begin{macrocode}
  \setlength \l_tmpa_dim
     {\pagebodylefthpos + \columndisplacement * \g_xor_cols_int }
   \mbox@addtopage ( \dim_use:N \l_tmpa_dim , \textheight )
     { \box_use_clear:N \saved@footins } % TEMP FMi
   \setlength \l_tmpa_dim       % add footer PvO
     {\textheight + \footskip}
   \mbox@addtopage (\pagebodylefthpos, \l_tmpa_dim)
     {\hbox to \textwidth{\@thefoot}}
%
%    Next thing is absolutely temp: mount a marginal area on the right
%    (bottom) to allow marginal floats there (this is just for testing).
%    \begin{macrocode}
  \cs_free:cF {g_xor_area_ m1\int_use:N\g_xor_curr_col_int
                          _seq }
  {
    \g_xor_curr_col_int\g_xor_cols_int
%FMi was local, why?
    \int_gincr:N \g_xor_curr_col_int
    \make@area@floats@box {m \int_use:N\g_xor_curr_col_int 1}\l_tmpa_box
    \setlength \l_tmpa_dim
       {\pagebodylefthpos + \columndisplacement * \g_xor_cols_int }
    \mbox@addtopage ( \dim_use:N \l_tmpa_dim , \textheight )
        { \vbox_to_ht:nn \textheight {\vfil \vbox_unpack_clear:N \l_tmpa_box  \vfil }}
  }
%
  \ifShowGrid
    \dim_compare:nNnT \pagesetup@grid@point@sep > \c_zero_dim
    {
      \int_set:Nn \l_tmpa_int \textheight
      \int_set:Nn \l_tmpb_int \topskip
      \int_sub:Nn \l_tmpa_int \l_tmpb_int
      \dim_set:Nn \l_tmpb_dim \pagesetup@grid@point@sep
      \int_set:Nn \l_tmpb_int \l_tmpb_dim
      \divide\l_tmpa_int\l_tmpb_int
      \int_incr:N \l_tmpa_int

      \setlength \l_tmpb_dim
       {\pagebodylefthpos + \columndisplacement * \g_xor_cols_int
                          - \columnsep }
      \int_set:Nn \count@ \l_tmpb_dim

      \sbox\grid@box{
               \setlength\unitlength{1sp}
               \begin{picture}(0,0)
                 \multiput(0,0)(0,\l_tmpb_int){\l_tmpa_int}
                   {\line(1,0){\count@}}
               \end{picture}
               }

      \mbox@addtopage ( \pagebodylefthpos ,\textheight  )
             {  \box_use_clear:N \grid@box }
    }
  \fi
  \box_ht:N\page@box=\topmargin %PvO
}

\box_new:N\grid@box

\newif\ifShowGrid
\ShowGridtrue

% for tracing only (unchanged)


\def\mbox@addtopage (#1,#2)#3{%
%  \tr@ce{box~being~added~to~page:~at~(#1,~#2) }
  \hbox_gset:Nn \page@box
    {
      \hbox_unpack_clear:N \page@box
      \mbox@put  (#1,#2) {#3}
    }
}




\def\mount@top@areas@loop#1#2#3{
  \ifx#1\relax
  \else
    \mount@top@area#1#2#3
    \exp_after:NN\mount@top@areas@loop
  \fi}


\def\mount@top@area#1#2#3 {
  \make@area@floats@box {#1#2#3}\l_tmpa_box

  \box_if_empty:NF \l_tmpa_box
  {

    \setlength \l_tmpb_dim
        { \dimen#2 + \box_ht:N\l_tmpa_box  + \box_dp:N\l_tmpa_box  }

    \setlength \l_tmpa_dim
        {\pagebodylefthpos - \columndisplacement + \columndisplacement * #2 }

%% change BP
%    \ifnum #2 > 1
% \addtolength \l_tmpa_dim {.5\columnsep}
%    \fi
%% end change

    \mbox@addtopage ( \dim_use:N \l_tmpa_dim ,\dim_use:N \l_tmpb_dim  )
         { \box_use_clear:N \l_tmpa_box  }

    \count@ #2\relax
    \int_add:Nn \count@ {#3}
    \int_dowhile:nNnT {#2} < \count@
    {
      \int_decr:N \count@
      \dimen \count@ =  \l_tmpb_dim
      \int_compare:nNnTF {\num_use:c {g_xor_t_floats_col_
                                        \int_use:N \count@
                                      _num}}
                          > \c_zero
         { \dim_add:Nn {\dimen \count@} \g_xor_float_area_skip }
         { \dim_add:Nn {\dimen \count@} \g_xor_float_text_skip }
    }
  }
}

\def\mount@bot@areas@loop#1#2#3{
  \ifx#1\relax
  \else
    \mount@bot@area#1#2#3
    \exp_after:NN\mount@bot@areas@loop
  \fi}

\def\mount@bot@area#1#2#3 {
  \make@area@floats@box {#1#2#3}\l_tmpa_box

  \box_if_empty:NF \l_tmpa_box
  {

    \setlength \l_tmpb_dim
        { \dimen#2 + \box_ht:N\l_tmpa_box  + \box_dp:N\l_tmpa_box  }

%    \end{macrocode}
%    There are probably much better ways to get the spacing right, the
%    one below is really only a temporary fix: in |\col@of@focus| we
%    remember the last column in which already applied
%    |\g_xor_float_text_skip|, any additional float area will
%    contribute another |\g_xor_float_area_skip|
%    instead.\footnote{To make this work it is absolutely necessary
%    that the floats in bot@areas are ordered by column!!! No-good. FIX!!}
%    \begin{macrocode}
    \int_compare:nNnTF \col@of@focus < {#2}
    {
      \def\col@of@focus{#2}
      \dim_add:Nn \l_tmpb_dim
                  \g_xor_float_text_skip
    }
    {
      \dim_add:Nn \l_tmpb_dim
                  \g_xor_float_area_skip
    }

    \setlength \l_tmpa_dim
        {\pagebodylefthpos - \columndisplacement
         + \columndisplacement * #2 }

%% change BP
%    \ifnum #2 > 1
% \addtolength \l_tmpa_dim {.5\columnsep}
%    \fi
%% end change

    \mbox@addtopage ( \dim_use:N \l_tmpa_dim ,\dim_use:N \l_tmpb_dim )
         { \box_use_clear:N \l_tmpa_box }

%    \end{macrocode}
%    Next loop is actually not necessary as long we keep the
%    restriction that we don't allow partial overlapping float areas, ie we
%    will never mount another float area in the columns that are
%    spanned by the current float area (other than potentially the
%    first and we set this one explicitly).
%    \begin{macrocode}
    \dimen #2 = \l_tmpb_dim
%    \count@ #2\relax
%    \int_add:Nn \count@ {#3}
%    \loop
%      \int_decr:N \count@
%      \dimen \count@ =  \l_tmpb_dim
%    \ifnum #2 < \count@
%    \repeat

  }
}


% of course \top@areas and \bot@areas should be constructed
% automatically when preparing the \g_xor_areas_used_clist or from the \g_xor_areas_known_clist
% but for now i simply define them here:

\def\top@areas{t13 t12 t22 t32 t11 t21 t31}

\def\bot@areas{b11 b12 b13 b21 b22 b31 b32}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
% next line activates my version (well some of it is activated already
% above)
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\let\make@page@box\myfinalpage

\fi % end of stuff modifying xo-final 1.15



%    \end{macrocode}
%

\endinput

%
% $Log$
% Revision 1.17  2005/12/23 13:59:42  morten
% Minor update to make the index work correctly
%
% Revision 1.16  2005/03/01 22:53:12  morten
% Small updates, more expl3 conversion
%
% Revision 1.14  2004/12/06 23:01:23  mittelba
% fix for here float not aligning to grid
%
% Revision 1.13  2004/12/04 22:54:08  mittelba
% starting to define a box module ... unfinished and names not yet right!
%
% Revision 1.12  2004/11/28 18:05:22  mittelba
% another attempt at balancing ... this now works (more or less) if no
% floats are around. basic logic is probably right, implementation
% disgusting and wrong ... but at least some output apears again, which
% is an improment :-) ... we'll see
%
% Revision 1.11  2004/11/13 10:04:06  mittelba
% new license (LPPL)
%
% Revision 1.10  2004/10/31 21:50:31  mittelba
% further balancing ... all very tmp but at least it does start to
% balance :-)
%
% Revision 1.9  2004/10/30 18:46:03  mittelba
% further cleanup using expl3 concepts
% first attempt at balancing (unfinished)
%
% Revision 1.8  2004/10/12 21:40:42  mittelba
% updates up to p29
%
% Revision 1.7  2004/10/03 15:35:59  mittelba
% more cleanup ... tedious ...
%
% Revision 1.6  2004/10/01 21:46:36  mittelba
% many further updates, still a lot to do
%
% Revision 1.5  2004/09/27 20:06:17  mittelba
% in the middle of normalizing to expl3 syntax
%
% Revision 1.4  2004/09/02 15:58:41  mittelba
% stuff moved to xo-final.dtx
%
% Revision 1.3  2003/02/19 14:34:39  kastrup
% Add changes from Piet van Oostrum: compatibility
% marks for LaTeX's default behavior, headers, footers, some fixes.
% Replace \count\z@ with \c@page.
%
% Revision 1.2  2003/02/19 14:16:14  kastrup
% Add changes from Piet van Oostrum: compatibility
% marks for LaTeX's default behavior, headers, footers, some fixes.
%
% Revision 1.1  2001/07/26 19:55:12  latex3
% original web distrib
%
% Revision 1.25  2000/08/11 07:14:23  latex3
% added header
%
% Revision 1.24  2000/08/11 06:49:09  latex3
% untabify
%
% Revision 1.23  2000/08/05 10:01:26  latex3
% ensure that \make@area@floats@box doesn't do any harm to areas not set
% up via \DeclareFloatArea
%
% Revision 1.22  2000/08/04 15:50:31  latex3
% \flushbottom default again
%
% Revision 1.21  2000/08/04 13:58:58  latex3
% \bot@areas need to be ordered by column at the moment!!!!
%
% Revision 1.20  2000/08/04 10:20:09  latex3
% removed old experimental code for grid layout
%
% Revision 1.19  2000/07/22 06:30:50  latex3
% fixed bug in positioning bottom floats
%
% Revision 1.18  2000/07/19 17:12:53  latex3
% introduced float sequence list
%
% Revision 1.17  2000/07/10 19:22:12  latex3
% more grid support
%
% Revision 1.16  2000/07/04 19:48:55  latex3
% experimental stuff for GRIDs
% start writing out columnsizes (unused)
% use \xor_update_this_area_span_cols:n
%
% Revision 1.15  2000/06/29 17:16:59  latex3
% introduced \xor_this_area_setup:o
%
% Revision 1.14  2000/06/26 15:17:26  latex3
% prototype support for \g_xor_float_area_skip
%
% Revision 1.13  2000/06/16 11:21:07  latex3
% rename \construct@and@test@col@height to \construct@and@test@col@ht
% rename \construct@and@test@col@heights to \construct@and@test@col@hts
% rename \cl@height1 to \@col@ht@1 (etc)
%
% Revision 1.12  2000/06/15 15:22:36  latex3
% implemented new semantics for area names
%
% Revision 1.11  2000/06/13 21:23:03  latex3
% *** empty log message ***
%
% Revision 1.10  2000/05/04 09:21:27  latex3
% urg: \g_xor_this_area_tlp undefined inside the output routine, so captions got
% typeset with whatever was the last \g_xor_this_area_tlp.
%
% Revision 1.9  2000/05/03 18:41:52  latex3
% still overwriting code for xo-final 1.15 ! (not 1.16)
% enabling support for caption templates
%
% Revision 1.8  2000/04/21 19:16:32  latex3
% activate my version of xo-final
%
% Revision 1.7  2000/04/21 19:05:21  latex3
% my version of xo-final mainly
%
% Revision 1.6  2000/04/09 20:02:42  latex3
% first draft of marginpar support
%
% Revision 1.5  2000/03/24 15:34:27  latex3
% version that starts supporting spans (still a hack yet)
%
% Revision 1.4  2000/02/26 18:26:08  david
% code moved to xo-*
%
% Revision 1.3  2000/02/13  21:37:20  latex3
% ooops, my ultrix rcs is too old to guess the comment char correctly
% so we better add explicit \endinput
%
% Revision 1.2  2000/02/13  21:35:25  latex3
% wording
%
% Revision 1.1  2000/02/13  21:34:51  latex3
% Initial revision
%
