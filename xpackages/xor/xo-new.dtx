% \iffalse
%% File xo-new.dtx (C) Copyright 1999-2000 Frank Mittelbach, David Carlisle, Chris Rowley
%%                 (C) Copyright 2003 Piet van Oostrum, David Kastrup
%%                 (C) Copyright 2004-2006 Frank Mittelbach, LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xor bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
\def\next$Id: #1.dtx #2 #3-#4-#5 #6 #7$#8{%
  \def\fileversion{#2}%
  \def\filedate{#3/#4/#5}%
  \ProvidesPackage{#1}[#3/#4/#5 v#2 #8]%
}
\next$Id$
          {xo-new (part of xor)}
% \fi
%
%
% This package is available for test overwrites that need integration
% into the main packages at some point
%
% Ignore white space in this package.
%    \begin{macrocode}
\InternalSyntaxOn
%    \end{macrocode}
%

%


% \begin{macro}{\g_xor_best_trial_col_hts_balance_NUM_tlp}
%    For balance point |NUM| (which is 0, 1,\ldots) this macro holds
%    the column heights for all columns (parts) that we will need for
%    getting a balanced result.
%    \begin{macrocode}
\tlp_new:cn {g_xor_best_trial_col_hts_balance_0_tlp} {}
%    \end{macrocode}
% \end{macro}
%
%
% Moved the balance boxes to xo-or.
%    \begin{macrocode}
%%\box_new:c {g_xor_col_
%%                  1
%%                  _balance_box }
%%
%%\box_new:c {g_xor_col_
%%                  2
%%                  _balance_box }



\dim_new:N \g_xor_balance_delta_dim

\bool_new:N \g_xor_balance_failed_bool


%    \end{macrocode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% new attempt at balancing
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{macro}{\balancecolumns}
%    Add a balance point into the galley. When we process this code we
%    will be  collecting material so we increment
%    |\g_xor_collect_balance_seen_num| (i.e., number of balance points
%    seen during collection and we record which floats are ``before''
%    that point by storing the current |\g_xor_flseq_int| in
%    |\g_xor_balance_<NUM>_last_float_num|.\footnote{before or after
%    we increment?}
%    \begin{macrocode}
\def\balancecolumns {
  \@tracepush{balancecolumns}
  \add@badly@guarded@penalty\c_xor_output_balance_penalty
  \num_gset:cn
      {g_xor_balance_
       \num_use:N \g_xor_collect_balance_seen_num
       _last_float_num}
      {\int_use:N \g_xor_flseq_int}
  \num_gincr:N\g_xor_collect_balance_seen_num
  \@tracepop{balancecolumns}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_balance_NUM_last_float_num}
%    \begin{macrocode}
\num_new:c{g_xor_balance_0_last_float_num}
\num_new:c{g_xor_balance_1_last_float_num}
\num_new:c{g_xor_balance_2_last_float_num}
\num_new:c{g_xor_balance_3_last_float_num}
%    \end{macrocode}
% \end{macro}


% \begin{macro}{\g_xor_collect_balance_seen_num}
%    Number of balance points encountered during collection
%    \begin{macrocode}
\num_new:N \g_xor_collect_balance_seen_num
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\g_xor_trial_balance_seen_num}
%    Number of balance points encountered in a trial (or when
%    generating the final columns) so far.
%    \begin{macrocode}
\num_new:N \g_xor_trial_balance_seen_num
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\g_xor_trial_balance_done_num}
%    Number of balance blocks we already know the column heights for
%    in a trial (or when generating the final columns).
%    \begin{macrocode}
\num_new:N \g_xor_trial_balance_done_num
%    \end{macrocode}
% \end{macro}


% \subsection{Grab Column Output Routine}
%
% \begin{description}
% \item[Entry:] |\xor_OR_trial_grab_cols_setup:|
% \item[Exit:]  |\xor_OR_cleanup_setup:N \xor_trial_place_float_loop:|
% \item[Prereq:]
% \item[Description:]
% \item[Flow:]
%\begin{footnotesize}
%\begin{verbatim}
%    \xor_OR_trial_grab_cols_setup:
%            |
%    New OR: \xor_OR_grab_trial_cols:
%            |
%    \xor_OR_trial_grab_balance_setup:  <-------
%            |
%    \xor_OR_trial_grab_next_col_setup: <-------
%            |
%    (when entering OR...)
%            |
%    <end of collection reached?>
%         |          |
%        yes        no
%         |          |
%         |     <col break requested?>
%         |          |        |
%         |         yes       no
%         |          |        |
%         |          |     <flush point encountered?>
%         |          |        |                  |
%         |          |       yes                 no
%         |          |        |                  |
%         |          | <grabbing already         |
%         |          |   balanced cols?  >       |
%         |          |        |     |            |
%         |          |        no   yes           |
%         |          |        |     |            |
%         |          |        |     |___         |
%         |          |        |         |        |
%         |          |        |         |        |
%         |          |        |         |        |
%         |          | <flush point     |   <here point encountered?>
%         |          |      too early?> |      |               |
%         |          |    |      |      |     yes              no
%         |          |   yes    no    __|      |               |
%         |          |    |      |    |        ?               ?
%         |          |    | (ignore break)
%         |          |    |      |
%         |          |    |      |
% (end column now) <-------      |
%         |                      |
%         V                      |
%   <all cols produced?>         |
%      |           |             V
%     yes          no--------------------> (reenter \xor_OR_trial_grab_next_col_setup:)
%      |
%  <grabbing already
%     balanced cols? >
%      |         |
%      no        yes---------------------> (incr. ???
%      |                                    reenter  \xor_OR_trial_grab_balance_setup:)
%      |
% (store results of trial)
%      |
%      V
%    \xor_OR_cleanup_setup:N \xor_trial_place_float_loop:
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%
%  \begin{macro}{\xor_OR_trial_grab_cols_setup:}
%    \begin{macrocode}
\def_new:Npn \xor_OR_trial_grab_cols_setup: {
%<*trace>
  \@tracepush{xor_OR_trial_grab_cols_setup:}
%</trace>
%    \end{macrocode}
%
%    We just returned to the MVL the current galley. At its end we
%    have added the special penalty |\c_xor_output_collect_penalty| to mark
%    the point that we need to reach in order to remove everything
%    after the trial run. However with one exception\footnote{why?
%    FIX/EXPLAIN}: if we have seen the |\c_xor_output_endgame_penalty| we
%    have not replaced it by |\c_xor_output_collect_penalty| so we do this
%    now.  This penalty has to be guarded against premature removal,
%    e.g., if the algorithm would break exactly before it it would
%    then be discarded which we can't allow.
%    \begin{macrocode}
%FMi may not be necessary
  \int_compare:nNnT \g_xor_saved_output_penalty_tlp  = {-\c_xor_output_endgame_penalty}
  {\add@badly@guarded@penalty\c_xor_output_collect_penalty}
%    \end{macrocode}
%
%    \begin{macrocode}
  \bool_gset_false:N \g_xor_trial_failed_bool
  \int_gzero:N \g_xor_curr_col_int
%    \end{macrocode}
%    In case there is a flush penalty in the collection we have to
%    find out if we see it again during the trial. So we record the
%    number of flush points we see during the trial. Same happens for
%    here and balance points.
%    \begin{macrocode}
  \num_gzero:N \g_xor_trial_flush_seen_num
  \num_gzero:N \g_xor_trial_here_seen_num
  \num_gzero:N \g_xor_trial_balance_seen_num
%<*trace>
  \tr@ce{BALANCE:~ g_xor_trial_balance_seen_num ~<-~
                    \num_use:N \g_xor_trial_balance_seen_num}
  \tr@ce{BALANCE:~ g_xor_trial_balance_done_num ~==~
                    \num_use:N \g_xor_trial_balance_done_num}
%</trace>
%    \end{macrocode}
%
%    Moved from |\xor_try_this_area:| as it should be executed
%    only if we really do a trial and thus back it out if
%    unsuccessful---this was a bug as it changed
%    |g_xor_flseq_type_|\meta{type}|_col_|\meta{col}|_num| in cases
%    we never came to this
%    point here but recoursed)
%    \begin{macrocode}
  \bool_if:NT \g_xor_trial_with_floats_bool
  {
%    \end{macrocode}
%    Depending on the policy a spanning float can be considered belong
%    to different columns. This influences the behaviour of the
%    call-out contraint tests and is determined by the code stored in
%    |\xor_calculate_float_col:|.
%    \begin{macrocode}
    \xor_calculate_float_col:
%    \end{macrocode}
%    |\xor_calculate_float_col:| returns its calculated column
%    number in |\l_xor_returned_float_col_num|.
%    \begin{macrocode}
    \num_gset_eq:Nc \g_xor_saved_flseq_num
                    {g_xor_flseq_type_ \g_xor_this_class_tlp _col_
                     \num_use:N \l_xor_returned_float_col_num _num}
    \num_gset_eq:cN {g_xor_flseq_type_ \g_xor_this_class_tlp _col_
                     \num_use:N \l_xor_returned_float_col_num _num}
                    \g_xor_this_flseq_num
%<*trace>
    \tr@ce{~g_xor_flseq_type_ \g_xor_this_class_tlp _col_
            \num_use:N \l_xor_returned_float_col_num _num \space <-~
           \num_use:c{g_xor_flseq_type_ \g_xor_this_class_tlp _col_
                      \num_use:N \l_xor_returned_float_col_num _num} }
%</trace>
%    \end{macrocode}
%    If we are adding to a top area we also have to update the
%    corresponding |\g_xor_flseq_areas_top_type_...| commands:
%    \begin{macrocode}
    \if:w t\g_xor_this_area_type_tlp
      \num_gset_eq:Nc \g_xor_saved_flseq_top_areas_num
                      {g_xor_flseq_areas_top_type_
                       \g_xor_this_class_tlp _col_
                       \num_use:N \l_xor_returned_float_col_num _num}
      \num_gset_eq:cN
                      {g_xor_flseq_areas_top_type_
           \g_xor_this_class_tlp _col_
             \num_use:N \l_xor_returned_float_col_num _num}
                      \g_xor_this_flseq_num
%<*trace>
      \tr@ce{~g_xor_flseq_areas_top_type_ \g_xor_this_class_tlp _col_
                    \num_use:N \l_xor_returned_float_col_num _num \space <-~
             \num_use:c {g_xor_flseq_areas_top_type_ \g_xor_this_class_tlp _col_
                         \num_use:N \l_xor_returned_float_col_num _num} }
%</trace>
    \fi:
  }
%    \end{macrocode}
%
%    If we have seen any flush points during collection we need to
%    save their current |min_col| positions in case we have to throw
%    away the current trial.
%    \begin{macrocode}
  \bool_if:NT \g_xor_flush_seen_bool
  {
    \int_zero:N \l_loop_int
    \int_while:nNnT \g_xor_collect_flush_seen_num>\l_loop_int
    {
      \int_incr:N \l_loop_int
      \num_gset_eq:cc
        {g_xor_saved_flush_ \int_use:N \l_loop_int _min_col_num}
        {g_xor_flush_       \int_use:N \l_loop_int _min_col_num}
%<*trace>
      \tr@ce{g_xor_saved_flush_ \int_use:N \l_loop_int _min_col_num \space <-~
            \num_use:c{g_xor_flush_ \int_use:N \l_loop_int _min_col_num}}
%</trace>
    }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_initialise_footins_action:
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_OR_trial_grab_balance_setup:
%    \end{macrocode}
%
%    \begin{macrocode}
%<*trace>
  \@tracepop{xor_OR_trial_grab_cols_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%

% \begin{macro}{\xor_OR_trial_grab_balance_setup:}
%    \begin{macrocode}
\def_new:Npn  \xor_OR_trial_grab_balance_setup:  {

  \global\output{\xor_OR_grab_trial_cols:}

% next line already set if entering from
% \xor_OR_trial_grab_cols_setup:
% init needs to be cleaned up between the two!

  \int_gzero:N \g_xor_curr_col_int

  \if_xor_grab_for_balance_done:T
  {
%<*trace>
    \tr@ce{BALANCE:~ regrabbing~ columns~ for~ block~
                    \num_use:N \g_xor_trial_balance_seen_num}
%</trace>
    \tlp_use:c {g_xor_best_trial_col_hts_balance_
                \num_use:N \g_xor_trial_balance_seen_num
                _tlp}
  }
  \xor_OR_trial_grab_next_col_setup:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\if_xor_grab_for_balance_done:TF}
% \begin{macro}{\if_xor_grab_for_balance_done:T}
%    \begin{macrocode}
\def_new:Npn \if_xor_grab_for_balance_done:TF {
  \if_num:w \g_xor_trial_balance_seen_num < \g_xor_trial_balance_done_num \scan_stop:
%<*trace>
     \tr@ce{BALANCE:~ doing~ existing~ block~
            \num_use:N \g_xor_trial_balance_seen_num <
            \num_use:N \g_xor_trial_balance_done_num
        }
%</trace>
     \exp_after:NN \use_arg_i:nn
   \else:
%<*trace>
     \tr@ce{BALANCE:~ working~ on~ new~ block}
%</trace>
     \exp_after:NN \use_arg_ii:nn
   \fi:
}
\def_new:Npn \if_xor_grab_for_balance_done:T {
  \if_num:w \g_xor_trial_balance_seen_num < \g_xor_trial_balance_done_num \scan_stop:
%<*trace>
     \tr@ce{BALANCE:~ doing~ existing~ block~
            \num_use:N \g_xor_trial_balance_seen_num <
            \num_use:N \g_xor_trial_balance_done_num
        }
%</trace>
     \exp_after:NN \use_arg_i:n
   \else:
     \exp_after:NN \use_none:n
   \fi:
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\xor_OR_trial_balance:n}
%    \begin{macrocode}
\def_new:Npn \xor_OR_trial_balance:n #1 {
%<*trace>
  \tr@ce{BALANCE:~ end~ point~ seen~ again}
%</trace>
  \remove@guard@box@from@cclv
  \if_xor_grab_for_balance_done:TF
  {
    \num_gincr:N \g_xor_trial_balance_seen_num
    \box_gclear:N \c_twohundred_fifty_five
    \box_gclear:N \footins
%?
    \int_gzero:N \g_xor_curr_col_int
    \g_xor_best_trial_col_hts_tlp
%<*trace>
    \tr@ce{BALANCE:~ setting~ up~ new~ col~ hts:~
         \cs_meaning:N \g_xor_best_trial_col_hts_tlp}
%</trace>
%     {\showoutput\showlists}
    \xor_OR_trial_grab_next_col_setup:
  }
  {
    \int_compare:nNnTF \g_xor_curr_col_int < \g_xor_cols_int
    {
%<*trace>
      \tr@ce{BALANCE:~ point~ too~ early;~ aborting}
%</trace>
%FMi tmp
      \dim_set:Nn \l_tmpa_dim {\vsize/\g_xor_cols_int}
      \dim_gadd:Nn \g_xor_balance_delta_dim {.5\l_tmpa_dim}
      \bool_gset_true:N \g_xor_balance_failed_bool
    }
    {
      \vbox_set:Nn \l_tmpa_box {\vbox_unpack_and_clear:N \c_twohundred_fifty_five}
      \dim_compare:nNnT {\vsize - \box_ht:N\l_tmpa_box} > {\g_xor_cols_int\baselineskip}
      {
%<*trace>
        \tr@ce{BALANCE:~ not~ nicely~ balanced;~ retry}
%</trace>
        \bool_gset_true:N \g_xor_balance_failed_bool
        \dim_gadd:Nn \g_xor_balance_delta_dim \baselineskip
      }
    }
    \bool_if:NTF \g_xor_balance_failed_bool
    {
% abort immediately
      \bool_gset_true:N \g_xor_trial_failed_bool
      \int_gset:Nn \g_xor_curr_col_int \g_xor_cols_int
      #1
    }
    {

% if too much space left over do something  (not done .. pretend ok)

%<*trace>
      \tr@ce{BALANCE:~ success;~ using~ \dim_use:N \g_xor_balance_delta_dim}
%</trace>
      \tlp_gclear:N \g_tmpa_tlp
      \tlp_gclear:N \g_xor_best_trial_col_hts_tlp

      \xor_forall_columns:n
      {
        \dim_set:Nc \l_tmpa_dim
            {g_xor_ht_col_
            \int_use:N \g_xor_curr_col_int
            _dim}
        \dim_sub:Nn \l_tmpa_dim  \g_xor_balance_delta_dim

        \tlp_gput_right:Nx \g_tmpa_tlp
        {
          \exp_not:N \dim_gset:Nn
          \exp_not:c  {g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim}
          {\dim_use:N \l_tmpa_dim }
        }

% next actually should be the remaining space (which it isn't if
% floats are allocated!)

        \tlp_gput_right:Nx \g_xor_best_trial_col_hts_tlp
        {
          \exp_not:N \dim_gset:Nn
          \exp_not:c  {g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim}
          {\dim_use:N \g_xor_balance_delta_dim }
        }
      }

      \tlp_gset_eq:cN {g_xor_best_trial_col_hts_balance_
                      \num_use:N \g_xor_trial_balance_seen_num
                      _tlp}
                      \g_tmpa_tlp

%<*trace>
      \tr@ce{BALANCE:~ g_xor_best_trial_col_hts_balance_
                      \num_use:N \g_xor_trial_balance_seen_num
                      _tlp ~=~ \meaning \g_tmpa_tlp }
%</trace>
      \num_gincr:N \g_xor_trial_balance_done_num
%<*trace>
      \tr@ce{BALANCE:~ g_xor_trial_balance_done_num ~<-~
                     \num_use:N \g_xor_trial_balance_done_num}
%</trace>
% restart trial
      \dim_gzero:N \g_xor_balance_delta_dim
      \xor_OR_cleanup_setup:N \xor_trial_get_balance_loop:
    }
% cleanup
% #1
  }
}
%    \end{macrocode}
% \end{macro}
%


% \begin{macro}{\xor_trial_place_float_setup:}
%
%    \begin{macrocode}
\def_new:Npn \xor_trial_place_float_setup: {
% initialise before trial loop (needs work)
%<*trace>
  \@tracepush{xor_trial_place_float_setup:}
%</trace>
%    \end{macrocode}
%    A bit statistics: how many floats do we have on the
%    |\g_xor_floats_active_seq|?
%    \begin{macrocode}
%<*progress>
  \seq_map_inline:Nn
      \g_xor_floats_active_seq
      {\num_gincr:N\g_xor_trials_done_num}
  \progress@nl{STATS:~ floats~ waiting~ =~ \num_use:N\g_xor_trials_done_num
        \space on~ page~ \num_use:N \g_xor_page_absolute_num}
  \progress@separator
  \num_gzero:N \g_xor_trials_done_num
%</progress>
%    \end{macrocode}
%    We need the list of here floats during all trials. They are
%    therefore saved in |\g_xor_saved_floats_here_seq| at this point which is then
%    used to initialise |\g_xor_floats_here_seq| at the beginning of each trial.
%    \begin{macrocode}
  \glet:NN \g_xor_saved_floats_here_seq \g_xor_floats_here_seq
%    \end{macrocode}
%
%    \begin{macrocode}
  \tighten@float@placement@conditions
%    \end{macrocode}
%
%    \begin{macrocode}
  \num_gzero:N \g_xor_trial_balance_done_num
%<*trace>
  \tr@ce{BALANCE:~ g_xor_trial_balance_done_num ~==~
                    \num_use:N \g_xor_trial_balance_done_num}
%</trace>
%    \end{macrocode}
%    First time we run the |\xor_trial_place_float_loop:| we run it without
%    actually trying any floats (i.e., we are just cutting the
%    galley).\footnote{Could be improved: if there are no floats then
%    we run it once too often this way (per page) so\ldots}
%    \begin{macrocode}
  \bool_gset_false:N \g_xor_trial_with_floats_bool
  \xor_trial_place_float_loop:
%<*trace>
  \@tracepop{xor_trial_place_float_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_trial_get_balance_loop:}
%    Place the galley box back on the MVL. Needs to be done via the
%    special output routine call |\xmark_OR_restore_state:n| to ensure that
%    \TeX's primitive marks reflect the `logical' previous page rather
%    than the previous actual output routine call.
%    \begin{macrocode}
\def_new:Npn \xor_trial_get_balance_loop: {
%<*trace>
  \@tracepush{xor_trial_get_balance_loop:}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
  \deadcycles\c_zero
  \glet:NN \xor_floats_active_seq_if_empty_action: \xor_OR_best_cols_setup:
  \glet:NN \pretests@success@action \xor_OR_trial_grab_cols_setup:
%    \end{macrocode}
%
%    |\xmark_OR_restore_state:n| state is a special output routine those
%    only purpose is to reinitialise the state of the mark
%    mechanism. Its argument is executed at the of that OR and must
%    (!) set up a new OR else we find ourselves in trouble.
%    \begin{macrocode}
  \xmark_OR_restore_state:n{
%    \end{macrocode}
%    Initialising the grabbing trials means putting the saved material
%    back onto the MVL and reinitialising the here float list.
%    \begin{macrocode}
    \vbox_unpack:N \g_xor_hold_page_box
%    \end{macrocode}
%    To be able to identify the end of the material for trials or fo
%    cutting the galley we mark it with a special penalty unless we
%    are at the end of the document since the
%    |\c_xor_output_endgame_penalty| will be readded by \TeX{} anyway if it
%    sees the |\@@end| primitive again.
%    \begin{macrocode}
    \int_compare:nNnT \g_xor_saved_output_penalty_tlp  > {-\c_xor_output_endgame_penalty}
    { \add@badly@guarded@penalty\c_xor_output_collect_penalty }
    \glet:NN \g_xor_floats_here_seq\g_xor_saved_floats_here_seq
%    \end{macrocode}
%
%    The we can start the actual loop: if we run with floats we go to
%    |\xor_trial_place_float_inner_loop:| otherwise we immediately setup the grap
%    column OR.
%    \begin{macrocode}
    \bool_if:NTF \g_xor_trial_with_floats_bool
    { \xor_trial_place_float_inner_loop: }
    { \xor_OR_trial_grab_cols_setup: }
    }
%<*trace>
  \@tracepop{xor_trial_get_balance_loop:}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_OR_trial_grab_next_col_setup:}
%    The |\xor_OR_grab_trial_cols:| output routine is responsible for
%    constructing one column of a layout trial.  The loop command
%    increments the column count and sets vsize to the target height
%    for the current column (which has already been set based on the
%    size and position of the floats in this trial layout.
%    \begin{macrocode}
\def_new:Npn \xor_OR_trial_grab_next_col_setup:{
%<*trace>
  \@tracepush{xor_OR_trial_grab_next_col_setup:}
%</trace>
  \int_gincr:N \g_xor_curr_col_int
  \dim_gset:Nc \vsize {g_xor_ht_col_
                       \int_use:N\g_xor_curr_col_int
                       _dim}
  \if_xor_grab_for_balance_done:TF
    {
%<*trace>
     \tr@ce{BALANCE:~ delta~ ignored }
%</trace>
    }
    {
%<*trace>
     \tr@ce{BALANCE:~ delta~ =~ \dim_use:N \g_xor_balance_delta_dim }
%</trace>
     \dim_gsub:Nn \vsize \g_xor_balance_delta_dim
    }
%<*trace>
  \tr@ce{vsize~ setup~ =~ \dim_use:N \vsize }
  \@tracepop{xor_OR_trial_grab_next_col_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_OR_best_cols_setup:}
%    This is the initialisation code for producing the final best set
%    of columns (via the |\xor_OR_grab_best_cols:| output routine).
%    \begin{macrocode}
\def_new:Npn \xor_OR_best_cols_setup:{
%<*trace>
  \@tracepush{xor_OR_best_cols_setup:}
%</trace>
  \int_gzero:N \g_xor_curr_col_int
  \num_gzero:N \g_xor_trial_flush_seen_num
  \num_gzero:N \g_xor_trial_here_seen_num
  \num_gzero:N \g_xor_trial_balance_seen_num
%<*trace>
  \tr@ce{BALANCE:~ g_xor_trial_balance_seen_num ~<-~
                    \num_use:N \g_xor_trial_balance_seen_num}
%</trace>
  \perhaps@write@placements@to@fpl@file

  \if_xor_grab_for_balance_done:TF
  {
%<*trace>
    \cs_show:c {
       g_xor_best_trial_col_hts_balance_
                 \num_use:N \g_xor_trial_balance_seen_num
                 _tlp
    }
%</trace>
     \tlp_use:c {g_xor_best_trial_col_hts_balance_
                 \num_use:N \g_xor_trial_balance_seen_num
                 _tlp}
  }
  {
%<*trace>
    \cs_show:N \g_xor_best_trial_col_hts_tlp
%</trace>
    \g_xor_best_trial_col_hts_tlp
  }
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_initialise_footins_action:
%    \end{macrocode}
%
%    \begin{macrocode}
   \xor_OR_best_balance_setup:
%<*trace>
 \@tracepop{xor_OR_best_cols_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_OR_best_balance_setup:}
%    \begin{macrocode}
\def_new:Npn  \xor_OR_best_balance_setup:  {

   \global\output{\xor_OR_grab_best_cols:}

% next line already set if entering from
% \xor_OR_trial_grab_cols_setup:
% init needs to be cleaned up between the two!

  \int_gzero:N \g_xor_curr_col_int

  \if_xor_grab_for_balance_done:T
  {
%<*trace>
    \tr@ce{BALANCE:~ regrabbing~ columns~ for~ block~
                     \num_use:N \g_xor_trial_balance_seen_num}
%</trace>
    \tlp_use:c {g_xor_best_trial_col_hts_balance_
                \num_use:N \g_xor_trial_balance_seen_num
                _tlp}
  }
  \xor_OR_best_next_col_setup:
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_OR_best_finish_col:}
%
%    \begin{macrocode}
\def\xor_OR_best_finish_col:{
%<*trace>
  \@tracepush{xor_OR_best_finish_col:}
%</trace>
  \xmark_update_structure
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_deal_with_footins_action:
%    \end{macrocode}
%
% save all marks here\footnote{not done yet!}
%
% add floats and footnotes etc to collected column
%
%    \begin{macrocode}
  \if_xor_grab_for_balance_done:TF
  {
%<*trace>
    \tr@ce{BALANCE:~ storing~ away~ col~ \int_use:N \g_xor_curr_col_int}
%</trace>
    \box_if_empty:cTF {g_xor_col_
                    \int_use:N \g_xor_curr_col_int
                    _balance_box }
    {
%<*trace>
    \tr@ce{BALANCE:~ box~ empty~ }
%</trace>
       \box_gset_eq:cN {g_xor_col_
       \int_use:N \g_xor_curr_col_int
       _balance_box}
          \c_twohundred_fifty_five
    }
    {
%<*trace>
      \tr@ce{BALANCE:~ box~ already~ used~ }
%</trace>
      \dim_set:Nn \l_tmpa_dim
      { \box_dp:c { g_xor_col_
                  \int_use:N \g_xor_curr_col_int
                  _balance_box
        }
      }
      \vbox_gset:cn
      {g_xor_col_
            \int_use:N \g_xor_curr_col_int
            _balance_box }
      { \box_use_and_clear:c {g_xor_col_
                              \int_use:N \g_xor_curr_col_int
                              _balance_box }
        \vskip -\l_tmpa_dim
        \hrule\kern-0.4pt
        \box_use_and_clear:N \c_twohundred_fifty_five
      }
%<*trace>
      {
        \showoutput
        \showboxdepth1\relax
        \scrollmode
        \box_show:c {g_xor_col_
                    \int_use:N \g_xor_curr_col_int
                    _balance_box }
      }
%</trace>
    }
    \int_compare:nNnT \g_xor_curr_col_int=\g_xor_cols_int
    {
      \num_gincr:N \g_xor_trial_balance_seen_num
%<*trace>
      \tr@ce{BALANCE:~ g_xor_trial_balance_seen_num ~<-~
                     \num_use:N \g_xor_trial_balance_seen_num}
%</trace>
      \int_gzero:N \g_xor_curr_col_int
      \if_xor_grab_for_balance_done:TF
      {
        \cs_show:c { g_xor_best_trial_col_hts_balance_
                     \num_use:N \g_xor_trial_balance_seen_num
                     _tlp }
        \tlp_use:c {g_xor_best_trial_col_hts_balance_
                   \num_use:N \g_xor_trial_balance_seen_num
                   _tlp}
      }
      {
        \cs_show:N \g_xor_best_trial_col_hts_tlp
        \g_xor_best_trial_col_hts_tlp
      }
    }
  }
  {
    \xor_produce_final_column:
  }
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_compare:nNnTF \g_xor_curr_col_int=\g_xor_cols_int
  {
    \produce@final@page
    \xor_next_page_setup:
    \xor_try_float_pages:
    \place@deferred@floats
    \xor_collect_setup:
%{\showoutput\showlists}
  }
  {
    \xor_OR_best_next_col_setup:
  }
%<*trace>
  \@tracepop{xor_OR_best_finish_col:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% STUFF THAT CHANGES CHRIS' xo-final (from 2000 or thereabouts)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%    \begin{macrocode}

\flushbottom


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%changes to xo-final
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iftrue %  using Frank's changes built on 1.15








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% my new xo-final stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

                                % traditional LaTeX marks PvO
\DeclareMarkType{leftmark}
\DeclareMarkType{rightmark}
\def\markboth#1#2{%
  \group_begin:
    \let\label\relax \let\index\relax \let\glossary\relax
    \unrestored@protected@xdef\@tempa{#1}%
    \exp_after:NN\@markleft\exp_after:NN{\@tempa}%
    \unrestored@protected@xdef\@tempa{#2}%
    \exp_after:NN\@markright\exp_after:NN{\@tempa}%
  \group_end:
  \if@nobreak\ifvmode\nobreak\fi\fi}
\def\markright#1{%
  \group_begin:
    \let\label\relax \let\index\relax \let\glossary\relax
    \unrestored@protected@xdef\@tempa{#1}%
    \exp_after:NN\@markright\exp_after:NN{\@tempa}%
  \group_end:
  \if@nobreak\ifvmode\nobreak\fi\fi}
\def\@markleft#1{\PutMark{leftmark}{#1}}
\def\@markright#1{\PutMark{rightmark}{#1}}
\def\leftmark{\LastMark{leftmark}}
\def\rightmark{\FirstMark{rightmark}}

                                % Traditional LaTeX headers and footers  PvO
\def\@thehead{\@oddhead} % initialization
\def\@thefoot{\@oddfoot}

\def \myfinalpage {
  \if@twoside
    \ifodd\c@page \let\@thehead\@oddhead \let\@thefoot\@oddfoot
         \let\pagebodylefthpos\oddsidemargin
    \else \let\@thehead\@evenhead
       \let\@thefoot\@evenfoot \let\pagebodylefthpos\evensidemargin
    \fi
  \else
    \let\pagebodylefthpos\oddsidemargin
  \fi
    \mbox@addtopage (\pagebodylefthpos, -\headsep)
       {\hbox to \textwidth{\@thehead}}
%    \end{macrocode}
%
%    \begin{macrocode}
%    Init |\dimen|1,2,3,\ldots as vertical current point per column
%    (don't forget in Chris's (sorry, Don's) universum zero is at the
%    top).
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_forall_columns:n{
     \dimen \int_use:N\g_xor_curr_col_int
            \c_zero
  }
%    \end{macrocode}
%    Now mount all top areas looping through an ordered list of top
%    areas.
%    \begin{macrocode}
  \exp_after:NN\mount@top@areas@loop
      \top@areas
      \relax\relax\relax
%    \end{macrocode}
%    Next mount the text columns.
%    \begin{macrocode}
  \xor_forall_columns:n{

%<*trace>
     \tr@ce{GRID (delta):~ column~\int_use:N\g_xor_curr_col_int t:~
        \tlp_use:c {g_xor_t_delta_col_ \int_use:N\g_xor_curr_col_int _tlp}
        \space used}
%</trace>
%%% dangerous scratch registers ... FIX
     \advance \dimen \int_use:N\g_xor_curr_col_int
              by %NEEDED!!!!!
              \csname g_xor_t_delta_col_ \int_use:N\g_xor_curr_col_int _tlp\endcsname

     \advance \dimen \int_use:N\g_xor_curr_col_int
              \csname g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim\endcsname


    \setlength \l_tmpa_dim
        {\pagebodylefthpos - \columndisplacement
                           + \columndisplacement * \g_xor_curr_col_int }

    \mbox@addtopage ( \dim_use:N \l_tmpa_dim ,\the \dimen\g_xor_curr_col_int  )
         { \box_use_and_clear:c {g_xor_col_ \int_use:N\g_xor_curr_col_int _box} }

%<*trace>
    \tr@ce{GRID (delta):~ column~\int_use:N\g_xor_curr_col_int b:~
        \tlp_use:c {g_xor_b_delta_col_ \int_use:N\g_xor_curr_col_int _tlp}
        \space used}
%</trace>
     \advance \dimen \int_use:N\g_xor_curr_col_int
              by %NEEDED!!!!!
              \csname g_xor_b_delta_col_ \int_use:N\g_xor_curr_col_int _tlp\endcsname
  }
%    \end{macrocode}
%    Then mount the bottom floats.
%    \begin{macrocode}
  \def\col@of@focus{0}               % temp solution see below
  \exp_after:NN\mount@bot@areas@loop
      \bot@areas
      \relax\relax\relax
%    \end{macrocode}
%
%    Next thing is absolutely temp: mount a marginal area on the right
%    (bottom) to allow footnotes there (this is just for testing).
%    \begin{macrocode}
  \setlength \l_tmpa_dim
     {\pagebodylefthpos + \columndisplacement * \g_xor_cols_int }
   \mbox@addtopage ( \dim_use:N \l_tmpa_dim , \textheight )
     { \box_use_and_clear:N \saved@footins } % TEMP FMi
   \setlength \l_tmpa_dim       % add footer PvO
     {\textheight + \footskip}
   \mbox@addtopage (\pagebodylefthpos, \l_tmpa_dim)
     {\hbox to \textwidth{\@thefoot}}
%
%    Next thing is absolutely temp: mount a marginal area on the right
%    (bottom) to allow marginal floats there (this is just for testing).
%    \begin{macrocode}
  \cs_free:cF {g_xor_area_ m1\int_use:N\g_xor_curr_col_int
                          _seq }
  {
    \g_xor_curr_col_int\g_xor_cols_int
%FMi was local, why?
    \int_gincr:N \g_xor_curr_col_int
    \make@area@floats@box {m \int_use:N\g_xor_curr_col_int 1}\l_tmpa_box
    \setlength \l_tmpa_dim
       {\pagebodylefthpos + \columndisplacement * \g_xor_cols_int }
    \mbox@addtopage ( \dim_use:N \l_tmpa_dim , \textheight )
        { \vbox_to_ht:nn \textheight {\vfil \vbox_unpack_and_clear:N \l_tmpa_box  \vfil }}
  }
%
  \ifShowGrid
    \dim_compare:nNnT \pagesetup@grid@point@sep > \c_zero
    {
      \int_set:Nn \l_tmpa_int \textheight
      \int_set:Nn \l_tmpb_int \topskip
      \int_sub:Nn \l_tmpa_int \l_tmpb_int
      \dim_set:Nn \l_tmpb_dim \pagesetup@grid@point@sep
      \int_set:Nn \l_tmpb_int \l_tmpb_dim
      \divide\l_tmpa_int\l_tmpb_int
      \int_incr:N \l_tmpa_int

      \setlength \l_tmpb_dim
       {\pagebodylefthpos + \columndisplacement * \g_xor_cols_int
                          - \columnsep }
      \int_set:Nn \count@ \l_tmpb_dim

      \sbox\grid@box{
               \setlength\unitlength{1sp}
               \begin{picture}(0,0)
                 \multiput(0,0)(0,\l_tmpb_int){\l_tmpa_int}
                   {\line(1,0){\count@}}
               \end{picture}
               }

      \mbox@addtopage ( \pagebodylefthpos ,\textheight  )
             {  \box_use_and_clear:N \grid@box }
    }
  \fi
  \box_ht:N\page@box=\topmargin %PvO
}

\box_new:N\grid@box

\newif\ifShowGrid
\ShowGridtrue

% for tracing only (unchanged)


\def\mbox@addtopage (#1,#2)#3{%
%  \tr@ce{box~being~added~to~page:~at~(#1,~#2) }
  \hbox_gset:Nn \page@box
    {
      \hbox_unpack_and_clear:N \page@box
      \mbox@put  (#1,#2) {#3}
    }
}




\def\mount@top@areas@loop#1#2#3{
  \ifx#1\relax
  \else
    \mount@top@area#1#2#3
    \exp_after:NN\mount@top@areas@loop
  \fi}


\def\mount@top@area#1#2#3 {
  \make@area@floats@box {#1#2#3}\l_tmpa_box

  \box_if_empty:NF \l_tmpa_box
  {

    \setlength \l_tmpb_dim
        { \dimen#2 + \box_ht:N\l_tmpa_box  + \box_dp:N\l_tmpa_box  }

    \setlength \l_tmpa_dim
        {\pagebodylefthpos - \columndisplacement + \columndisplacement * #2 }

%% change BP
%    \ifnum #2 > 1
% \addtolength \l_tmpa_dim {.5\columnsep}
%    \fi
%% end change

    \mbox@addtopage ( \dim_use:N \l_tmpa_dim ,\dim_use:N \l_tmpb_dim  )
         { \box_use_and_clear:N \l_tmpa_box  }

    \count@ #2\relax
    \int_add:Nn \count@ {#3}
    \int_dowhile:nNnT {#2} < \count@
    {
      \int_decr:N \count@
      \dimen \count@ =  \l_tmpb_dim
      \int_compare:nNnTF {\num_use:c {g_xor_t_floats_col_ \int_use:N \count@ _num}} > \c_zero
      { \dim_add:Nn {\dimen \count@} \g_xor_float_area_skip }
      { \dim_add:Nn {\dimen \count@} \g_xor_float_text_skip }
    }
  }
}

\def\mount@bot@areas@loop#1#2#3{
  \ifx#1\relax
  \else
    \mount@bot@area#1#2#3
    \exp_after:NN\mount@bot@areas@loop
  \fi}

\def\mount@bot@area#1#2#3 {
  \make@area@floats@box {#1#2#3}\l_tmpa_box

  \box_if_empty:NF \l_tmpa_box
  {

    \setlength \l_tmpb_dim
        { \dimen#2 + \box_ht:N\l_tmpa_box  + \box_dp:N\l_tmpa_box  }

%    \end{macrocode}
%    There are probably much better ways to get the spacing right, the
%    one below is really only a temporary fix: in |\col@of@focus| we
%    remember the last column in which already applied
%    |\g_xor_float_text_skip|, any additional float area will
%    contribute another |\g_xor_float_area_skip|
%    instead.\footnote{To make this work it is absolutely necessary
%    that the floats in bot@areas are ordered by column!!! No-good. FIX!!}
%    \begin{macrocode}
    \int_compare:nNnTF \col@of@focus < {#2}
    {
      \def\col@of@focus{#2}
      \dim_add:Nn \l_tmpb_dim
                  \g_xor_float_text_skip
    }
    {
      \dim_add:Nn \l_tmpb_dim
                  \g_xor_float_area_skip
    }

    \setlength \l_tmpa_dim
        {\pagebodylefthpos - \columndisplacement
         + \columndisplacement * #2 }

%% change BP
%    \ifnum #2 > 1
% \addtolength \l_tmpa_dim {.5\columnsep}
%    \fi
%% end change

    \mbox@addtopage ( \dim_use:N \l_tmpa_dim ,\dim_use:N \l_tmpb_dim )
         { \box_use_and_clear:N \l_tmpa_box }

%    \end{macrocode}
%    Next loop is actually not necessary as long we keep the
%    restriction that we don't allow partial overlapping float areas, ie we
%    will never mount another float area in the columns that are
%    spanned by the current float area (other than potentially the
%    first and we set this one explicitly).
%    \begin{macrocode}
    \dimen #2 = \l_tmpb_dim
%    \count@ #2\relax
%    \int_add:Nn \count@ {#3}
%    \loop
%      \int_decr:N \count@
%      \dimen \count@ =  \l_tmpb_dim
%    \ifnum #2 < \count@
%    \repeat

  }
}


% of course \top@areas and \bot@areas should be constructed
% automatically when preparing the \g_xor_areas_used_clist or from the \g_xor_areas_known_clist
% but for now i simply define them here:

\def\top@areas{t13 t12 t22 t32 t11 t21 t31}

\def\bot@areas{b11 b12 b13 b21 b22 b31 b32}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
% next line activates my version (well some of it is activated already
% above)
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\let\make@page@box\myfinalpage

\fi % end of stuff modifying xo-final 1.15

%    \end{macrocode}
%

\endinput

%
% $Log$
% Revision 1.17  2005/12/23 13:59:42  morten
% Minor update to make the index work correctly
%
% Revision 1.16  2005/03/01 22:53:12  morten
% Small updates, more expl3 conversion
%
% Revision 1.14  2004/12/06 23:01:23  mittelba
% fix for here float not aligning to grid
%
% Revision 1.13  2004/12/04 22:54:08  mittelba
% starting to define a box module ... unfinished and names not yet right!
%
% Revision 1.12  2004/11/28 18:05:22  mittelba
% another attempt at balancing ... this now works (more or less) if no
% floats are around. basic logic is probably right, implementation
% disgusting and wrong ... but at least some output apears again, which
% is an improment :-) ... we'll see
%
% Revision 1.11  2004/11/13 10:04:06  mittelba
% new license (LPPL)
%
% Revision 1.10  2004/10/31 21:50:31  mittelba
% further balancing ... all very tmp but at least it does start to
% balance :-)
%
% Revision 1.9  2004/10/30 18:46:03  mittelba
% further cleanup using expl3 concepts
% first attempt at balancing (unfinished)
%
% Revision 1.8  2004/10/12 21:40:42  mittelba
% updates up to p29
%
% Revision 1.7  2004/10/03 15:35:59  mittelba
% more cleanup ... tedious ...
%
% Revision 1.6  2004/10/01 21:46:36  mittelba
% many further updates, still a lot to do
%
% Revision 1.5  2004/09/27 20:06:17  mittelba
% in the middle of normalizing to expl3 syntax
%
% Revision 1.4  2004/09/02 15:58:41  mittelba
% stuff moved to xo-final.dtx
%
% Revision 1.3  2003/02/19 14:34:39  kastrup
% Add changes from Piet van Oostrum: compatibility
% marks for LaTeX's default behavior, headers, footers, some fixes.
% Replace \count\z@ with \c@page.
%
% Revision 1.2  2003/02/19 14:16:14  kastrup
% Add changes from Piet van Oostrum: compatibility
% marks for LaTeX's default behavior, headers, footers, some fixes.
%
% Revision 1.1  2001/07/26 19:55:12  latex3
% original web distrib
%
% Revision 1.25  2000/08/11 07:14:23  latex3
% added header
%
% Revision 1.24  2000/08/11 06:49:09  latex3
% untabify
%
% Revision 1.23  2000/08/05 10:01:26  latex3
% ensure that \make@area@floats@box doesn't do any harm to areas not set
% up via \DeclareFloatArea
%
% Revision 1.22  2000/08/04 15:50:31  latex3
% \flushbottom default again
%
% Revision 1.21  2000/08/04 13:58:58  latex3
% \bot@areas need to be ordered by column at the moment!!!!
%
% Revision 1.20  2000/08/04 10:20:09  latex3
% removed old experimental code for grid layout
%
% Revision 1.19  2000/07/22 06:30:50  latex3
% fixed bug in positioning bottom floats
%
% Revision 1.18  2000/07/19 17:12:53  latex3
% introduced float sequence list
%
% Revision 1.17  2000/07/10 19:22:12  latex3
% more grid support
%
% Revision 1.16  2000/07/04 19:48:55  latex3
% experimental stuff for GRIDs
% start writing out columnsizes (unused)
% use \xor_update_this_area_span_cols:n
%
% Revision 1.15  2000/06/29 17:16:59  latex3
% introduced \xor_this_area_setup:o
%
% Revision 1.14  2000/06/26 15:17:26  latex3
% prototype support for \g_xor_float_area_skip
%
% Revision 1.13  2000/06/16 11:21:07  latex3
% rename \construct@and@test@col@height to \construct@and@test@col@ht
% rename \construct@and@test@col@heights to \construct@and@test@col@hts
% rename \cl@height1 to \@col@ht@1 (etc)
%
% Revision 1.12  2000/06/15 15:22:36  latex3
% implemented new semantics for area names
%
% Revision 1.11  2000/06/13 21:23:03  latex3
% *** empty log message ***
%
% Revision 1.10  2000/05/04 09:21:27  latex3
% urg: \g_xor_this_area_tlp undefined inside the output routine, so captions got
% typeset with whatever was the last \g_xor_this_area_tlp.
%
% Revision 1.9  2000/05/03 18:41:52  latex3
% still overwriting code for xo-final 1.15 ! (not 1.16)
% enabling support for caption templates
%
% Revision 1.8  2000/04/21 19:16:32  latex3
% activate my version of xo-final
%
% Revision 1.7  2000/04/21 19:05:21  latex3
% my version of xo-final mainly
%
% Revision 1.6  2000/04/09 20:02:42  latex3
% first draft of marginpar support
%
% Revision 1.5  2000/03/24 15:34:27  latex3
% version that starts supporting spans (still a hack yet)
%
% Revision 1.4  2000/02/26 18:26:08  david
% code moved to xo-*
%
% Revision 1.3  2000/02/13  21:37:20  latex3
% ooops, my ultrix rcs is too old to guess the comment char correctly
% so we better add explicit \endinput
%
% Revision 1.2  2000/02/13  21:35:25  latex3
% wording
%
% Revision 1.1  2000/02/13  21:34:51  latex3
% Initial revision
%
