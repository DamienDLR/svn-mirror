% \iffalse
%% File xo-place.dtx (C) Copyright 1999-2000 Frank Mittelbach, David Carlisle, Chris Rowley
%%                   (C) Copyright 2004-2007 Frank Mittelbach, LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xor bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
\RequirePackage{l3names}
\GetIdInfo $Id$
          {xo-place}
\ProvidesExplPackage{\filename}
  {\filedate}{\fileversion}{\filedescription}
% \fi
%
%
%
% \subsection{Selecting the next area to try}
%
%
% \begin{macro}{\xor_try_this_area_std:}
%    The |\xor_try_this_area_std:| command is called when we have
%    selected a float from the |\g_xor_floats_active_seq| and want to place it
%    in one of the open areas to see if it fits there. If we succeed
%    in finding a potential candidate place we will exit using
%    |\contruct@trial| which will run a trial cutting the galley to
%    see if each column gets the right kind of text and contains the
%    right kind of callouts.
%    The areas are tried in a defined order.
%
%    If we don't find any open areas we return putting the current
%    float onto the |\g_xor_area_DDD_seq| and then calling |\@trynextfloat|.
%
%    If we find an open area but for some reason the float is not
%    allowed to go there we close that area for floats of this type
%    and recurse (i.e. try to use the next open area for this type).
%
%    The reasons for failure to place the float into the first open
%    area are numerous. First there are restrictions on the number of
%    floats on a page (if we reach this all areas get closed) there
%    there are similar restrictions for each individual float area.
%
%    If those tests are passed we trial typeset the float with its
%    caption (or rather typeset and attach its caption) to determine
%    the size needed by the float. That will give us a dimension to
%    test against restrictions for the amount of space floats are
%    allowed to occupy etc.
%
%    \begin{macrocode}
\def_new:Npn \xor_try_this_area_std: {
%<*trace>
  \trace_push:n{xor_try_this_area_std:}
%</trace>

%%B
  \num_gzero:N \g_xor_trial_balance_done_num
  \trace:n{BALANCE:~ g_xor_trial_balance_done_num ~<-~
                    \num_use:N \g_xor_trial_balance_done_num}
  \g_xor_best_trial_col_hts_tlp

%    \end{macrocode}
%    If all areas for the float type are closed we have to defer this float.
%    \begin{macrocode}
  \clist_if_empty:NTF \g_xor_this_areas_open_clist
  {
%<*trace>
        \trace:n{defer:~no~open~area~ available}
%</trace>
        \xor_do_next:N \xor_attempt_to_defer_and_try_next_float:
  }
  {
%    \end{macrocode}
%    Otherwise the next area to try is the first of |\g_xor_this_areas_open_clist|:
%    \begin{macrocode}
    \clist_get:NN \g_xor_this_areas_open_clist \l_tmpa_tlp
    \xor_this_area_setup:o  \l_tmpa_tlp
%<*trace>
    \trace:n{area~trial:~ \g_xor_this_area_name_tlp}
%</trace>
%<*progress>
    \xor_progress:n{~ area~trial:~ \g_xor_this_area_name_tlp}
%</progress>
%    \end{macrocode}
%    Next test needs cleanup once the span has a decent data
%    structure.\footnote{FIX!!}
%    \begin{macrocode}
    \int_compare:nNnTF \g_xor_this_area_span_tlp = \g_xor_this_span_num_tlp
    {
%<*trace>
      \trace:n{span~ count~ okay:~ \g_xor_this_area_name_tlp \space =~
             \g_xor_this_span_num_tlp }
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
      \int_compare:nNnTF \pagesetup@max@float@num > \g_xor_page_float_int
      {
%    \end{macrocode}
%
%    \begin{macrocode}
        \int_compare:nNnTF 
          {\num_use:c {g_xor_area_ \g_xor_this_area_name_tlp  _max_float_num} }
        = {\int_use:c {g_xor_area_ \g_xor_this_area_name_tlp  _float_int } }
        {
%    \end{macrocode}
%    Current area doesn't accept any more floats, so try next one (if any)
%    \begin{macrocode}
%<*trace>
          \trace:n{close~area:~\g_xor_this_area_name_tlp\space float~num~reached ~
              (\num_use:c {g_xor_area_ \g_xor_this_area_name_tlp _max_float_num})}
%</trace>
%<*progress>
          \xor_progress_failed:n{\g_xor_this_area_name_tlp\space float~num~reached ~
               (\num_use:c{g_xor_area_ \g_xor_this_area_name_tlp _max_float_num})}
%</progress>
          \xor_do_next:N \xor_try_next_area:
        }
%    \end{macrocode}
%
%    \begin{macrocode}
        {
          \clist_if_in:NoTF
             \g_xor_curr_page_areas_closed_clist
             \g_xor_this_area_name_tlp
             {
%<*trace>
               \trace:n{area~ closed~ for~ all~ types;~ member~ of~
                      (\g_xor_curr_page_areas_closed_clist)}
%</trace>
%<*progress>
               \xor_progress_failed:n{area~ closed~ for~ all~ types}
%</progress>
               \xor_do_next:N \xor_try_next_area:
             }
             {
%<*trace>
               \trace:n{area~ not~ closed~ for~ all~ types:~ not~ member~ of~
                      (\g_xor_curr_page_areas_closed_clist)}
%</trace>
               \clist_if_in:NoTF
                 \g_xor_this_areas_closed_clist
                 \g_xor_this_area_name_tlp
                 {
%<*trace>
                   \trace:n{area~ closed~ for~ class~ \g_xor_this_class_tlp;~ 
                          member~ of~  (\g_xor_this_areas_closed_clist)}
%</trace>
%<*progress>
                   \xor_progress_failed:n
                         {area~ closed~ for~ class~ \g_xor_this_class_tlp}
%</progress>
                   \xor_do_next:N \xor_try_next_area:
                 }
                 {
%<*trace>
                  \trace:n{area~ open~ for~ class~ \g_xor_this_class_tlp;~ 
                         not~ member~ of~
                         (\g_xor_this_areas_closed_clist)}
%</trace>
                  \clist_if_in:NoTF
                    \g_xor_this_allowed_areas_tlp
                    \g_xor_this_area_name_tlp
                    {
                      \xor_append_caption_to_float:
                      \xor_construct_and_test_col_hts:
                      \if@test
                        \xor_do_next:N \xor_try_next_area:
                      \else
                        \xor_do_next:N \pretests@success@action
                      \fi
                    }
                    {
%<*trace>
                      \trace:n{close~area:~\g_xor_this_area_name_tlp\space 
                             float~not~allowed~
                             by~ user~ control~ (\g_xor_this_allowed_areas_tlp)}
%</trace>
%<*progress>
                      \xor_progress_failed:n{\g_xor_this_area_name_tlp\space 
                             float~not~allowed~
                             by~ user~ control~ (\g_xor_this_allowed_areas_tlp)}
%</progress>
                      \xor_do_next:N \xor_try_next_area:
                    }
                }
            }
        }
      }
      {
% defer
        \clist_gclear:N \g_xor_this_areas_open_clist
%<*trace>
        \trace:n{defer:~max~float~num~reached ~(\pagesetup@max@float@num)}
%</trace>
%<*progress>
        \xor_progress_failed:n{max~float~num~reached ~(\pagesetup@max@float@num)}
%</progress>
        \xor_do_next:N \xor_attempt_to_defer_and_try_next_float:
      }
    }
    {
%<*trace>
      \trace:n{span~ count~ unsuitable:~ \g_xor_this_area_name_tlp \space /=~
             \g_xor_this_span_num_tlp }
%</trace>
%<*progress>
      \xor_progress_failed:n{span~ count~ \g_xor_this_area_name_tlp \space /=~
             \g_xor_this_span_num_tlp }
%</progress>
      \xor_do_next:N \xor_try_next_area:
    }
  }
%<*trace>
  \trace_pop:n{xor_try_this_area_std:}
%</trace>
  \xor_continue:
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_do_next:N}
%    Emergency macro to reduce the number of input levels (as the code
%    got past the internal default of 300). This is because we have a
%    lot of recursion going on without being tail
%    recursion. Essentially this means some of the code needs slightly
%    different implementation.\footnote{fix}
%    \begin{macrocode}
\def_new:Npn \xor_do_next:N {\let:NN \xor_continue:}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_try_this_area_relaxed:}
%    \begin{macrocode}
\def_new:Npn \xor_try_this_area_relaxed: {
%<*trace>
  \trace_push:n{xor_try_this_area_relaxed:}
%</trace>
%    \end{macrocode}
%    If all areas for the float type are closed we have to defer this float.
%    \begin{macrocode}
  \clist_if_empty:NTF \g_xor_this_areas_open_clist
  {
%<*trace>
        \trace:n{defer:~no~open~area~ available}
%</trace>
        \xor_do_next:N \xor_attempt_to_defer_and_try_next_float:
  }
  {
%    \end{macrocode}
%    Otherwise the next area to try is the first of |\g_xor_this_areas_open_clist|:
%    \begin{macrocode}
    \clist_get:NN \g_xor_this_areas_open_clist \l_tmpa_tlp
    \xor_this_area_setup:o  \l_tmpa_tlp
%<*trace>
    \trace:n{area~trial:~ \g_xor_this_area_name_tlp}
%</trace>
%<*progress>
    \xor_progress:n{~ area~trial:~ \g_xor_this_area_name_tlp}
%</progress>
%    \end{macrocode}
%    Next test needs cleanup once the span has a decent data
%    structure.\footnote{FIX!!}
%    \begin{macrocode}
    \int_compare:nNnTF \g_xor_this_area_span_tlp = \g_xor_this_span_num_tlp
    {
%<*trace>
      \trace:n{span~ count~ okay:~ \g_xor_this_area_name_tlp \space =~
             \g_xor_this_span_num_tlp}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
      \clist_if_in:NoTF
      \g_xor_curr_page_areas_closed_clist
      \g_xor_this_area_name_tlp
      {
%<*trace>
        \trace:n{area~ closed~ for~ all~ types;~ member~ of~
               (\g_xor_curr_page_areas_closed_clist)}
%</trace>
%<*progress>
            \xor_progress_failed:n{area~ closed~ for~ all~ types}
%</progress>
        \xor_do_next:N\xor_try_next_area:
      }
      {
%<*trace>
        \trace:n{area~ not~ closed~ for~ all~ types:~ not~ member~ of~
               (\g_xor_curr_page_areas_closed_clist)}
%</trace>
        \clist_if_in:NoTF
          \g_xor_this_area_name_tlp
          \g_xor_this_areas_closed_clist
        {
%<*trace>
          \trace:n{area~ closed~ for~ class~ \g_xor_this_class_tlp;~ 
                 member~ of~
                 (\g_xor_this_areas_closed_clist)}
%</trace>
%<*progress>
          \xor_progress_failed:n
                    {area~ closed~ for~ class~ \g_xor_this_class_tlp}
%</progress>
          \xor_do_next:N\xor_try_next_area:
        }
        {
%<*trace>
          \trace:n{area~ open~ for~ class~ \g_xor_this_class_tlp;~ 
                 not~ member~ of~
                 (\g_xor_this_areas_closed_clist)}
%</trace>
          \xor_append_caption_to_float:
          \xor_construct_and_test_col_hts:
          \if@test
            \xor_do_next:N\xor_try_next_area:
          \else
            \xor_do_next:N\pretests@success@action
          \fi
        }
      }
    }
    {
%<*trace>
      \trace:n{span~ count~ unsuitable:~ \g_xor_this_area_name_tlp \space /=~
             \g_xor_this_span_num_tlp}
%</trace>
%<*progress>
      \xor_progress_failed:n{span~ count~ \g_xor_this_area_name_tlp \space /=~
             \g_xor_this_span_num_tlp }
%</progress>
      \xor_do_next:N\xor_try_next_area:
    }
  }
%<*trace>
  \trace_pop:n{xor_try_this_area_relaxed:}
%</trace>
  \xor_continue:
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_construct_and_test_col_hts:}
%    The |\xor_construct_and_test_col_hts:| loops over all columns
%    affected by the float area we want to place our float into
%    and reduces the column size as
%    needed. It sets the switch |@test| to true in case the float
%    doesn't fit into area for some reason. It is up to the calling
%    macro to take proper action in this case (including resetting
%    column heights to their former values).
%    \begin{macrocode}
\def_new:Npn \xor_construct_and_test_col_hts: {
%    \end{macrocode}
%    We use the information from the area not from the float (which
%    allows us to put small floats into larger areas.
%    \begin{macrocode}
  \xor_update_this_area_span_cols:n
  {
    \exp_args:Nc
      \xor_construct_and_test_col_ht:nn
        {g_xor_ht_col_ \int_use:N \l_xor_update_col_int _dim }
        {\int_use:N \l_xor_update_col_int}
%    \end{macrocode}
%    We need to break out of the updating loop if we found a column that
%    doesn't work, a) to save time and b) since the
%    |\xor_construct_and_test_col_ht:nn| resets the switch again to false
%    (in the current implementation).
%    \begin{macrocode}
    \if@test
        \int_zero:N \l_xor_update_col_int   % break out of loop
    \fi
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_construct_and_test_col_ht:nn}
%    The |\xor_construct_and_test_col_ht:nn| reduces the height of one column
%    by the size of the current float (plus some suitable extra space)
%    and tests if this reduction is possible/allowed. It sets the
%    switch |@test| to true if it encounters a problem.
%    \begin{macrocode}
\def_new:Npn \xor_construct_and_test_col_ht:nn #1#2{
%<*trace>
  \trace:n{col~ height~before:~ \the#1 (\string#1)}
%</trace>
%    \end{macrocode}
%    In |\l_tmpa_dim| we calculate the amount of space we need if we
%    place the float. This is the size of the float, i.e., its height
%    and depth, plus either |\g_xor_float_text_skip| if this is the
%    very first float in this column (on top or on bottom), or
%    |\g_xor_float_area_skip| if it is the first float in the
%    current area, or |\g_xor_float_float_skip| if we already have
%    floats in this area.
%    \begin{macrocode}
  \dim_set:Nn \l_tmpa_dim {\box_ht:N\g_xor_this_captioned_float_box}
  \dim_add:Nn \l_tmpa_dim {\box_dp:N\g_xor_this_captioned_float_box}
  \int_compare:nNnTF {\num_use:c {g_xor_ \g_xor_this_area_type_tlp
                                  _floats_col_ #2 _num}
                 }  = \c_zero
  {
%<*trace>
       \trace:n{first~ float~ in~ any~ \g_xor_this_area_type_tlp\space
              in~ column~ #2:~
              adding~ \string\g_xor_float_text_skip
              =\the\g_xor_float_text_skip}
%</trace>
    \dim_add:Nn \l_tmpa_dim \g_xor_float_text_skip
  }
  {
    \seq_if_empty:cTF {g_xor_area_ \g_xor_this_area_name_tlp _seq}
    {
      \dim_add:Nn \l_tmpa_dim \g_xor_float_area_skip
%<*trace>
        \trace:n{first~ float~ in~ \g_xor_this_area_name_tlp :~
              adding~ \string\g_xor_float_area_skip
              =\the\g_xor_float_area_skip}
%</trace>
    }
    {
      \dim_add:Nn \l_tmpa_dim \g_xor_float_float_skip
%<*trace>
        \trace:n{additional~ float~ in~ \g_xor_this_area_name_tlp :~
              adding~ \string\g_xor_float_float_skip
              = \the\g_xor_float_float_skip}
%</trace>
    }
  }
%    \end{macrocode}
%    Now we make the area size fully fall into the page grid (if there
%    is one). To do this we first substract any delta that has been
%    accumulated for the column (to get back to the real size) and
%    then run |\xor_snap_to_grid:nn| to get the next grid point.
%    \begin{macrocode}
  \dim_sub:Nc \l_tmpa_dim
              {g_xor_ \g_xor_this_area_type_tlp _delta_col_ #2 _tlp}
%    \end{macrocode}
%    The |\g_xor_|\meta{area-type}|_delta_col_|\meta{col}|_tlp| are macros but
%    fortunately low-level \TeX{} supports register assignments of the
%    form |--3pt| so the above will work even if the macro contains a
%    negative value.
%    \begin{macrocode}
  \xor_snap_to_grid:nn  \l_tmpa_dim \pagesetup@grid@point@sep
%    \end{macrocode}
%
%    If the distance to the next grid point is larger than the
%    distance to the previous one, and if the space between floats and
%    text is allowed to shrink by the needed amount we will use the
%    previous grid point.
%    \begin{macrocode}
  \dim_compare:nNnT \returned@lower@delta@size < \returned@delta@size
  {
    \dim_compare:nNnT \returned@lower@delta@size 
                    < \g_xor_float_text_shrink_dim
    {
%<*trace>
      \trace:n{GRID:~ column~#2:~ choosing~ lower~ grid~ point}
%</trace>
%    \end{macrocode}
%    We do this by copying the |\returned@lower@...| to the macros
%    used below. Note that for the delta size we have to use the
%    negation since we want to backup by this amount and delta sizes
%    are always given in absolute values.
%    \begin{macrocode}
      \glet:NN \returned@size \returned@lower@size
      \gdef:Npx \returned@delta@size {-\returned@lower@delta@size }
    }
  }
%<*trace>
  \trace:n{GRID:~ column~#2:~ \dim_use:N \l_tmpa_dim\space ->~ \returned@size}
%</trace>
  \dim_set:Nn \l_tmpa_dim \returned@size
%    \end{macrocode}
%
%    After updating |\l_tmpa_dim| in this way we now have to check if
%    the space remaining for the text column is large enough.
%    \begin{macrocode}
  \dim_set:Nn \l_tmpb_dim {#1 - \l_tmpa_dim }
  \@testfalse
  \dim_compare:nNnTF {\textminlines\baselineskip} > \l_tmpb_dim
  {
%    \end{macrocode}
%    If not we bail out
%    \begin{macrocode}
    \@testtrue
%<*trace>
    \trace:n{close~area:~\g_xor_this_area_name_tlp\space not~ enough~
       text~ lines~ left~
      (\textminlines x\the\baselineskip> \dim_use:N \l_tmpb_dim)}
%</trace>
%<*progress>
    \xor_progress_failed:n{not~ enough~ text~ space~
      (\textminlines x\the\baselineskip\space
      >~ \dim_use:N \l_tmpb_dim)}
%</progress>
  }
  {
%    \end{macrocode}
%    Otherwise we have to update the column heights (and their saved
%    version in case we back out later) as well as storing the new
%    delta (which is still in |\returned@delta@size|).
%    \begin{macrocode}
%<*trace>
    \trace:n{g_xor_saved_ht_col_#2_tlp ~ <-~\the#1}
%</trace>
    \tlp_gset:cx {g_xor_saved_ht_col_#2_tlp} {\the#1}
    \dim_gset:Nn {#1}\l_tmpb_dim
%    \end{macrocode}
%
%    If we are adding the float to a bottom area we also need to change the
%    information about how much space has been used from the bottom up, since that
%    is needed for correct balancing.
%    \begin{macrocode}
    \if:w b \g_xor_this_area_type_tlp
      \tlp_gset:cx {g_xor_saved_bottom_ht_col_#2_tlp} 
                   {\dim_use:c{g_xor_bottom_ht_col_#2_dim}}
      \dim_gadd:cn{g_xor_bottom_ht_col_#2_dim}\l_tmpa_dim
%<*trace>
      \trace:n{g_xor_saved_bottom_ht_col_#2_tlp ~ <-~
             \tlp_use:c{g_xor_saved_bottom_ht_col_#2_tlp}}
      \trace:n{g_xor_bottom_ht_col_#2_dim ~ <-~
             \dim_use:c{g_xor_bottom_ht_col_#2_dim}}
%</trace>
    \fi:
%    \end{macrocode}

%    \begin{macrocode}
    \tlp_gset_eq:cc
      {g_xor_saved_ \g_xor_this_area_type_tlp _delta_col_ #2 _tlp}
      {g_xor_       \g_xor_this_area_type_tlp _delta_col_ #2 _tlp}
    \tlp_gset_eq:cN
      {g_xor_ \g_xor_this_area_type_tlp _delta_col_ #2 _tlp}
      \returned@delta@size
%<*trace>
    \trace:n{GRID (delta):~ column~#2\g_xor_this_area_type_tlp :~
      \tlp_use:c{g_xor_saved_ \g_xor_this_area_type_tlp _delta_col_ #2 _tlp}
      \space ->~ \returned@delta@size}
%</trace>
  }
%<*trace>
  \trace:n{col height~after:~ \the#1}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\textminlines}
%    Tmp definition; should be interfaced to pagesetup.
%    \begin{macrocode}
\def\textminlines{4}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Supporting grid based designs}
%
%
%
% \begin{macro}{\pagesetup@grid@point@sep}
%    |\pagesetup@grid@point@sep| is the distance between grid points
%    for page design or 0pt if we are not doing grid design.
%    \begin{macrocode}
\let\pagesetup@grid@point@sep\ERROR
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_snap_to_grid:nn}
%    |\xor_snap_to_grid:nn| takes a dimension as first argument and a
%    ``grid-size'' as second argument and from those two values
%    calculates a new dimension which is a multiple of the grid-size
%    and equal or larger than the first argument.
%
%    It returns this calculated value globally in |\returned@size|. In
%    addition it will return in |\returned@delta@size| the delta
%    between the original and the new dimension.
%
%    It also returns a lower or equal grid point in
%    |\returned@lower@size| and the delta to it (absolute value) in
%    |\returned@lower@delta@size|.
%
%    Thus the first argument lies on a grid point if and only if
%    |\returned@size| equals |\returned@lower@size|.
%
%    If we are not doing grid typesetting then |\xor_snap_to_grid:nn| is
%    actually a dummy which will return always the first argument in
%    |\returned@size| and |\returned@lower@size|, and |0pt| in the
%    deltas.
%
%    The actual definition is assigned within the page setup.
%    \begin{macrocode}
\def_new:Npn \xor_snap_to_grid:nn {\ERROR}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_snap_to_grid_dummy:nn}
%    In case we don't do grids we simply pretend that all sizes lie on
%    grid points.
%    \begin{macrocode}
\def_new:Npn \xor_snap_to_grid_dummy:nn #1#2{
   \group_begin:
%    \end{macrocode}
%    Definitions below can be optimised for speed but the ones used
%    give better tracing.
%    \begin{macrocode}
     \dim_set:Nn \l_tmpa_dim {#1}
     \gdef:Npx \returned@size { \dim_use:N \l_tmpa_dim }
     \glet:NN \returned@lower@size \returned@size
     \gdef:Npn \returned@delta@size {0pt}
     \glet:NN \returned@lower@delta@size  \returned@delta@size
   \group_end:
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_snap_to_grid_std:nn}
%    But if we do grid typesetting we have to do a bit more work
%    here.
%    \begin{macrocode}
\def_new:Npn \xor_snap_to_grid_std:nn #1#2{
%    \end{macrocode}
%    Everything is done in a group so that the register change do not
%    affect other parts of the code.
%    \begin{macrocode}
  \group_begin:
%    \end{macrocode}
%    First we calculate in |\l_tmpc_dim| the nearest grid point which
%    is smaller or equal to the given size in |#1| by using scaled
%    point arithmetic.
%    \begin{macrocode}
    \dim_set:Nn \l_tmpa_dim {#1}
    \dim_set:Nn \l_tmpb_dim {#2}
    \int_set:Nn \l_tmpa_int \l_tmpa_dim      % orig size in sp
    \int_set:Nn \l_tmpb_int \l_tmpb_dim      % grid size in sp
    \divide \l_tmpa_int \l_tmpb_int
    \dim_set:Nn \l_tmpc_dim {\l_tmpa_int \l_tmpb_dim}
%    \end{macrocode}
%    If the calculated grid point is smaller than the original
%    dimension use the next larger one. But record the other in
%    |\returned@lower@size|.
%    \begin{macrocode}
    \dim_compare:nNnT \l_tmpc_dim < \l_tmpa_dim
    {
      \gdef:Npx \returned@lower@size { \dim_use:N \l_tmpc_dim }
      \dim_add:Nn \l_tmpc_dim \l_tmpb_dim
    }
%    \end{macrocode}
%    The |\returned@size| will be whatever the result of the above is
%    and |\returned@delta@size| the difference to the given value in
%    |#1|. Note that |\returned@size| will always be larger or equal
%    to this value so the difference computed below will also be
%    non-negative!
%    \begin{macrocode}
    \gdef:Npx \returned@size { \dim_use:N \l_tmpc_dim }
    \dim_sub:Nn \l_tmpc_dim \l_tmpa_dim
    \gdef:Npx \returned@delta@size { \dim_use:N \l_tmpc_dim }
%    \end{macrocode}
%    Now if this difference turns out to be zero then we actually
%    started with a dimension exactly on a grid point. In this case we
%    better define both |\returned@lower@size| and
%    |\returned@lower@delta@size| to equal their counterparts.
%    \begin{macrocode}
    \dim_compare:nNnTF \l_tmpc_dim = \c_zero_dim
    {
      \glet:NN \returned@lower@size \returned@size
      \glet:NN \returned@lower@delta@size \returned@delta@size
%    \end{macrocode}
%    Otherwise we only have to compute |\returned@lower@delta@size|
%    since in that case we already recorded |\returned@lower@size|
%    above (and we better had since by now we lost this information as
%    we reused |\l_tmpc_dim|). Now the value for this macro should be
%    the difference between |\returned@delta@size| and our grid size
%    both of which are already stored in some temp registers,
%    thus\ldots
%    \begin{macrocode}
    }
    {
      \dim_sub:Nn \l_tmpb_dim \l_tmpc_dim
      \gdef:Npx \returned@lower@delta@size { \dim_use:N \l_tmpb_dim }
    }
  \group_end:
%<*trace>
  \trace:n{GRID:~ \string\returned@lower@size=\returned@lower@size}
  \trace:n{GRID:~ \string\returned@lower@delta@size=\returned@lower@delta@size}
  \trace:n{GRID:~ \string\returned@size=\returned@size}
  \trace:n{GRID:~ \string\returned@delta@size=\returned@delta@size}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%  \begin{macro}{\xor_snap_to_grid_std:nn}
%  A different implementation of the above.
%    \begin{macrocode}
\def:Npn \xor_snap_to_grid_std:nn #1#2{
%    \end{macrocode}
%  Check if  |#2| is a multiple of |#1|.
%    \begin{macrocode}
  \int_compare:nNnTF
    { \int_mod:nn { \tex_number:D \dim_eval:n{#1} }
                  { \tex_number:D \dim_eval:n{#2} } }
    = \c_zero
%    \end{macrocode}
%  If it is, things are easy.
%    \begin{macrocode}
  {
    \def:Npx \returned@size{\tex_the:D \dim_eval:n{#1}}
    \def:Npx \returned@delta@size { \tex_the:D \c_zero_dim }
    \let:NN  \returned@lower@size       \returned@size
    \let:NN  \returned@lower@delta@size \returned@delta@size
  }
%    \end{macrocode}
%  Else we have to do a few more calculations.
%    \begin{macrocode}
  {
    \def:Npx \returned@lower@size {
      \tex_the:D \dim_eval:n {#2*
        \tex_number:D \int_div_truncate:nn {\tex_number:D \dim_eval:n{#1}}{\tex_number:D\dim_eval:n{#2}}
      }
    }
    \def:Npx \returned@size{\tex_the:D \dim_eval:n{\returned@lower@size+#2}}
    \def:Npx \returned@delta@size{\tex_the:D \dim_eval:n{\returned@size-#1}}
    \def:Npx \returned@lower@delta@size {\tex_the:D \dim_eval:n{#2-\returned@delta@size}}
  }
%<*trace>
  \trace:n{GRID:~ \string\returned@lower@size=\returned@lower@size}
  \trace:n{GRID:~ \string\returned@lower@delta@size=\returned@lower@delta@size}
  \trace:n{GRID:~ \string\returned@size=\returned@size}
  \trace:n{GRID:~ \string\returned@delta@size=\returned@delta@size}
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%
% \subsection{Deferring a float}
%
%
%
% \begin{macro}{\xor_really_defer_and_try_next_float:}
%    This function unconditionally defers the current float (in
%    |\g_xor_this_float_box_tlp|) and then restarts trying the next float (if
%    any).
%    \begin{macrocode}
\def_new:Npn \xor_really_defer_and_try_next_float:{
%<*progress>
        \xor_progress_failed:n{-->~ defer}
        \xor_progress_newline:n{}
%</progress>
      \seq_gput_right:No \g_xor_area_DDD_seq \g_xor_this_float_box_tlp
%<*trace>
      \trace:n{g_xor_curr_page_areas_closed_clist~ <-~ 
             "\g_xor_curr_page_areas_closed_clist"~ +~
             "\g_xor_DDD_all_close_clist"}
%</trace>
      \clist_gconcat:NNN \g_xor_curr_page_areas_closed_clist
                         \g_xor_curr_page_areas_closed_clist
                         \g_xor_DDD_all_close_clist

      \clist_if_eq:NNTF \g_xor_DDD_class_close_clist \pagesetup@area@list
      {
%<*trace>
        \trace:n{g_xor_this_areas_closed_clist~ <-~
               "\g_xor_DDD_class_close_clist"~ (all~ closed)}
%</trace>
        \clist_gset_eq:NN \g_xor_this_areas_closed_clist 
                          \g_xor_DDD_class_close_clist
      }
      {
%<*trace>
        \trace:n{g_xor_this_areas_closed_clist~ <-~ 
               "\g_xor_this_areas_closed_clist"~ +~
               "\g_xor_DDD_class_close_clist"}
%</trace>
        \clist_gconcat:NNN \g_xor_this_areas_closed_clist
                           \g_xor_this_areas_closed_clist
                           \g_xor_DDD_class_close_clist
      }

      \clist_gset_eq:cN {g_xor_class_ \g_xor_this_class_tlp _areas_closed_clist} % FMi tmp
                        \g_xor_this_areas_closed_clist
      \xor_try_next_float:
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_attempt_to_defer_and_try_next_float:}
%
%    This code either defers the current float and restarts by calling
%    |\xor_try_next_float:| or recurses after relaxing the placement
%    conditions (in case the current float should be flushed).
%
%    If the placement conditions are already relaxed we move the first
%    flush point that affects the current float one column forward and
%    then retry. This might result in succeding to place the float, if
%    not it will ultiamtely result in the flush point being moved from
%    the page at which point the float can be deferred.
%
%    \begin{macrocode}
\def_new:Npn \xor_attempt_to_defer_and_try_next_float:{
%<*trace>
  \trace_push:n{xor_attempt_to_defer_and_try_next_float:}
%</trace>
%    \end{macrocode}
%    If there have been no flush points or if the flush points seen do
%    not affect the current float we can immediately defer it.
%    \begin{macrocode}
  \bool_if:NTF \g_xor_flush_seen_bool
  {
    \clist_if_in:NoTF
      \g_xor_flush_max_classes_clist
      \g_xor_this_class_tlp
    {
%<*trace>
      \trace:n{flush:~ class~ \g_xor_this_class_tlp\space in~
             \g_xor_flush_max_classes_clist}
%</trace>
%    \end{macrocode}
%    First test is just there to avoid doing any of the loops
%    (might not be worth having)
%    \begin{macrocode}
      \int_compare:nNnTF {\num_use:c {g_xor_flush_1_min_col_num}}
                       > \g_xor_curr_col_int
      {
%<*trace>
        \trace:n{flush:~ no~ flush~ points~ on~ page;~ defer}
%</trace>
        \xor_do_next:N\xor_really_defer_and_try_next_float:
      }
%    \end{macrocode}
%
%    The code is often invoked before there is an attempt to split the
%    galley; this means we don't know which flush point affects the
%    current float and thus have to manually get at it.
%
%    So we loop through the |\g_xor_flush_|\meta{num}|_last_float_num| values to ^^A((
%    find the first one that a) affects the current float type and b)
%    holds a sequence number that is higher or equal to the sequence
%    number of the current float.\footnote{Fix this loop structure. MH}
%    \begin{macrocode}
      {
        \count@ \c_one
        \loop
%    \end{macrocode}
%    If |\count@| is greater than |\g_xor_collect_flush_seen_num| we have exhausted
%    all possible flush points without finding a candidate.
%    \begin{macrocode}
          \int_compare:nNnTF \g_xor_collect_flush_seen_num < \count@
          { \in@false }
          {
%    \end{macrocode}
%    Otherwise, if |\g_xor_this_flseq_num| is greater than
%    |\g_xor_flush_|\meta{num}|_last_float_num| the current flush point is before
%    the call-out to the current float.
%    \begin{macrocode}
%<*trace>
            \trace:n{flush:~  \num_use:N \g_xor_this_flseq_num
                   \space ???~
                   \num_use:c {g_xor_flush_ \int_use:N \count@
                               _last_float_num}
                  }
%</trace>
            \int_compare:nNnTF \g_xor_this_flseq_num >
                   { \num_use:c{g_xor_flush_ \int_use:N \count@ _last_float_num } }
            {
%    \end{macrocode}
%    We set |\in@true| to get a repeat below with a new value of
%    |\count@|.
%    \begin{macrocode}
              \in@true
            }
            {
%    \end{macrocode}
%    Otherwise we have a flush point that is later in the galley in
%    comparison to the call-out of the current float thus potentially
%    affects it. Therefore we now have to check if the sequence class
%    of the current float is affected by the flush point found:
%    \begin{macrocode}
              \clist_if_in:coTF
                {g_xor_flush_ \int_use:N \count@ _classes_clist}
                \g_xor_this_class_tlp
%    \end{macrocode}
%    Now we could make good use of the |\unless| primitive of
%    e\TeX. But since we want to run with standard \TeX{} and don't
%    have |\xnotin@| available we invert the result.
%    \begin{macrocode}
              {
                \in@false
              }
              {
                \in@true
%<*trace>
                 \trace:n{flush:~ class~ \g_xor_this_class_tlp\space not~ in~
                   \clist_use:c {g_xor_flush_ \int_use:N \count@ _classes_clist}
                   \space (ignored)
                   }
%</trace>
              }
            }
          }
        \ifin@
          \int_incr:N \count@
        \repeat
%<*trace>
        \trace:n{flush:~ first~ float~ point~ after~ float~ =~
               \int_use:N \count@}
%</trace>
        \int_compare:nNnTF \g_xor_collect_flush_seen_num < \count@
        {
%<*trace>
          \trace:n{flush:~ this~ float~ past~all~flush~ points;~ defer}
%</trace>
          \xor_do_next:N\xor_really_defer_and_try_next_float:
        }
%    \end{macrocode}
%    Once a |\g_xor_flush_NUM_min_col_num| is larger 
%    than |\g_xor_curr_col_int| it has
%    moved to the next page. In particular this is true for the
%    artificial value |\maxdimen| to which it is sometimes set to
%    denote this fact. If so we can defer our float.
%    \begin{macrocode}
        {
          \int_compare:nNnTF { \num_use:c{g_xor_flush_ 
                                          \int_use:N \count@ 
                                          _min_col_num }}
                             > \g_xor_curr_col_int
          {
%<*trace>
            \trace:n{flush:~ float~ past~ all~ flush~ points~
                   on~ current~ page;~ defer}
%</trace>
            \xor_do_next:N\xor_really_defer_and_try_next_float:
          }
%    \end{macrocode}
%    If we have already relaxed the conditions and we are still in
%    conflict with a flush point on the current page we nearly ran out
%    of options. In this case we are forced to move the flush point,
%    but rather than moving it to the next page and defering the float
%    we can move it one column further (which might make it fall off
%    the page though) and then retry to place the float since we have
%    now more space available.
%    \begin{macrocode}
          {
            \if_meaning:NN \xor_try_this_area: \xor_try_this_area_relaxed:
%<*trace>
              \trace:n{flush:~ defer~ forced;~ move~
                     flush~ point~ columns}
%</trace>
%<*progress>
              \xor_progress_newline:n{}
              \xor_progress_newline:n{Flushing~ impossible~ -->~ breaking~
                           before~ flush~ point~ and~ retry}
%</progress>
%    \end{macrocode}
%    We should only increment the |\g_xor_flush_NUM_min_col_num| value of the first
%    flush point that affects our float (this will automatically move
%    later flush points if necessary). Incrementing the later ones is
%    incorrect as they might not need moving!
%    \begin{macrocode}
              \num_gincr:c {g_xor_flush_ \int_use:N \count@ _min_col_num}
%<*trace>
              \trace:n{g_xor_flush_ \int_use:N \count@ _min_col_num \space <-~
                     \num_use:c {g_xor_flush_ \int_use:N \count@ _min_col_num}
                     }
%</trace>
%<*progress>
              \xor_progress_newline:n{}
              \xor_progress_newline:n{Defer~ impossible~ -->~ moving~
                           flush~ point~ to~ column~
                           \num_use:c {g_xor_flush_ \int_use:N \count@ _min_col_num}
                           \space
                           and~ retry}
%</progress>
%    \end{macrocode}
%    Not clear that it is really necessary to check all areas again,
%    but it is late (after midnight) and it is definitely not
%    wrong.\footnote{Check!}
%    \begin{macrocode}
              \xor_relax_float_placement_conditions:  % needed to reset open areas
              \xor_do_next:N\xor_try_this_area:

            \else:
%    \end{macrocode}
%
%    \begin{macrocode}
              \xor_relax_float_placement_conditions:
              \xor_do_next:N\xor_try_this_area:
            \fi:
          }
        }
      }
    }
    {
%<*trace>
      \trace:n{flush:~ class~ \g_xor_this_class_tlp\space not~ in~
             \g_xor_flush_max_classes_clist ;~ defer}
%</trace>
      \xor_do_next:N\xor_really_defer_and_try_next_float:
    }
  }
  {
%<*trace>
    \trace:n{flush:~ no~ flush~ point~ seen; defer}
%</trace>
    \xor_do_next:N\xor_really_defer_and_try_next_float:
  }
%<*trace>
  \trace_pop:n{xor_attempt_to_defer_and_try_next_float:}
%</trace>
  \xor_continue:
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_relax_float_placement_conditions:}
%    \begin{macrocode}
\def_new:Npn \xor_relax_float_placement_conditions: {
%<*progress>
    \xor_progress_failed:n{-->~ retry~ with~ relaxed~ conditions}
    \xor_progress_newline:n{}
%</progress>
%<*trace>
    \trace:n{flush:~relax~placement~conditions}
%</trace>
    \clist_gset_eq:NN \g_xor_this_areas_open_clist
                      \g_xor_saved_this_areas_open_clist
%<*trace>
    \trace:n{~g_xor_this_areas_open_clist~
           <-~
           \g_xor_this_areas_open_clist \space (reopen)}
%</trace>
    \glet:NN \xor_try_this_area: \xor_try_this_area_relaxed:
    \glet:NN \xor_check_float_constraints:\relaxed@check@some@constraints
    \glet:NN \xor_check_callout_constraints:n \xor_relaxed_check_callout_constraints:n
    \glet:NN \xor_calculate_float_col: \xor_calculate_float_col_relaxed:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_tighten_float_placement_conditions:}
%    \begin{macrocode}
\def_new:Npn \xor_tighten_float_placement_conditions: {
%<*trace>
    \trace:n{flush:~tighten~placement~conditions}
%</trace>
    \glet:NN \xor_try_this_area: \xor_try_this_area_std:

    \glet:NN \xor_check_float_constraints:\std@check@some@constraints
    \glet:NN \xor_check_callout_constraints:n\xor_std_check_callout_constraints:n
    \glet:NN \xor_calculate_float_col: \xor_calculate_float_col_std:
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_partly_tighten_float_placement_conditions:}
%    This is used when we have placed the last float that is affected
%    by a certain flush point. We don't want to tighten up completely
%    since this would essentially mean that we can't place any further
%    floats since callout relationships etc might be violated for
%    them. Good question is whether or not the last restriction should
%    be used again since this too might prevent any further placements.
%    \begin{macrocode}
\def_new:Npn \xor_partly_tighten_float_placement_conditions: {
%<*trace>
    \trace:n{flush:~partly~tighten~placement~conditions}
%</trace>
    \glet:NN \xor_try_this_area: \xor_try_this_area_std:

%    \glet:NN \xor_check_float_constraints:\std@check@some@constraints
%    \glet:NN \xor_check_callout_constraints:n    \xor_std_check_callout_constraints:n
    \glet:NN \xor_calculate_float_col: \xor_calculate_float_col_std:
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Checking float placement during trial}
%
% The interface to checking float placement in relation to its callout
% is the following piece of code in |\xor_OR_grab_trial_cols:|:
%\begin{verbatim}
%    \seq_map:NN \g_xor_float_classes_seq
%                \xor_check_callout_constraints:n
%\end{verbatim}
% This loops through all float types and executes
% |\xor_check_callout_constraints:n| with the float type as an argument. The output
% routine |\xor_OR_grab_trial_cols:| itself is called for each column of a trial
% configuration, thus the above loop is called for each column
% individually (|\g_xor_curr_col_int| can be used to determine the current
% column number).
%
% By giving |\xor_check_callout_constraints:n| an appropriate definition a
% pagesetup template can implement different relationships between
% callout and float.
%
% Possible tests (getting stronger):
% \begin{itemize}
%
% \item
%   Don't check, i.e., add the float when you find it and it fits
%   according to other criteria (like number of floats in the area,
%   etc.). This is implemented in |\xor_check_callout_none:n|.
%
%
% \item
%  Check if callouts for all floats on the page (not column) are
%  either on the same page or on an earlier page; i.e., callout can be
%  late as long as the float is visible from the callout.
%
%   Fail if for last column and all float types:
%     last callout number for float type is smaller than maximum last float
%     of type put into any column.\footnote{This description is
%     probably wrong}
%
%   This is implemented in |\xor_check_callout_page:n|.
%
% \item
%  Check if callouts for all floats in the column are either on the
%  same column or on an earlier column.
%
%  Fail if for any column and any float type:
%  last callout number for float type is smaller last float sequence
%  number for type recorded for this column.
%
%  This case consists in fact of two subcases depending on how we
%  interpret to which column a spanning float belongs. If we claim
%  that a spanning float is placed into its starting column, then we
%  fail if its call-out is in a later column even though this column
%  might still be spanned by the float area.
%
%  This is implemented in |\xor_check_callout_column:n|.
%
% \item
%  Check if callouts for all floats in the column are on an earlier
%   column or if on the same column the float was added to the bottom
%   (or marginal) area; i.e. strict float/callout order
%
%   Fail if for each type and for any column:
%     `top' callout number  less than `top' float number
%      (at top of text column)
%\begin{verbatim}
%      [Corectness proof:
%       TRUE  => first callout's float comes before bottom
%                  and so comes too early
%             => FAIL
%       FALSE => first callout's float comes in bottom and all other
%                  callouts come later and so are in bottom or beyond
%             => OK
%       ]
%\end{verbatim}
%   The proof above is in fact only valid if you look at the whole
%   document and not only at a single page since a float in the bottom
%   area of the last column with its callout on the next page will
%   only be detected when testing the next page. Therefore one needs
%   an additional check of type |\xor_check_callout_column:n|.
%
%   This is implemented in |\xor_check_callout_after:n|.
%
%
% \end{itemize}
%
%
% \begin{macro}{\xor_check_callout_none:n}
%    This test is an easy one: just do nothing, i.e., gobble the argument.
%    \begin{macrocode}
\let_new:NN \xor_check_callout_none:n \use_none:n
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_check_callout_page:n}
%    We are are only interested in the callout/float relation per page
%    we only have to do a check when producing the last column, i.e.,
%    when |\g_xor_curr_col_int| is |\g_xor_cols_int|.
%    \begin{macrocode}
\def_new:Npn \xor_check_callout_page:n#1{
%<*trace>
  \trace_push:n{xor_check_callout_page:n}
%</trace>
  \int_compare:nNnT \g_xor_curr_col_int=\g_xor_cols_int
  {
%    \end{macrocode}
%    We store in |\g_xor_flseq_max_num| the highest sequence number for floats of
%    the current type up to the end of the page. For this we have to
%    find the maximum of |\g_xor_flseq_type_|\meta{type}|_col_0_num| (highest
%    float number on 
%    previous pages) and those for the columns, e.g.,
%    |\g_xor_flseq_type_|\meta{type}|_col_|\meta{column}|_num|; this is done
%    by the following 
%    code:
%    \begin{macrocode}
    \num_gset_eq:Nc \g_xor_flseq_max_num
                    {g_xor_flseq_type_#1_col_0_num}
    \xor_forall_columns:n {
      \int_compare:nNnT {\num_use:c{g_xor_flseq_type_#1_col_ 
                                    \int_use:N \g_xor_curr_col_int 
                                    _num} }
                        > \g_xor_flseq_max_num
      {
         \num_gset_eq:Nc \g_xor_flseq_max_num 
                         {g_xor_flseq_type_#1_col_ 
                          \int_use:N \g_xor_curr_col_int 
                          _num}
      }
    }
%    \end{macrocode}
%    We then store the number of the last callout in |\count@|; the
%    |0| will take care of the potential problem that there was never any
%    callout so far. And we better have a |\relax| afterwards since
%    otherwise we will expand the |\ifnum| before we have finished
%    assigning the |\count@|.
%    \begin{macrocode}
    \count@0\LastMark{#1}\relax
%<*trace>
    \trace:n{Last~callout~ (#1)~ =~ \int_use:N \count@}
%{\showoutput\showbox255}
%</trace>
%    \end{macrocode}
%    Now we have to compare those two numbers to find out if that
%    trial has failed:
%    \begin{macrocode}
    \int_compare:nNnT \count@ < \g_xor_flseq_max_num
    {
      \bool_gset_true:N \g_xor_trial_failed_bool
%<*progress>
      \xor_progress_failed:n{last~callout~
        \int_use:N \count@\space~<~\g_xor_flseq_max_num
        \space last~float~put~on~page~or~ earlier}
%</progress>
%<*trace>
      \trace:n{Failed:~(#1)~ last~callout~
        \int_use:N \count@\space~<~\g_xor_flseq_max_num
        \space last~float~put~on~page~or~ earlier}
    }
    {
    \trace:n{OK:~(#1)~ last~callout~
       \int_use:N \count@\space~>=~\g_xor_flseq_max_num
       \space last~float~put~on~page~or~ earlier}
%</trace>
    }
  }
%<*trace>
  \trace_pop:n{xor_check_callout_page:n}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_flseq_max_num}
%    The macro |\g_xor_flseq_max_num| is used within |\xor_check_callout_page:n| to hold
%    the highest sequence number of any allocated float on the current
%    page for the type under testing.  It will be recalculated on
%    each pass.\footnote{One could generate this value while running through
%    the trials --- this would perhaps be a bit more time efficient.}
%    \begin{macrocode}
\let\g_xor_flseq_max_num\ERROR
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_check_callout_column:n}
%    Checking each column separately means we have to compare for each
%    type the last callout on this or previous columns (i.e., as
%    returned by |\LastMark|) with the highest sequence number for
%    floats of this type in the current column (as stored in
%    |\g_xor_flseq_type_|\meta{type}|_col_|\meta{column}|_num|). So we first store the callout
%    info in |\count@|.
%    \begin{macrocode}
\def_new:Npn \xor_check_callout_column:n#1{
%<*trace>
  \trace_push:n{xor_check_callout_column:n}
%</trace>
  \count@0\LastMark{#1}\relax
%<*trace>
    \trace:n{Last~callout~ (#1)~ =~ \int_use:N \count@}
%</trace>
%    \end{macrocode}
%    Then we do the test. If there are no floats of the current type
%    in the current column
%    |\g_xor_flseq_type_|\meta{type}|_col_|\meta{column}|_num| will be zero
%    and thus the following test will come out true. This is the
%    correct behaviour as any callouts that might be present will be
%    correctly evaluated in tests on neighboring columns with floats.
%    \begin{macrocode}
  \int_compare:nNnTF \count@< {\num_use:c{g_xor_flseq_type_#1_col_ 
                                          \int_use:N \g_xor_curr_col_int
                                          _num}}
  {
%<*progress>
    \xor_progress_failed:n{last~ callout~
         \int_use:N \count@\space <~
         \num_use:c {g_xor_flseq_type_#1_col_ \int_use:N \g_xor_curr_col_int _num}
         \space last~ float~ placed~ in~ column~ \int_use:N \g_xor_curr_col_int}
%</progress>
%<*trace>
    \trace:n{Failed:~(#1)~ last~ callout~
         \int_use:N \count@\space <~
         \num_use:c{g_xor_flseq_type_#1_col_ \int_use:N \g_xor_curr_col_int _num}
         \space last~float~placed}
%</trace>
%    \end{macrocode}
%    If the test fails we abort this trial by setting the switch
%    |@fail| to true. We also set
%    |\g_xor_curr_col_int| to |\g_xor_cols_int| which will save us any further
%    iteration (in case this wasn't the last column). Finally we
%    locally set |\seq_elt:w| to gobble which will essentially abort
%    the current loop through the |\g_xor_float_classes_seq|.
%    \begin{macrocode}
      \bool_gset_true:N \g_xor_trial_failed_bool
      \global\g_xor_curr_col_int\g_xor_cols_int
%FMi tmp
      \def\seq_elt:w ##1\seq_elt_end:{}
%    \end{macrocode}
%    Otherwise the constraints for callout of current float type are
%    met so we report this fact if we do tracing.
%    \begin{macrocode}
  }
  {
%<*trace>
  \trace:n{OK:~(#1)~ last~ callout~
         \int_use:N \count@\space >=~
         \num_use:c {g_xor_flseq_type_#1_col_ \int_use:N \g_xor_curr_col_int _num}
         \space last~float~placed}
%</trace>
  }
%<*trace>
  \trace_pop:n{xor_check_callout_column:n}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_check_callout_after:n}
%
%    \begin{macrocode}
\def_new:Npn \xor_check_callout_after:n#1{
%<*trace>
  \trace_push:n{xor_check_callout_after:n}
%</trace>
%    \end{macrocode}
%
%    We first check if all floats are either on the same column than
%    their callout or on an later column by calling
%    |\xor_check_callout_column:n|. If this returns |@fail| we immediately
%    abort any further processing.
%    \begin{macrocode}
  \xor_check_callout_column:n{#1}
  \bool_if:NF \g_xor_trial_failed_bool
  {
%    \end{macrocode}
%
%    If the above check found no violation we have to check for top
%    area floats that might preceed their callouts.
%
%    For this we look at the value of the \\
%    |\g_xor_flseq_areas_top_type_|\meta{float-type}|_col_|\meta{col}|_num|
%    macro which holds the
%    highest float sequence number for floats of this type allocated
%    in that column.
%    \begin{macrocode}
    \num_gset_eq:Nc
        \g_xor_flseq_returned_num
        {g_xor_flseq_areas_top_type_#1_col_
                        \int_use:N \g_xor_curr_col_int _num }
%    \end{macrocode}
%
%    If there was no float in the top area we get |0| back and in
%    that case we are done since all our constraints are met.
%    \begin{macrocode}
    \int_compare:nNnTF \g_xor_flseq_returned_num = \c_zero
    {
%<*trace>
      \trace:n{OK:~(#1)~ top~ areas~ have~ no~ floats}
%</trace>
    }
    {
%    \end{macrocode}
%
%    Otherwise we have to look at the top callout number and compare
%    it to the last float number of the top area.
%    \begin{macrocode}
      \count@ 0\PreviousMark{#1}\relax
%    \end{macrocode}
%    If that callout number is less than the last float number we
%    failed since this means that there is a float in the top area
%    which callout has not yet been seem. So we abort the
%    trial. Otherwise our constraints are met.
%    \begin{macrocode}
      \int_compare:nNnT \count@ < \g_xor_flseq_returned_num
      {
%    \end{macrocode}
%    But before aborting we give some information on why we
%    failed. This has to come first since we change |\g_xor_curr_col_int|
%    below.
%    \begin{macrocode}
%<*progress>
        \xor_progress_failed:n{top~ callout~
              \int_use:N \count@\space <~ \g_xor_flseq_returned_num
              \space last~ float~ put~ in~ top~
              of~ column~ \int_use:N \g_xor_curr_col_int}
%</progress>
        \bool_gset_true:N \g_xor_trial_failed_bool
        \int_gset:Nn \g_xor_curr_col_int \g_xor_cols_int
%FMi tmp
        \def\seq_elt:w ##1\seq_elt_end:{}
%<*trace>
        \trace:n{Failed:~(#1)~ top~ callout~
              \int_use:N \count@\space <~ \g_xor_flseq_returned_num
              \space last~float~put~in~top}
      }
      {
        \trace:n{OK:~(#1)~ top~ callout~
               \int_use:N \count@\space >=~ \g_xor_flseq_returned_num
              \space last~float~put~in~top}
%</trace>
      }
    }
  }
%<*trace>
  \trace_pop:n{xor_check_callout_after:n}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{Checking bottom float footnote constraints}
%
% In |\xor_OR_grab_trial_cols:| (when the output routine that grabs a single column
% during a trial) we have the command |\xor_check_float_constraints:| which
% allows to check some constraints and if they aren't met is supposed
% to set the switch |@fail|.
%
% This can, for example be used to implement a constraint that bottom
% floats are only allowed if there are no footnotes in the current
% column.\footnote{At the moment this is restricted to single column
%    floats. Spanning floats are always allowed.}
%
% \begin{macro}{\xor_check_float_footnote_forbidden:}
%    The command |\xor_check_float_footnote_forbidden| is the
%    implementation for |\xor_check_float_constraints:| that prevents bottom
%    floats if the current column contains footnotes.
%    \begin{macrocode}
\def_new:Npn \xor_check_float_footnote_forbidden: {
%<*trace>
  \trace_push:n{xor_check_float_footnote_forbidden:}
%</trace>
  \box_if_empty:NF \footins
  {
%    \end{macrocode}
%    If the current column contains footnotes and we have bottom
%    floats we fail. First we check if there is a bottom area for this
%    column defined if not we pretend there is an empty one.
%    \begin{macrocode}
    \cs_free:cT {g_xor_area_
                 b\int_use:N\g_xor_curr_col_int 1
                 _seq}
    {
      \seq_gclear:c { g_xor_area_
                      b\int_use:N\g_xor_curr_col_int 1
                      _seq}
    }
%    \end{macrocode}
%    Then we check if the bottom area is empty and fail otherwise
%    \begin{macrocode}
%<+trace> \seq_if_empty:cTF
%<-trace> \seq_if_empty:cF
        {g_xor_area_
         b\int_use:N\g_xor_curr_col_int 1
         _seq}
%<*trace>
        { \trace:n{OK:~ no~ old~ bottom~ floats} }
%</trace>
        {
%<*progress>
          \xor_progress_failed:n{old~bottom~floats:~
          \cs_meaning:c{g_xor_area_ b\int_use:N\g_xor_curr_col_int 1 _seq}}
%</progress>
%<*trace>
          \trace:n{Failed:~ old~bottom~floats:~ \cs_meaning:c
            {g_xor_area_ b1\int_use:N\g_xor_curr_col_int _seq}}
%</trace>
          \bool_gset_true:N \g_xor_trial_failed_bool
        }
%    \end{macrocode}
%    Finally we test if the float we are try to place is going onto a
%    bottom area.
%
%    However, we only do this if the float doesn't span.\footnote{Extend?}
%    \begin{macrocode}
    \int_compare:nNnT \g_xor_this_area_span_tlp = \c_one
    {
%<*trace>
      \trace:n{this@area,column:~ \g_xor_this_area_name_tlp,~
             \int_use:N \g_xor_curr_col_int}
%</trace>
      \if b \g_xor_this_area_type_tlp
         \int_compare:nNnT \g_xor_this_area_col_tlp = \g_xor_curr_col_int
         { \bool_gset_true:N \g_xor_trial_failed_bool }
      \fi
    }
    \bool_if:NT \g_xor_trial_failed_bool
    {
%<*progress>
      \xor_progress_failed:n{column~ \int_use:N \g_xor_curr_col_int\space
                            contains~ footnotes~ and~ bottom~ floats}
%</progress>
%<*trace>
      \trace:n{Failed:~ column~ \int_use:N \g_xor_curr_col_int\space
                      contains~ footnotes~ and~ bottom~ floats}
%</trace>
      \int_gset:Nn \g_xor_curr_col_int \g_xor_cols_int
    }
  }
%<*trace>
  \trace_pop:n{xor_check_float_footnote_forbidden:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_check_float_footnote_none:}
%
%    This is the implementation for |\xor_check_float_constraints:| if we
%    don't care about mixing footnotes and bottom floats. The reason
%    |\do_nothing:| rather than |\scan_stop:| is used is that otherwise the
%    |\ifx| test in the template would fail.
%    \begin{macrocode}
\let\xor_check_float_footnote_none: \do_nothing:
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \endinput
\endinput
%
% $Log$
% Revision 1.12  2005/03/01 22:54:18  morten
% Small updates, more expl3 conversion
%
% Revision 1.10  2004/12/12 20:27:37  mittelba
% fixed typo: backslash too many
%
% Revision 1.9  2004/12/05 22:20:59  mittelba
% fixing \SPANCNT to have 1 instead of <empty> as default
% adding missing gloabl to inline box assignment
%
% Revision 1.8  2004/11/13 10:04:06  mittelba
% new license (LPPL)
%
% Revision 1.7  2004/10/30 18:46:20  mittelba
% further cleanup using expl3 concepts
% first attempt at balancing (unfinished)
%
% Revision 1.6  2004/10/12 21:40:53  mittelba
% updates up to p29
%
% Revision 1.5  2004/10/03 22:44:34  mittelba
% more updates ... still not getting closer ...
%
% Revision 1.4  2004/10/03 15:36:13  mittelba
% more cleanup ... tedious ...
%
% Revision 1.3  2004/10/01 21:46:51  mittelba
% many further updates, still a lot to do
%
% Revision 1.2  2004/09/27 20:06:31  mittelba
% in the middle of normalizing to expl3 syntax
%
% Revision 1.1  2001/07/26 19:55:12  latex3
% original web distrib
%
% Revision 1.37  2000/08/11 07:14:28  latex3
% added header
%
% Revision 1.36  2000/08/11 06:49:47  latex3
% untabify
%
% Revision 1.35  2000/08/11 06:45:03  latex3
% only partially tighten float constraints after passing a flush point
%
% Revision 1.34  2000/07/23 21:03:19  latex3
% removed obsolete commentary
%
% Revision 1.33  2000/07/21 13:53:17  latex3
% more renaming for float sequence class concept
%
% Revision 1.32  2000/07/18 21:06:36  latex3
% introduced float sequence classes
%
% Revision 1.31  2000/07/12 17:24:53  latex3
% more support for grids
%
% Revision 1.30  2000/07/10 21:00:57  latex3
% support for grid typesetting
%
% Revision 1.29  2000/07/04 19:42:05  latex3
% fix tracing for GRID stuff
%
% Revision 1.28  2000/07/01 15:57:25  latex3
% use \xor_update_this_area_span_cols:n
% integrate code to support grid design (first draft)
%
% Revision 1.27  2000/06/29 17:18:14  latex3
% introduced \xor_this_area_setup:o
%
% Revision 1.26  2000/06/26 15:03:40  latex3
% making prototype for \g_xor_float_area_skip
%
% Revision 1.25  2000/06/22 20:08:09  latex3
% renamed some macros to get them more uniform
%
% Revision 1.24  2000/06/22 11:01:24  latex3
% When substracting heights from columns do this for the columns spanned
% by the area. Don't use the span number from the float (in the future
% this might be smaller than the span number of the area)
%
% Revision 1.23  2000/06/19 21:38:04  latex3
% fixed flush point handling when deferring
%
% Revision 1.22  2000/06/18 19:03:53  latex3
% added "Checking bottom float footnote constraints" from xo-page
%
% Revision 1.21  2000/06/16 11:20:15  latex3
% rename \construct@and@test@col@height to \construct@and@test@col@ht
% rename \construct@and@test@col@heights to \construct@and@test@col@hts
% rename \cl@height1 to \@col@ht@1 (etc)
%
% Revision 1.20  2000/06/16 11:06:37  latex3
% support float-callout-span-constraint
%
% Revision 1.19  2000/06/16 07:49:49  latex3
% improve progress info
%
% Revision 1.18  2000/06/15 17:49:02  latex3
% moved macros from xo-page into here since they deal with placement
%
% Revision 1.17  2000/06/15 15:23:32  latex3
% implemented new semantics for area names
%
% Revision 1.16  2000/06/13 20:48:18  latex3
% docu update
%
% Revision 1.15  2000/06/06 12:50:40  latex3
% before attempting fuzzy flushpoints
%
% Revision 1.14  2000/05/03 18:57:56  latex3
% provide \construct@and@test@col@heights subroutine
%
% fix problem that deferred floats would not stop other floats going
% into earlier areas
%
% Revision 1.13  2000/03/31 17:08:50  latex3
% avoid using up too much input stack by using tail recursion in
% strategic places (tmp fix)
%
% Revision 1.12  2000/03/26 21:04:03  latex3
% some renaming of macros
%
% Revision 1.11  2000/03/24 15:34:27  latex3
% version that starts supporting spans (still a hack yet)
%
% Revision 1.10  2000/03/22 15:52:37  latex3
% some normalisations of names
% first go at spans (tmp version)
%
% Revision 1.9  2000/03/17 20:23:11  latex3
% more fixes to flushing (looks good now)
%
% Revision 1.8  2000/03/16 10:28:29  latex3
% partial and full flush working for the first time
%
% Revision 1.7  2000/03/05 19:31:56  latex3
% some renaming
% extend to multiple columns (6 max right now)
% fix defer logic: when flushseen don't defer immediately
%
% Revision 1.6  2000/02/27 15:12:45  david
% *** empty log message ***
%
% Revision 1.5  2000/02/27 11:27:45  david
% first attempt at flush floats
%
% Revision 1.4  2000/02/26 18:24:21  david
% renaming, and using \xor_area_setup:
%
% Revision 1.3  2000/02/16  13:40:09  latex3
% added 3col support
%
% Revision 1.2  2000/02/16  10:10:43  latex3
% added documentation
% added test for float area size after adding float
%
% Revision 1.1  2000/02/13  22:27:39  latex3
% Initial revision
%
