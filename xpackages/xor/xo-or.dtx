% \iffalse
%% File xo-or.dtx (C) Copyright 1999-2000 Frank Mittelbach, David Carlisle, Chris Rowley
%%                (C) Copyright 2004-2007 Frank Mittelbach, LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xor bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
\RequirePackage{l3names}
\GetIdInfo $Id$
          {xo-or}
\ProvidesExplPackage{\filename}
  {\filedate}{\fileversion}{\filedescription}
% \fi
%
%
% \subsection{A flowchart of the algorithm}
%
% Several output routines are employed.  Output routines (that is,
% macros to be used as the sole content of the primitive |\output|
% register) are named |\xor_OR_...:|\footnote{and so are some of their helper
% commands right now}. Typically a companion macro named
% |\xor_OR_..._setup:|\footnote{again not quite true right now ... normalise!} 
% is called to initialise the state (typically setting
% vsize) and to assign |\output|.
%
%
% ^^A  [The flow chart has be cut into pieces and individual pieces are
% ^^A   shown below.]
%
% ^^A \input{xo-flow-chart.sty}  ^^A .sty to ease updating
%
%
%
%
%
% \subsection{Special Output Routine Penalties}
%
% \begin{macro}{\c_xor_output_endgame_penalty}
%    Special penalty added by \TeX's primitive |\end| (aka |\@@end|
%    aka ...)
%    \begin{macrocode}
\def_new:Npn \c_xor_output_endgame_penalty
             {1073741824\scan_stop:}         % too big for mathchar
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\c_xor_output_collect_penalty}
%    Special penalty marking the point at which the collection OR ended.
%    \begin{macrocode}
\tex_mathchardef:D \c_xor_output_collect_penalty=20202 \scan_stop:
%    \end{macrocode}
% \end{macro}
%
%
% Other special penalties are inbetween -10000 and -10010. Those will
% not stop  the collection OR but are instead recorded along the way.
%
% \begin{macro}{\c_xor_output_columnbreak_penalty}
%    Special penalty marking the point a forced column break was
%    requested by the user.
%    \begin{macrocode}
\tex_mathchardef:D \c_xor_output_columnbreak_penalty=10005\scan_stop:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\c_xor_output_flush_float_penalty}
% Special penalty to trigger float flushing for one or more types.
%    \begin{macrocode}
\tex_mathchardef:D \c_xor_output_flush_float_penalty=10006\scan_stop:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\c_xor_output_here_float_penalty}
% Special penalty for floats that should stay with their callout.
%    \begin{macrocode}
\tex_mathchardef:D\c_xor_output_here_float_penalty=10007\scan_stop:
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\c_xor_output_grid_align_penalty}
% Special penalty for places that should fall on the page grid.
%    \begin{macrocode}
\tex_mathchardef:D\c_xor_output_grid_align_penalty=10008\scan_stop:
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\c_xor_output_balance_penalty}
%    Special penalty marking the point at which balancing should happen.
%    \begin{macrocode}
\tex_mathchardef:D\c_xor_output_balance_penalty=10009\scan_stop:
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsubsection{Utilities for Special Output Routine Penalties}
%
%
% \begin{macro}{\xor_add_badly_guarded_penalty:N}
%    Put a special penalty into the output and guard it with a
%    box. The reason this macro is called |\xor_add_badly_guarded_penalty:N|
%    is that such a box of size zero is still messing up spacing
%    caluclations. Why? Because when the penalty is reached on the MVL
%    the preceeding line has already be fully added (i.e., including
%    its depth). This means that \TeX{} might not reach it at all in
%    time! For example, if the preceeding line would be the last line
%    of the page the depth would not be taken into account yet, but by
%    the time we reach the special penalty it has been added to
%    |\pagetotal| and that may result in not fitting anymore onto the
%    page.
%
%    A solution would be to use a box that has the same depth as its
%    preceeding box and a negative height so that it effectively
%    doesn't modify the galley length. Easy, right?  The only problem
%    is that in case of |\vadjust| (and that is unfortunately the more
%    important case) we just don't know what the preceeding depth is,
%    since |\prevdepth| will always give us a friendly |-1000pt| in
%    that case (start of a vertical sub-list\ldots).
%
%    So not so easy after all. The way out of this dilemma turned out
%    to be complicated and involves a lot of strange corrective
%    actions in the collection process, see there for a replacement of
%    that box and what else can go wrong if one delves into messing
%    around with that part of \TeX.
%    \begin{macrocode}
\def_new:Npn \xor_add_badly_guarded_penalty:N #1 {
  \mode_vertical:TF
  {
    \nointerlineskip
    \vbox_to_zero:n {\vss\the#1 ~BAD}
    \penalty-#1\scan_stop: }
  {
    \@bsphack
    \vadjust{\vbox_to_zero:n {\vss\the#1 ~BAD}
             \penalty-#1\scan_stop:}
    \@esphack
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_remove_guard_box_from_cclv:}
%    Remove a guard box again. This always happens in the OR and so we
%    hard code the box number for speed.
%
%    Chris thinks this needs a maxdepth setting.
%    \begin{macrocode}
\def_new:Npn \xor_remove_guard_box_from_cclv: {
  \vbox_gset:Nn \c_twohundred_fifty_five {
    \boxmaxdepth\@maxdepth
    \vbox_unpack_clear:N\c_twohundred_fifty_five
    \box_gset_to_previous:N \g_removed_guard_box}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_readd_guarded_penalty:n}
%    Readding a guarded penalty including the box that was removed
%    earlier. Probably not needed in the end either since the way it
%    is used at the moment we have a |\topskip| problem this
%    way.\footnote{FIX!!!!}
%    \begin{macrocode}
\def_new:Npn \xor_readd_guarded_penalty:n #1 {
  \box_use_clear:N\g_removed_guard_box
%FMi what about topskip?
  \penalty-#1\relax}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_removed_guard_box}
%    A register to hold a guard box that was just removed from the current
%    list so that we can readd it later if necessary.
%    \begin{macrocode}
\box_new:N \g_removed_guard_box
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsection{Columns and their Data Structures}
%
% \begin{macro}{\g_xor_cols_int}
%    We are collecting stuff for a given number of columns. This
%    number of column is available in a count register.
%    \begin{macrocode}
\int_new:N \g_xor_cols_int
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_curr_col_int}
%    Register denoting the column number of the current column while
%    we cut the galley etc. Should always be modified globally since
%    it is used within output routines.
%    \begin{macrocode}
\int_new:N \g_xor_curr_col_int
%    \end{macrocode}
% \end{macro}
%
%
%
% \DescribeMacro\g_xor_col_NUM_box
%    Per column number NUM we have one box register allocated in which
%    the column text from the galley is stored during trials and page
%    makeup.
%
% \DescribeMacro\g_xor_ht_col_NUM_dim
%    Per column number NUM we have dimen  register allocated which
%    holds the vertical target size for the column during the trials.
%
% \DescribeMacro\g_xor_bottom_ht_col_NUM_dim
%    Per column number NUM we have dimen  register allocated which
%    holds the vertical size already taken up by bottom floats during the trials.
%    This is used during balancing.
%
% \DescribeMacro\g_xor_t_floats_col_NUM_num
%    Per column number NUM we have a macro number in which we count
%    the number of top floats we have seen so far in this column. This
%    is used to implement |\g_xor_float_area_skip| handling.
%
% \DescribeMacro\g_xor_b_floats_col_NUM_num
%    Per column number NUM we have a macro number in which we count
%    the number of bottom floats we have seen so far in this column. This
%    is used to implement |\g_xor_float_area_skip| handling.
%
%
% \DescribeMacro\g_xor_t_delta_col_NUM_tlp
%    Per column number NUM we have a macro in which we record the
%    difference between the real size of all top floats (including
%    there separation spaces) and the nominal size which is used to
%    determine the vertical size of the remaining text column. The two
%    may differ if we do grid typesetting.
%
% \DescribeMacro\g_xor_b_delta_col_NUM_tlp
%    Same kind of delta is recorded per column for the bottom floats.
%
% \DescribeMacro\g_xor_flseq_type_BAR_col_NUM_num
%    For each float type BAR (e.g., |figure|, |table|, etc.) and each
%    column number NUM we have a macro which holds the highest float
%    sequence number for floats of type BAR allocated to column NUM or
%    zero if no float has been allocated so far.
%
% \DescribeMacro{\g_xor_flseq_type_BAR_col_0_num}
%    \mbox{}
%    \hfill
%    For each float type BAR (e.g., |figure|, |table|, etc.)\\
%    |\g_xor_flseq_type_BAR_col_0_num| holds the highest sequence number in
%    columns of the 
%    previous page.
%
% \DescribeMacro{\g_xor_flseq_areas_top_type_BAR_col_NUM_num}
%    \mbox{}
%    \hfill
%    |\g_xor_flseq_areas_top_type_BAR_col_NUM_num| is like \\
%    |\g_xor_flseq_type_BAR_col_NUM_num| but only stores information
%    about floats allocated to top areas.
%
%
%
% \begin{macro}{\g_xor_col_NUM_box}
% \begin{macro}{\g_xor_col_NUM_balance_box}
% \begin{macro}{\g_xor_ht_col_NUM_dim}
% \begin{macro}{\g_xor_bottom_ht_col_NUM_dim}
% \begin{macro}{\g_xor_balance_ht_col_NUM_dim}
%  For each column we need: a box to hold material from the galley, a
%  box to do balancing, and a dimension to hold its current vertical
%  target size. Currently we allocate for six columns.
%    \begin{macrocode}
\clist_map_inline:nn {1,2,3,4,5,6}
{
  \box_new:c {g_xor_col_#1_box}
  \box_new:c {g_xor_col_#1_balance_box}
  \dim_new:c {g_xor_ht_col_#1_dim}
  \dim_new:c {g_xor_best_ht_col_#1_dim}        % not really the best solution
  \dim_new:c {g_xor_bottom_ht_col_#1_dim}
  \dim_new:c {g_xor_balance_ht_col_#1_dim}
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
% \subsubsection{Utilities for Columns and their Data Structures}
%
% \begin{macro}{\xor_forall_columns:n}
%    If we want to do something to data structures for all column we
%    can use the macro |\xor_forall_columns:n|. Within its argument the
%    current column is available in the register
%    |\g_xor_curr_col_int|. The macro takes some pains to restore the
%    original value of |\g_xor_curr_col_int| afterwards so that it can
%    be called recursively.
%    \begin{macrocode}
\def_new:Npn \xor_forall_columns:n #1 {
  \tlp_set:Nx \l_xor_saved_curr_col_tlp {\int_use:N \g_xor_curr_col_int}
  \int_gzero:N \g_xor_curr_col_int
  \int_whiledo:nNnT \g_xor_curr_col_int<\g_xor_cols_int
      {
        \int_gincr:N \g_xor_curr_col_int  
         #1   
      }
  \int_gset:Nn \g_xor_curr_col_int \l_xor_saved_curr_col_tlp
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_cols_setup:}
%    \begin{macrocode}
\def_new:Npn \xor_cols_setup:{
%<*trace>
  \trace_push:n{xor_cols_setup:}
%</trace>
%    \end{macrocode}
%
%    The initial target size for all columns is |\textheight| to which
%   |g_xor_ht_col_NUM_dim| is set. The size already taken up by bottom floats is
%   zero. These values are stored in |\g_xor_best_trial_col_hts_tlp| for later
%   retrieval during trials.
%    \begin{macrocode}
  \xor_set_best_trial_col_hts:n {\dim_use:N \textheight}
%    \end{macrocode}

%    \begin{macrocode}
  \xor_forall_columns:n
     {
      \tlp_gput_right:Nx \g_xor_best_trial_col_hts_tlp
        {
         \exp_not:N \dim_gset:Nn
         \exp_not:c   {g_xor_bottom_ht_col_ \int_use:N\g_xor_curr_col_int _dim}
                      {\c_zero_dim}
        }
%    \end{macrocode}
%    We haven't seen any balance points yet, thus clearly none are
%    already handled.\footnote{FIX: not needed here?}
%    \begin{macrocode}
%     \num_gzero:N \g_xor_best_balance_done_num
%    \end{macrocode}
%    We haven't seen any top or bottom floats yet.
%    \begin{macrocode}
      \num_gzero:c {g_xor_t_floats_col_ \int_use:N\g_xor_curr_col_int
                     _num}
      \num_gzero:c {g_xor_b_floats_col_ \int_use:N\g_xor_curr_col_int
                     _num}
%    \end{macrocode}
%    For the same reason the delta values for top and bottom areas are
%    zeroed.\footnote{Using \texttt{\string\let} and
%    \texttt{\string\c\_zero} in places like this would be more faster and
%    shorter, but it wouldn't work nicely in tracing as it would make
%    unexpandable macros. Perhaps the tracing versions should be made
%    specially.}
%    \begin{macrocode}
      \tlp_gset:cn {g_xor_t_delta_col_ \int_use:N\g_xor_curr_col_int _tlp}{0pt}
      \tlp_gset:cn {g_xor_b_delta_col_ \int_use:N\g_xor_curr_col_int _tlp}{0pt}
  }
%    \end{macrocode}
%    We now execute |\g_xor_best_trial_col_hts_tlp| to initialise the various
%    dim registers for all columns.
%    \begin{macrocode}
  \g_xor_best_trial_col_hts_tlp
%<*trace>
  \trace:n{Use~ g_xor_best_trial_col_hts_tlp~ =~ \tlp_to_str:N \g_xor_best_trial_col_hts_tlp}
  \trace_pop:n{xor_cols_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \subsubsection{User Commands for Columns}
%
%
% \begin{macro}{\columnbreak}
%    And here is the user command formaking a column
%    break:\footnote{All this is stolen from \texttt{multicol.sty} and
%    there is still code that doesn't belong here.}  |\columnbreak| is
%    modelled after |\pagebreak| except that we generate a penalty
%    with value
%    |-\c_xor_output_columnbreak_penalty|.
%    \begin{macrocode}
\def_new:Npn \columnbreak{
%    \end{macrocode}
%    We have to ensure that it is only used within a multicolumn
%    environment since if that penalty would be seen by the unmodified
%    \LaTeX{} output routine strange things would happen.
%    \begin{macrocode}
  \int_compare:nNnTF \g_xor_cols_int<\c_two
    {
     \PackageError{xoutput}
       {\exp_not:N \columnbreak~ in~ one-column~ mode}
       {???}
    }
    {
     \mode_vertical:TF
          { \penalty -\c_xor_output_columnbreak_penalty }
          {
           \@bsphack
             \vadjust{\penalty -\c_xor_output_columnbreak_penalty}
           \@esphack
          }
    }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
%
%
% \subsection{Float Areas and their Data Structures}
%
% Naming conventions for float areas is as follows:
% \begin{quote}
% \meta{identifier}\meta{start-column}\meta{span-count}.
% \end{quote}
% The \meta{identifier} is a single letter denoting the type of area,
% e.g., |t| for top, |b| for bottom. The \meta{span-count} is a single
% digit denoting the number of columns to span. The
% \meta{start-column} is a single digit\footnote{with a bit of care in
% the code this could be extended to allow more than one digit.}
% denoting the start column of the area. Thus |t32| is a top area
% starting at column three and spanning two columns ie three and four.
% A restriction due to the naming scheme is that currently no more than
% 9 columns are possible.
%
% Only a subset of the float areas is allowed to be populated on a
% page. In essense the current algorithm does not support placements
% that result in splitting the text of a column due to a float (other
% than column `here' floats).\footnote{Perhaps this restriction is
% lifted one day.} This means that if $pcs$ ($p=\textrm{pos}$,
% $c=\textrm{column}$, $s=\textrm{span}$) is a float area that is
% being populated then it must prevent populating all float areas that
% satisfy either
% \[
%    pij  \textrm{ with }   i < c \leq i+j < c+s
% \]
% or
% \[
%    pij  \textrm{ with }   i \leq c+s < i+j \leq \verb=\g_xor_cols_int=
% \]
% The first formula describes the areas which partly overlap from the
% left, the second formula describes those that partly overlap from
% the right. Areas which are sub- or super-areas, e.g., \texttt{t13}
% and \texttt{t22} do not affect each other. The above restriction is
% necessary to prevent situations like
%\begin{verbatim}
%aaaaaaaaaaa 444
%aaaaaaaaaaa 444
%aaaaaaaaaaa 444
%111 222 bbbbbbb
%111 222 bbbbbbb
%111 222 bbbbbbb
%111 222 333 444
%111 222 333 444
%\end{verbatim}
%
%
% For each area |FOO| (e.g., |t13|) we keep a number of global
% variables to store relevant data. These are the following
%    variables\footnote{Not a consistent lot}:
%
% \DescribeMacro\g_xor_area_FOO_seq
%    Floats allocated to the area |FOO| by the page building process
%    are stored in the sequence |\g_xor_area_FOO_seq|.
%
% \DescribeMacro\g_xor_area_FOO_max_float_num
%    The maximum number of floats allowed in area |FOO| is stored in
%    the macro |\g_xor_area_FOO_max_float_num|.
%
% \DescribeMacro\g_xor_area_FOO_float_int
%
%    The number of floats currently allocated to area |FOO| is stored
%    in the count register |\g_xor_area_FOO_float_int|.\footnote{This is a
%    waste of registers!}
%
% \DescribeMacro\g_xor_FOO_class_close_clist
%    The areas that should be closed for floats of the same sequence class the
%    moment a float is placed into area |FOO|. This is a comma
%    separated list.
%
% \DescribeMacro\g_xor_FOO_all_close_clist
%    The areas that should be closed for all float sequence classes the
%    moment a float is placed into area |FOO|. This is a comma
%    separated list.
%
%
%
% \begin{macro}{\g_xor_areas_known_clist}
%    |\g_xor_areas_known_clist| are the areas known to the system.\footnote{or
%    something else, the semantics are still changing} Initialisation
%    is done when declaring individual areas.
%    \begin{macrocode}
\clist_new:N \g_xor_areas_known_clist
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_areas_used_clist}
%    |\g_xor_areas_used_clist| are the areas used by the current page setup.
%    Initialisation is done in the page setup template so the
%    definition below is arbitrary.
%    \begin{macrocode}
\clist_new:N \g_xor_areas_used_clist
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_floats_free_seq}
%    Sequence of float structures free to receive floats.
%    \begin{macrocode}
\seq_new:N \g_xor_floats_free_seq
%    \end{macrocode}
%
%    Since 2e already allocates a large number in |\@freelist| we
%    reuse those at the moment.
%    \begin{macrocode}
\def\@elt#1{\seq_gput_right:Nn \g_xor_floats_free_seq{#1}}
\@freelist
\let:NN \@freelist \c_undefined
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_floats_active_seq}
%    \begin{macrocode}
\seq_new:N \g_xor_floats_active_seq
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_floats_mvl_seq}
%    \begin{macrocode}
\seq_new:N \g_xor_floats_mvl_seq
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_area_DDD_seq}
%    The list of deferred floats (which we consider being an area in
%    some respects). And that area also needs a three-char name!
%    \begin{macrocode}
\seq_new:N \g_xor_area_DDD_seq
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_DDD_class_close_clist}
% \begin{macro}{\g_xor_DDD_all_close_clist}
%    \begin{macrocode}
\clist_new:N \g_xor_DDD_class_close_clist
\clist_new:N \g_xor_DDD_all_close_clist
%%%%\def \g_xor_DDD_class_close_clist {\pagesetup@area@list}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\g_xor_this_caption_tlp}
% \begin{macro}{\g_xor_this_span_num_tlp}
% \begin{macro}{\g_xor_this_display_tlp}
% \begin{macro}{\g_xor_this_display_cnt_tlp}
% \begin{macro}{\g_xor_this_allowed_areas_tlp}
% \begin{macro}{\g_xor_this_type_tlp}
% \begin{macro}{\g_xor_this_flseq_num}
% \begin{macro}{\g_xor_this_class_tlp}
% Each float box has an associated token register storing several
% information fields.
% \begin{enumerate}
% \item[1] float caption (set by caption command)
% \item[2] 
% \item[3] saved label string
% \item[4] `display counter' number (per-type count) set by float environment.
% \item[5] Allowed float areas (from default or optional arg.)
% \item[6] float type (currently this is the long name, eg figure) should
% probably be the single token name, to allow quicker testing.
% \item[7] float sequence number.
% \end{enumerate}
%
%    \begin{macrocode}
\tlp_new:N \g_xor_this_caption_tlp      
\tlp_new:N \g_xor_this_span_num_tlp     
\tlp_new:N \g_xor_this_label_key_tlp
\tlp_new:N \g_xor_this_display_cnt_tlp
\tlp_new:N \g_xor_this_allowed_areas_tlp
\tlp_new:N \g_xor_this_type_tlp       
\num_new:N \g_xor_this_flseq_num
%    \end{macrocode}
%    From the ``type'' the float class can be determined which is then stored
%    in the following token lost pointer:
%    \begin{macrocode}
\tlp_new:N \g_xor_this_class_tlp
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\g_xor_this_areas_open_clist}
% \begin{macro}{\g_xor_saved_this_areas_open_clist}
%    In |\g_xor_this_areas_open_clist| we store the float areas in which we will try
%    to place a float onto the current page. These areas are tried one
%    after another until the float is successfully placed or we run
%    out of areas. The list does not have any separator (as we assume
%    that all areas are denoted by a letter followed by two digits).
%
%    |\g_xor_saved_this_areas_open_clist| is the saved version needed for
%    backtracking if we encounter a flush point that can't be resolved.
%    \begin{macrocode}
\clist_new:N \g_xor_this_areas_open_clist
\clist_new:N \g_xor_saved_this_areas_open_clist
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_this_areas_closed_clist}
%    In |\g_xor_this_areas_closed_clist| we store the float areas which have been
%    closed for the current float while trying to place it. In this
%    list each area name is followed by a comma (to avoid spurious
%    matches). It is initialised with
%    |\g_xor_class_ \g_xor_this_class_tlp _areas_closed_clist| when
%    we fetch a new float to try. Once the float is placed we write
%    the then current value back.
%    \begin{macrocode}
\clist_new:N \g_xor_this_areas_closed_clist
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_curr_page_areas_closed_clist}
%    In |\g_xor_curr_page_areas_closed_clist| we store the float areas which have been
%    closed for all float types. In this list each area name is
%    followed by a comma (to avoid spurious matches).
%    \begin{macrocode}
\clist_new:N \g_xor_curr_page_areas_closed_clist
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\g_xor_area_t11_float_int}
% \begin{macro}{\g_xor_area_t21_float_int}
% \begin{macro}{\g_xor_area_b11_float_int}
% \begin{macro}{\g_xor_area_b21_float_int}
%    The float counts are allocated dynamically when an area is
%    declared if they are not defined, but we have a few registers
%    left over from \LaTeX{}'s old OR so we might as well use them.
%    \begin{macrocode}
%\int_new:c {g_xor_area_t11_float_int}
%\int_new:c {g_xor_area_b11_float_int}
%\int_new:c {g_xor_area_t12_float_int}
%\int_new:c {g_xor_area_b12_float_int}
\let:cN {g_xor_area_t11_float_int} \@topnum
\let:cN {g_xor_area_b11_float_int} \@botnum
\let:cN {g_xor_area_t12_float_int} \@dbltopnum
\let:cN {g_xor_area_b12_float_int} \@dblbotnum
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\g_xor_area_DDD_float_int}
%    And we need to declare the one for the defer area is that isn't
%    going through the normal initialisation process.
%    \begin{macrocode}
\int_new:N \g_xor_area_DDD_float_int
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\g_xor_float_area_skip}
%    |\g_xor_float_area_skip| is the separation to use between two
%    adjacent float areas.
%    \begin{macrocode}
\skip_new:N \g_xor_float_area_skip
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_float_text_skip}
%    |\g_xor_float_text_skip| is the separation to use between
%    column text and adjacent float areas.
%    \begin{macrocode}
%\skip_new:N \g_xor_float_text_skip
\let:NN \g_xor_float_text_skip \textfloatsep % reuse register
\let:NN \textfloatsep \c_undefined
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_float_float_skip}
%    |\g_xor_float_float_skip| is the separation to use between
%    two floats in the same float area.
%    \begin{macrocode}
%\skip_new:N \g_xor_float_float_skip
\let:NN \g_xor_float_float_skip\floatsep % reuse register
\let:NN \floatsep \c_undefined
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_float_text_shrink_dim}
%    |\g_xor_float_text_shrink_dim| is the allowed shrinkability of
%    |\g_xor_float_text_skip|. This is used if we are doing grid
%    typesetting and have to adjust the vertical size of the column.
%    \begin{macrocode}
\dim_new:N \g_xor_float_text_shrink_dim
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\g_xor_float_inline_skip}
%    |\g_xor_float_inline_skip| is the separation to use between
%    two floats in the same float area.
%    \begin{macrocode}
%\skip_new:N \g_xor_float_inline_skip
\let:NN \g_xor_float_inline_skip\intextsep % reuse register
\let:NN \intextsep \c_undefined
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_float_inline_shrink_dim}
%    |\g_xor_float_inline_shrink_dim| is the allowed shrinkability of
%    |\g_xor_float_inline_skip|. This is used if we are doing grid
%    typesetting and have to adjust the vertical size of object to be
%    added, e.g., an inline float with its caption.
%    \begin{macrocode}
\dim_new:N \g_xor_float_inline_shrink_dim
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \subsubsection{Utilities for Float Areas and their Data Structures}
%
%
% \begin{macro}{\xor_area_setup:}
%    Initialise all float areas used within the current page setup.
%    \begin{macrocode}
\def_new:Npn \xor_area_setup: {
  \clist_map_inline:Nn
      \g_xor_areas_used_clist
      {
        \int_gzero:c  {g_xor_area_ ##1 _float_int}
        \seq_gclear:c {g_xor_area_ ##1 _seq}
      }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_flseq_returned_num}
%    \begin{macrocode}
\num_new:N \g_xor_flseq_returned_num
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_this_area_setup:o}
%
%   Whenever the algorithm works with some area as the current
%   candidate for putting a float into it uses the following commands
%   to reference this area:
%
% \DescribeMacro\g_xor_this_area_tlp
%   The macro |\g_xor_this_area_tlp| holds the name of the candidate area, e.g.,
%   it would expand to something like |t13|.
%
% \DescribeMacro\g_xor_this_area_type_tlp
%   The macro |\g_xor_this_area_type_tlp| holds the ``type'' of the area, e.g., |t|
%   in the above example.
%
% \DescribeMacro\g_xor_this_area_col_tlp
%   The macro |\g_xor_this_area_col_tlp| holds the starting column of the
%   area, e.g., |1| in the above example.
%
%
% \DescribeMacro\g_xor_this_area_span_tlp
%   The macro |\g_xor_this_area_span_tlp| holds the number of columns
%   spanned by the  area, e.g., |3| in the above example.
%
%    All the above macros are globally assigned when calling
%    |\xor_this_area_setup:o|. The argument is expanded (!) once since one
%    typical usage is to pick up the first area from an area like
%    |\g_xor_this_areas_open_clist| and pass a token list pointer as
%    the argument. If the area name is passed directly this doesn't
%    really hurt
%
%    \begin{macrocode}
\def_new:Npn \xor_this_area_setup:o #1 {
  \tlp_gset:No \g_xor_this_area_name_tlp {#1}
%    \end{macrocode}
%    This really relies on |\g_xor_this_area_name_tlp| containing exactly three
%    tokens (no error recovery if not).
%    \begin{macrocode}
%\show\g_xor_this_area_name_tlp
  \exp_after:NN\xor_gassign_area_type_col_and_span_aux:nnn
               \g_xor_this_area_name_tlp
}
\def_new:Npn \xor_gassign_area_type_col_and_span_aux:nnn #1#2#3{
  \gdef:Npn \g_xor_this_area_type_tlp {#1}  % type
  \gdef:Npn \g_xor_this_area_col_tlp  {#2}  % col
  \gdef:Npn \g_xor_this_area_span_tlp {#3}  % span
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\l_xor_update_col_int}
%    Local counter used in loops over columns.
%    \begin{macrocode}
\int_new:N \l_xor_update_col_int
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_update_this_area_span_cols:n}
%
%    If we have to do updates for all columns that are spanned by the
%    current target area we can call |\xor_update_this_area_span_cols:n|. It
%    loops through the columns (backwards!) with |\l_xor_update_col_int|
%    referring to the current
%    column. Data structure updates have to be global as everything
%    happens within a group.
%    \begin{macrocode}
\def_new:Npn \xor_update_this_area_span_cols:n #1 {
  \group_begin:
    \int_set:Nn \l_xor_update_col_int \g_xor_this_area_col_tlp
    \int_add:Nn \l_xor_update_col_int \g_xor_this_area_span_tlp
    \int_whiledo:nNnT \g_xor_this_area_col_tlp < \l_xor_update_col_int
    {
      \int_decr:N \l_xor_update_col_int
%<*trace>
      \trace:n{looking~ at~ column:~ \int_use:N \l_xor_update_col_int}
%</trace>
      #1
    }
  \group_end:
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \newpage
% \subsection{Collection Output Routine}
%
% \begin{description}
% \item[Entry:]  |\xor_collect_setup:|
% \item[Exit:]   |\xor_trial_place_float_setup:|
% \item[Prereq:] |\xor_next_page_setup:| should have been called before.
% \item[Description:] Grab enough text (and float call-outs) to obtain
%    a galley big enough to form the next text page. The page goal is
%    set to a value high enough to ensure that in normal cases text
%    for all columns of the page is collected, i.e, we have a safety
%    margin of 5 extra lines per column.\footnote{This should be made
%    customisable for unusual jobs!}
%
%    If the output routine is triggered with a special penalty (in the
%    range of $-10000>p>=-10009=|\c_xor_output_balance_penalty|$) the penalty
%    is moved into the collection box |\g_xor_partial_mvl_box| without
%    further processing; otherwise the collection is ended and all
%    collected material is moved to |\g_xor_hold_page_box| for use in page
%    production.
%
% \item[Flow:]
%\begin{footnotesize}
%\begin{verbatim}
%   \xor_collect_setup:
%           |
%           V
%  New OR: \xor_OR_collect:
%           |
%           |<-----------------------------------------
%           |                                         |
%  (natural end of collection reached?)               |
%           |           |                             |
%          yes          no                            |
%           |           |                             |
%           | (record special penalty and carry on)----
%           |
%           V
%   \xor_trial_place_float_setup:
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
% \begin{macro}{\xor_collect_setup:}
%    \begin{macrocode}
\def_new:Npn \xor_collect_setup:{
%<*trace>
  \trace_push:n{xor_collect_setup:}
%</trace>
  \int_gset:Nn \holdinginserts \c_one
%    \end{macrocode}
%    We set the |\vsize| for collection to the height of a single
%    column (plus a safety margin of currently five lines to allow for
%    vanishing space at margins) multiplied by the number of columns.
%    \begin{macrocode}
  \dim_gset:Nn \vsize { \dim_eval:n{\textheight + 5\baselineskip} }
  \dim_gset:Nn \vsize {\int_use:N \g_xor_cols_int \vsize}
%<*trace>
  \trace:n{collection~vsize:~\dim_use:N \vsize }
%</trace>
%    \end{macrocode}
%    Initialising the flush point handling:
%    \begin{macrocode}
  \bool_gset_false:N \g_xor_flush_seen_bool
  \bool_gset_false:N \g_xor_flush_failed_bool
%    \end{macrocode}
%    We may have to restart the collection (whenever we find a here or
%    a flush point) and we don't want to get extra space added via
%    |\topskip|. So we can either make |\topskip| zero during
%    collection (current strategy) or back it out whenever we restart.
%
%    We can't set topskip to zero now since a) we want a proper
%    |\topskip| for the first column and b) due to a bloody fix for the
%    old \LaTeX{} OR, a value of |0pt| is set to |1sp| in
%    |\begin{document}| and this results in adding |1sp| at every
%    special point\ldots no, we definitely do not want this! It took
%    me ages to find out why the grid design macros didn't work.
%    \begin{macrocode}
  \tlp_gset:Nx \g_xor_saved_topskip_tlp {\the\topskip}
%    \end{macrocode}
%
%    Free up the space still taken up by |\g_xor_hold_page_box| (as
%    its was always copied---could probably done earlier).
%    \begin{macrocode}
  \box_gclear:N \g_xor_hold_page_box
%    \end{macrocode}
%
%    \begin{macrocode}
  \global\output{\xor_OR_collect:}
%<*trace>
  \trace_pop:n{xor_collect_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\g_xor_collect_new_stuff_bool}
%    There are actually two collecting modes: one when the recent
%    contributions are empty and we are really collecting material
%    that we haven't seen before and one where we collect material
%    that has been collected on a previous collection pass and has been
%    placed again on to the main vertical list. The reason why we need
%    to differentiate between the two is that in the second case we
%    have to handle the special penalties differently since by now
%    they are already surrounded by the proper guard boxes before and
%    after and we better do not disturb this fragile setup.
%    \begin{macrocode}
\bool_new:N \g_xor_collect_new_stuff_bool
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_OR_collect:}
%    The output routine during the collection phase assembles the
%    material until enough has been gathered to be sure to fill a
%    page.
%    \begin{macrocode}
\def_new:Npn \xor_OR_collect:{
%<*trace>
  \trace_push:n{xor_OR_collect:}
  \trace:n{output~pen:~ \the\outputpenalty}
%{\x\showoutput\showbox255}
%</trace>
%    \end{macrocode}
%    We first look if the call to the OR is due to a special penalty.
%    \begin{macrocode}
  \@testfalse
  \predicate:nT {
     \int_compare_p:nNn \outputpenalty < {-\c_ten_thousand} &&
     \int_compare_p:nNn \outputpenalty > {-\c_xor_output_collect_penalty} 
      % might need special value here
  }
  { \@testtrue }
  \if@test
%<*trace>
    \trace:n{Forced~ break~(\the\outputpenalty)~ seen\on@line}
%</trace>
%    \end{macrocode}
%    Whenever a special penalty, i.e., one between $-10000 > p >
%    -10010$\footnote{FIX docu} is encountered we need some magic:
%    \begin{itemize}
% \item We want to keep the the penalty in the collected material but
%      nevertheless carry on with the collection. Simply moving the
%      collected material to a separate box is not enough since then
%      we will restart the collection with an empty page and thus
%      receive a |\topskip| glue as well as probably losing material
%      if there is anything discardable after the special penalty.
% \item But putting a zero box back and doing something to fix the
%      problem with the  |\topskip| glue isn't good either in case we
%      later actually want to break after the line with special
%      penalty, since then we would start a page with our inserted
%      box, and in this case we would like to get a proper |\topskip|
%      and we would like to get rid of discardable stuff.
% \item And there is another problem, we need a guard box in front of
%      that special penalty, but this guard box should not be simply a
%      |\null| box (as it is right now added by
%      |\xor_add_badly_guarded_penalty:N|) since that will result in wrong
%      page calculations because it will make \TeX{} add the depth of
%      the precious line to the page total which it shouldn't.
%    \end{itemize}
%    So what to do? First of all we remove the guard box in front of
%    the special penalty (which is now at the end of box 255) since we
%    want to replace that with something better, then we
%    store away the depth of box 255 since we need that in a minute.
%    \begin{macrocode}
    \xor_remove_guard_box_from_cclv:
%    \end{macrocode}
%    We really have to say |\box_dp:N\c_twohundred_fifty_five| not |\pagedepth|. The latter is
%    always zero in the OR which looks suspiciously like a bug or at
%    least an inconsistency when Don implemented the change from \TeX2
%    to \TeX3 (in \TeX2 |\page...| registers were useless in the OR,
%    now only |\pagedepth| seems to be left).
%    \begin{macrocode}
    \dim_set:Nn \l_tmpa_dim {\box_dp:N\c_twohundred_fifty_five}
%    \end{macrocode}
%    Then we subtract the size of the collected material from
%    |\vsize| since we will store it away in a separate box for a
%    while. Note that we have to use |\box_ht:N\c_twohundred_fifty_five| here not |\pagetotal|
%    since the latter might be too large because of that |\null|
%    box. The height of 255 on the other hand is, after the removal of
%    that box the natural height of the material.
%    \begin{macrocode}
    \dim_gsub:Nn \vsize {\box_ht:N\c_twohundred_fifty_five}
%    \end{macrocode}
%    Now we append the material to |\g_xor_partial_mvl_box|, this is
%    straight forward.
%    \begin{macrocode}
    \vbox_gset:Nn \g_xor_partial_mvl_box
    {
      \box_if_empty:NF \g_xor_partial_mvl_box
          { \vbox_unpack_clear:N\g_xor_partial_mvl_box }
      \vbox_unpack_clear:N\c_twohundred_fifty_five
%    \end{macrocode}
%    But how to add the penalty and how to guard it? We need a box or
%    something to ensure the penalty doesn't get lost at a column
%    break but we also want to avoid that \TeX{} adds the depth of the
%    preceding line to |\pagetotal|. Fortunately we know this depth by
%    now (we have just stored it in |\l_tmpa_dim|), something we didn't
%    know at the time the we added the penalty with
%    |\xor_add_badly_guarded_penalty:N|. So we could back up and then add a
%    box with zero height and that depth. This way a break directly
%    after this line would have the same |\pagetotal| as a break at
%    the special penalty. In fact, instead of backing up using a
%    |\kern| or a |\vskip| we can simply make the height of the box
%    negative. The advantage is that this way we don't generate a
%    break point between the box and a preceding box and thus don't
%    have to use special precautions to prevent \TeX{} from breaking in
%    front of the guard box.\footnote{This statement is only true for
%    special penalties added using \texttt{\string\vadjust}, i.e., in
%    hmode. If the penalty was added between paragraphs then there
%    might be vertical space in front of the box. This might need
%    special handling too. CHECK!}
%    \begin{macrocode}
      \vbox_set_to_ht:Nnn \c_zero {-\l_tmpa_dim}{}
      \box_dp:N\c_zero\l_tmpa_dim
      \box_use_clear:N\c_zero
      \penalty\outputpenalty
    }
%{\showoutput\batchmode\showbox\g_xor_partial_mvl_box\errorstopmode}
%    \end{macrocode}
%    So now we have put everything we need into the
%    |\g_xor_partial_mvl_box|, but how do we restart our collection
%    process without running into the problems outlined above?
%
%    Well, right now on the recent contributions there will be a
%    penalty node (from our special penalty) which gets set to 10000
%    by \TeX{} followed perhaps by another penalty from the line
%    breaking followed probably by interline glue calculated to make
%    the next line of text fit vertically with the preceding one ---
%    and we don't want to loose that that glue if we are ending up in
%    the middle of a column. But we want to make it vanish if we
%    happen to finally break at the special penalty place.
%
%    So the trick is that we a) disable |\topskip| by setting it to
%    |-\maxdimen| (not zero this might be too large still) and b) we
%    add another of those funny boxes followed by a penalty of zero to
%    allow for a break after it.
%
%    If later on all this is put together again into a single box (in
%    |\g_xor_hold_page_box|) we will have the following sequence there:
%    \begin{itemize}
% \item text line (box) preceding the special penalty with depth $d$
%      or some other vertical material in which case $d=0\texttt{pt}$
% \item special box with height $-d$ and depth $d$
% \item special penalty, e.g. $-10008$
% \item |\topskip| glue of 0pt
% \item special box with height $-d$ and depth $d$
% \item |\penalty| 0
% \item |\penalty| 10000
% \item perhaps a |\penalty| and/or interline glue
% \item perhaps the next text line (box)
%    \end{itemize}
%    Now if during later processing we hit the special penalty
%    |\pagetotal| has the same value as if we would have broken the
%    galley directly after the text line, in other words we do not see
%    the penalty too late (assume this happens to be the last line of
%    the column then if |\pagetotal| would also have the extra depth
%    added to it it might have been overfull and the penalty not being
%    considered at all for this column).
%
%    After the OR's have dealt with the special penalty, e.g., by
%    flushing some floats, etc. the penalty will be replaced by 10000
%    and thus the next time the galley is processed there is no
%    breakpoint between the two special boxes any more. As a result
%    the next potential breakpoint is the penalty 0 which again
%    results in exactly the same |\pagetotal| as before, i.e., if the
%    text line was the last line to fit in the column then this
%    breakpoint will still fit there. Thus if we break the column
%    there then the interline glue etc will vanish and \TeX{} will
%    insert |\topskip| glue (which has be set back to a normal value
%    by then). If on the other hand, this break point is not chosen
%    the interline glue will stay and thus the two text lines, before
%    and after the special penalty will sit one |\baselineskip| apart
%    just as they should.
%
%    Woah. What did Don said on page 125 of \textit{The \TeX{}book}?
%    (Deep breath.) You got that?\footnote{There are probably still
%    cases that aren't covered I fear and the need for an explicit
%    penalty 0 at the end is kind of toublesome, so we have to see if
%    this needs further refinements.}
%
%    And here is already the first case where the above method is not
%    appropriate: if we stumble across a |\c_xor_output_columnbreak_penalty|
%    or |\c_xor_output_balance_penalty|
%    we need to discard any following glue, so we don't want a box
%    intervene here.\footnote{Once this is interfaced with the galley
%    code problems like this should vanish since then we can ensure
%    that all such penalties are added to the galley on at save
%    places. REDO THEN!}
%
%    And the same is true for |\c_xor_output_balance_penalty|!
%    \begin{macrocode}
    \skip_gset:Nn \topskip {-\c_max_skip}  %  okay here?
%
% CHECK following code doesn't work ... alternate below does
%
%    \prg_if_predicate:nT {
%        \bool_if_p:N \g_xor_collect_new_stuff_bool
%         &&
%        \prg_if_predicate_not_p:n {\int_compare_p:nNn \outputpenalty 
%                                  {-\c_xor_output_columnbreak_penalty}} 
%         &&
%        \prg_if_predicate_not_p:n {\int_compare_p:nNn \outputpenalty 
%                                       = {-\c_xor_output_balance_penalty}}
%      }
%    }
%
%    \end{macrocode}
%    If the current penalty is a column or a balancing penalty, we do not want
%    any box after it as here we know that we are starting a new column and
%    should not hinder any glue following to vanishin in the break.
%    \begin{macrocode}
    \bool_if:NT \g_xor_collect_new_stuff_bool
      { 
        \int_compare:nNnF  \outputpenalty = {-\c_xor_output_columnbreak_penalty}
           { \int_compare:nNnF \outputpenalty = {-\c_xor_output_balance_penalty}
                {
                 \vbox_set_to_ht:Nnn \c_zero {-\l_tmpa_dim}{}
                 \box_dp:N\c_zero\l_tmpa_dim
                 \box_use_clear:N\c_zero
                 \penalty\c_zero
                }
           }
      }
%    \end{macrocode}
%
%    \begin{macrocode}
    \int_compare:nNnT \outputpenalty = {-\c_xor_output_flush_float_penalty}
       {
%<*trace>
        \trace:n{Forced~ break~ =~ flush~ float~ point}
%</trace>
        \bool_gset_true:N \g_xor_flush_seen_bool
       }
%    \begin{macrocode}
    \int_compare:nNnT \outputpenalty = {-\c_xor_output_balance_penalty}
      {
%<*trace>
       \trace:n{BALANCE:~ break~ seen\on@line}
%</trace>
      }
%    \end{macrocode}
%    Otherwise either the we reached the natural end of the
%    collection, or the point where we have been before (in case we
%    are recollecting previously seen material).
%    \begin{macrocode}
  \else: % belongs to \if@test way, way up
    \int_compare:nNnTF \outputpenalty = {-\c_xor_output_collect_penalty}
     {
%    \end{macrocode}
%    If we got an |-\c_xor_output_collect_penalty| then we are at the point
%    to which the previous collection pass got. So, away with the
%    guard box, then everything back onto the MVL and as a penalty we
%    try to put what we have found in the previous collection pass.
%    \begin{macrocode}
      \xor_remove_guard_box_from_cclv:
      \vbox_unpack_clear:N\c_twohundred_fifty_five
%    \end{macrocode}
%    In this particular case we also have to reset the |\deadcycles|
%    to zero since otherwise we will produce an infinite loop in some
%    cases. Why? Because the guard box may have been the only thing
%    left on the recent contributions followed so after the above
%    lines the recent contributions are empty, but by then
%    |\deadcycles| would be |1| so a final |\tex_end:D| in the
%    document (e.g., from |\stop| or |\end{document}|) would insert an
%    empty box and a |\filll| generating column after column \ldots
%    (see \TeX book page 264).
%    \begin{macrocode}
      \int_gzero:N \deadcycles
%<*trace>
      \trace:n{reinsert~penalty:~ \g_xor_saved_output_penalty_tlp \space
        (unless~ 10000~ or~ <~ -9999)}
%</trace>
      \int_compare:nNnTF \g_xor_saved_output_penalty_tlp > {-\c_ten_thousand}
       {
        \int_compare:nNnTF \g_xor_saved_output_penalty_tlp =\c_ten_thousand
           { \penalty \c_zero }
           { \penalty \g_xor_saved_output_penalty_tlp \scan_stop: }
%    \end{macrocode}
%    We have a special situation to account for here: if we have a
%    |\pagebreak| that ended the collection last time then it might
%    still be the case that we haven't got to this point due to
%    floats. So we would need to put that penalty back. But only then,
%    and therese the catch!  The alternative is to not stop a
%    collection as such a point so that this problem doesn't arise in
%    the first place. Right now we lose the
%    penalty.\footnote{Unresolved situation. FIX!}
%    \begin{macrocode}
       }
       {     }
%    \end{macrocode}
%    Finally we change the |\g_xor_collect_new_stuff_bool| switch since we
%    are from now on looking at really new material.
%    \begin{macrocode}
      \bool_gset_true:N \g_xor_collect_new_stuff_bool
     }
     {
%    \end{macrocode}
%    This is now the point where the collection ended naturally: we
%    save the penalty that triggered it and combine the
%    |\g_xor_partial_mvl_box| if it contains material with the stuff now
%    in 255 and put everything into |\g_xor_hold_page_box|.
%    \begin{macrocode}
      \tlp_gset:Nx \g_xor_saved_output_penalty_tlp {\the\outputpenalty}
%<*trace>
        \trace:n{CHECK:~ Saving~ output~ penalty~ (\the\outputpenalty)}
%</trace>
      \box_if_empty:NTF \g_xor_partial_mvl_box
      { \box_gset_eq:NN \g_xor_hold_page_box \c_twohundred_fifty_five }
      {
%<*trace>
        \trace:n{Re-adding~ forced~ break(s)~ for~ splitting}
%</trace>
        \vbox_gset:Nn \g_xor_hold_page_box
        {
          \vbox_unpack_clear:N\g_xor_partial_mvl_box
          \vbox_unpack_clear:N\c_twohundred_fifty_five
        }
      }

%\showbox\g_xor_hold_page_box

      \xmark_save_state:
      \xmark_update_structure

      \int_gzero:N \holdinginserts

      \skip_gset:Nn \topskip \g_xor_saved_topskip_tlp

      \xor_trial_place_float_setup:

      \bool_gset_false:N \g_xor_collect_new_stuff_bool
    }
  \fi: % end of \if@test
%<*trace>
  \trace_pop:n{xor_OR_collect:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_partial_mvl_box}
%    Need a box to store the partially collected galley.
%    \begin{macrocode}
\box_new:N \g_xor_partial_mvl_box
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_hold_page_box}
%    Need a box to temp store the fully collected galley.
%    \begin{macrocode}
%\box_new:N\g_xor_hold_page_box
\let:NN \g_xor_hold_page_box \@holdpg
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\xor_float_class_setup:n}
%
%    \begin{macrocode}
\def_new:Npn \xor_float_class_setup:n #1 {
%<*trace>
  \trace_push:n{xor_float_class_setup:n}
%</trace>
  \count@0\LastMark{#1}
%<*trace>
  \trace:n{count~ (#1) = \int_use:N \count@}
%</trace>
%    \end{macrocode}
%
%    Check: the close list should probably not be made empty but
%    initialised with all areas not on the allowed list!\footnote{FIX}
%    \begin{macrocode}
  \clist_gclear:c {g_xor_class_ #1 _areas_closed_clist}
%    \end{macrocode}
%
%    what is the meaning of the "allowed" floats doesn't seem to be used
%    anywhere these days\footnote{check and fix}
%    \begin{macrocode}
%<*trace>
%  \trace:n{allowed~ (#1) = \clist_use:c{g_xor_class_ #1 _areas_allowed_clist}}
  \trace:n{closed~ (#1) = \clist_use:c{g_xor_class_ #1 _areas_closed_clist}}
%</trace>
%    \end{macrocode}
%
%    |\g_xor_flseq_type_figure_col_1_num| are macros that expands to the highest numbered
%    figure callout in this column (or zero if there is none).
%    |\g_xor_flseq_type_figure_col_0_num| is the highest value from
%    previous pages (or zero
%    if there was never any float of this type).
%    \begin{macrocode}
  \xor_forall_columns:n {
    \int_compare:nNnT
      { \num_use:c {g_xor_flseq_type_#1_col_ \int_use:N\g_xor_curr_col_int _num }} 
      > \c_zero
    {
      \num_gset_eq:cc {g_xor_flseq_type_#1_col_0_num}
                      {g_xor_flseq_type_#1_col_ \int_use:N\g_xor_curr_col_int _num}
      \num_gset:cn
                  {g_xor_flseq_type_#1_col_ \int_use:N\g_xor_curr_col_int _num}{0}
    }
%    \end{macrocode}
%    |\g_xor_flseq_areas_top_type_figure_col_1_num| is like \\
%    |\g_xor_flseq_type_figure_col_1_num| but only stores
%    information about floats allocated to top areas.
%    \begin{macrocode}
    \num_gzero:c {g_xor_flseq_areas_top_type_#1_col_
                  \int_use:N\g_xor_curr_col_int _num}
  }
%<*trace>
  \trace_pop:n{xor_float_class_setup:n}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \newpage
%
% \subsection{Placing Floats}
%
%
% \begin{description}
% \item[Entry:] |\xor_trial_place_float_setup:|
% \item[Exit:]  |\xor_OR_trial_grab_cols_setup:| or
%               |\xor_OR_best_cols_setup:|
% \item[Prereq:]
% \item[Description:]
% \item[Flow:]
%\begin{footnotesize}
%\begin{verbatim}
%      \xor_trial_place_float_setup:
%      (initialisation for all trials)
%           |
%           V
%(2)--> \xor_trial_place_float_loop:
%       (return collected material to galley)
%           |
%       <run with floats?>
%           |      |
%          yes     no----------> \xor_OR_trial_grab_cols_setup:
%           |
%           V
%       \xor_trial_place_float_inner_loop:
%           |
%           V
%   <current float successfully placed in previous trial?>
%      |                                     |
%     no                                    yes
%      |                                     |
%  (means we now try                         V
%   again using different             \xor_try_next_float:  <--------------
%   placement rules below )                  |                            |
%      |                                     |                            |
%      |                     <\g_xor_floats_active_seq empty?>            |
%      |                             |               |                    |
%      |                            no              yes                   |
%      |                             |               |                    |
%      |                             |               V                    |
%      |                          (get it) \xor_floats_active_seq_if_empty_action:
%      |                             |       (= \xor_OR_best_cols_setup:) |
%      -------------v----------------                                     |
%                   |                                                     |
%   -----> \xor_try_this_area: (= \xor_try_this_area_std:, or             |
%   |               |             \xor_try_this_area_relaxed:)            |
%   |               |                                                     |
%   |  <still open areas for current float type?>                         |
%   |         |                |                                          |
%   |        yes               no---------------(defer float)--------------
%   |         |                                                           |
%   |  (do some tests and perhaps                                         |
%   |    close area this way)                                             |
%   |         |                                                           |
%   |  <float allowed on this page/column (according to tests)?>          |
%   |         |                |                                          |
%   |        yes               no---------------(defer float)--------------
%   |         |
%   |   <current area got closed by any test?>
%   |      |                 |
%   |     yes                no
%   |      |                 |
%   | (select next area)     |
%   |      |                 |
%   --------                 V
%                 \pretests@success@action (\xor_OR_trial_grab_cols_setup:)
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%
%
%
%
% \begin{macro}{\g_xor_trial_failed_bool}
%    \begin{macrocode}
\bool_new:N \g_xor_trial_failed_bool
%    \end{macrocode}
% \end{macro}
%
%

% \begin{macro}{\xor_trial_place_float_setup:}
%
%    \begin{macrocode}
\def_new:Npn \xor_trial_place_float_setup: {
% initialise before trial loop (needs work)
%<*trace>
  \trace_push:n{xor_trial_place_float_setup:}
%</trace>
%    \end{macrocode}
%    A bit statistics: how many floats do we have on the
%    |\g_xor_floats_active_seq|?
%    \begin{macrocode}
%<*progress>
  \seq_map_inline:Nn
      \g_xor_floats_active_seq
      {\num_gincr:N\g_xor_trials_done_num}
  \xor_progress_newline:n{STATS:~ floats~ waiting~ =~ \num_use:N\g_xor_trials_done_num
        \space on~ page~ \num_use:N \g_xor_page_absolute_num}
  \xor_progress_separator:
  \num_gzero:N \g_xor_trials_done_num
%</progress>
%    \end{macrocode}
%    We need the list of here floats during all trials. They are
%    therefore saved in |\g_xor_saved_floats_here_seq| at this point which is then
%    used to initialise |\g_xor_floats_here_seq| at the beginning of each trial.
%    \begin{macrocode}
  \glet:NN \g_xor_saved_floats_here_seq \g_xor_floats_here_seq
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_tighten_float_placement_conditions:

  \num_gzero:N \g_xor_trial_balance_done_num
  \trace:n{BALANCE:~ g_xor_trial_balance_done_num ~<-~
                    \num_use:N \g_xor_trial_balance_done_num}
%    \end{macrocode}
%    First time we run the |\xor_trial_place_float_loop:| we run it without
%    actually trying any floats (i.e., we are just cutting the
%    galley).\footnote{Could be improved: if there are no floats then
%    we run it once too often this way (per page) so\ldots}
%    \begin{macrocode}
  \bool_gset_false:N \g_xor_trial_with_floats_bool
  \xor_trial_place_float_loop:
%<*trace>
  \trace_pop:n{xor_trial_place_float_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_trial_place_float_loop:}
%    Place the galley box back on the MVL. Needs to be done via the
%    special output routine call |\xmark_OR_restore_state:n| to ensure that
%    \TeX's primitive marks reflect the `logical' previous page rather
%    than the previous actual output routine call.
%    \begin{macrocode}
\def_new:Npn \xor_trial_place_float_loop: {
%<*trace>
  \trace_push:n{xor_trial_place_float_loop:}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_gzero:N \deadcycles
  \glet:NN \xor_floats_active_seq_if_empty_action: \xor_OR_best_cols_setup:
  \glet:NN \pretests@success@action \xor_OR_trial_grab_cols_setup:
%    \end{macrocode}
%
%    |\xmark_OR_restore_state:n| state is a special output routine those
%    only purpose is to reinitialise the state of the mark
%    mechanism. Its argument is executed at the of that OR and must
%    (!) set up a new OR else we find ourselves in trouble.
%    \begin{macrocode}
  \xmark_OR_restore_state:n
  {
%    \end{macrocode}
%    Initialising the grabbing trials means putting the saved material
%    back onto the MVL and reinitialising the here float list.
%    \begin{macrocode}
    \vbox_unpack:N\g_xor_hold_page_box
%    \end{macrocode}
%    To be able to identify the end of the material for trials or for
%    cutting the galley we mark it with a special penalty.
%    \begin{macrocode}
    \xor_add_badly_guarded_penalty:N \c_xor_output_collect_penalty 
    \glet:NN \g_xor_floats_here_seq \g_xor_saved_floats_here_seq
%    \end{macrocode}
%
%    The we can start the actual loop: if we run with floats we go to \\
%    |\xor_trial_place_float_inner_loop:| otherwise we immediately set up the grab
%    column OR.
%    \begin{macrocode}
    \bool_if:NTF \g_xor_trial_with_floats_bool
    { \xor_trial_place_float_inner_loop: }
    { \xor_OR_trial_grab_cols_setup:     }
  }
%<*trace>
  \trace_pop:n{xor_trial_place_float_loop:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_trial_place_float_inner_loop:}
%    Alternative entry into the float placement trial loop. This can
%    be used by setting |\@activelist@empty@action| and
%    |\pretests@success@action| to different values, e.g., for trying
%    float pages without the overhead of the grabcolumn output
%    routine, etc.
%    \begin{macrocode}
\def_new:Npn \xor_trial_place_float_inner_loop:{
%<*trace>
  \trace_push:n{xor_trial_place_float_inner_loop:}
%</trace>
%    \end{macrocode}
%    If |\if_xor_trial_failed:| is true we have already tried the current float
%    before. This means we either do a retry with relaxed conditions
%    (in which case the current area to try was suitably modified
%    beforehand) or else we have just started with a new float and
%    should try the first area of |\g_xor_this_areas_open_clist|.
%    \begin{macrocode}
  \bool_if:NTF \g_xor_trial_failed_bool
  {
    \bool_gset_false:N \g_xor_trial_failed_bool
    \bool_gset_false:N \g_xor_flush_failed_bool
%    \end{macrocode}
%
%    \begin{macrocode}
%<*progress>
    \num_gincr:N \g_xor_trials_done_num
%</progress>
%    \end{macrocode}
%
%    \begin{macrocode}
    \xor_do_next:N \xor_try_this_area:
  }
  { \xor_do_next:N \xor_try_next_float: }
%<*trace>
  \trace_pop:n{xor_trial_place_float_inner_loop:}
%</trace>
  \xor_continue:
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_trials_done_num}
%    To gather statistics we count the number of trials per page.
%    \begin{macrocode}
%<*progress>
\num_new:N \g_xor_trials_done_num
%</progress>
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_try_this_area:}
%    |\xor_try_this_area:| is |\let:NN| to the right definition before it is
%    called (either |\xor_try_this_area_std:| or |\xor_try_this_area_relaxed:|)
%    so on top-level it is defined to be an error.
%    \begin{macrocode}
\let_new:NN \xor_try_this_area: \ERROR
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_try_next_area:}
%    |\xor_try_next_area:| first updates |\g_xor_this_areas_open_clist| by removing the
%    first area in this list and then calls |\xor_try_this_area:|. Thus it
%    should never be called if |\g_xor_this_areas_open_clist| is already empty.
%    \begin{macrocode}
\def_new:Npn \xor_try_next_area:{
  \clist_gpop:NN \g_xor_this_areas_open_clist \l_tmpa_tlp
%<*progress>
  \num_gincr:N \g_xor_trials_done_num
%</progress>
  \xor_try_this_area:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_curr_float_box_tlp}
%    Pointer to the float box that is currently under investigation.
%    \begin{macrocode}
\tlp_new:Nn \g_xor_curr_float_box_tlp {\ERROR}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_try_next_float:}
%    If there is still a float on the active list take it and try to
%    place it in the next open float area (which will be the same as
%    the current area after a successful trial). If there are no
%    floats left execute |\xor_floats_active_seq_if_empty_action:|.
%
% Leftover comment:\footnote{FIX}
%     to return to that state then
%    switch to the bestcolumn output routine to begin typesetting
%    columns.
%    \begin{macrocode}
\def_new:Npn \xor_try_next_float: {
%<*trace>
  \trace_push:n{xor_try_next_float:}
%</trace>
  \xor_gpop_float:NNTF
     \g_xor_floats_active_seq
     \g_xor_curr_float_box_tlp
     {
%<*trace>
      \trace:n{currbox:~ \g_xor_curr_float_box_tlp}
%</trace>
%<*progress>
      \xor_progress:n{Float:~ \g_xor_curr_float_box_tlp}
%</progress>
      \xor_extract_this_float_values:N \g_xor_curr_float_box_tlp
%<*trace>
      \trace:n{g_xor_saved_this_areas_open_clist~(init):~
       \g_xor_saved_this_areas_open_clist\space :=~\g_xor_this_areas_open_clist}
%</trace>
      \tlp_gset_eq:NN \g_xor_saved_this_areas_open_clist\g_xor_this_areas_open_clist
%<*progress>
      \num_gincr:N \g_xor_trials_done_num
%</progress>
      \xor_try_this_area:
     }
%    \end{macrocode}
%     no floats left\ldots
%    \begin{macrocode}
     {
%<*progress>
      \xor_progress_newline:n {STATS:~ trials~ =~ \num_use:N\g_xor_trials_done_num}
      \num_gzero:N \g_xor_trials_done_num
%</progress>
      \xor_floats_active_seq_if_empty_action:
     }
%<*trace>
  \trace_pop:n{xor_try_next_float:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \begin{macro}{\xor_extract_this_float_values:N}
%   This command takes a float box or a float box pointer as its
%   argument and updates all the data structures associated with it.
%    \begin{macrocode}
\def_new:Npn \xor_extract_this_float_values:N #1
 {
  \xor_extract_this_float_core_values:N #1
%    \end{macrocode}
%    If we want to consider all areas for each float (and storing
%    closed areas via |\g_xor_class_|\meta{class}|_areas_closed_clist|
%    we have to initialise \\
%    |\g_xor_this_areas_open_clist| to
%    |\g_xor_areas_used_clist| (which is
%    derived from the |area-list| key.
%    \begin{macrocode}
  \clist_gset_eq:NN \g_xor_this_areas_open_clist \g_xor_areas_used_clist
%    \end{macrocode}
%
%    \begin{macrocode}
  \clist_gset_eq:Nc \g_xor_this_areas_closed_clist
                    {g_xor_class_ \g_xor_this_class_tlp _areas_closed_clist}  % FMi tmp
  \tlp_gset_eq:NN \g_xor_this_float_box_tlp
                  \g_xor_curr_float_box_tlp
%<*trace>
  \trace:n{This~ float~ structure:}
  \toks_set:No \l_tmpa_toks \g_xor_this_caption_tlp
  \trace:n{~{\toks_use:N \l_tmpa_toks }}
  \trace:n{~{\g_xor_this_span_num_tlp}}
  \trace:n{~{\g_xor_this_label_key_tlp}}
  \trace:n{~{\g_xor_this_display_cnt_tlp}}
  \trace:n{~{\g_xor_this_allowed_areas_tlp}}
  \trace:n{~{\g_xor_this_type_tlp}}
  \trace:n{~{\g_xor_this_flseq_num}}
  \trace:n{~g_xor_this_areas_open_clist~ <-~ \g_xor_this_areas_open_clist}
  \trace:n{~g_xor_this_areas_closed_clist~ <-~ \g_xor_this_areas_closed_clist}
%</trace>
%<*progress>
  \xor_progress:n{~{\g_xor_this_flseq_num}}
  \xor_progress:n{~{\g_xor_this_type_tlp}~(\g_xor_this_class_tlp)}
  \xor_progress:n{~{\g_xor_this_display_cnt_tlp}}
  %\xor_progress:n{~{\g_xor_this_span_num_tlp}}
  %\xor_progress:n{~{\g_xor_this_label_key_tlp}}
  %\xor_progress:n{~{\g_xor_this_allowed_areas_tlp}}
  \toks_set:Nn \l_tmpa_toks {#1}
  \xor_progress_newline:n{~{\toks_use:N \l_tmpa_toks }}
%</progress>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_extract_this_float_core_values:N}
%   This command takes a float box or a float box pointer as its
%   argument and updates all the data structures associated with it.
%    \begin{macrocode}
\def_new:Npn \xor_extract_this_float_core_values:N #1{
  \exp_after:NN \xor_extract_this_float_values:nnnnnnn \the\toks#1
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_extract_this_float_values:nnnnnnn}
% This macro assumes that |\g_xor_curr_float_box_tlp| is the box number for this structure
%    \begin{macrocode}
\def_new:Npn \xor_extract_this_float_values:nnnnnnn #1#2#3#4#5#6#7{
  \tlp_gset:Nn \g_xor_this_caption_tlp {#1}
  \tlp_gset:Nn \g_xor_this_span_num_tlp {#2}
  \tlp_gset:Nn \g_xor_this_label_key_tlp {#3}
  \tlp_gset:Nn \g_xor_this_display_cnt_tlp {#4}
  \tlp_gset:Nn \g_xor_this_allowed_areas_tlp {#5}
  \tlp_gset:Nn \g_xor_this_type_tlp {#6}
%    \end{macrocode}
%    From the type we infer the class:
%    \begin{macrocode}
  \tlp_gset_eq:Nc
       \g_xor_this_class_tlp {g_xor_type_ #6 _class_tlp}
  \num_gset:Nn \g_xor_this_flseq_num {#7}
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\xor_extract_here_float_values:nnnnnnn}
%
%    Similar to |\xor_extract_this_float_values:nnnnnnn| but filling different
%    macros as here floats are looked at while trying to place other
%    floats.
%
%    This macro assumes that |\g_xor_curr_float_box_tlp| is the box number for this
%    structure.\footnote{true?}
%
%    \begin{macrocode}
\def_new:Npn \xor_extract_here_float_values:nnnnnnn#1#2#3#4#5#6#7{
  \tlp_gset:Nn \g_xor_here_caption_tlp {#1}
  \tlp_gset:Nn \g_xor_here_span_num_tlp {#2}
  \tlp_gset:Nn \g_xor_here_display_cnt_tlp {#4}
  \tlp_gset:Nn \g_xor_here_type_tlp {#6}
  \tlp_gset_eq:Nc
       \g_xor_here_class_tlp {g_xor_type_ #6 _class_tlp}
  \tlp_gset:Nn \g_xor_here_flseq_tlp {#7}
  \tlp_gset_eq:NN \g_xor_here_float_box_tlp \g_xor_curr_float_box_tlp
%<*trace>
  \trace:n{Here~ object~ structure:}
  \toks_set:Nn \l_tmpa_toks {#1}
  \trace:n~{~{\toks_use:N \l_tmpa_toks }}
  \trace:n{~{#2}}
  \trace:n{~{#3}}
  \trace:n{~{#4}}
  \trace:n{~{#5}}
  \trace:n{~{#6}}
  \trace:n{~{#7}}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\g_xor_page_float_int}
%    This integer keeps track on the total number of floats added to
%    the current page.
%    \begin{macrocode}
%\int_new:N \g_xor_page_float_int
\let:NN \g_xor_page_float_int \@colnum
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \newpage
%
% \subsection{Grab Column Output Routine}
%
% \begin{description}
% \item[Entry:] |\xor_OR_trial_grab_cols_setup:|
% \item[Exit:]  |\xor_OR_cleanup_setup:N \xor_trial_place_float_loop:|
% \item[Prereq:]
% \item[Description:]
% \item[Flow:]
%\begin{footnotesize}
%\begin{verbatim}
%    \xor_OR_trial_grab_cols_setup:
%            |
%    New OR: \xor_OR_grab_trial_cols:
%            |
%    \xor_OR_trial_grab_balance_setup:  <-------
%            |
%    \xor_OR_trial_grab_next_col_setup: <-------
%            |
%    (when entering OR...)
%            |
%    <end of collection reached?>
%         |          |
%        yes        no
%         |          |
%         |     <col break requested?>
%         |          |        |
%         |         yes       no
%         |          |        |
%         |          |     <flush point encountered?>
%         |          |        |                  |
%         |          |       yes                 no
%         |          |        |                  |
%         |          | <grabbing already         |
%         |          |   balanced cols?  >       |
%         |          |        |     |            |
%         |          |        no   yes           |
%         |          |        |     |            |
%         |          |        |     |___         |
%         |          |        |         |        |
%         |          |        |         |        |
%         |          |        |         |        |
%         |          | <flush point     |   <here point encountered?>
%         |          |      too early?> |      |               |
%         |          |    |      |      |     yes              no
%         |          |   yes    no    __|      |               |
%         |          |    |      |    |        ?               ?
%         |          |    | (ignore break)
%         |          |    |      |
%         |          |    |      |
% (end column now) <-------      |
%         |                      |
%         V                      |
%   <all cols produced?>         |
%      |           |             V
%     yes          no--------------------> (reenter 
%                                           \xor_OR_trial_grab_next_col_setup:)
%      |
%  <grabbing already
%     balanced cols? >
%      |         |
%      no        yes---------------------> (incr. ???
%      |                                    reenter  
%                                           \xor_OR_trial_grab_balance_setup:)
%      |
% (store results of trial)
%      |
%      V
%    \xor_OR_cleanup_setup:N \xor_trial_place_float_loop:
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%
%  \begin{macro}{\xor_OR_trial_grab_cols_setup:}
%    \begin{macrocode}
\def_new:Npn \xor_OR_trial_grab_cols_setup: {
%<*trace>
  \trace_push:n{xor_OR_trial_grab_cols_setup:}
%</trace>
%    \end{macrocode}
%
%    We just returned to the MVL the current galley. At its end we
%    have added the special penalty |\c_xor_output_collect_penalty| to mark
%    the point that we need to reach in order to remove everything
%    after the trial run.
%    \begin{macrocode}
  \bool_gset_false:N \g_xor_trial_failed_bool
%    \end{macrocode}
%
%    Moved from |\xor_try_this_area:| as it should be executed
%    only if we really do a trial and thus back it out if
%    unsuccessful---this was a bug as it changed
%    |g_xor_flseq_type_|\meta{type}|_col_|\meta{col}|_num| in cases
%    we never came to this
%    point here but recoursed)
%    \begin{macrocode}
  \bool_if:NT \g_xor_trial_with_floats_bool
  {
%    \end{macrocode}
%    Depending on the policy a spanning float can be considered belong
%    to different columns. This influences the behaviour of the
%    call-out contraint tests and is determined by the code stored in
%    |\xor_calculate_float_col:|.
%    \begin{macrocode}
    \xor_calculate_float_col:
%    \end{macrocode}
%    |\xor_calculate_float_col:| returns its calculated column
%    number in \\
%    |\l_xor_returned_float_col_num|.
%    \begin{macrocode}
    \num_gset_eq:Nc \g_xor_saved_flseq_num
                    {g_xor_flseq_type_ \g_xor_this_class_tlp _col_
                     \num_use:N \l_xor_returned_float_col_num _num}
    \num_gset_eq:cN {g_xor_flseq_type_ \g_xor_this_class_tlp _col_
                     \num_use:N \l_xor_returned_float_col_num _num}
                    \g_xor_this_flseq_num
%<*trace>
    \trace:n{~g_xor_flseq_type_ \g_xor_this_class_tlp _col_
            \num_use:N \l_xor_returned_float_col_num _num \space <-~
           \num_use:c{g_xor_flseq_type_ \g_xor_this_class_tlp _col_
                      \num_use:N \l_xor_returned_float_col_num _num} }
%</trace>
%    \end{macrocode}
%    If we are adding to a top area we also have to update the
%    corresponding |\g_xor_flseq_areas_top_type_...| commands:
%    \begin{macrocode}
    \if:w t\g_xor_this_area_type_tlp
      \num_gset_eq:Nc \g_xor_saved_flseq_top_areas_num
                      {g_xor_flseq_areas_top_type_
                       \g_xor_this_class_tlp _col_
                       \num_use:N \l_xor_returned_float_col_num _num}
      \num_gset_eq:cN
                      {g_xor_flseq_areas_top_type_
           \g_xor_this_class_tlp _col_
             \num_use:N \l_xor_returned_float_col_num _num}
                      \g_xor_this_flseq_num
%<*trace>
      \trace:n{~g_xor_flseq_areas_top_type_ \g_xor_this_class_tlp _col_
                    \num_use:N \l_xor_returned_float_col_num _num \space <-~
             \num_use:c {g_xor_flseq_areas_top_type_ \g_xor_this_class_tlp _col_
                         \num_use:N \l_xor_returned_float_col_num _num} }
%</trace>
    \fi:
  }
%    \end{macrocode}
%
%    If we have seen any flush points during collection we need to
%    save their current |min_col| positions in case we have to throw
%    away the current trial.
%    \begin{macrocode}
  \bool_if:NT \g_xor_flush_seen_bool
  {
    \int_zero:N \l_loop_int
    \int_whiledo:nNnT \g_xor_collect_flush_seen_num>\l_loop_int
    {
      \int_incr:N \l_loop_int
      \num_gset_eq:cc
        {g_xor_saved_flush_ \int_use:N \l_loop_int _min_col_num}
        {g_xor_flush_       \int_use:N \l_loop_int _min_col_num}
%<*trace>
      \trace:n{g_xor_saved_flush_ \int_use:N \l_loop_int _min_col_num \space <-~
            \num_use:c{g_xor_flush_ \int_use:N \l_loop_int _min_col_num}}
%</trace>
    }
  }


  \tlp_gclear:N \g_xor_saved_trial_col_hts_tlp
  \xor_forall_columns:n{
    \tlp_gput_right:Nx \g_xor_saved_trial_col_hts_tlp
       {
        \exp_not:N \dim_gset:Nn
        \exp_not:c  {g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim}
                    { \dim_use:c {g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim} }
      }
  }
%<*trace>
  \trace:n{Saving~ column~ heights:}
  \trace:n{g_xor_saved_trial_col_hts_tlp ~:=~\meaning\g_xor_saved_trial_col_hts_tlp}
%</trace>


%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_initialise_footins_action:
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_OR_trial_grab_balance_setup:
%    \end{macrocode}
%
%    \begin{macrocode}
%<*trace>
  \trace_pop:n{xor_OR_trial_grab_cols_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\xor_calculate_float_col:}
% \begin{macro}{\xor_calculate_float_col_flexible:}
% \begin{macro}{\xor_calculate_float_col_strict:}
%    The purpose of |\xor_calculate_float_col:| is to calculate
%    the column number for which the |\fl@|\meta{col}|@number| has to
%    be updated in case we place the current float into the area with
%    start column |\g_xor_this_area_col_tlp| and span-number
%    |\g_xor_this_area_span_tlp|. It returns the calculated number in
%    |\l_xor_target_col_tlp|.
%
%    For non-spanning floats it is simply returning
%    |\g_xor_this_area_col_tlp|. If we return this value also in case of
%    spanning floats then this means that we claim that the float has
%    be placed the first of its spanned columns. Alternatively we
%    could return the last of the spanned columns which would if the
%    |column| policy is in force, allow to place a float into |t12|
%    even if its call-out is in the second column.
%
%    The real value for |\xor_calculate_float_col:| will be assigned
%    in the page setup template.
%    \begin{macrocode}
\let_new:NN \xor_calculate_float_col: \ERROR
%    \end{macrocode}
%
%    And here are the two possibilities.
%    \begin{macrocode}
\def_new:Npn \xor_calculate_float_col_flexible: {
    \num_set:Nn \l_xor_returned_float_col_num \g_xor_this_area_col_tlp
    \num_add:Nn \l_xor_returned_float_col_num \g_xor_this_area_span_tlp
    \num_decr:N \l_xor_returned_float_col_num
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def_new:Npn \xor_calculate_float_col_strict: {
    \num_set_eq:NN \l_xor_returned_float_col_num \g_xor_this_area_col_tlp
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\g_xor_trial_with_floats_bool}
%    When we are doing trials with floats then more work is necessary compared
%    to the situation without any floats. The boolean
%    |\g_xor_trial_with_floats_bool| distinugishes between the two cases.
%    \begin{macrocode}
\bool_new:N \g_xor_trial_with_floats_bool
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_OR_trial_grab_next_col_setup:}
%    The |\xor_OR_grab_trial_cols:| output routine is responsible for
%    constructing one column of a layout trial.  The loop command
%    increments the column count and sets vsize to the target height
%    for the current column (which has already been set based on the
%    size and position of the floats in this trial layout.
%    \begin{macrocode}
\def_new:Npn \xor_OR_trial_grab_next_col_setup: {
%<*trace>
  \trace_push:n{xor_OR_trial_grab_next_col_setup:}
%</trace>
  \int_gincr:N \g_xor_curr_col_int
  \dim_gset:Nc \vsize {g_xor_ht_col_
                       \int_use:N\g_xor_curr_col_int
                       _dim}
  \if_xor_grab_for_balance_done:TF
    {
%<*trace>
     \trace:n{BALANCE:~ delta~ ignored }
%</trace>
    }
    {
%    \end{macrocode}
%    Calculate the real reduction to use in the current column (depends on the
%    bottom float situation) and substract it from |\vsize|.
%    \begin{macrocode}
     \xor_calculate_delta_to_use:N \l_tmpa_dim
     \dim_gsub:Nn \vsize \l_tmpa_dim
    }
%<*trace>
  \trace:n{vsize~ setup~ =~ \dim_use:N \vsize }
%</trace>

%    \end{macrocode}
%    tmp\footnote{fix implement differently}
%    \begin{macrocode}
  \dim_compare:nNnF \vsize > \baselineskip
    { \ignorethiscolumn  \par\null\penalty-10003\relax}
%<*trace>
  \trace_pop:n{xor_OR_trial_grab_next_col_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\ignorethiscolumn}
%    \begin{macrocode}
\def_new:Npn \ignorethiscolumn {\typeout{if~ we~ reach~ this~ the~ algorithm~
    should~ change~ behavior~ ...one~ day}} 
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_calculate_delta_to_use:N}
%    The |\g_xor_balance_delta_dim| value during balancing is a nominal
%    one. It is only used on a column if the column doesn't have any bottom
%    floats. If it does then the actual value used is the difference between
%    |\g_xor_balance_delta_dim| and the amount taken up by the bottom floats in
%    that column or zero if that difference is negative.
%
%    This is calculated in the following macro and the result is returned in
%    the local variable specified in its argument. This can then be further
%    used to reduce the |\vsize| for cutting etc.
%    \begin{macrocode}
\def_new:Npn \xor_calculate_delta_to_use:N #1 {

%<*trace>
     \trace:n{BALANCE:~ delta~ =~ \dim_use:N \g_xor_balance_delta_dim }
%</trace>
     \dim_set:Nn #1 \g_xor_balance_delta_dim
     \dim_sub:Nn #1
                 { \dim_use:c {g_xor_bottom_ht_col_
                                \int_use:N\g_xor_curr_col_int
                              _dim} }
     \dim_compare:nNnTF  #1 > \c_zero_dim
        { 
%<*trace>
          \trace:n{BALANCE:~ reduction~ used~ on~ col~
                 \int_use:N\g_xor_curr_col_int\space =~ \dim_use:N #1 }
%</trace>
        }
        {
%<*trace>
          \trace:n{BALANCE:~ no~ reduction~ used~ on~ col~
                 \int_use:N\g_xor_curr_col_int\space =~ 
                 \dim_use:N #1 \space !>~ 0pt}
%</trace>
          \dim_zero:N #1
        }
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_OR_grab_some_cols:nnnnn}
%    |\xor_OR_grab_trial_cols:| and |\xor_OR_grab_best_cols:| are sharing most of their
%    code which is therefore placed into a separate macro. At the
%    moment it takes 5 arguments: the name (``grab'' or ``best''),
%    what to do when we actually finish the column
%    (``|\xor_OR_trial_finish_col:|'' or ``|\xor_OR_best_finish_col:|''),
%    what to do for a flush point, what to do when we encounter a
%    here float, and finally what to do if we encounter a balancing point.
%
% \footnote{This code needs a bit of redesign to deal
%    properly with the case that we have stumbled upon one of the
%    special penalties. In this case we need to ensure that we also
%    remove the special box after the penalty in case we are at a
%    column break. This is not done right now so that in this case we
%    will not discard material at the top of the column properly. FIX!!!!}
%    \begin{macrocode}
\def_new:Npn \xor_OR_grab_some_cols:nnnnn #1#2#3#4#5{
%<*trace>
  \trace_push:n{xor_OR_grab_some_cols:~ (#1)}
  \trace:n{output~pen:~ \the\outputpenalty}
  \trace:n{#1~ col:~ \int_use:N\g_xor_curr_col_int\space of~ \int_use:N\g_xor_cols_int}
  \trace:n{vsize:~ \the\vsize;~ pagegoal:~ \the\pagegoal}
%</trace>
  \int_compare:nNnTF \outputpenalty= {-\c_xor_output_collect_penalty}
   { \xor_handle_premature_ending:  #2 }
   { \int_compare:nNnTF \outputpenalty={-\c_ten_thousand}
      { \xor_handle_forced_pagebreak:  #2 }
%    \end{macrocode}
%
%    \begin{macrocode}
      { 
        \int_compare:nNnTF \outputpenalty={-\c_xor_output_balance_penalty}
         { #5 {#2} \ERRORxxx }
%    \end{macrocode}
%    If the |\outputpenalty| is |-\c_xor_output_flush_float_penalty| we
%    have reached a float flush point in the galley.
%    \begin{macrocode}
         { \int_compare:nNnTF \outputpenalty= {-\c_xor_output_flush_float_penalty }
            { \xor_handle_flush:nn {#2} {#3} }
%    \end{macrocode}
%    If it was not a flush point we might have a here point to take
%    care of. This is more or less like the code above.
%    \begin{macrocode}
            { \int_compare:nNnTF \outputpenalty={-\c_xor_output_here_float_penalty}
               { \xor_handle_here:nn {#2} {#4} }
%    \end{macrocode}
%    If it is neither a flush nor a here point it might be a grid point:
%    \begin{macrocode}
               { \int_compare:nNnTF \outputpenalty={-\c_xor_output_grid_align_penalty }
                  { \xor_align_collected_galley_and_restart: }
%    \end{macrocode}
%    If we see a column break then this is like having a natural end (right
%    now). The reason that this case is differenciated is that at some point we may
%    like to allow guided column breaks which are taken or not taken depending on
%    the fill situation of the column.\footnote{extend code one day}
%    \begin{macrocode}
                  { \int_compare:nNnTF \outputpenalty={-\c_xor_output_columnbreak_penalty }
                     { #2 }
%    \end{macrocode}
%    So we now know that it wasn't one of our special points so this
%    must have been a normal end of the galley. 
%    However we might be balancing columns and in that case we have to ensure
%    that we reach the balancing point again.
%    \begin{macrocode}
                     { \int_compare:nNnTF \g_xor_curr_col_int = \g_xor_cols_int
                        { \bool_if:NTF \g_xor_balance_point_expected_bool 
                           { \ERRORlostbalancepoint }
                           { #2 }
                        }
                        { #2 }
                     }
                  }
               }
            }
          }
        }
     }
%<*trace>
  \trace_pop:n{xor_OR_grab_some_cols:~ (#1)}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%

% \begin{macro}{\ERRORlostbalancepoint}
%
%    \begin{macrocode}
\def:Npn \ERRORlostbalancepoint {

        \dim_gset:Nn \g_xor_balance_delta_dim \g_xor_saved_balance_delta_dim
        \bool_gset_true:N \g_xor_balance_finish_bool

        \box_gclear:N \c_twohundred_fifty_five
        \box_gclear:N \footins
        \xor_OR_cleanup_setup:N \xor_trial_get_balance_loop:
}
%    \end{macrocode}
% \end{macro}

%
% \begin{macro}{\xor_handle_here:nn}
%
%    \begin{macrocode}
\def_new:Npn \xor_handle_here:nn #1 #2 {
  \num_gincr:N\g_xor_trial_here_seen_num
%<*trace>
  \trace:n{here~ penalty~(\g_xor_trial_here_seen_num)~ reached}
%</trace>
  \xor_remove_guard_box_from_cclv:
  \int_compare:nNnTF
     { \num_use:c {g_xor_here_ \g_xor_trial_here_seen_num  _min_col_num } }
     > \g_xor_curr_col_int
  {
%<*trace>
    \trace:n{g_xor_here_ \g_xor_trial_here_seen_num _min_col_num \space 
           >~g_xor_curr_col_int~
          (\num_use:c {g_xor_here_ \g_xor_trial_here_seen_num
                    _min_col_num}
            \space >~ \int_use:N \g_xor_curr_col_int)~ ->~ ending~ column}
%</trace>
    \xor_split_off_last_line_from_clvv:
    \num_gdecr:N \g_xor_trial_here_seen_num
    \xor_readd_guarded_penalty:n\c_xor_output_here_float_penalty
    #1
  }
  {
    \dim_set:Nn \l_tmpa_dim \pagegoal
    \dim_sub:Nn \l_tmpa_dim \pagetotal
    \dim_compare:nNnTF
      \l_tmpa_dim <
      { \tlp_use:c {g_xor_here_ \g_xor_trial_here_seen_num _required_space_tlp} }
    {
%<*trace>
      \trace:n{g_xor_here_ \g_xor_trial_here_seen_num _required_space_tlp\space >~
            \pagegoal-\pagetotal \space
            (\tlp_use:c {g_xor_here_
                    \g_xor_trial_here_seen_num  _required_space_tlp}
              \space >~ \dim_use:N \pagegoal\space
                        -~ \dim_use:N \pagetotal\space =~
                        \dim_use:N \l_tmpa_dim)~
            ->~ ending~ column}
%</trace>
      \xor_split_off_last_line_from_clvv:
      \num_gdecr:N\g_xor_trial_here_seen_num
      \xor_readd_guarded_penalty:n\c_xor_output_here_float_penalty
      #1
    }
    {
%<*trace>
      \trace:n{g_xor_here_ \g_xor_trial_here_seen_num _required_space_tlp\space <=~
            \pagegoal-\pagetotal \space
            (\tlp_use:c {g_xor_here_ \g_xor_trial_here_seen_num _required_space_tlp}
              \space <=~ \dim_use:N \pagegoal\space
                        -~ \dim_use:N \pagetotal\space =~
                        \dim_use:N \l_tmpa_dim)~
            ->~ accepting~ here~ point}
%</trace>
      \@reinserts
      \vbox_unpack_clear:N\c_twohundred_fifty_five
      \xor_gpop_float:NNTF
        \g_xor_floats_here_seq
        \g_xor_curr_float_box_tlp
      {
%<*trace>
        \trace:n{@currbox:~ \g_xor_curr_float_box_tlp}
%</trace>
        \exp_after:NN
          \xor_extract_here_float_values:nnnnnnn
            \the\toks\g_xor_curr_float_box_tlp
%    \end{macrocode}
%    Different things need to be done depending on the type of the
%    here point:
%    \begin{macrocode}
        \tlp_set:Nn \l_testa_tlp {mpar}
        \tlp_if_eq:NNTF \l_testa_tlp \g_xor_here_type_tlp
        { \xor_typeset_a_marginpar: }
        {
          \tlp_set:Nn \l_testa_tlp {rspace}
          \tlp_if_eq:NNF \l_testa_tlp \g_xor_here_type_tlp
          { #2 }
        }
      }
%    \end{macrocode}
%    If there is no here object left the algorithm has screwed up
%    (i.e., a ``this can't happen'' situation).
%    \begin{macrocode}
      \ERROR
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_handle_flush:nn}
%
%    \begin{macrocode}
\def_new:Npn \xor_handle_flush:nn #1#2 {
  \num_gincr:N \g_xor_trial_flush_seen_num
%<*trace>
  \trace:n{flush~ point~( \g_xor_trial_flush_seen_num,~
    affects:~ \clist_use:c {g_xor_flush_
                      \g_xor_trial_flush_seen_num _classes_clist},~
    mincol:~    \num_use:c {g_xor_flush_
                            \num_use:N \g_xor_trial_flush_seen_num
                            _min_col_num},~
    lastfloat:~ \num_use:c {g_xor_flush_
                            \num_use:N \g_xor_trial_flush_seen_num
                            _last_float_num}
        )~ reached}
%</trace>
%    \end{macrocode}
%    We then remove the guard box from the output (which is at the end
%    of box |\c_twohundred_fifty_five|.
%    \begin{macrocode}
  \xor_remove_guard_box_from_cclv:
%    \end{macrocode}
%    If the flush penalty moved to an earlier column than in the last
%    trial we end the current column (by calling
%    |\xor_OR_trial_finish_col:| or |\xor_OR_best_finish_col:|) and reinsert the penalty so that it will
%    be seen again if we do the next column.
%    \begin{macrocode}
  \int_compare:nNnTF
  { \num_use:c {g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num} }
    > \g_xor_curr_col_int
  {
%<*trace>
    \trace:n{g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num\space >~
          g_xor_curr_col_int~
          (\num_use:c {g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num}
            \space >~ \int_use:N \g_xor_curr_col_int)~ ->~ ending~ column}
%</trace>
    \num_gdecr:N \g_xor_trial_flush_seen_num
    \xor_readd_guarded_penalty:n\c_xor_output_flush_float_penalty
    #1
  }
  {
%    \end{macrocode}
%    Otherwise the flush point is in an acceptable position which
%    means we ignore it and carry on collecting material for the
%    current column. This is done be putting everything back onto the
%    MVL except the guard box and the penalty. We lose a
%    potential break point here,  see comments in
%    |\xor_OR_grab_best_cols:|!!\footnote{acceptable?}
%    \begin{macrocode}
%<*trace>
    \trace:n{g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num~
          <=~ g_xor_curr_col_int~
          (\num_use:c {g_xor_flush_
                        \g_xor_trial_flush_seen_num _min_col_num}
          \space <=~ \int_use:N\g_xor_curr_col_int)}
%</trace>
%    \end{macrocode}
%    What exactly happens here (beside the above) depends on the
%    calling macro.
%    \begin{macrocode}
    #2
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_OR_grab_trial_cols:}
%    Here is the output routine used during trials, an instantiation
%    of |\xor_OR_grab_some_cols:nnnn|.
%    \begin{macrocode}
\def_new:Npn \xor_OR_grab_trial_cols:{
  \xor_OR_grab_some_cols:nnnnn{grab}
    \xor_OR_trial_finish_col:
    \xor_OR_trial_check_flush:
    \xor_check_and_typeset_a_here_float:
    \xor_OR_trial_balance:NN
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_OR_trial_check_flush:}
%
%    The |\xor_OR_trial_check_flush:| code checks for restrictions
%    regarding the placement of the current float. It is called when
%    we just have encountered a flush float penalty while grabbing the
%    text for a column and now have to see which floats (if any) need
%    to be positioned before that flush point.
%    \begin{macrocode}
\def_new:Npn \xor_OR_trial_check_flush:{
%<*trace>
  \trace_push:n{xor_OR_trial_check_flush:}
%</trace>
%    \end{macrocode}
%    If we are making a dry-run without floats then there is no need to
%    do much, so we skip all testing that involves flush points and
%    only do the cleanup actions at the end.
%    \begin{macrocode}
  \bool_if:NT \g_xor_trial_with_floats_bool
  {
    \clist_if_in:coTF
    {g_xor_flush_\g_xor_trial_flush_seen_num _classs_clist}
    \g_xor_this_class_tlp
    {
%<*trace>
      \trace:n{flush:~ class~ \g_xor_this_class_tlp\space in~
             {\clist_use:c {g_xor_flush_ \g_xor_trial_flush_seen_num _classes_clist}}}
%</trace>
%    \end{macrocode}
%    We store in |\l_tmpa_int| the float sequence number of the last float
%    that would be affected by the current flush penalty. This value
%    is then used in the tests below.
%    \begin{macrocode}
      \int_set:Nc \l_tmpa_int
                  {g_xor_flush_ \num_use:N \g_xor_trial_flush_seen_num
                   _last_float_num}
%    \end{macrocode}
%
%    If the current float number is higher than float number stored in \\
%    |\g_xor_flush_|\meta{num}|_last_float_num| with the flush penalty, we are
%    dealing with a float whose call-out is after the flush penalty
%    and thus we have no restriction.
%    \begin{macrocode}
      \int_compare:nNnTF \g_xor_this_flseq_num > \l_tmpa_int
      {
%<*trace>
        \trace:n{???:\g_xor_this_flseq_num>\int_use:N \l_tmpa_int}
        \trace:n{this~float~ past~flush~point}
%</trace>
      }
      {
%    \end{macrocode}
%    Otherwise check if this float is placed in an acceptable position
%    with respect to the current flush point. For this we run
%    different code depending on the ``fuzziness'' of the flush point
%    under check:
%    \begin{macrocode}
        \use:c {xor_flush_fuzziness_action_ \num_use:N \g_xor_trial_flush_seen_num :}
      }
    }
    {
%<*trace>
      \trace:n{flush:~ class~ \g_xor_this_class_tlp\space not~ in~
             {\clist_use:c {g_xor_flush_ \g_xor_trial_flush_seen_num _classes_clist}}}
%</trace>
    }
  }
%    \end{macrocode}
%    If we failed above we additionally record that the failure is
%    due to violating restrictions for a flush point.
%    \begin{macrocode}
  \bool_if:NTF \g_xor_trial_failed_bool
  {
    \bool_gset_true:N \g_xor_flush_failed_bool
%    \end{macrocode}
%
%    \begin{macrocode}
    \box_gclear:N \c_twohundred_fifty_five
    \box_gclear:N \footins
%    \end{macrocode}
%    We have to immediately abort the current trial otherwise a
%    flush point following in the galley might be encountered and
%    processed before we reach |\xor_evaluate_trial_results:|. That
%    would result in updating the wrong data structure there (due to
%    the fact that there it assumes that |\g_xor_trial_flush_seen_num|
%    refers to the flush point that is the reason for
%    failure).\footnote{Implementation could be improved!}
%    \begin{macrocode}
    \int_gset:Nn \g_xor_curr_col_int \g_xor_cols_int
    \xor_OR_trial_finish_col:
  }
  {
%    \end{macrocode}
%    If we haven't failed we might have to update the
%    |\g_xor_flush_|\meta{num}|_min_col_num| for the current flush point in case it
%    moved to a new column.
%    \begin{macrocode}
    \int_compare:nNnT
    { \num_use:c {g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num} }
      < \g_xor_curr_col_int
    {
      \num_gset:cn
        {g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num}
        \g_xor_curr_col_int
%<*trace>
      \trace:n{set~ g_xor_flush_ \g_xor_trial_flush_seen_num
                  _min_col_num :~
             \num_use:c {g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num}}
%</trace>
    }
%    \end{macrocode}
%    We have to return the collected footnotes first or else \TeX{}
%    might decide that it is better to break before
%    them.\footnote{Quite likely that this needs some refinement as it
%    might mess up vertical spacing in other respects. Look out for
%    other places where \texttt{\string\@reinserts} is used, if this
%    needs fixing.}
%    \begin{macrocode}
    \@reinserts
    \vbox_unpack_clear:N\c_twohundred_fifty_five
%    \end{macrocode}
%    What penalty to return???\footnote{FIX!!!}
%    \begin{macrocode}
%    \penalty\c_zero    % none i think now (in the current version) but this
                    % will change again
  }
%<*trace>
  \trace_pop:n{xor_OR_trial_check_flush:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\xor_check_flush_page:}
%    ???\footnote{doc}
%    \begin{macrocode}
\def_new:Npn \xor_check_flush_page: {
%<*trace>
  \trace:n{OK:~flush~check~ (same~page)}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_check_flush_spread:}
%
%    This is actually a dummy definition. There is more to do if we
%    want to provide support for spreads!\footnote{Finish implementation}
%    \begin{macrocode}
\def_new:Npn \xor_check_flush_spread: {
%<*trace>
  \trace:n{OK:~flush~check~ (using~page~not~ spread)}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_check_flush_strict:}
%    \begin{macrocode}
\def_new:Npn \xor_check_flush_strict: {
%<*trace>
  \trace_push:n{xor_check_flush_strict:}
%</trace>
%    \end{macrocode}
%    If strict flushing is required we look where the current float is
%    being placed. If it
%    is placed in a column which is earlier than the current column
%    then it is definitely before the flush point and thus we are okay.
%    \begin{macrocode}
  \int_compare:nNnTF \g_xor_this_area_col_tlp<\g_xor_curr_col_int
  {
%<*trace>
    \trace:n{OK:~flush~check~
           (\g_xor_this_area_col_tlp <
            \int_use:N\g_xor_curr_col_int ,~
            \g_xor_this_area_name_tlp)}
%</trace>
  }
  {
%    \end{macrocode}
%    Otherwise we test if the float is placed into the current
%    column. If this is the case it might be okay, but only if it is
%    not placed into the bottom area.
%    \begin{macrocode}
    \int_compare:nNnTF \g_xor_this_area_col_tlp=\g_xor_curr_col_int
    {
%    \end{macrocode}
%    To test for the bottom area(s) means looking at the first token
%    in the area identifier. If it is |b| we are past the flush
%    point.\footnote{It might be an interesting extension to allow
%    relaxing the flush situation to allow the floats to appear
%    anywhere on the current column (on which the flush point ends up),
%    or even allowing that it only has to appear on the current page
%    or page spread.}
%    \begin{macrocode}
      \if:w b \g_xor_this_area_type_tlp
        \bool_gset_true:N \g_xor_trial_failed_bool
%<*progress>
        \xor_progress_failed:n{area~ below~ flush~ point~
               (\g_xor_this_area_col_tlp =
                \int_use:N\g_xor_curr_col_int ,~
                \g_xor_this_area_name_tlp)}
%</progress>
%<*trace>
        \trace:n{Fail:~flush~check~
               (\g_xor_this_area_col_tlp =
                \int_use:N\g_xor_curr_col_int,~
                \g_xor_this_area_name_tlp)}
%    \end{macrocode}
%    Otherwise the float was placed into an area that is still before
%    the flush point.
%    \begin{macrocode}
      \else:
        \trace:n{OK:~flush~check~
               (\g_xor_this_area_col_tlp =
                \int_use:N\g_xor_curr_col_int ,~
                \g_xor_this_area_name_tlp)}
%</trace>
      \fi:
%    \end{macrocode}
%    If the float was neither placed before nor into the current
%    column we have to conclude that it was placed into a later column
%    which means it was placed after the flush point --- thus we fail.
%    \begin{macrocode}
    }
    {
      \bool_gset_true:N \g_xor_trial_failed_bool
%<*progress>
      \xor_progress_failed:n{area~ after~ flush~ point~
             (\g_xor_this_area_col_tlp >
              \int_use:N\g_xor_curr_col_int ,~
              \g_xor_this_area_name_tlp)}
%</progress>
%<*trace>
      \trace:n{Fail:~flush~check~
             (\g_xor_this_area_col_tlp >
              \int_use:N\g_xor_curr_col_int ,~
              \g_xor_this_area_name_tlp)}
%</trace>
    }
  }
%<*trace>
  \trace_pop:n{xor_check_flush_strict:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_check_flush_column:}
%    Check whether the column associated with the currently selected
%    area is after the current
%    column and if so declare this trial a failure.
%    \begin{macrocode}
\def_new:Npn \xor_check_flush_column: {
  \int_compare:nNnTF \g_xor_this_area_col_tlp>\g_xor_curr_col_int
  {
    \bool_gset_true:N \g_xor_trial_failed_bool
%<*progress>
    \xor_progress_failed:n{area~ after~ flush~ point~ column~
      (\g_xor_this_area_col_tlp>\int_use:N\g_xor_curr_col_int,
       ~\g_xor_this_area_name_tlp)}
%</progress>
%<*trace>
    \trace:n{Fail:~flush~check~
           (\g_xor_this_area_col_tlp>\int_use:N\g_xor_curr_col_int,
             ~\g_xor_this_area_name_tlp)}
  }
  {
    \trace:n{OK:~flush~check~
           (\g_xor_this_area_col_tlp<=\int_use:N\g_xor_curr_col_int,
            ~\g_xor_this_area_name_tlp)}
%</trace>
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_OR_trial_finish_col:}
%    Finish off the current trial column, doing some final checks to
%    see if this trial might be a good one, and then prepare to get
%    the next column, or, if this was the last one, do a final cleanup.
%    \begin{macrocode}
\def_new:Npn \xor_OR_trial_finish_col:{
%<*trace>
  \trace_push:n{xor_OR_trial_finish_col:}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
  \xmark_update_structure
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_deal_with_footins_action:
%    \end{macrocode}
%
%    First check if there are some special constraints that should be
%    met (this is, for example, used to check if there are both bottom
%    floats and footnotes). If the constraints are not met don't
%    bother to check the callout/float constraints.
%
%    Especially while doing balancing and not having reached the final
%    balanced solution,
%    no tests should be made since they would fail the 
%    trial!\footnote{this now disables the checks even on last run! fix!}
%    \begin{macrocode}

  \bool_if:NTF \g_xor_balance_point_expected_bool
   {
%<*trace>
  \trace:n{BALANCE:~ skipping~ tests~ while~ balancing}
%</trace>
   }
   {
    \bool_if:NF \g_xor_trial_failed_bool
     {
      \bool_if:NT \g_xor_trial_with_floats_bool
         \xor_check_float_constraints:
     }
    \bool_if:NF \g_xor_trial_failed_bool
     {
%    \end{macrocode}
%     For each float sequence class, call |\xor_check_callout_constraints:n|
%    this will be set via a call to a pagesetup template to do an
%    appropriate check on the float placement relative to float
%    call-out.
%    \begin{macrocode}
      \bool_if:NT \g_xor_trial_with_floats_bool
       { \seq_map:NN \g_xor_float_classes_seq  \xor_check_callout_constraints:n }
     }
   }
%    \end{macrocode}
%
%    Throw the text away (it will be reset later if this trial is
%    in fact chosen).
%    \begin{macrocode}
  \box_gclear:N \c_twohundred_fifty_five
  \box_gclear:N \footins
%    \end{macrocode}
%    After the last column we evaluate the results of the trial (and
%    if the result looks ok remember it as a candidate for the final
%    solution). We then switch to the `clean up' OR which will
%    collect up the main vertical list as far as the special penalty
%    marking the end of the collection pass, to clear the MVL for the
%    next trial.  If this isn't the last column, set up the next
%    column.
%    \begin{macrocode}
  \int_compare:nNnTF \g_xor_curr_col_int=\g_xor_cols_int
  {
    \xor_evaluate_trial_results:
    \xor_OR_cleanup_setup:N \xor_trial_place_float_loop:
  }
  {
    \xor_OR_trial_grab_next_col_setup:
  }
%<*trace>
  \trace_pop:n{xor_OR_trial_finish_col:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_handle_premature_ending:}
%    This case needs rethinking: what is the best
%    approach if we hit the penalty which denotes the end of the
%    collected galley too early, e.g., in the middle of a trial using
%    |\xor_OR_grab_trial_cols:| or when producing the final columns with
%    |\xor_OR_grab_best_cols:|? Current solution gets the stuff out, but is it
%    probably not the best solution.
%    correct?
%    \begin{macrocode}
\def_new:Npn \xor_handle_premature_ending:{
%<*trace>
        \trace:n{CHECK~ Handle~ premature~ ending}
%</trace>
  \xor_remove_guard_box_from_cclv:
  \xor_readd_guarded_penalty:n \c_xor_output_collect_penalty
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_check_float_constraints:}
%    In |\xor_OR_grab_trial_cols:| (when the output routine that grabs a single column
%    during a trial) we have the command |\xor_check_float_constraints:| which
%    allows to check some constraints and if they aren't met is supposed
%    to set the switch |@fail|.
%
%    By default there are no additional constraints to check for.
%    \begin{macrocode}
\let_new:NN \xor_check_float_constraints: \c_empty_tlp
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_evaluate_trial_results:}
%
%    The purpose of |\xor_evaluate_trial_results:| is to determine if
%    the current trial is a potential candiate for the final solution
%    and if so store it away. We can determine if the trial failed by
%    looking at the switch |@fail|.
%    \begin{macrocode}
\def_new:Npn \xor_evaluate_trial_results:{
%<*trace>
  \trace_push:n{xor_evaluate_trial_results:}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
  \bool_if:NT \g_xor_trial_with_floats_bool
  {
    \tlp_if_eq:NNT \xor_try_this_area:\xor_try_this_area_std:
    {
      \int_set:Nn \l_tmpa_int \g_xor_trial_here_seen_num
      \int_add:Nn \l_tmpa_int \g_xor_page_float_int
      \int_compare:nNnT \pagesetup@max@float@num < \l_tmpa_int
      {
%<*trace>
        \trace:n{Failed:~ area~ +~ here~ floats~ exceed~ max~ floats}
%</trace>
%<*progress>
        \xor_progress_failed:n{area~ +~ here~ floats~ exceed~ max~ floats}
%</progress>
        \bool_gset_true:N \g_xor_trial_failed_bool
      }
    }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
  \bool_if:NTF \g_xor_trial_failed_bool
  {
%<*trace>
    \trace:n{fail:~true}
%</trace>
%    \end{macrocode}
%    If we have been doing balancing the status needs to be brought back to
%    \begin{macrocode}
%    initial state. Probably should be done elsewhere instead.\footnote{check/fix}
    \dim_gzero:N \g_xor_balance_delta_dim
    \bool_gset_false:N \g_xor_balance_point_expected_bool
    \bool_gset_false:N \g_xor_balance_finish_bool
%<*trace>
    \trace:n{BALANCE:~ g_xor_balance_point_expected_bool~ <-~ false}
%</trace>
%    \end{macrocode}
%    If the trial has failed we have to distinguish two cases:
%    \begin{itemize}
%    \item
%      There has been a request for flushing out floats up to a
%      certain float somewhere
%      and the current float belongs to the list of floats to flush.
%    \item
%      There has been no such request.
%    \end{itemize}
%
%    If there have been flush points we need to restore their
%    |min_col| values since we might have updated them.
%    \begin{macrocode}
    \bool_if:NT \g_xor_flush_seen_bool
      \xor_trial_restore_flush:

    \bool_if:NTF \g_xor_flush_failed_bool
    {
%<*trace>
      \trace:n{flushfail:~true}
%</trace>
%    \end{macrocode}
%    If we have failed and |\xor_try_this_area:| is already the ``relaxed''
%    version we have to artificially move the offending flush point to
%    the next column and hope that this way we get ourselves some new
%    options (worst case is that eventually the flush point is removed
%    from the page in which case we can as a last resort defer the
%    float).
%    \begin{macrocode}
      \tlp_if_eq:NNT \xor_try_this_area:\xor_try_this_area_relaxed:
      {
        \num_gincr:c {g_xor_flush_ \g_xor_trial_flush_seen_num
                      _min_col_num}
%<*trace>
        \trace:n{g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num ~ <-~
               \num_use:c {g_xor_flush_
                           \g_xor_trial_flush_seen_num _min_col_num}
              }
%</trace>
%<*progress>
        \xor_progress_failed:n{flush~ point~ \g_xor_trial_flush_seen_num\space
                     moved~ to~ column~
                     \num_use:c {g_xor_flush_
                                 \g_xor_trial_flush_seen_num _min_col_num}
                    }
%</progress>
      }
      {
%    \end{macrocode}
%    Next test is a safety measure which probably can go away at some
%    point: the saved open area list should contain at least the area
%    that was used during this trial \ldots\ however the number of
%    times the algorithm got screwed up during
%    development suggested this as a good catch point (:-)
%    \begin{macrocode}
        \clist_if_empty:NTF \g_xor_saved_this_areas_open_clist
        {
%<*debug>
          \trace:n{g_xor_saved_this_areas_open_clist:~empty ????????}
%</debug>
          \ERROR
        }
        {
%    \end{macrocode}
%    If we have failed and |\xor_try_this_area:| is not yet ``relaxed''
%    we can retry with less restrict placement conditions.
%    \begin{macrocode}
          \xor_relax_float_placement_conditions:
        }
      }
    }
    {
%<*trace>
      \trace:n{flushfail:~false}
%</trace>
      \bool_if:NTF \g_xor_balance_failed_bool
      {
%<*trace>
        \trace:n{balancefail:~true}
%</trace>
        \bool_gset_false:N \g_xor_balance_failed_bool
      }
      {
        \clist_gpop:NN \g_xor_this_areas_open_clist \l_tmpa_tlp
      }
    }
%<*trace>
    \trace:n{open:~\g_xor_this_areas_open_clist}
%</trace>
%    \end{macrocode}
%    To restore the previous state we have to recalculate the target
%    |fl@| column. However, there is nothing to restore if we haven't
%    run the trial with floats.
%    \begin{macrocode}
    \bool_if:NT \g_xor_trial_with_floats_bool
    { \xor_trial_restore_flseq: }
  }
  {
%<*trace>
    \trace:n{fail:~false}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*progress>
    \tlp_set_eq:NN \l_xor_progress_pending_info_tlp \c_empty_tlp
%</progress>
%    \end{macrocode}

%    \begin{macrocode}
%%B
    \bool_if:NF \g_xor_trial_with_floats_bool
       { \num_gset_eq:NN \g_xor_best_balance_done_num
                         \g_xor_trial_balance_done_num
       }
%    \end{macrocode}
%    If this trial is valid and we haven't seen all flush penalties
%    again we must have pushed them  to the next page. We record
%    this fact by setting |\g_xor_flush_..._min_col_num| to |\maxdimen|.
%    \begin{macrocode}
    \bool_if:NT \g_xor_flush_seen_bool
    {
      \int_set:Nn \l_loop_int \g_xor_collect_flush_seen_num
      \int_whiledo:nNnT \g_xor_trial_flush_seen_num < \l_loop_int
      {
        \num_gset:cn {g_xor_flush_ \int_use:N \l_loop_int _min_col_num} \maxdimen
%<*trace>
        \trace:n{g_xor_flush_ \int_use:N \l_loop_int _min_col_num \space <-~ maxdimen}
%</trace>
        \int_decr:N \l_loop_int
      }
%    \end{macrocode}
%    If there has been a flush point (ie if |\g_xor_trial_flush_seen_num| and
%    thus |\l_loop_int| is greater than 0) we test whether or not the
%    float recently placed was the last one affected by the last flush
%    point on the current page and if so tighten the float placement
%    setting again.\footnote{correct logic?}
%    \begin{macrocode}
%<*progress>
      \tlp_set_eq:NN \l_xor_progress_pending_info_tlp \c_empty_tlp
%</progress>
      \bool_if:NT \g_xor_trial_with_floats_bool
        {
         \int_compare:nNnT \l_loop_int > \c_zero    
           {
            \int_compare:nNnT  
              { \num_use:c {g_xor_flush_  \num_use:N \g_xor_trial_flush_seen_num
                            _last_float_num} } 
                        =  { \num_use:N \g_xor_this_flseq_num }
              {
%<*trace>
               \trace:n{flush:~ last~float~affected~ by~ flush~ point~
                      \num_use:N \g_xor_trial_flush_seen_num\space placed~ ->~
                       use~ partly~ normal~ placement~ conditions~ again}
%</trace>
%<*progress>
                \tlp_set:Nn \l_xor_progress_pending_info_tlp {
                  \xor_progress_newline:n{->~ past~ flush~ point:~ -->~
                              tighten~ conditions~ again}
                    \xor_progress_newline:n{}
                }
%</progress>
                \xor_partly_tighten_float_placement_conditions:
               }
            }
         }
%    \end{macrocode}
%    Having placed a float we need to update |\g_xor_flush_max_classes_clist| to
%    reflect which float types are affected by the flush points
%    currently on the page as this might be needed when trying to
%    place or rather defer the next float.
%
%    So we loop and concatenate all |\g_xor_flush_|\meta{num}|_classes_clist| that
%    belong to flush points on the current page. This might result in
%    the list containing types several times but for the test we need
%    to do this doesn't make any difference (and it is far faster than
%    unifying the list).
%    \begin{macrocode}
      \int_zero:N \l_loop_int
      \clist_gclear:N \g_xor_flush_max_classes_clist
      \int_whiledo:nNnT \g_xor_trial_flush_seen_num > \l_loop_int
      {
        \int_incr:N \l_loop_int
        \clist_gconcat:NNc
           \g_xor_flush_max_classes_clist
           \g_xor_flush_max_classes_clist
           {g_xor_flush_ \int_use:N \l_loop_int _classes_clist}
%<*trace>
        \trace:n{g_xor_flush_max_classes_clist~ <-~ \g_xor_flush_max_classes_clist}
%</trace>
      }
    }
%    \end{macrocode}
%
%    With this algorithm a trial which passed so far is always
%    considered to be better than previous trials (meaning more floats
%    on the page are better). So we always update the best trial data
%    (unless this was the run without adding floats in which case we
%    only change the |\g_xor_trial_with_floats_bool| switch).
%    \begin{macrocode}
    \bool_if:NTF \g_xor_trial_with_floats_bool
    {
      \update@best@trial
%<*progress>
      \l_xor_progress_pending_info_tlp
%</progress>
    }
    { \bool_gset_true:N \g_xor_trial_with_floats_bool }
  }
%<*trace>
  \trace_pop:n{xor_evaluate_trial_results:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_trial_restore_flseq:}
%
%    \begin{macrocode}
\def_new:Npn \xor_trial_restore_flseq: {
%<*trace>
  \trace_push:n{xor_trial_restore_flseq:}
  \trace:n{restore:~last~allocated:~\g_xor_saved_flseq_num}
%</trace>
  \xor_calculate_float_col:
  \num_gset_eq:cN {g_xor_flseq_type_ \g_xor_this_class_tlp _col_
                    \num_use:N \l_xor_returned_float_col_num _num}
                    \g_xor_saved_flseq_num
%<*trace>
  \trace:n{~g_xor_flseq_type_ \g_xor_this_class_tlp _col_
          \num_use:N \l_xor_returned_float_col_num _num \space <-~
          \g_xor_saved_flseq_num \space (restored)}
%</trace>
%    \end{macrocode}
%    And if we tried a top area we also have to restore the
%    corresponding \\
%    |\g_xor_flseq_areas_top_type_...| macro.
%    \begin{macrocode}
  \if:w t\g_xor_this_area_type_tlp
    \num_gset_eq:cN {g_xor_flseq_areas_top_type_ \g_xor_this_class_tlp _col_
                      \num_use:N \l_xor_returned_float_col_num _num}
                      \g_xor_saved_flseq_top_areas_num
%<*trace>
    \trace:n{~g_xor_flseq_areas_top_type_ \g_xor_this_class_tlp _col_
            \num_use:N \l_xor_returned_float_col_num _num \space <-~
            \g_xor_saved_flseq_top_areas_num \space (restored)}
%</trace>
  \fi:
%    \end{macrocode}
%    And we better don't forget to restore the heights.\footnote{This
%    is most likely buggy: I seem to restore all column values but i think
%    i don't save all of them! FIX!!!!}
%    \begin{macrocode}
  \xor_update_this_area_span_cols:n
   {
%<*trace>
    \trace:n{restore:~g_xor_ht_col_
            \int_use:N \l_xor_update_col_int
                    _dim :~
            \tlp_use:c {g_xor_saved_ht_col_
                        \int_use:N \l_xor_update_col_int
                      _tlp}
           }
%</trace>
      %%\cs_show:c{g_xor_saved_ht_col_ \int_use:N \l_xor_update_col_int _tlp}
      \dim_gset:cc {g_xor      _ht_col_ \int_use:N \l_xor_update_col_int _dim}
                   {g_xor_saved_ht_col_ \int_use:N \l_xor_update_col_int _tlp}
%<*trace>
    \trace:n{restore:~g_xor_bottom_ht_col_
            \int_use:N \l_xor_update_col_int
                    _dim :~
            \tlp_use:c {g_xor_saved_bottom_ht_col_
                        \int_use:N \l_xor_update_col_int
                       _tlp}
           }
%</trace>
      %%\cs_show:c{g_xor_saved_bottom_ht_col_  \int_use:N \l_xor_update_col_int _tlp}
      \dim_gset:cc {g_xor_bottom_ht_col_       \int_use:N \l_xor_update_col_int _dim}
                   {g_xor_saved_bottom_ht_col_ \int_use:N \l_xor_update_col_int _tlp}
%    \end{macrocode}
%    \begin{macrocode}
    \tlp_gset_eq:cc
        {g_xor_       \g_xor_this_area_type_tlp _delta_col_
                      \int_use:N \l_xor_update_col_int _tlp}
        {g_xor_saved_ \g_xor_this_area_type_tlp _delta_col_
                      \int_use:N \l_xor_update_col_int _tlp}
%<*trace>
    \trace:n{GRID (delta):~ column~\int_use:N \l_xor_update_col_int
                          \g_xor_this_area_type_tlp :~
            \tlp_use:c {g_xor_saved_ \g_xor_this_area_type_tlp
                    _delta_col_
                        \int_use:N \l_xor_update_col_int _tlp}
            \space  (restore) }
%</trace>
  }
%<*trace>
  \trace_pop:n{xor_trial_restore_flseq:}
%</trace>
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\xor_trial_restore_flush:}
%
%    \begin{macrocode}
\def_new:Npn \xor_trial_restore_flush: {
%<*trace>
  \trace_push:n{xor_trial_restore_flush:}
%</trace>
  \int_zero:N \l_loop_int
  \int_whiledo:nNnT \g_xor_collect_flush_seen_num>\l_loop_int
  {
    \int_incr:N \l_loop_int
      \num_gset_eq:cc
          {g_xor_flush_ \int_use:N \l_loop_int _min_col_num}
          {g_xor_saved_flush_ \int_use:N \l_loop_int _min_col_num}
%<*trace>
      \trace:n{g_xor_flush_ \int_use:N \l_loop_int _min_col_num\space <-~
            \num_use:c {g_xor_flush_ \int_use:N \l_loop_int _min_col_num} ~
            (restore) }
%</trace>
  }
%<*trace>
  \trace_pop:n{xor_trial_restore_flush:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\g_xor_saved_flseq_num}
% \begin{macro}{\g_xor_saved_flseq_top_areas_num}
%    \begin{macrocode}
\num_new:N \g_xor_saved_flseq_num
\num_new:N \g_xor_saved_flseq_top_areas_num
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \subsection{Best Trial Data}
%
%
% \begin{macro}{\g_xor_best_trial_col_hts_tlp}
%    This macro holds the column heights for all columns in the best
%    trial (i.e., |\textheight| minus allocated floats minus and
%    material already balanced).
%    \begin{macrocode}
\tlp_new:N \g_xor_best_trial_col_hts_tlp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\update@best@trial}
%    Not all of this belongs into this macro!\footnote{redistribute}
%    \begin{macrocode}
\def_new:Npn \update@best@trial{
%<*trace>
  \trace_push:n{update@best@trial}
%</trace>
%<*progress>
  \xor_progress_newline:n{->~ accepted}
%</progress>
  \tlp_gset_eq:NN \g_xor_best_trial_col_hts_tlp
                  \g_xor_saved_trial_col_hts_tlp

%<*trace>
  \trace:n{new~ best~ trial:~ \tlp_to_str:N \g_xor_best_trial_col_hts_tlp}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
%%B
   \num_gset_eq:NN \g_xor_best_balance_done_num
                   \g_xor_trial_balance_done_num
%    \end{macrocode}
%
%    Frank says this needs to be documented (the rest of the code is
%    self evident) |\g_xor_this_float_box_tlp| is |\let| to
%    |\g_xor_curr_float_box_tlp| which is defed to a chardefed token
%    from newinsert. so this is OK. honest.
%    \begin{macrocode}
  \seq_gput_right:co {g_xor_area_\g_xor_this_area_name_tlp _seq}
                      \g_xor_this_float_box_tlp
%    \end{macrocode}
%
%    \begin{macrocode}
%<*trace>
  \trace:n{g_xor_curr_page_areas_closed_clist 
          ~\g_xor_curr_page_areas_closed_clist\space +~
          "\clist_use:c{g_xor_ \g_xor_this_area_name_tlp _all_close_clist}"}
  \trace:n{g_xor_this_areas_closed_clist~ \g_xor_this_areas_closed_clist\space +~
          "\clist_use:c{g_xor_ \g_xor_this_area_name_tlp _class_close_clist}"}
%</trace>
  \clist_gput_right:NC \g_xor_curr_page_areas_closed_clist
                        {g_xor_ \g_xor_this_area_name_tlp _all_close_clist}
  \clist_gput_right:NC \g_xor_this_areas_closed_clist
                        {g_xor_ \g_xor_this_area_name_tlp _class_close_clist}
%    \end{macrocode}
%
%    Check: why the remark "tmp"?\footnote{FIX}
%    \begin{macrocode}
  \clist_gset_eq:cN {g_xor_class_ \g_xor_this_class_tlp _areas_closed_clist} % FMi tmp
                    \g_xor_this_areas_closed_clist
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_gincr:N \g_xor_page_float_int
  \int_gincr:c {g_xor_area_ \g_xor_this_area_name_tlp _float_int}
%    \end{macrocode}
%
%    Since the trial was successful, we have to update the the macros
%    that hold the number of top or bottom floats we have seen so far
%    in each column.\footnote{Code for this is similar to the one in
%    construct@and@test@col@ht and elsewhere; perhaps there should be
%    a subroutine for it!}
%    \begin{macrocode}
  \xor_update_this_area_span_cols:n
  {
    \num_gincr:c
        {g_xor_ \g_xor_this_area_type_tlp _floats_col_
        \int_use:N \l_xor_update_col_int _num}
%<*trace>
    \trace:n{g_xor_ \g_xor_this_area_type_tlp
          _floats_col_ \int_use:N \l_xor_update_col_int _num <-~
          \num_use:c {g_xor_ \g_xor_this_area_type_tlp
                      _floats_col \int_use:N \l_xor_update_col_int _num}
    }
%</trace>
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<*trace>
  \trace:n{area:~\g_xor_this_area_name_tlp\space 
         \csname g_xor_area_ \g_xor_this_area_name_tlp _seq \endcsname}
  \trace_pop:n{update@best@trial}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \newpage
%
% \subsection{Best Column Output Routine}
%
% \begin{description}
% \item[Entry:] |\xor_OR_best_cols_setup:|
% \item[Exit:]  |\xor_collect_setup:|
% \item[Prereq:]
% \item[Description:]
% \item[Flow:]
%\begin{footnotesize}
%\begin{verbatim}
%    \xor_OR_best_cols_setup:
%            |
%    New OR: \xor_OR_grab_best_cols:
%            |
%            V
%    \xor_OR_best_next_col_setup: <-------
%            |
%    (when entering OR...)
%            |
%    <end of collection reached?>
%         |          |
%        yes        no
%         |          |
%         |     <col break requested?>
%         |          |        |
%         |         yes       no
%         |          |        |
%         |          |     <flush point encountered?>
%         |          |        |                  |
%         |          |       yes                 no
%         |          |        |                  |
%         |          | <flush point         <here point encountered?>
%         |          |      too early?>        |               |
%         |          |    |      |            yes              no
%         |          |   yes    no             |               |
%         |          |    |      |             ?               ?
%         |          |    | (ignore break)
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
% (end column now) <-------      |
%         |                      |
%         V                      |
%   <all cols produced?>         |
%      |           |             V
%     yes          no--------------------> (reenter \xor_OR_best_next_col_setup:)
%      |
% (produce final page)
%      |
%      V
%  \xor_next_page_setup:
%      |
%      V
% (try to make float pages)
%      |
%      V
%  \xor_collect_setup:
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%
% After the best trial is chosen the |\xor_OR_grab_best_cols:| output routines
% are executed. Structurally this is similar to the grab column output
% routines used during the trials, but this time information
% about the float placements is recorded in the float area lists
% and also optionally in float placement control files.
%
% \begin{macro}{\xor_OR_best_cols_setup:}
%    This is the initialisation code for producing the final best set
%    of columns (via the |\xor_OR_grab_best_cols:| output routine).
%    \begin{macrocode}
\def_new:Npn \xor_OR_best_cols_setup:{
%<*trace>
  \trace_push:n{xor_OR_best_cols_setup:}
%</trace>
%<*trace>
    \trace:n{XX~initial:~
           \tlp_to_str:N \g_xor_best_trial_col_hts_tlp}
%</trace>
  \g_xor_best_trial_col_hts_tlp
  \xor_forall_columns:n {
      \dim_gset:cc {g_xor_best_ht_col_ \int_use:N \g_xor_curr_col_int _dim}
                   {g_xor_ht_col_ \int_use:N \g_xor_curr_col_int _dim}
     }

  \int_gzero:N \g_xor_curr_col_int
  \num_gzero:N \g_xor_trial_flush_seen_num
  \num_gzero:N \g_xor_trial_here_seen_num
  \num_gzero:N \g_xor_trial_balance_seen_num
%<*trace>
  \trace:n{BALANCE:~ g_xor_trial_balance_seen_num ~<-~
                    \num_use:N \g_xor_trial_balance_seen_num}
%</trace>
  \xor_perhaps_write_placements_to_fpl_file:

%<*trace>
  \trace:n{Setting~ up~ column~ heights:}
%</trace>

  \num_gset_eq:NN \g_xor_trial_balance_done_num
                  \g_xor_best_balance_done_num

  \if_xor_grab_for_balance_done:TF
  {
%<*trace>
     \trace:n{\tlp_to_str:c {g_xor_best_trial_col_hts_balance_
                           \num_use:N \g_xor_trial_balance_seen_num
                           _tlp }
           }
%</trace>
     \tlp_use:c {g_xor_best_trial_col_hts_balance_
                 \num_use:N \g_xor_trial_balance_seen_num
                 _tlp}
  }
  {
%<*trace>
    \trace:n{Setting~ up~ column~ heights:~ 
           \tlp_to_str:N \g_xor_best_trial_col_hts_tlp}
%</trace>
    \g_xor_best_trial_col_hts_tlp
  }
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_initialise_footins_action:
%    \end{macrocode}
%
%    \begin{macrocode}
   \xor_OR_best_balance_setup:
%<*trace>
 \trace_pop:n{xor_OR_best_cols_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}

%
% \begin{macro}{\xor_OR_best_next_col_setup:}
%    \begin{macrocode}
\def_new:Npn \xor_OR_best_next_col_setup:{
%<*trace>
  \trace_push:n{xor_OR_best_next_col_setup:}
%</trace>
  \int_gincr:N \g_xor_curr_col_int
  \dim_gset:Nc \vsize {g_xor_ht_col_
                       \int_use:N\g_xor_curr_col_int
                       _dim}
%<*trace>
  \trace:n{vsize~ <-~ \dim_use:N \vsize }
%</trace>
%    \end{macrocode}
%    tmp\footnote{fix implement differently} --- same code/logic as in
%    |\xor_OR_trial_grab_next_col_setup:|
%    \begin{macrocode}
  \dim_compare:nNnF \vsize > \baselineskip
    { \ignorethiscolumn  \par\null\penalty-10003\relax}
%<*trace>
  \trace_pop:n{xor_OR_best_next_col_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_OR_grab_best_cols:}
%    Here is the output routine used when preparing the final columns,
%    an instantiation of |\xor_OR_grab_some_cols:nnnnn|. In contrast to the version
%    used for |\xor_OR_grab_trial_cols:| it doesn't do the tests.
%    \begin{macrocode}
\def_new:Npn \xor_OR_grab_best_cols: {
  \xor_OR_grab_some_cols:nnnnn{best}
    \xor_OR_best_finish_col:
    {
      \@reinserts
      \vbox_unpack_clear:N\c_twohundred_fifty_five
%    \end{macrocode}
%    Next line not okay! we need to add a penalty here but which one?
%    Or we need a different mechanism using either |\holdinginserts|
%    or a partial box line in collection OR.\footnote{FIX!!! there is
%    also another place like this!}
%    \begin{macrocode}
%       \penalty\c_zero  %FMi?
    }
    {
      \xor_perhaps_write_to_fpl_file:n{
        \@spaces Area:~hhh^^J
        \exp_after:NN 
        \xor_gen_float_placement_fpl_info:nnnnnnn
           \the\toks\g_xor_curr_float_box_tlp
      }
      \xor_typeset_a_here_float:
    }
%    \end{macrocode}
%    What to do if we encouter a balance point; right now this needs to be a
%    function with two args.
%    \begin{macrocode}
    {
      \xor_best_handle_balance_point:nn
    }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%  \begin{macro}{\xor_best_handle_balance_point:nn}
%    
%    \begin{macrocode}
\def_new:Npn \xor_best_handle_balance_point:nn #1 #2 {
%<*trace>
  \trace_push:n{xor_best_handle_balance_point:nn}
%</trace>
%    \end{macrocode}
%    
%    \begin{macrocode}
   \int_set:Nn \l_tmpa_int \g_xor_curr_col_int
   \int_whiledo:nNnT \l_tmpa_int < \g_xor_cols_int
     {
       \int_incr:N \l_tmpa_int
%<*trace>
  \trace:n{BALANCE:~ gen~ empty~ col~ \the\g_xor_curr_col_int}
%</trace>
       \endgraf \null \break
     }
%    \end{macrocode}
%    
%    \begin{macrocode}
   #1
%<*trace>
  \trace_pop:n{xor_best_handle_balance_point:nn}
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%
% \begin{macro}{\xor_OR_best_finish_col:}
%
%    \begin{macrocode}
\def_new:Npn \xor_OR_best_finish_col:{
%<*trace>
  \trace_push:n{xor_OR_best_finish_col:}
%</trace>
  \xmark_update_structure
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_deal_with_footins_action:
%    \end{macrocode}
%
% save all marks here\footnote{not done yet!}
%
% add floats and footnotes etc to collected column
%
%    \begin{macrocode}
  \if_xor_grab_for_balance_done:TF
  {
%<*trace>
    \trace:n{BALANCE:~ storing~ away~ col~ \int_use:N \g_xor_curr_col_int}
%</trace>
    \box_if_empty:cTF {g_xor_col_
                    \int_use:N \g_xor_curr_col_int
                    _balance_box }
    {
%<*trace>
    \trace:n{BALANCE:~ box~ empty~ }
%</trace>
       \box_gset_eq:cN {g_xor_col_
       \int_use:N \g_xor_curr_col_int
       _balance_box}
          \c_twohundred_fifty_five
    }
    {
%<*trace>
      \trace:n{BALANCE:~ box~ already~ used~ }
%</trace>
      \dim_set:Nn \l_tmpa_dim
      { \box_dp:c { g_xor_col_
                  \int_use:N \g_xor_curr_col_int
                  _balance_box
        }
      }
      \vbox_gset:cn
      {g_xor_col_
            \int_use:N \g_xor_curr_col_int
            _balance_box }
      { \box_use_clear:c {g_xor_col_
                              \int_use:N \g_xor_curr_col_int
                              _balance_box }
        \vskip -\l_tmpa_dim
        \hrule\kern-0.4pt
        \box_use_clear:N \c_twohundred_fifty_five
      }
%<*trace>
      {
        \showoutput
        \showboxdepth1\relax
        \scrollmode
        \box_show:c {g_xor_col_
                    \int_use:N \g_xor_curr_col_int
                    _balance_box }
      }
%</trace>
    }

% very inefficient this way and only tmp

      \vbox_gset:cn
      {g_xor_col_
            \int_use:N \g_xor_curr_col_int
            _balance_box }
      { \box_use_clear:c {g_xor_col_
                              \int_use:N \g_xor_curr_col_int
                              _balance_box }
        \ifvoid\footins   \else
          \vskip \skip\footins
          \vbox_unpack_clear:N \footins
        \fi
      }

    \int_compare:nNnT \g_xor_curr_col_int=\g_xor_cols_int
    {
      \num_gincr:N \g_xor_trial_balance_seen_num
%<*trace>
      \trace:n{BALANCE:~ g_xor_trial_balance_seen_num ~<-~
                      \num_use:N \g_xor_trial_balance_seen_num}
%</trace>
      \int_gzero:N \g_xor_curr_col_int
      \if_xor_grab_for_balance_done:TF
      {
%<*trace>
       \trace:n{Setting~ up~ balance~ column~ heights:~
        \tlp_to_str:c { g_xor_best_trial_col_hts_balance_
                       \num_use:N \g_xor_trial_balance_seen_num
                       _tlp }}
%</trace>
        \tlp_use:c {g_xor_best_trial_col_hts_balance_
                   \num_use:N \g_xor_trial_balance_seen_num
                   _tlp}
      }
      {
%<*trace>
       \trace:n{Setting~ up~ column~ heights:~
        \tlp_to_str:N \g_xor_balance_trial_col_hts_tlp}
%</trace>
        \g_xor_balance_trial_col_hts_tlp
      }
    }
  }
  {
    \xor_produce_final_column:
  }
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_compare:nNnTF \g_xor_curr_col_int=\g_xor_cols_int
  {
    \xor_produce_final_page:
    \xor_next_page_setup:
    \xor_try_float_pages:
    \place@deferred@floats
    \xor_collect_setup:
%{\showoutput\showlists}
  }
  {
    \xor_OR_best_next_col_setup:
  }
%<*trace>
  \trace_pop:n{xor_OR_best_finish_col:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_next_page_setup:}
%    Initialises the column heights to text height. Clear the float
%    area lists, zero |\holdinginserts| to allow footnote texts to arrive
%    in the insertion box.
%    \begin{macrocode}
\def_new:Npn\xor_next_page_setup:{
%<*trace>
  \trace_push:n{xor_next_page_setup:}
%</trace>
%
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_cols_setup:
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_area_setup:
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_gzero:N \g_xor_page_float_int
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_initialise_flush_data:
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_initialise_here_data:
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_initialise_footins_action:
%    \end{macrocode}
%
%    Nothing is closed when we are at the start of a page.
%    \begin{macrocode}
  \clist_gclear:N \g_xor_curr_page_areas_closed_clist
%    \end{macrocode}
%
%    \begin{macrocode}
  \seq_map:NN \g_xor_float_classes_seq
              \xor_float_class_setup:n
%    \end{macrocode}
%    for safety
%    \begin{macrocode}
  \tlp_gset_eq:NN \g_xor_this_float_box_tlp \@undefined
%<*trace>
  \trace_pop:n{xor_next_page_setup:}
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%
%
% \begin{macro}{\xor_handle_forced_pagebreak:}
%    This is related to |\xor_handle_premature_ending:| but we have
%    to return the penalty only if we haven't reached the last column.
%    If we don't do this we would start collecting material in the
%    middle of final page generation!
%    \begin{macrocode}
\def_new:Npn \xor_handle_forced_pagebreak:{
  \int_compare:nNnT \g_xor_curr_col_int<\g_xor_cols_int
    \@emptycol
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \newpage
%
% \subsection{Cleanup Output Routine}
%
% \begin{description}
% \item[Entry:] |\xor_OR_cleanup_setup:N|
% \item[Exit:]  |#1|
% \item[Prereq:]
% \item[Description:]
%    Responsible for discarding unused text still on Main Vertical
%    List After the end of a trial. It eats everything until it sees
%    the special penalty marking the end of the last collection output
%    routine. This output routine may need to be called several times
%    in succession due to forced penalties in the galley.
% \item[Flow:]
%\begin{footnotesize}
%\begin{verbatim}
%    \xor_OR_cleanup_setup:N #1
%           |
%           V
%    New OR: \xor_OR_cleanup:N #1
%           |
%           V
% <special outputpenalty reached?> --> #1
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%
% \begin{macro}{\xor_OR_cleanup_setup:N}
%    \begin{macrocode}
\def_new:Npn \xor_OR_cleanup_setup:N #1 {
  \dim_gset:Nn \vsize \c_max_skip
  \pref_global:D \output{\xor_OR_cleanup:N #1}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_OR_cleanup:N}
%    In the actual output routine we grab text and throw it away until
%    we see the special output penalty. Then we prepare for the trials
%    to place the floats properly.
%    \begin{macrocode}
\def_new:Npn \xor_OR_cleanup:N #1 {
%<*trace>
  \trace_push:n{xor_OR_cleanup:N}
  \trace:n{output~pen:~ \the\outputpenalty}
%</trace>
%    \end{macrocode}
%    Throw everything away \ldots
%    \begin{macrocode}
  \box_gclear:N \c_twohundred_fifty_five
  \box_gclear:N \footins
%    \end{macrocode}
%    \ldots\ until we see the special output penalty again.
%    \begin{macrocode}
  \int_compare:nNnT \outputpenalty={-\c_xor_output_collect_penalty}  { #1 }
%<*trace>
  \trace_pop:n{xor_OR_cleanup:N}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \newpage
%
% \subsection{Making float pages}
%
%
% \begin{description}
% \item[Entry:] |\xor_try_float_pages:|
% \item[Exit:]  --- (this happens within the OR)\\
%    On exit |\g_xor_area_DDD_seq| will be empty and the floats not being put
%    onto float pages are moved to |\g_xor_floats_active_seq| (those that have
%    their call outs on previous pages) and |\g_xor_floats_mvl_seq| (those that
%    have their call outs still on the MVL).
% \item[Prereq:] |\g_xor_area_DDD_seq| contains the float to work on; all other
%    areas are empty.
% \item[Description:]
% \item[Flow:]
%\begin{footnotesize}
%\begin{verbatim}
%   \xor_try_float_pages:
%         |
%         V
%  <\g_xor_area_DDD_seq has floats?>
%      |          |
% ----no         yes
% |               |
% |               V
% |  (split \g_xor_area_DDD_seq into \g_xor_floats_active_seq and 
% |   \g_xor_floats_mvl_seq; setup trial conditions)
% |               |
% |               V
% |           \try@float@page <----------------------
% |               |                                  |
% |          <float page produced?>                  |
% |             |         |                          |
% |            no        yes                         |
% |             |         |                          |
% |             |     (output page)                  |
% |             |         |                          |
% |             |     (move new \g_xor_area_DDD_seq  |
% |             |      to \g_xor_floats_active_seq)  |
% |             |         |                          |
% |             |         ---------------------------
% |             |
% |             |
% |   (restore float conditions before last trial)
% |             |
% |   (restore trial condition to normal)
% |             |
% ------------->|
%               |
%               V
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%
%
% \begin{macro}{\xor_try_float_pages:}
%
%    \begin{macrocode}
\def_new:Npn \xor_try_float_pages: {
%<*trace>
  \trace_push:n{xor_try_float_pages:}
%</trace>
%<-trace>  \seq_if_empty:NF
%<+trace>  \seq_if_empty:NTF
  \g_xor_area_DDD_seq
%<+trace>       { \trace:n{no~ deferred~ floats} }
  {
    \glet:NN \xor_floats_active_seq_if_empty_action: \do_nothing:
    \glet:NN \pretests@success@action \floatpage@pretests@success@action
%    \end{macrocode}
%    this is only a tmp: we just use |\xor_try_this_area_relaxed:| but of
%    course there should be different rules for float pages (and
%    different float areas and \ldots)
%    \begin{macrocode}
    \glet:NN \xor_try_this_area: \xor_try_this_area_relaxed:
%    \end{macrocode}
%
%    First thing to do is to split the list of deferred floats into
%    those that have ther callouts already typeset (on previous pages)
%    and those that we have only seen because we looked a bit
%    ahead. For making float pages we can only use the former.
%    \begin{macrocode}
    \seq_map:NN \g_xor_area_DDD_seq
                \xor_redistributed_defer_list_float:n
    \seq_gclear:N\g_xor_area_DDD_seq
%    \end{macrocode}
%    Now we loop until we fail to make float pages. The actual work is
%    done in the macro |\try@float@page|.
%    \begin{macrocode}
    \bool_gset_true:N \g_xor_float_page_bool
    \bool_whiledo:NT \g_xor_float_page_bool
    {
      \group_begin: % no nesting of \loop without grouping ...
%    \end{macrocode}
%   Does the extra group matter now? MH
%
%    A bit statistics: how many floats do we have on the
%    |\g_xor_floats_active_seq|?
%    \begin{macrocode}
%<*progress>
        \seq_map_inline:Nn
          \g_xor_floats_active_seq
          {\num_gincr:N\g_xor_trials_done_num}
        \xor_progress_newline:n{}
        \xor_progress_separator:
        \xor_progress_newline:n{STATS:~ floats~ waiting~ =~ \num_use:N\g_xor_trials_done_num
                \space on~ page~ \num_use:N \g_xor_page_absolute_num \space
                (float~ page)}
        \xor_progress_separator:
        \num_gzero:N \g_xor_trials_done_num
%</progress>
%    \end{macrocode}
%    \begin{macrocode}
        \try@float@page
      \group_end:
    }
%    \end{macrocode}
%    Once we are finished we have to return to normal trial
%    conditions, so\ldots
%    \begin{macrocode}
    \glet:NN \xor_try_this_area: \xor_try_this_area_std:
  }
%<*trace>
  \trace_pop:n{xor_try_float_pages:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\try@float@page}
%    This macro tries to build a single float page from the floats in
%    |\g_xor_floats_active_seq|. If it fails it (tries to) restores the state of
%    the floats. If it succeeds it will output a float page and returns.
%    \begin{macrocode}
\def_new:Npn \try@float@page {
%<*trace>
  \trace_push:n{try@float@page}
%</trace>
%    \end{macrocode}
%    Save the current state in case of failure then run the float
%    placement loop (setup for this loop should have happened
%    earlier).
%    \begin{macrocode}
  \xor_save_current_float_state:
  \xor_trial_place_float_inner_loop:
%
%\typeout{float.list.after.trial}
%\showfloatlists
%
%    \end{macrocode}
%    Loop through all ``text columns'' and add up their heights. This
%    is again only done to have some sort of measure for float pages
%    and should be removed once some real code gets into this part.
%    \begin{macrocode}
  \dim_zero:N \l_tmpa_dim
  \xor_forall_columns:n
  {
%<*trace>
    \trace:n{\box_ht:N\int_use:N\g_xor_curr_col_int=
            \dim_use:c {g_xor_ht_col_ \int_use:N\g_xor_curr_col_int
                      _dim}
    }
%</trace>
    \dim_add:Nc \l_tmpa_dim
                {g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim}
  }
%    \end{macrocode}
%
%    If the sum of all white space is more than 300pt :-)
%    \begin{macrocode}
  \dim_compare:nNnTF \l_tmpa_dim > {300pt}
  {
%    \end{macrocode}
%    we fail
%    \begin{macrocode}
    \bool_gset_false:N \g_xor_float_page_bool
%<*trace>
    \trace:n{float~page~failed}
%</trace>
%<*progress>
    \xor_progress_failed:n{no~ float~ page~ made}
    \xor_progress_newline:n{}
%</progress>
%    \end{macrocode}
%    Return to the previous state (and as can be seen by using
%    |\xor_next_page_setup:|) this needs some work; the latter might
%    in fact do too much like calling
%    |\initialise@flush@num|!\footnote{FIX}
%    \begin{macrocode}
    \g_saved_float_state_tlp
%    \end{macrocode}
%    To avoid having |\initialise@flush@num| do anything harmful we
%    set \\
%    |\g_xor_trial_flush_seen_num| to zero at this point.\footnote{This
%    needs fixing properly! and what about balance points?} And the same is
%                   necessary for 
%    |\initialise@here@num|.
%    \begin{macrocode}
    \num_gzero:N \g_xor_trial_flush_seen_num
    \num_gzero:N \g_xor_trial_here_seen_num
    \xor_next_page_setup:
  }
  {
%    \end{macrocode}
%    Otherwise we claim we have  a good float page.
%    \begin{macrocode}
%<*trace>
    \trace:n{float~page~succeeded}
    \trace:n{We~ better~ output~ something~ now~ ...}
%</trace>
%<*progress>
    \xor_progress_newline:n{succeeded}
    \xor_progress_newline:n{}
%</progress>
%    \end{macrocode}
%    producing this page is rubbish as well but it can't be written
%    before we have parameters and rules for making float pages.
%    \begin{macrocode}
    \xor_forall_columns:n{
      \vbox_gset_to_ht:ccn
        {g_xor_col_ \int_use:N\g_xor_curr_col_int _box}
        {g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim} {}
      \xor_produce_final_column:
    }
    \xor_perhaps_write_placements_to_fpl_file:
    \xor_produce_final_page:
    \xor_next_page_setup:
%    \end{macrocode}
%    But the final lines are for real: if we did succeed we need to
%    provide a new |\g_xor_floats_active_seq| for the next potential float page.
%    It should be the floats we deferred while trying to make the
%    current float page followed by the floats that are still on the
%    active list (i.e., those we haven't even tried for the current
%    page).
%    \begin{macrocode}
    \seq_gconcat:NNN \g_xor_floats_active_seq
                     \g_xor_area_DDD_seq
                     \g_xor_floats_active_seq
    \seq_gclear:N \g_xor_area_DDD_seq
  }
%
%\typeout{float.list.after.shipout.float.page.or.fail}
%\showfloatlists
%
%<*trace>
  \trace_pop:n{try@float@page}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_float_page_bool}
%    Switch which is set to true while we are in the process of making
%    float pages and haven't failed.
%    \begin{macrocode}
\bool_new:N \g_xor_float_page_bool
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_save_current_float_state:}
%
%    Save the current state of affairs concerning
%    floats\footnote{Needs more work, there are now other data
%    structures that should be saved if this is every going to be of
%    much use. (its current usage actually could be achieved with
%    simpler means). FIX or fold!}. In case of failure return to
%    this state by executing |\g_saved_float_state_tlp|.
%    \begin{macrocode}
\def_new:Npn \xor_save_current_float_state: {
%<*trace>
  \trace_push:n{xor_save_current_float_state:}
%</trace>
%%% FMi tmp
\let\seq_elt:w\relax
\let\seq_elt_end:\relax
  \tlp_gset:Nx \g_saved_float_state_tlp
               { \gdef:Npn \exp_not:N \g_xor_floats_active_seq
                        {\g_xor_floats_active_seq} }
  \xor_forall_columns:n {
    \tlp_gput_right:Nx \g_saved_float_state_tlp
        { \exp_not:N \dim_set:Nn
          \exp_not:c   {g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim}
                       {\dim_use:c {g_xor_ht_col_
                                    \int_use:N\g_xor_curr_col_int
            _dim}
                       }
        }
  }
%    \end{macrocode}
%    Save current state of all used float areas by looping though them.
%    \begin{macrocode}
  \clist_map_function:NN \g_xor_areas_used_clist \xor_save_area_info:n
  \xor_save_area_info:n {DDD}
%<*trace>
  \trace:n{saved:~ \meaning\g_saved_float_state_tlp}
  \trace_pop:n{xor_save_current_float_state:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xor_save_area_info:n}
%    Argument is the three character area name.
%
%    THIS MAKES USE OF AREAS STORED WITHOUT SEPARATOR RIGHT NOW!
%    Save information about area.
%    \begin{macrocode}
\def_new:Npn \xor_save_area_info:n #1 {
\group_begin:
  \let\seq_elt:w\relax
  \let\seq_elt_end:\relax
    \edef\@tempa {
       \exp_not:N \int_gset:cn
          {g_xor_area_ #1 _float_int}
          {\int_use:c {g_xor_area_ #1 _float_int} }
%    \end{macrocode}
%
%    \begin{macrocode}
% FMI fix, see above
       \gdef \expandafter\noexpand \csname g_xor_area_#1_seq \endcsname
          {\csname g_xor_area_#1_seq\endcsname}
    }
    \tlp_gput_right:No \g_saved_float_state_tlp \@tempa
\group_end:
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_saved_float_state_tlp}
%    To return to the saved float state execute |\g_saved_float_state_tlp|.
%    \begin{macrocode}
\tlp_new:N \g_saved_float_state_tlp
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_redistributed_defer_list_float:n}
%    This function is used to look at each float on the |\g_xor_area_DDD_seq|
%    list in turn, moving those floats whose callouts have
%    been typeset to |\g_xor_floats_active_seq| for consideration for (one day)
%    float pages, and for allocating to text page float areas.
%
%    Floats whose callouts are still on MVL are placed on |\g_xor_floats_mvl_seq|.
%    \begin{macrocode}
\def_new:Npn \xor_redistributed_defer_list_float:n #1 {
%%% local????? FIX
  \tlp_set:Nn \g_xor_curr_float_box_tlp {#1}
  \xor_extract_this_float_core_values:N #1
%<*trace>
  \trace:n { #1:~\LastMark{\g_xor_this_class_tlp}~ ???~\g_xor_this_flseq_num }
%</trace>
  \int_compare:nNnTF {0\LastMark{\g_xor_this_class_tlp}} < \g_xor_this_flseq_num
  {
%<*trace>
    \trace:n {#1:~ not~ really~ defered }
%</trace>
    \seq_gput_right:Nn \g_xor_floats_mvl_seq #1
  }
  {
%<*trace>
    \trace:n {#1:~ callout~ has~ been~ typeset}
%</trace>
    \seq_gput_right:Nn \g_xor_floats_active_seq #1
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsection{Preassign deferred floats}
%
%
%
% \begin{macro}{\place@deferred@floats}
%
%    The |\place@deferred@floats| is supposed to distribute from
%    previous pages (i.e., from the top of |\g_xor_area_DDD_seq| or more exactly
%    those currently on the |\g_xor_floats_active_seq| since the
%    |\g_xor_area_DDD_seq| was
%    already split when trying to build float pages) into the areas
%    of the page to be build. After all we know that for those floats
%    the call outs are on previous pages so testing for them
%    is unnecessary and we could save time by bypassing this stuff.
%
%    On the other hand if we have flush points in the upcoming text
%    all our placements might be wrong, so perhaps this doesn't really
%    save so much time after all and the extra complication might not
%    be worth the effort.
%
%    Perhaps a compromise is to make a first column grab without any
%    floats to see if we end up with a flush point (not implemented).
%
%    So if we don't do this then the only thing we need to do at this
%    point is to move the floats from the |\g_xor_floats_mvl_seq| to the end of
%    the |\g_xor_floats_active_seq|.
%    \begin{macrocode}
\def_new:Npn \place@deferred@floats {
%<*trace>
  \trace_push:n{place@deferred@floats}
%</trace>
  \seq_gconcat:NNN \g_xor_floats_active_seq
                   \g_xor_floats_active_seq
                   \g_xor_floats_mvl_seq
  \seq_gclear:N \g_xor_floats_mvl_seq
%\showfloatlists
%<*trace>
  \trace_pop:n{place@deferred@floats}
%</trace>
}
%    \end{macrocode}
%
%
%    Here is an alternate definition which does the preassigning but
%    it would need to be extended by checking for flush points or by a
%    flag that ensures that if we later encounter a flush point that
%    we know we could backtrack if necessary (e.g., the preassignment
%    might have already deferred some floats past the flush
%    point).\footnote{Extend, fix, or get rid of.}
%    \begin{macrocode}
\iffalse % we don't do it right now
\def_new:Npn \place@deferred@floats {
%<*trace>
  \trace_push:n{place@deferred@floats}
%</trace>
%\showfloatlists
  \glet:NN \xor_floats_active_seq_if_empty_action: \relax
  \glet:NN \pretests@success@action \floatpage@pretests@success@action
  \xor_trial_place_float_inner_loop:
  \seq_gconcat:NNN \g_xor_floats_active_seq
                   \g_xor_area_DDD_seq
                   \g_xor_floats_mvl_seq
  \seq_gclear:N \g_xor_area_DDD_seq
  \seq_gclear:N \g_xor_floats_mvl_seq
%\showfloatlists
%<*trace>
  \trace_pop:n{place@deferred@floats}
%</trace>
}
\fi
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\floatpage@pretests@success@action}
% Version of |\pretests@success@action| for use in initial phase
% when previously deferred floats are being allocated to float areas.
%    \begin{macrocode}
\def_new:Npn \floatpage@pretests@success@action{
%<*trace>
  \trace_push:n{floatpage@pretests@success@action}
%</trace>
  \update@best@trial
  \xor_trial_place_float_inner_loop:
%<*trace>
  \trace_pop:n{floatpage@pretests@success@action}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \newpage
%
% \subsection{Support for Balancing}
%
%
% \subsubsection{Algorithm---collection phase}
% 
% \begin{itemize}
% \item Points at which balancing should occur are denoted in the source with
%   a special penalty just like ``here points'' or ``flush points''.
% \item During collection these points receive the same treatment as any other
%   special point, i.e., they are stored away in the uncut galley for later
%   use during the trials.
% \end{itemize}
% 
% \subsubsection{Algorithm---trial phase}
% 
% \begin{itemize}
% \item When a trial is made with a certain set of placed floats the galley is
%   cut into individual columns of a certain height (which is initially given
%   by the placement for the current floats).
% \item If a new balancing point is encountered (i.e., one for which there is
%   no known information how to balance yet) the following process is carried
%   out:
%   \begin{itemize}
%   \item
%     Column cutting is stopped and it is checked if the current
%     ``unbalanced'' cutting already fulfills the requirements for balanced
%     columns. This is the case if
%     \begin{itemize}
%     \item
%       we have produced all columns
%     \item
%       the last column is already so full that it seems pointless to shorten
%       all columns to achieve better balancing.
%     \end{itemize}
%   \item
%     If the current cutting is considered unsatisfactory then new target
%     column heights are calculated (in the hope of achieving better
%     balancing) and the trial is restarted using the new values.
%   \item
%     The ``correct'' values are approximated from the top, meaning that the
%     heights are gradually shortend until a satifactory solution is obtained.
%   \item
%     This is done by
%    \begin{itemize}
%    \item
%      maintaining a global delta value (same for all columns) which starts
%      out at zero and is gradually increased.
%    \item
%      This delta value describes by what amount each column height has to be
%      reduced from its nominal value in the current balancing attempt.
%    \item
%      However, for columns that contain bottom floats no reduction happens as
%      long as the delta value is less than the height taken up by such floats
%      and once it exceeds this value only the difference between the two
%      values is used, i.e., $\string| \delta - \textit{bot\_float\_ht}
%      \string| $.
%    \item
%      This process iterates until a suitable balancing is achieved.
%    \end{itemize}
%    \item
%      Finally the heights needed for balancing this section are recorded and
%      the current balance point is marked as being ``processed''. The
%      remainder height (if any) in all columns is calculated and used fro
%      cutting more material in the normal way.
%   \end{itemize}
%   \item
%     If during cutting (for example when restaring a trial) a balance point
%     is encountered for which balancing information already exists (marked as
%     ``processed'' then this information (i.e., the required column heights
%     for the balanced part) are recalled and the cutting proceeds using these
%     values.
%   \item
%     Once all columns are cut fully the trial is evaluted as usual
%     (determining if the current placement of floats is valid).
%     \begin{itemize}
%     \item
%       If yes, the trial is recorded as the best one so far (see float
%       placement algorithm) and the next float is tried.
%     \item
%       If no, a different placement for the current float is tried (or the
%       float is deferred.
%     \item 
%       In any case, the column structure will be changed this way, thus all
%       previously calculated column values for balancing need to be redone in
%       the next trial. This can be done by marking all balancing points as
%       "unprocessed"
%     \end{itemize}
% \end{itemize}
% 
% \subsubsection{Algorithm---bells and whistles}
% 
% There are many way that can be envisioned to allow customisation of this
% algorithm, here are a few:
% \begin{itemize}
% \item
%   Measure the amount of remaining space for all columns, if the space is too
%   small in any of them, do not balance.
% \item
%   It should be possible to extend the algorithm to have only certain column
%   participate in balancing, e.g., in a 3-col layout the first 2 \ldots
% \end{itemize}
%
%
%
% \subsubsection{Algorithm---some more details}
%
% When the columns are cut for a trial the mechanism works (1000 feet high and
%   handwaving) as follows.
% \begin{itemize}
% \item
%   First the previously collected material material is placed back onto the
%   main vertical list (with a special marker at the end to be able to take it
%   off in case the trial fails (or even if it works out well).
% \item
%   Then columns are cut according to column sizes determined by the current
%   float trial (i.e., depending on the placement of trial floats).
% \item
%   Then, in case we already have balanced some blocks on this page, the
%   algorithm switches to a high speed output routine that simply jumbs from
%   break point to break point until it hits the balance points it already
%   knows about.
% \item
%   After that, or when no such blocks exist yet, the output routine is
%   switched (back) to the column grabbing routine and the column heights are
%   adjusted to what is left on the page (in case we had balanced blocks). The
%   correct values for the column heights have been calculated previously when
%   the blocks were balanced.
% \item
%   The moment the cutting hits a previously unknown balance point
%   penalty\footnote{Not really unknown, as we have seen it during collection,
%   but unknown in the sense that we haven't balanced anything for it.}  it
%   will switch to some special balancing routine which will take over
%   processing for a while.
%   \begin{itemize}
%   \item
%     If the balancing point is encountered for the first time the routine will
%     check if by any change the cutting is already ok (which currently is
%     defined to be as
%     \begin{itemize}
%     \item
%       currently cutting the last column
%     \item
%       the last column is more or less full.
%     \end{itemize}
%     This is clearly sub-optimal, but for the moment it is a good enough
%     approximation.
%     \begin{itemize}
%     \item
%       If balancing is bad the currently used column heights are reduced by
%       some amount (depends on how far we are probably away from a good
%       balancing value) and then everything is removed from the MVL via some
%       cleanup output routine and then the whole collected material is placed
%       again onto it and cutting is retried with the new values.
%     \item
%       Important: the float trial situation must not change, that is the
%       restart has to happen in the inner loop of the bigger float trial
%       loop.
%     \item
%       Also important: we know know that we are looking to reach some
%       balancing point and by reducing the column heights we may actually
%       never reach it again (and ergo not return to the balancing procedure
%       but ending up in the part that looks at the whole column and
%       determines whether or not the float tril was successful. That of
%       course would be a desaster since we currently use small column hts for
%       the balancing part somewhere in the middle of the page! So we have to
%       record that we are in balancing mode and if the cutting routine
%       |\xor_OR_grab_some_cols:nnnn| cuts the last column (and only then) and
%       we finish it without having reached the balancing point once more we
%       have shortened the columns too much (very easy to do if headings or
%       footnotes or anything is in the material which doesn't allow breaking
%       after every line). If that is the case we need to back up a
%       bit. Correct approach would be to now slowly enlarge the column
%       heights again and then make some final decisions which of the
%       balancing trials actually work best (using all kind of bells and
%       whistles as used in the multicol package implementation). Right now we
%       take the simple approach and claim that the balancing trial before was
%       the one that is best. So we enlarge the heights once more, set a
%       special flag to be evaluated in the balancing routine, then remove all
%       remaining material from the MVL, put the whole collected material on
%       once more and start recutting for a final time.
%     \item
%       This time we should reach the balancing point again during cutting,
%       jump to the balancing routine, there see the flag (we just set) and
%       decide that therefore this set of column height values is the one to
%       use for balancing. This will then be recorded as being the one to use
%       for this balancing point. In addition this balancing point will be
%       marked as processed.
%     \item
%       Another way to reach this state is that after cutting and switching to
%       the balancing process, the routine at some point decides that the
%       current trial balancing is already good enough (again that really
%       depends on how the process to arrive at the best balancing is worked
%       out but right now this is one way to get to this final state).
%     \end{itemize}
%   \end{itemize}
% \item
%   Once the balancing is done, the remainder space in each column is
%   calculated and the cutting for it is restarted using those values. Since
%   the material after the balancing point is already on the MVL all that is
%   necessary is to make sure that we are back to cutting for column one and
%   switch to the appropriate output routine.
% \item
%   Now either all columns can be cut and the float trial ends or another
%   balance point is encountered along the way in which case everything starts
%   all over (with the difference that we have one additional block for which
%   the balancing info is now known).
% \item
%   At the end of the day a page has finally be cut (theoretically since most
%   of the time the material has simply been thrown away after looking at it).
%   At this point the float trial is evaluated resulting either in accepting
%   the float position as good or rejecting it for one or the other
%   reason. Then the our loop will attempt to place another float onto the
%   page (or place the current one in a different area and start another
%   trial).
% \item
%   Important to notice here: if the next trial is started all our information
%   about the balancing is worthless. After all, placing an additional float
%   onto the page or moving one around changes all the column heights, at
%   least potentially. So for the next trial we have to start all over and do
%   all balancing again.
% \item
%   Finally the outer loop will run out of floats to try and a best solution
%   has been determined. At that point the collected material is copied for a
%   final time onto the MVL and a slightly different output routine is
%   installed. This one makes use of our known information about the balanced
%   blocks (from the last successful trial) and uses this information to cut
%   individual bits and put them together to form the final page.
% \end{itemize}
% 
%
%  \subsubsection{User interface commands}
%
% \begin{macro}{\balancecolumns}
%    Add a balance point into the galley. When we process this code we will be
%    collecting material so we increment |\g_xor_collect_balance_seen_num|
%    (i.e., number of balance points seen during collection and we record
%    which floats are ``before'' that point by storing the current
%    |\g_xor_flseq_int| in
%    |\g_xor_balance_<NUM>_last_float_num|.\footnote{before or after we
%    increment?}
%    \begin{macrocode}
\def_new:Npn \balancecolumns {
%<*trace>
  \trace_push:n{balancecolumns}
%</trace>
  \num_gincr:N\g_xor_collect_balance_seen_num
  \num_gset:cn
      {g_xor_balance_
       \num_use:N \g_xor_collect_balance_seen_num
       _last_float_num}
      {\int_use:N \g_xor_flseq_int}
  \xor_add_badly_guarded_penalty:N \c_xor_output_balance_penalty
%<*trace>
  \trace_pop:n{balancecolumns}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
% 
%
%  \subsubsection{Variables used}
%
% \begin{macro}{\g_xor_best_trial_col_hts_balance_NUM_tlp}
%    For balance point |NUM| (which is 0, 1,\ldots) this macro holds
%    the column heights for all columns (parts) that we will need for
%    getting a balanced result.
%    \begin{macrocode}
\tlp_new:c {g_xor_best_trial_col_hts_balance_0_tlp}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_balance_delta_dim}
% \begin{macro}{\g_xor_saved_balance_delta_dim}
%     Nominal amount of space not used in all columns when trial
%    balancing. The actual amount might be smaller due to bottom floats in a
%    column
%    \begin{macrocode}
\dim_new:N \g_xor_balance_delta_dim
\dim_new:N \g_xor_saved_balance_delta_dim
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\g_xor_balance_failed_bool}
%    Boolean to indicate that the current balancing trial has failed.
%    \begin{macrocode}
\bool_new:N \g_xor_balance_failed_bool
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_balance_finish_bool}
%    Indicate that we are really finished balancing.\footnote{logic should be
%    checked why do we need two booleans here?}
%    \begin{macrocode}
\bool_new:N \g_xor_balance_finish_bool
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_balance_point_expected_bool}
%    Boolean to indicate that we expect the grab column routine to see a
%    balance point at the end of its last column (if not we have not picked up
%    enough material).
%    \begin{macrocode}
\bool_new:N \g_xor_balance_point_expected_bool
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_balance_NUM_last_float_num}
%    \begin{macrocode}
\num_new:c{g_xor_balance_0_last_float_num}
\num_new:c{g_xor_balance_1_last_float_num}
\num_new:c{g_xor_balance_2_last_float_num}
\num_new:c{g_xor_balance_3_last_float_num}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_collect_balance_seen_num}
%    Number of balance points encountered during collection.
%    \begin{macrocode}
\num_new:N \g_xor_collect_balance_seen_num
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\g_xor_trial_balance_seen_num}
%    Number of balance points encountered in a trial (or when generating the
%    final columns) so far.
%    \begin{macrocode}
\num_new:N \g_xor_trial_balance_seen_num
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_trial_balance_done_num}
%    Number of balance blocks we already know the column heights for in the
%    current trial.
%    \begin{macrocode}
\num_new:N \g_xor_trial_balance_done_num
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\g_xor_best_balance_done_num}
%    Number of balance blocks we already know the column heights for
%    in the nest trial so far.
%    \begin{macrocode}
\num_new:N \g_xor_best_balance_done_num
%    \end{macrocode}
% \end{macro}
%
% 
%
%  \subsubsection{Helper functions}
%
%
%
%
% \begin{macro}{\if_xor_grab_for_balance_done:TF}
% \begin{macro}{\if_xor_grab_for_balance_done:T}
%    \begin{macrocode}
\def_new:Npn \if_xor_grab_for_balance_done:TF {
  \if_num:w \g_xor_trial_balance_seen_num 
             < \g_xor_trial_balance_done_num \scan_stop:
%<*trace>
     \trace:n{BALANCE:~ doing~ existing~ block~
            \num_use:N \g_xor_trial_balance_seen_num <
            \num_use:N \g_xor_trial_balance_done_num
        }
%</trace>
     \exp_after:NN \use_arg_i:nn
   \else:
%<*trace>
     \trace:n{BALANCE:~ working~ on~ new~ block}
%</trace>
     \exp_after:NN \use_arg_ii:nn
   \fi:
}
\def_new:Npn \if_xor_grab_for_balance_done:T {
  \if_num:w \g_xor_trial_balance_seen_num 
            < \g_xor_trial_balance_done_num \scan_stop:
%<*trace>
     \trace:n{BALANCE:~ doing~ existing~ block~
            \num_use:N \g_xor_trial_balance_seen_num <
            \num_use:N \g_xor_trial_balance_done_num
        }
%</trace>
     \exp_after:NN \use_arg_i:n
   \else:
     \exp_after:NN \use_none:n
   \fi:
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% 
%
%  \subsubsection{Balancing output routines}
%
%
% \begin{macro}{\xor_OR_trial_grab_balance_setup:}
%
%
%    \begin{macrocode}
\def_new:Npn  \xor_OR_trial_grab_balance_setup:  {
%<*trace>
  \trace_push:n{xor_OR_trial_grab_balance_setup:}
%</trace>
%    \end{macrocode}
%    In case there is a flush penalty in the collection we have to
%    find out if we see it again during the trial. So we record the
%    number of flush points we see during the trial. Same happens for
%    here and balance points.
%    \begin{macrocode}
  \num_gzero:N \g_xor_trial_flush_seen_num
  \num_gzero:N \g_xor_trial_here_seen_num
  \num_gzero:N \g_xor_trial_balance_seen_num
%<*trace>
  \trace:n{BALANCE:~ g_xor_trial_balance_seen_num ~<-~
                    \num_use:N \g_xor_trial_balance_seen_num}
  \trace:n{BALANCE:~ g_xor_trial_balance_done_num ~==~
                    \num_use:N \g_xor_trial_balance_done_num}
%</trace>


  \int_gzero:N \g_xor_curr_col_int

  \if_xor_grab_for_balance_done:TF
     {
%<*trace>
      \trace:n{BALANCE:~ fast~ regrabbing~ balanced blocks}
%</trace>
      \global\vsize\maxdimen
      \global\output{\xor_OR_regrab_balanced_material:}
     }
     {
      \global\output{\xor_OR_grab_trial_cols:}
      \xor_OR_trial_grab_next_col_setup:
     }
%<*trace>
  \trace_pop:n{xor_OR_trial_grab_balance_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\xor_OR_regrab_balanced_material:}
%    \begin{macrocode}
\def_new:Npn \xor_OR_regrab_balanced_material: {
%<*trace>
  \trace_push:n{xor_OR_regrab_balanced_material:}
  \trace:n{output~pen:~ \the\outputpenalty}
  \trace:n{vsize:~ \the\vsize;~ pagegoal:~ \the\pagegoal}
%</trace>
  \box_gclear:N \c_twohundred_fifty_five
  \box_gclear:N \footins

  \int_compare:nNnTF \outputpenalty={-\c_xor_output_balance_penalty}
    {
     \num_gincr:N \g_xor_trial_balance_seen_num
     \int_compare:nNnT \g_xor_trial_balance_seen_num =
                       \g_xor_trial_balance_done_num
        {
         \global\output{\xor_OR_grab_trial_cols:}
%<*trace>
         \trace:n{BALANCE:~ setting~ up~ new~ col~ hts:~
                \tlp_to_str:N \g_xor_balance_trial_col_hts_tlp}
%</trace>
         \g_xor_balance_trial_col_hts_tlp

         \int_gzero:N \g_xor_curr_col_int
         \xor_OR_trial_grab_next_col_setup:
        }
    }
%    \end{macrocode}
%    If it is not a balance point it might be a here or a flush point in which
%    case we record that fact and carry on. Otherwise we simply ignore the
%    penalty.
%    \begin{macrocode}
    {
     \int_compare:nNnTF \outputpenalty={-\c_xor_output_here_float_penalty}
       { \num_gincr:N \g_xor_trial_here_seen_num }
       {
         \int_compare:nNnT \outputpenalty={-\c_xor_output_flush_float_penalty}
          { \num_gincr:N \g_xor_trial_flush_seen_num }
       }
    }
%<*trace>
  \trace_pop:n{xor_OR_regrab_balanced_material:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\xor_OR_trial_balance:NN}
%
%    \begin{macrocode}
%
% #1 what to do next if balancing failed
% #2 what to do next if balancing succeeded (not used right now)
%
\def_new:Npn \xor_OR_trial_balance:NN #1 #2 {
%<*trace>
  \trace_push:n{xor_OR_trial_balance:NN~  \exp_not:n{(#1 #2)}}
  \trace:n{BALANCE:~ balance~ point~ seen~ again}
%</trace>
  \xor_remove_guard_box_from_cclv:
%    \end{macrocode}
%    Doing balancing in earnest on a newly detected balancing point. Look how
%    good we are with this trial, if necessary adjust
%    |\g_xor_balance_delta_dim| and recourse.
%    
%    First some safety measure: if the current |\vsize| gets really small we
%    better stop any balancing attempt immediatly.
%    \begin{macrocode}
  \dim_compare:nNnT \vsize < {2\baselineskip}
    { \bool_gset_true:N \g_xor_balance_finish_bool }
%    \end{macrocode}
%    This is a temp solution for crude balancing. Once we shortend the vize so
%    much that we didn't got to the balancing point we retreat to the last
%    good solution and give up. \textbf{To be replaced by something more
%    granular using multicols methods one day.}
%    \begin{macrocode}
  \bool_if:NF \g_xor_balance_finish_bool
   {
    \int_compare:nNnTF \g_xor_curr_col_int < \g_xor_cols_int
      {
%<*trace>
       \trace:n{BALANCE:~ point~ too~ early;~ aborting}
%</trace>
%    \end{macrocode}
%    Save the old delta in case we have to use it after all.
%    \begin{macrocode}
       \dim_gset:Nn \g_xor_saved_balance_delta_dim \g_xor_balance_delta_dim 
%    \end{macrocode}
%    
%    \begin{macrocode}
       \dim_set:Nn \l_tmpa_dim {\vsize/\g_xor_cols_int}
       \dim_gadd:Nn \g_xor_balance_delta_dim {.5\l_tmpa_dim}
%       \xor_snap_to_grid:nn \g_xor_balance_delta_dim \pagesetup@grid@point@sep
%%B
%<*trace>
       \trace:n{BALANCE:~ delta~ <-~ \dim_use:N\g_xor_balance_delta_dim}
%</trace>
       \bool_gset_true:N \g_xor_balance_failed_bool
       \bool_gset_true:N \g_xor_balance_point_expected_bool
%<*trace>
       \trace:n{BALANCE:~ g_xor_balance_point_expected_bool~ <-~ true}
%</trace>
      }
% we are in the last column but the result may look bad
      {
       \vbox_set:Nn \l_tmpa_box 
                    {\vbox_unpack_clear:N \c_twohundred_fifty_five
                     \ifvoid\footins   \else
                       \vskip \skip\footins
                       \vbox_unpack_clear:N \footins
                     \fi
                    }
%    \end{macrocode}
%    
%    \begin{macrocode}
       \dim_compare:nNnT {\vsize - \box_ht:N\l_tmpa_box} > 
                         {\baselineskip}
          {
%<*trace>
           \trace:n{BALANCE:~ not~ nicely~ balanced;~ retry}
%</trace>
           \bool_gset_true:N \g_xor_balance_failed_bool
           \bool_gset_true:N \g_xor_balance_point_expected_bool
%<*trace>
       \trace:n{BALANCE:~ g_xor_balance_point_expected_bool~ <-~ true}
%</trace>
           \dim_gset:Nn \g_xor_saved_balance_delta_dim \g_xor_balance_delta_dim 
           \dim_gadd:Nn \g_xor_balance_delta_dim \baselineskip
%           \xor_snap_to_grid:nn \g_xor_balance_delta_dim \pagesetup@grid@point@sep
          }
      }
    }

    \bool_if:NTF \g_xor_balance_failed_bool
      {
%<*trace>
        \trace:n{BALANCE:~ fail;~ abort}
%</trace>
        \bool_gset_false:N \g_xor_balance_failed_bool
        \box_gclear:N \c_twohundred_fifty_five
        \box_gclear:N \footins
        \xor_OR_cleanup_setup:N \xor_trial_get_balance_loop:
       
      }
      {

% if too much space left over do something  (not done .. pretend ok)

%<*trace>
        \trace:n{BALANCE:~ success;~ delta~ used:~ \dim_use:N \g_xor_balance_delta_dim}
%</trace>
        \tlp_gclear:N \g_tmpa_tlp

%%B
        \tlp_gclear:N \g_xor_balance_trial_col_hts_tlp


        \xor_forall_columns:n
          {
           \dim_set:Nc \l_tmpa_dim
                       {g_xor_ht_col_
                        \int_use:N \g_xor_curr_col_int
                        _dim}
% calculate the real delta that was used in this column (actually could be
% saved rather than calculated twice

           \xor_calculate_delta_to_use:N \l_tmpb_dim
           \dim_sub:Nn \l_tmpa_dim \l_tmpb_dim

           \tlp_gput_right:Nx \g_tmpa_tlp
            {
             \exp_not:N \dim_gset:Nn
             \exp_not:c  {g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim}
             {\dim_use:N \l_tmpa_dim }
            }
% next actually should be the remaining space (which it isn't if
% floats are allocated!)

%%B
          \tlp_gput_right:Nx \g_xor_balance_trial_col_hts_tlp
           {
            \exp_not:N \dim_gset:Nn
            \exp_not:c  {g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim}
             {\dim_use:N \l_tmpb_dim }
           }
          }
        \tlp_gset_eq:cN {g_xor_best_trial_col_hts_balance_
                         \num_use:N \g_xor_trial_balance_seen_num
                         _tlp}
                        \g_tmpa_tlp

%<*trace>
        \trace:n{BALANCE:~ g_xor_best_trial_col_hts_balance_
                      \num_use:N \g_xor_trial_balance_seen_num
                      _tlp ~=~ \tlp_to_str:N \g_tmpa_tlp }
%</trace>
        \num_gincr:N \g_xor_trial_balance_done_num
%<*trace>
        \trace:n{BALANCE:~ g_xor_trial_balance_done_num ~<-~
                     \num_use:N \g_xor_trial_balance_done_num}
        \trace:n{BALANCE:~ solution~ found;~ restart~ cutting~ remaining~ columns}
%</trace>
% restart main trial
        \dim_gzero:N \g_xor_balance_delta_dim

%    \end{macrocode}
%     Finished with balancing so not expecting to see a balance point
%     again\footnote{FIX: we can probably just use a single boolean not two}
%    \begin{macrocode}
        \bool_gset_false:N \g_xor_balance_point_expected_bool
        \bool_gset_false:N \g_xor_balance_finish_bool
%<*trace>
        \trace:n{BALANCE:~ g_xor_balance_point_expected_bool~ <-~ false}
%</trace>

        \box_gclear:N \c_twohundred_fifty_five
        \box_gclear:N \footins
%    \end{macrocode}
%    We have stored the column heights for the rest of the columns in
%    |\g_xor_balance_trial_col_hts_tlp| and can now restart cutting column
%    material normally (restarting with column 1).
%    \begin{macrocode}
%<*trace>
        \trace:n{BALANCE:~ new~ col~ heights:~ \tlp_to_str:N\g_xor_balance_trial_col_hts_tlp}
%</trace>
        \g_xor_balance_trial_col_hts_tlp

        \int_gzero:N \g_xor_curr_col_int

% BUG: something is resetting balance_seen to 0

        \xor_OR_trial_grab_next_col_setup:
      }
%<*trace>
  \trace_pop:n{xor_OR_trial_balance:NN}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%

%
% \begin{macro}{\xor_trial_get_balance_loop:}
%    Place the galley box back on the MVL. Needs to be done via the
%    special output routine call |\xmark_OR_restore_state:n| to ensure that
%    \TeX's primitive marks reflect the `logical' previous page rather
%    than the previous actual output routine call.
%    \begin{macrocode}
\def_new:Npn \xor_trial_get_balance_loop: {
%<*trace>
  \trace_push:n{xor_trial_get_balance_loop:}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
  \deadcycles\c_zero
  \glet:NN \xor_floats_active_seq_if_empty_action: \xor_OR_best_cols_setup:
  \glet:NN \pretests@success@action \xor_OR_trial_grab_cols_setup:
%    \end{macrocode}
%
%    |\xmark_OR_restore_state:n| state is a special output routine those
%    only purpose is to reinitialise the state of the mark
%    mechanism. Its argument is executed at the of that OR and must
%    (!) set up a new OR else we find ourselves in trouble.
%    \begin{macrocode}
  \xmark_OR_restore_state:n{
%    \end{macrocode}
%    Initialising the grabbing trials means putting the saved material
%    back onto the MVL and reinitialising the here float list.
%    \begin{macrocode}
    \vbox_unpack:N \g_xor_hold_page_box
%    \end{macrocode}
%    To be able to identify the end of the material for trials for
%    cutting the galley we mark it with a special penalty.
%    \begin{macrocode}
    \xor_add_badly_guarded_penalty:N \c_xor_output_collect_penalty 

    \seq_gset_eq:NN \g_xor_floats_here_seq \g_xor_saved_floats_here_seq
%    \end{macrocode}
%
%    The we can start the actual loop: if we run with floats we go to \\
%    |\xor_trial_place_float_inner_loop:| otherwise we immediately setup the
%    grab column OR.\footnote{fix docu}
%    \begin{macrocode}
%%B
%    \bool_if:NTF \g_xor_trial_with_floats_bool
%    { \xor_trial_place_float_inner_loop: }
%    { \xor_OR_trial_grab_cols_setup: }

     \xor_OR_trial_grab_balance_setup:

    }
%<*trace>
  \trace_pop:n{xor_trial_get_balance_loop:}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%
% 
%
%  \subsubsection{Balancing in the best column phase}
%
%
%
% \begin{macro}{\xor_OR_best_balance_setup:}
%    \begin{macrocode}
\def_new:Npn  \xor_OR_best_balance_setup:  {

   \global\output{\xor_OR_grab_best_cols:}

% next line already set if entering from
% \xor_OR_trial_grab_cols_setup:
% init needs to be cleaned up between the two!

  \int_gzero:N \g_xor_curr_col_int

  \if_xor_grab_for_balance_done:T
  {
%<*trace>
    \trace:n{BALANCE:~ regrabbing~ columns~ for~ block~
                     \num_use:N \g_xor_trial_balance_seen_num}
%</trace>
    \tlp_use:c {g_xor_best_trial_col_hts_balance_
                \num_use:N \g_xor_trial_balance_seen_num
                _tlp}
  }
  \xor_OR_best_next_col_setup:
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_set_best_trial_col_hts:n}
%    Sets |\g_xor_best_trial_col_hts_tlp| with each column getting the height
%    specified in the argument (|\g_xor_curr_col_int| is the current column
%    number and can be used in the argument).
%
%    Calling |\g_xor_best_trial_col_hts_tlp| doesn't change the current
%    |\vsize| but sets for each column |\g_xor_ht_col_NUM_dim| to hold a new
%    height which can then be assigned to |\vsize| when cutting the galley for
%    the column NUM.
%    \begin{macrocode}
\def_new:Npn \xor_set_best_trial_col_hts:n #1 {
  \tlp_gclear:N \g_xor_best_trial_col_hts_tlp
  \xor_forall_columns:n{
    \tlp_gput_right:Nx \g_xor_best_trial_col_hts_tlp
       {
        \exp_not:N \dim_gset:Nn
        \exp_not:c  {g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim}
                    { #1 }
      }
  }
%<*trace>
  \trace:n{Saving~ column~ heights:}
  \trace:n{g_xor_best_trial_col_hts_tlp ~:=~
         \tlp_to_str:N \g_xor_best_trial_col_hts_tlp}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \newpage
%
% \subsection{Support for Flush Points}
%
%
% \begin{macro}{\g_xor_flush_seen_bool}
% \begin{macro}{\g_xor_flush_failed_bool}
%
%    |\g_xor_flush_seen_bool| is set to true if we encounter a flush penalty
%    during collection.
%
%    |\g_xor_flush_failed_bool| is set to true if we fail a trial due to
%    placing the float after the flush penalty.
%    \begin{macrocode}
\bool_new:N \g_xor_flush_seen_bool
\bool_new:N \g_xor_flush_failed_bool
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\flushfloats}
%
% User command to indicate that floats should be flushed.
%
% Supported variants:
% \begin{itemize}
% \item
%    Flush only one (some) types or all types (default).
%
% \item
%    Fuzzyflush or, more precisely, flush-to-this-column
%      or -page or -spread.\footnote{Right now "spread" is not implemented.}
% \end{itemize}
%
%    \begin{macrocode}
\DeclareDocumentCommand\flushfloats { o O{strict} }
  { \xor_add_flush_floats_point:nn {#1} {#2} }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\clearpage}
%    \LaTeX's |\clearpage| command now looks like this:
%    \begin{macrocode}
\def\clearpage{ \flushfloats \newpage }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\doubleclearpage}
%    \LaTeX's |\doubleclearpage| command also needs a new
%    definition:\footnote{But not this one :-) FIX!}
%    \begin{macrocode}
\def\doubleclearpage{ \clearpage }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_add_flush_floats_point:nn}
%
%    Parts of the flushpenalty (all types) data structure:
% \begin{itemize}
% \item
%    |\g_xor_flush_|\meta{num}|_min_col_num|
%
% \item
%    |\saved@flush@min@col@|\meta{num}
%
% \item
%    |\flush@prev@float@num@|\meta{num}\footnote{what is this Chris?}
%
% \item
%    |\g_xor_collect_flush_seen_num| is the number of these so that
%    \meta{num} has range [1, |\g_xor_collect_flush_seen_num|]
% \end{itemize}
%
%    In addition, whilst doing an fp trial we need |\g_xor_trial_flush_seen_num|
%    to record that we have, in this trial so far, seen the
%    flush points in the interval \\[0pt]
%    [1, |\g_xor_trial_flush_seen_num|].
%
%    \begin{macrocode}
\def_new:Npn \xor_add_flush_floats_point:nn #1 #2 {
%    \end{macrocode}
%
%    \begin{macrocode}
  \num_gincr:N\g_xor_collect_flush_seen_num
%    \end{macrocode}
%
%    \begin{macrocode}
  \num_gset:cn {g_xor_flush_
                \num_use:N\g_xor_collect_flush_seen_num
                _min_col_num}{1}
%    \end{macrocode}
%
%    \begin{macrocode}
  \num_gset:cn
      {g_xor_flush_
       \num_use:N \g_xor_collect_flush_seen_num
       _last_float_num}
      {\int_use:N \g_xor_flseq_int}
%    \end{macrocode}
%    If |#1| is |\NoValue| the current flush point affects all float
%    sequence classes, thus we store in
%    |\g_xor_flush_|\meta{num}|_classes_clist| a list of all float sequence
%    classes separated by semicolons. Otherwise we assume that we got
%    a single float type(!) as argument and flush the corresponding
%    class.
%    \begin{macrocode}
  \IfNoValueTF{#1}{
%FMi tmp!
    \def\seq_elt:w ##1\seq_elt_end:{##1,}
    \def:cpx {g_xor_flush_ \g_xor_collect_flush_seen_num  _classes_clist }
      {\g_xor_float_classes_seq}
  }
  {
    \cs_free:cTF {g_xor_type_ #1 _class_tlp}
    { \ErrorArgumentNotAFloatType }
    {
      \clist_gset_eq:cc
         {g_xor_flush_ \g_xor_collect_flush_seen_num _classes_clist}
         {g_xor_type_ #1 _class_tlp}
    }
  }
%    \end{macrocode}
%    The argument |#2| holds the fuzziness of the flush point which
%    currently can be either |strict|, |column| or |page|.
%    We link |\xor_flush_fuzziness_|\meta{num}|_action:| to the code stored in
%    |\xor_check_flush_#2:| after making sure that such code
%    exists.\footnote{Improve error handling (as elsewhere) and this check
%    should probably come first!}
%    \begin{macrocode}
  \cs_free:cTF {xor_check_flush_#2:}
  {\userinputERROR }
  {
    \glet:cc
    {xor_flush_fuzziness_ \num_use:N\g_xor_collect_flush_seen_num _action:}
    {xor_check_flush_#2:}
%<*trace>
    \trace:n{xor_flush_fuzziness_ \num_use:N\g_xor_collect_flush_seen_num
           _action: \space
            =:~ \exp_not:c {xor_check_flush_#2:}
    }
%</trace>
%    \end{macrocode}
%    Finally we add the penalty the indicates the flush point in the galley
%    and triggers the collect output routine.
%    \begin{macrocode}
  \xor_add_badly_guarded_penalty:N \c_xor_output_flush_float_penalty
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_collect_flush_seen_num}
%    The number |\g_xor_collect_flush_seen_num| records the number of flush
%    points we have have seen during collection.
%    \begin{macrocode}
\num_new:N \g_xor_collect_flush_seen_num
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_trial_flush_seen_num}
%    The number |\g_xor_trial_flush_seen_num| records the number of flush
%    points we have seen so far during a trial, i.e., it will be
%    initialised to zero at the beginning of the trial and advanced by
%    one for each flush point encountered.
%    \begin{macrocode}
\num_gzero:N \g_xor_trial_flush_seen_num
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_flush_NUN_last_float_num}
% \begin{macro}{\g_xor_flush_NUM_min_col_num}
% \begin{macro}{\g_xor_flush_NUM_classes_clist}
% \begin{macro}{\xor_flush_fuzziness_NUM_action:}
%
%    For each flush point we have a data structure in which we store
%    relevant information. This data structure is provided by a set of
%    macros which can be accessed by using the number of the current
%    flush point and constructing command names from it, e.g., to get at
%    the ``flush min col'' for the flush point with number 3 would be
%    |\g_xor_flush_3_min_col_num|.

%    |\g_xor_flush_|\meta{num}|_min_col_num| holds the column number in which we
%    last seen the flush penalty while trying to find a solution for
%    the current page. This is initialised to 1 in |\xor_OR_collect:| when
%    a flush penalty is encountered during collection (since 1 is the
%    earliest column in which the flush penalty finally may fall). By
%    adding additional floats to the page the penalty might move to a
%    later column but normally not back to an earlier
%    one\footnote{There is a possibility that this happens if there is
%    enough space vanishing at the new break.}  If we end up with the
%    flush penalty moving backwards we force a break at this point
%    until we reach the column where it was before. The reason for
%    this action is that we might have allocated floats to later
%    columns that would otherwise end after after the flush penalty.
%
%    If by adding floats to the trials the flush penalty is moved to
%    the next page we set |\g_xor_flush_|\meta{num}|_min_col_num| to
%    |\maxdimen|. The actual test to see if a flush penalty still
%    belongs to the current page is to check against |\g_xor_curr_col_int|
%    (so |\g_xor_curr_col_int+1| would be sufficient, but using
%    |\maxdimen| avoids calculations.
%
%    |\g_xor_flush_|\meta{num}|_classes_clist| holds a comma separated
%    list of float types which
%    are affected by the current flush point.
%
%    |\xor_flush_fuzziness_action_|\meta{num}|:| holds the fuzziness associated with
%    the flushpoint, valid values are |strict| and |page|.
%
%    By defining (some of) them on top-level we avoid unnecessary
%    entries on the savestack since they would otherwise be
%    constructed (locally) first within the output routine (when doing
%    |\ifx| testing), resulting in |\relax| being stored on the
%    savestack.
%    \begin{macrocode}
\let_new:cN {g_xor_flush_1_last_float_num}  \ERROR
\let_new:cN {g_xor_flush_1_classes_clist}   \ERROR
\let_new:cN {g_xor_flush_1_min_col_num}     \ERROR
\let_new:cN {xor_flush_fuzziness_1_action:} \ERROR
\let_new:cN {g_xor_flush_2_last_float_num}  \ERROR
\let_new:cN {g_xor_flush_2_classes_clist}   \ERROR
\let_new:cN {g_xor_flush_2_min_col_num}     \ERROR
\let_new:cN {xor_flush_fuzziness_2_action:} \ERROR
\let_new:cN {g_xor_flush_3_last_float_num}  \ERROR
\let_new:cN {g_xor_flush_3_classes_clist}   \ERROR
\let_new:cN {g_xor_flush_3_min_col_num}     \ERROR
\let_new:cN {xor_flush_fuzziness_3_action:} \ERROR
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\g_xor_flush_max_classes_clist}
%    |\g_xor_flush_max_classes_clist| holds the concatenation of all \\
%    |\g_xor_flush_|\meta{num}|_classes_clist| on the page currently
%    constructed. This information is needed in case we get to a new
%    float and the preliminary tests suggests that it needs to be
%    deferred. In that case we need to know which flush points have
%    been seen previously to decide whether or not we can defer the
%    new float.
%    \begin{macrocode}
\clist_new:N \g_xor_flush_max_classes_clist
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_initialise_flush_data:}
%    \begin{macrocode}
\def_new:Npn \xor_initialise_flush_data:{
%<*trace>
  \trace_push:n{xor_initialise_flush_data:}
%</trace>
%    \end{macrocode}
%    Does this need any documentation?
%
%    Well, we have to get rid of all information relating to flush
%    float penalties that have been typeset on the previous page and
%    move the remaining ones (if any) to the front.
%    \begin{macrocode}
  \int_set:Nn \l_tmpa_int \g_xor_collect_flush_seen_num
  \int_add:Nn \l_tmpa_int {-\g_xor_trial_flush_seen_num }
%<*trace>
  \trace:n{g_xor_collect_flush_seen_num~
         =~ \g_xor_collect_flush_seen_num\space <-~
            \int_use:N \l_tmpa_int  }
%</trace>
%    \end{macrocode}
%    Something wrong here if we get negative values!
%    \begin{macrocode}
%<*debug>
  \int_compare:nNnT \l_tmpa_int < \c_zero {\ERROR }
%</debug>
%    \end{macrocode}
%
%    \begin{macrocode}
  \num_gset:Nn \g_xor_collect_flush_seen_num {%\the ok? FMi
               \l_tmpa_int}
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_set:Nn \l_tmpc_int \g_xor_trial_flush_seen_num
  \int_zero:N \l_tmpb_int
  \int_whiledo:nNnT \l_tmpb_int < \l_tmpa_int
  {
    \int_incr:N \l_tmpb_int
    \int_incr:N \l_tmpc_int
%<*trace>
    \trace:n{xor_flush_fuzziness_ \int_use:N \l_tmpb_int _action:\space
           =~ \exp_not:c { xor_flush_fuzziness_ \int_use:N \l_tmpb_int _action:}\space
           <-~ \exp_not:c  {xor_flush_fuzziness_ \int_use:N \l_tmpc_int _action:}
          }
    \trace:n{g_xor_flush_ \int_use:N \l_tmpb_int _last_float_num\space
           =~ \num_use:c {g_xor_flush_
                          \int_use:N \l_tmpb_int
                          _last_float_num}
           \space <-~
           \num_use:c {g_xor_flush_ \int_use:N \l_tmpc_int
                       _last_float_num}
          }
    \trace:n{g_xor_flush_ \int_use:N \l_tmpb_int _classes_clist\space
           =~ \clist_use:c {g_xor_flush_ \int_use:N \l_tmpb_int _classes_clist}
              \space <-~
              \clist_use:c {g_xor_flush_ \int_use:N \l_tmpc_int _classes_clist}
          }
    \trace:n{g_xor_flush_ \int_use:N \l_tmpb_int _min_col_num \space <-~ 1}
%</trace>
    \glet:cc
      { xor_flush_fuzziness_ \int_use:N \l_tmpb_int _action:}
      { xor_flush_fuzziness_ \int_use:N \l_tmpc_int _action:}
    \num_gset_eq:cc
      {g_xor_flush_ \int_use:N \l_tmpb_int _last_float_num}
      {g_xor_flush_ \int_use:N \l_tmpc_int _last_float_num}

    \clist_gset_eq:cc
      {g_xor_flush_\int_use:N \l_tmpb_int _classes_clist}
      {g_xor_flush_\int_use:N \l_tmpc_int _classes_clist}

    \num_gset:cn {g_xor_flush_ \int_use:N \l_tmpb_int _min_col_num}{1}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
  \clist_gclear:N \g_xor_flush_max_classes_clist
%    \end{macrocode}
%    Need to reset |\g_xor_trial_flush_seen_num| in case the current macro
%    is called again too early, e.g., if it is called to initialize a
%    float page and then again to initialize a text page.
%    \begin{macrocode}
  \num_gzero:N \g_xor_trial_flush_seen_num
%<*trace>
  \trace_pop:n{xor_initialise_flush_data:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsection{Support for Here Points}
%
% A ``Here Point'' is a place in the galley at which something is
% supposed to happen. For example, a marginal note needs to be
% attached to the column, or a float needs to be inserted into the
% column (here float), or it needs to be made sure that from that
% point on there is still a certain amount of space available in the
% column.
%
% With each here point there is associated a float structure (i.e. a
% box and its corresponding |\toks| register) although in most cases
% only parts of that structure is used. In addition each here point
% has an associated dimension which denotes the amount of available
% space which is required after the here point in the column to allow
% to place the here point into this column. If this requirement is not
% met the here point is moved to the next column (or page) by ending
% the current column prematurely at the last legal breakpoint before
% the here point (not at the here point itself\footnote{It should be
% considered to allow breaking directly at the here point in special
% cases, i.e., specified at the here point declaration.}). This
% behaviour will ensure that a line of text preceding the here point
% will also be moved to the next column or page which is important in
% case of marginals and similar situations. In case of here floats it
% might not be a requirements so perhaps this should be made
% customisable.
%
% At the moment the ``type'' in the float structure is used to define
% the type of here point. E.g.,
% \begin{description}
% \item[mpar] denotes a marginal
% \item[rspace] denotes a requested space
% \item[figure,table,\ldots] all normal float types identify the here
% point as belonging to a here float.
% \end{description}
% The down side of this approach is that ``mpar'' can't be used as a
% float type  any longer and the whole approach might be too difficult
% to extend this way. This needs certainly needs a cleanup.
%
% It  is quite likely that there will be additional values that need
% storing on a per here point basis. For this reason the code below
% provides the requiredspace as a data structure external to the float
% structure. Otherwise it could probably be integrated therein.
%
% When a here point is encountered while making columns for a trial or
% for the final page, its requirements are checked. If they are
% fulfilled then a here-point-type specific function will update the
% column material (e.g. by adding a here float or a marginal).
%
% Here points are in many aspects like flush points. So most of the
% code below should not be very surprising.
%
% \begin{macro}{\g_xor_collect_here_seen_num}
%    The number |\g_xor_collect_here_seen_num| records the number of here
%    points we have have seen during collection.
%    \begin{macrocode}
\num_new:N \g_xor_collect_here_seen_num
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_trial_here_seen_num}
%    The number |\g_xor_trial_here_seen_num| records the number of here
%    points we have seen so far during a trial, i.e., it will be
%    initialised to zero at the beginning of the trial and advanced by
%    one for each here point encountered.
%    \begin{macrocode}
\num_new:N \g_xor_trial_here_seen_num
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_floats_here_seq}
%    List of floats that should appear at a here point.\footnote{list?
%       or on several here points?}
%    \begin{macrocode}
\seq_new:N \g_xor_floats_here_seq
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_saved_floats_here_seq}
%    Saved version of the |\g_xor_floats_here_seq| while we run a through the
%    float placement trial since we need the full |\g_xor_floats_here_seq| again in
%    the next trial.
%    \begin{macrocode}
\seq_new:N \g_xor_saved_floats_here_seq
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_add_here_point:Nn}
%    |\xor_add_here_point:Nn| adds a here point to the MVL. It takes two
%    arguments: the box reference associated with the here point and
%    the vertical space that needs to be reserved for the material
%    added.
%    \begin{macrocode}
\def_new:Npn \xor_add_here_point:Nn #1#2{
%    \end{macrocode}
%    we get passed a tlp containing the float box so we need to expand
%    it once before putting it into the sequence.
%    \begin{macrocode}
  \seq_gput_right:No \g_xor_floats_here_seq #1
%    \end{macrocode}
%
%    \begin{macrocode}
  \num_gincr:N\g_xor_collect_here_seen_num
%    \end{macrocode}
%
%    \begin{macrocode}
  \num_gset:cn {g_xor_here_ 
                \num_use:N\g_xor_collect_here_seen_num _min_col_num}
               {1}
%    \end{macrocode}
%
%    \begin{macrocode}
  \setlength\l_tmpa_dim{#2}
  \tlp_gset:cx {g_xor_here_ 
                \num_use:N \g_xor_collect_here_seen_num _required_space_tlp}
               {\dim_use:N \l_tmpa_dim}
%    \end{macrocode}
%
%    \begin{macrocode}
  \xor_add_badly_guarded_penalty:N\c_xor_output_here_float_penalty
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_initialise_here_data:}
%    \begin{macrocode}
\def_new:Npn \xor_initialise_here_data:{
%<*trace>
  \trace_push:n{xor_initialise_here_data:}
%</trace>
%    Does this need any documentation?
%
%    Well, we have to get rid of all information relating to here
%    float penalties that have been typeset on the previous page and
%    move the remaining ones (if any) to the front.
%    \begin{macrocode}
  \int_set:Nn \l_tmpa_int \g_xor_collect_here_seen_num
  \int_add:Nn \l_tmpa_int {-\g_xor_trial_here_seen_num }
%<*trace>
  \trace:n{g_xor_collect_here_seen_num~
         =~ \g_xor_collect_here_seen_num\space <-~
            \int_use:N \l_tmpa_int  }
%</trace>
%    \end{macrocode}
%    Something wrong hereif we get negative values!
%    \begin{macrocode}
%<*debug>
  \int_compare:nNnT \l_tmpa_int<\c_zero {\ERROR}
%</debug>
%    \end{macrocode}
%
%    \begin{macrocode}
  \num_gset:Nn \g_xor_collect_here_seen_num \l_tmpa_int
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_set:Nn \l_tmpc_int \g_xor_trial_here_seen_num
  \int_zero:N \l_tmpb_int
  \int_whiledo:nNnT \l_tmpb_int < \l_tmpa_int
  {
    \int_incr:N \l_tmpb_int
    \int_incr:N \l_tmpc_int
%<*trace>
    \trace:n{g_xor_here_ \int_use:N \l_tmpb_int _required_space_tlp\space
           =~ \tlp_use:c {g_xor_here_ \int_use:N\l_tmpb_int 
                          _required_space_tlp}
    \space <-~
              \tlp_use:c {g_xor_here_ \int_use:N \l_tmpc_int 
                          _required_space_tlp}
          }
    \trace:n{g_xor_here_ \int_use:N \l_tmpb_int _min_col_num \space <-~ 1}
%</trace>
    \tlp_gset_eq:cc
       {g_xor_here_ \int_use:N \l_tmpb_int _required_space_tlp}
       {g_xor_here_ \int_use:N \l_tmpc_int _required_space_tlp}

    \num_gset:cn {g_xor_here_ \int_use:N \l_tmpb_int _min_col_num}{1}
  }
%<*trace>
  \trace_pop:n{xor_initialise_here_data:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_split_off_last_line_from_clvv:}
%
%    When a here point doesn't fit onto the current page or column for
%    some reason it will be moved into the next column. In some cases,
%    e.g., when the here point is associated with the line before it
%    (as, for example, in marginals) it is necessary to move the line
%    also to the later column.
%
%    The purpose of |\xor_split_off_last_line_from_clvv:| (to be called inside the
%    OR) is to split box 255 at the latest possible breakpoint before
%    the end and return the material following this breakpoint to the
%    MVL.
%
%    The idea is as follows: if we subtract 1sp from the height of
%    box 255 and also subtract all of its internal shrinkability and
%    then split it to this height it can't any longer reach the final
%    breakpoint (by 1sp). Thus it will settle with some earlier
%    breakpoint and chances are very very good that this will be the
%    prefinal one.
%    \begin{macrocode}
\def_new:Npn \xor_split_off_last_line_from_clvv: {
%<*trace>
  \trace_push:n{xor_split_off_last_line_from_clvv:}
  \trace:n{goal:~ \dim_use:N \pagegoal;~ total:~ \dim_use:N \pagetotal;~ shrink:~
         \dim_use:N \pageshrink}
  \trace:n{ht255:~ \the\box_ht:N255;~ dp255:~ \the\box_dp:N255}
%</trace>
%    \end{macrocode}
%
%
%    \begin{macrocode}
  \dim_set:Nn \l_tmpa_dim {\box_ht:N\c_twohundred_fifty_five}
%    \end{macrocode}
%    Looking at |\box_ht:N255| should be the same as |\pagetotal-\pagedepth|
%    or not?\footnote{Doesn't seem to be the case, bug in the code,
%    the program, or in my thinking? (seems to be a bug in \TeX:
%    pagedepth is always zero in the OR!)}
%    \begin{macrocode}
  \dim_sub:Nn \l_tmpa_dim \pageshrink
  \dim_sub:Nn \l_tmpa_dim {1sp}
%{\showoutput\showbox\c_twohundred_fifty_five}
%    \end{macrocode}
%    Before splitting we have to ensure that the maximum depth is not
%    larger than the maximum depth allowed on the MVL.
%    \begin{macrocode}
  \dim_set:Nn \splitmaxdepth \@maxdepth
  \vbox_set_split_to_ht:NNn \c_zero \c_twohundred_fifty_five {\l_tmpa_dim}
%{\showoutput\showbox\c_zero}
%{\showoutput\showbox\c_twohundred_fifty_five}
%    \end{macrocode}
%
%    Before we now |\vbox_unpack_clear:N| 255 back onto the MVL we have to make sure
%    that the sum of its vertical dimensions plus the requested space
%    for the current here point is smaller than a full column height.
%
%    If we don't do that we might end up with a situation where we are
%    pushing the two from column to columns since they will never fit.
%    \begin{macrocode}
  \dim_set:Nc \l_tmpa_dim
             {g_xor_here_ \g_xor_trial_here_seen_num _required_space_tlp}
  \dim_add:Nn \l_tmpa_dim {   \box_ht:N\c_twohundred_fifty_five
                            + \box_dp:N\c_twohundred_fifty_five}
%    \end{macrocode}
%    If the sum is too large we reduce the required space for the here
%    point and complain (not really done yet the latter).
%    \begin{macrocode}
  \dim_compare:nNnT \l_tmpa_dim > \textheight
  {
    \ERROR-HERE-TOO-LARGE
    \dim_set:Nn \l_tmpa_dim { \textheight - \box_ht:N\c_twohundred_fifty_five
                                          - \box_dp:N\c_twohundred_fifty_five }
    \tlp_gset:cx
      {g_xor_here_ \num_use:N\g_xor_trial_here_seen_num _required_space_tlp}
      {\dim_use:N \l_tmpa_dim}
  }
%    \end{macrocode}
%    So now we can |\vbox_unpack_clear:N| and then move the top from the split back
%    into 255 (essentially to have it taken out of that register by
%    the code following, but such is life).
%    \begin{macrocode}
  \vbox_unpack_clear:N\c_twohundred_fifty_five
  \box_gset_eq:NN \c_twohundred_fifty_five \c_zero
%<*trace>
  \trace_pop:n{xor_split_off_last_line_from_clvv:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{Support for Grid Points}
%
%
%
%
% \begin{macro}{\xor_align_collected_galley_and_restart:}
%    |\xor_align_collected_galley_and_restart:| is called inside
%    |\xor_OR_grab_some_cols:nnnn| when we have encountered a grid point. It is
%    supposed to align the current line with the text grid and then
%    restarts the galley processing.
%
%    We do this by putting the material gathered so far into a box of
%    appropriate size, and then push this pack onto the recent
%    contributions for reconsideration.
%    \begin{macrocode}
\def_new:Npn \xor_align_collected_galley_and_restart: {
%<*trace>
  \trace_push:n{xor_align_collected_galley_and_restart:}
  \trace:n{GRID:~ page~ goal~\space\space\space =~ \dim_use:N \pagegoal}
  \trace:n{GRID:~ page~ total~\space\space =~ \dim_use:N \pagetotal}
  \trace:n{GRID:~ page~ depth~\space\space =~ \dim_use:N \pagedepth}
  \trace:n{GRID:~ page~ shrink~\space =~ \dim_use:N \pageshrink}
  \trace:n{GRID:~ page~ stretch~ =~ \dim_use:N \pagestretch}
  \trace:n{GRID:~ page~ fil~ stretch~ =~ \dim_use:N \pagefilstretch}
  \trace:n{GRID:~ page~ fill~ stretch~ =~ \dim_use:N \pagefillstretch}
  \trace:n{GRID:~ page~ filll~ stretch~ =~ \dim_use:N \pagefillstretch}
  \trace:n{GRID:~ ht~ 255~\space =~ \the\box_ht:N\c_twohundred_fifty_five}
  \trace:n{GRID:~ dp~ 255~\space =~ \the\box_dp:N\c_twohundred_fifty_five}
%</trace>
%    \end{macrocode}
%    As a first step we remove the guard box since it has now served
%    its purpose.
%    \begin{macrocode}
  \xor_remove_guard_box_from_cclv:
%    \end{macrocode}
%    Then we calculate the distance to nearby grid points.
%    \begin{macrocode}
  \xor_snap_to_grid:nn {\box_ht:N\c_twohundred_fifty_five} 
                       \pagesetup@grid@point@sep
%    \end{macrocode}
%    So the next step is to make a decision which grid point to
%    use. The strategy used below can probably be refined
%    further\ldots
%
%    First we test if the next grid point down makes us fall off the
%    page\footnote{We should use \texttt{\string\pagegoal} for the
%    test I think, not the commented out construct below, since in
%    case of footnotes the available space for text might has be
%    reduced!}, if so\ldots
%    \begin{macrocode}
  \dim_compare:nNnTF \returned@size > \pagegoal
  {
          %  \csname g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim\endcsname % not!
%    \end{macrocode}
%    \ldots we better try using the previous grid point.
%    \begin{macrocode}
    \dim_compare:nNnTF \returned@lower@delta@size < \pageshrink
    {
%    \end{macrocode}
%    If the |\pageshrink| allows us to reach the previous point then
%    use it.
%    \begin{macrocode}
% can use it: do so
%<*trace>
      \trace:n{GRID:~ outside~ page,~ choosing~ lower~ grid~ point}
%</trace>
      \glet:NN \returned@size \returned@lower@size
      \gdef:Npx \returned@delta@size {-\returned@lower@delta@size }
    }
    {
%    \end{macrocode}
%    Otherwise, ouch \ldots{} what now? Can this happen? Unfortunately
%    yes, it seems to happen, for example, when we are trying to place
%    floats.\footnote{Analyse this situation and decide on a course of
%    action if necessary.}
%    \begin{macrocode}
      \OuchERROR
    }
%    \end{macrocode}
%    Otherwise we are in the normal case, i.e., somewhere in the
%    middle of the page.
%    \begin{macrocode}
  }
  {
%    \end{macrocode}
%    So now we can in principle choose either grid point. The code
%    below makes the decision based on which grid point is closer but
%    chooses the previous point only if |\pageshink| allows
%    it.\footnote{One could also have a look at the available
%    stretchability and base the decision on the resulting badness,
%    this might in fact be the more appropriate way!}
%    \begin{macrocode}
    \dim_compare:nNnT \returned@lower@delta@size < \returned@delta@size
    {
      \dim_compare:nNnT \returned@lower@delta@size < \pageshrink
      {
%<*trace>
        \trace:n{GRID:~ choosing~ lower~ grid~ point}
%</trace>
        \glet:NN \returned@size \returned@lower@size
        \gdef:Npx \returned@delta@size {-\returned@lower@delta@size }
      }
    }
  }
%<*trace>
  \trace:n{GRID:~ adjustment:~ \the\box_ht:N\c_twohundred_fifty_five\space 
         ->~ \returned@size}
%</trace>
%    \end{macrocode}
%    Whatever the decision was, we finally bundle up all material in a
%    box with the vertical size being that of the chosen grid point
%    (no |\maxdepth| setting in this case) and return this box to the
%    MVL followed by any footnotes found in that process. These
%    footnotes are reinserted so that they will be reconsidered but
%    since we have no break point between the box and them they will
%    be considered as a unit.
%    \begin{macrocode}
  \vbox_to_ht:nn \returned@size {\vbox_unpack_clear:N\c_twohundred_fifty_five}
  \@reinserts
%    \end{macrocode}
%    We know that the material returned to the MVL is followered
%    immediately by a box of size zero followed by a penalty thus
%    there will be a breakpoint in the right place (or so we hope) so
%    that the box plus the following footnotes will still fit into the
%    column when reprocessed.
%    \begin{macrocode}
%<*trace>
  \trace_pop:n{xor_align_collected_galley_and_restart:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\OuchERROR}
%    This part of the code (as far as I can see right now) will be
%    executed if there is some larger display object (ie off grid)
%    which will just fit onto the page unaligned but not if we align
%    to the next grid point. The reason for this is that somewhere on
%    the column there are also footnotes for example, which result in
%    the column not being an integral number of grid lines.
%    \begin{macrocode}
\def_new:Npn \OuchERROR{
%<*trace>
  \trace:n{Failed:~grid~ overflowing~ column~ \int_use:N\g_xor_curr_col_int}
%</trace>
%<*progress>
  \xor_progress_failed:n{next~ possible~ grid~ point~ in~ column~
                        \int_use:N\g_xor_curr_col_int\space outside~ page}
%</progress>
%    \end{macrocode}
%    I think essentially what is needed here is to split the column
%    just before the current line, ie, using something like
%    |\xor_split_off_last_line_from_clvv:| (except that this only works for here
%    points right now) and this move the grid align penalty to the
%    next column.\footnote{Not done! FIX}
%    \begin{macrocode}
%  \xor_split_off_last_line_from_clvv:
%  \(re)???add@guarded@penalty\c_xor_output_grid_align_penalty
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\std@AlignToGrid}
%    This is the definition for |\AlignToGrid| if we are really doing
%    grid based layout.
%    \begin{macrocode}
\def_new:Npn \std@AlignToGrid{
  \xor_add_badly_guarded_penalty:N\c_xor_output_grid_align_penalty
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\IgnoreAlignToGrid}
% \begin{macro}{\ObeyAlignToGrid}
%    |\IgnoreAlignToGrid| will turn off automatic grid alignment for a
%    while, while |\ObeyAlignToGrid| will turn it on again. This is
%    needed in commands that want to set something outside the grid
%    and then realign afterwards, e.g., a heading. If that heading
%    would follow, say, a list that issued a |\AlignToGrid| to be
%    executed on the next paragraph, that |\AlignToGrid| would
%    effectively appear on the heading title thus forcing that to be
%    on a grid line, which is typically not intended. So the heading
%    macro first says |\IgnoreAlignToGrid| then typesets the material
%    which should be not aligned, then says |\ObeyAlignToGrid| and
%    prepares to install its own |\AlignToGrid| (typically after the
%    first line of text via |\everypar|).
%    \begin{macrocode}
\def_new:Npn \IgnoreAlignToGrid{
  \glet:NN \AlignToGrid \do_nothing:
}
\def_new:Npn \ObeyAlignToGrid{
  \glet:NN \AlignToGrid \std@AlignToGrid
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\AlignToGrid}
%    |\AlignToGrid| is the command that inserts a grid point which
%    triggers alignment to the text grid for the current line (if we
%    are doing grid based design). It should be set in the page setup
%    so the default is an error.
%    \begin{macrocode}
\def_new:Npn \AlignToGrid {\ERROR}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\TextAlignToGrid}
%    In nearly all cases the alignment should be done for a text line,
%    so we provide this abbreviation which starts horizontal mode if
%    necessary.
%    \begin{macrocode}
\def_new:Npn \TextAlignToGrid{ \leavevmode \AlignToGrid }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \subsection{Initialisations}
%
%    The initialisation at begin document isn't properly done
%    yet. Some bits are done unnecessarily here (by calling
%    initialisation commands that do too much and some bits are
%    problably still in the wrong place. Furthermore the column data
%    initialisation needs to be resolved properly. Right now we
%    hardwire a maximum of 6 columns down there and initialise the
%    data structures for all the potential columns independently of
%    whether or not they are ever being used.\footnote{SORT OUT! FIX}
%    \begin{macrocode}
\AtBeginDocument{
  \group_begin:
    \int_gset:Nn \g_xor_cols_int 6
    \xor_cols_setup:
%    \end{macrocode}
%    More column data stuff which needs to be set only the very first
%    time!
%    \begin{macrocode}
    \xor_forall_columns:n {
%    \end{macrocode}
%
%    \begin{macrocode}
%FMi ##1?
       \seq_map_inline:Nn \g_xor_float_classes_seq
              {
               \num_gset:cn {g_xor_flseq_type_#1_col_
                             \int_use:N\g_xor_curr_col_int _num}{0}
               \num_gset:cn {g_xor_flseq_areas_top_type_#1_col_
                             \int_use:N\g_xor_curr_col_int _num}{0}
              }
    }
%    \end{macrocode}
%
%    The default for the allowed float positions should be all areas known (not only those
%    currently used!)
%    \begin{macrocode}
    \seq_map_inline:Nn \g_xor_float_classes_seq
       {
        \tlp_gset_eq:cN
            {g_xor_type_ #1 _allowed_areas_tlp}
            \g_xor_areas_known_clist
        \num_gset:cn {g_xor_flseq_type_#1_col_0_num}{0}
       }
  \group_end:
%    \end{macrocode}
%
%    Start the document by collecting text.
%    \begin{macrocode}
  \bool_gset_true:N \g_xor_collect_new_stuff_bool
% \xor_next_page_setup:         not necessary? check
  \xor_collect_setup:
}
%    \end{macrocode}
%
%
% \endinput
\endinput
%
% $Log$
% Revision 1.16  2005/03/01 22:53:24  morten
% Small updates, more expl3 conversion
%
% Revision 1.14  2004/12/12 20:30:18  mittelba
% if we end the document not in the last column, something is left over
% (probably some guarded penalty) which is then carried from page to
% page thus making the document generated end endless succestion of
% pages.
%
% further checks suggests that this is due to hitting the \end
% primitive while \deadcycles is > zero ... yes indeed it happened
% because we have to invoke the OR once to remove the collect
% penalty. so this needs to set deadcycles back to zero.
%
% Revision 1.13  2004/12/06 23:01:23  mittelba
% fix for here float not aligning to grid
%
% Revision 1.12  2004/12/05 22:20:58  mittelba
% fixing \SPANCNT to have 1 instead of <empty> as default
% adding missing gloabl to inline box assignment
%
% Revision 1.11  2004/12/04 22:54:08  mittelba
% starting to define a box module ... unfinished and names not yet right!
%
% Revision 1.10  2004/11/28 18:09:38  mittelba
% \xor_OR_cleanup_setup: has got an argument so that different followup
% actions can happen.
%
% lots of small stuff related to the balancing setup
%
% Revision 1.9  2004/11/13 10:04:06  mittelba
% new license (LPPL)
%
% Revision 1.8  2004/10/31 21:54:05  mittelba
% further balancing ... all very tmp but at least it does start to
% balance :-)
%
% Revision 1.7  2004/10/30 18:46:06  mittelba
% further cleanup using expl3 concepts
% first attempt at balancing (unfinished)
%
% Revision 1.6  2004/10/12 21:40:46  mittelba
% updates up to p29
%
% Revision 1.5  2004/10/03 22:44:27  mittelba
% more updates ... still not getting closer ...
%
% Revision 1.4  2004/10/03 15:36:03  mittelba
% more cleanup ... tedious ...
%
% Revision 1.3  2004/10/01 21:46:40  mittelba
% many further updates, still a lot to do
%
% Revision 1.2  2004/09/27 20:06:20  mittelba
% in the middle of normalizing to expl3 syntax
%
% Revision 1.1  2001/07/26 19:55:12  latex3
% original web distrib
%
% Revision 1.53  2000/08/11 07:14:25  latex3
% added header
%
% Revision 1.52  2000/08/11 06:49:21  latex3
% untabify
%
% Revision 1.51  2000/08/11 06:46:48  latex3
% change logic for handling special penalties once more (and still not
% okay)
%
% Revision 1.50  2000/08/06 19:03:44  latex3
% change initialisation at \begin{document}
% fix \columnbreak
%
% Revision 1.49  2000/08/04 13:58:16  latex3
% documented issue when grid point overflows column
%
% Revision 1.48  2000/08/04 10:22:31  latex3
% added \split_get_parts:nnNN (probably not final version)
%
% Revision 1.47  2000/07/26 20:37:03  latex3
% working version of grid points (text grids)
%
% Revision 1.46  2000/07/21 13:52:13  latex3
% more renaming for float sequence class concept
%
% Revision 1.45  2000/07/19 17:12:08  latex3
% introduced float sequence class concept
% added variables for float area separation
%
% Revision 1.44  2000/07/10 19:24:59  latex3
% some start at supporting "balance points" (unfinished).
% added \xor_cols_setup:.
% getting rid of extra empty page at end due to old defnition of
% \clearpage.
%
% Revision 1.43  2000/07/04 19:45:40  latex3
% fix GRID stuff (restore all values as needed)
%
% Revision 1.42  2000/07/01 16:07:26  latex3
% use \xor_update_this_area_span_cols:n
% integrate code to support grid design (first draft)
%
% Revision 1.41  2000/06/29 17:40:44  latex3
% introduced \xor_this_area_setup:o
%
% Revision 1.40  2000/06/26 15:16:15  latex3
% prototype support for \g_xor_float_area_skip
%
% Revision 1.39  2000/06/22 20:07:51  latex3
% renamed some macros to get them more uniform
%
% Revision 1.38  2000/06/22 10:59:57  latex3
% Included support for writing fpl files
%
% Revision 1.37  2000/06/21 09:55:41  latex3
% fix typo
%
% Revision 1.36  2000/06/19 19:03:56  latex3
% make \num_gincr:N and \num_gdecr:N behave (not update \count@)
% cleanup flushing (if fail only move flush point one column)
%
% Revision 1.35  2000/06/18 14:59:50  latex3
% docu updates (and a bug fix due to typo)
%
% Revision 1.34  2000/06/16 11:21:14  latex3
% rename \construct@and@test@col@height to \construct@and@test@col@ht
% rename \construct@and@test@col@heights to \construct@and@test@col@hts
% rename \cl@height1 to \@col@ht@1 (etc)
%
% Revision 1.33  2000/06/16 11:05:25  latex3
% implemented tfl@ support (top area float sequences)
% support float-callout-span-constraint
% more documentation
%
% Revision 1.32  2000/06/15 15:20:16  latex3
% implemented new semantics for area names
%
% Revision 1.31  2000/06/15 09:32:18  latex3
% added mising \end{macro}'s
%
% Revision 1.30  2000/06/13 20:44:25  latex3
% guard the output@collect@penalty
% implemented fuzzy flushing (except for spreads)
%
% Revision 1.29  2000/06/06 11:03:21  latex3
% before attempting fuzzyflush
%
% Revision 1.28  2000/05/03 20:17:31  latex3
% need more info about here floats
%
% Revision 1.27  2000/05/03 18:45:40  latex3
% fix bugs: always have a trial run wihtout floats to initialise here
% and flush points; reset \g_xor_trial_flush_seen_num after using it to update
% the data structures on a new pages; have adding to the defer area
% close other areas :-)
% more documentation
%
% Revision 1.26  2000/04/27 19:50:11  latex3
% some stats gathered now
% combine \xor_OR_grab_trial_cols: and \xor_OR_grab_best_cols: as far as possible
% some bug fixes and additional documentation
%
% Revision 1.25  2000/04/21 19:08:43  latex3
% code cleanup
% additional documentation
% fixes for here points
% support for footnote setup
%
% Revision 1.24  2000/04/11 21:06:06  latex3
% basically Chris's 1.24 plus my changes
%
% Revision 1.24  2000/04/10  16:41:14  car2
% typos, comments and guardbox removal
%
% Revision 1.23  2000/04/09 20:02:00  latex3
% fix topskip problem in collection
% added first draft of marginpar support
%
% Revision 1.22  2000/04/08 09:47:06  latex3
% first draft of here point implementation
% code cleanup
% further documentation
%
% Revision 1.21  2000/03/31 17:12:41  latex3
% disable preplacing deferred floats (until caption handling is fixed)
% fix float page handling
% ensure that float pages don't add additional captions (don't mind that
% the float page comes out even worse)
%
% Revision 1.20  2000/03/26 21:05:11  latex3
% work on float pages
% some renaming in particular \xor_try_this_area:
%   and \xor_try_next_area:
% some more documentation
%
% Revision 1.19  2000/03/24 15:34:27  latex3
% version that starts supporting spans (still a hack yet)
%
% Revision 1.18  2000/03/22 15:51:11  latex3
% some normalisations of names
% moved code around
% lot of updates
%
% Revision 1.17  2000/03/17 20:26:40  latex3
% more fixes to flushing (looks good now)
%
% Revision 1.16  2000/03/16 10:28:29  latex3
% partial and full flush working for the first time
%
% Revision 1.15  2000/03/05 19:36:53  latex3
% some renaming
% support multiple columns (6 max right now)
% fix flush float logic (hopefully)
%
% Revision 1.14  2000/02/28 23:41:14  david
% deadcycles
%
% Revision 1.13  2000/02/27 15:39:53  david
% *** empty log message ***
%
% Revision 1.12  2000/02/27 15:12:00  david
% 2nd attempt at flush floats (working as far as implemented)
%
% Revision 1.11  2000/02/27 11:26:35  david
% first attempt at flush floats
%
% Revision 1.10  2000/02/26 18:20:09  david
% added pre-allocation of deferred floats to float areas
%
% Revision 1.9  2000/02/21 23:25:11  david
% t11|t22 support in optional argument
%
% Revision 1.8  2000/02/19 23:14:58  david
% chris' doc fix
%
% Revision 1.7  2000/02/16  13:40:40  latex3
% added 3col support
%
% Revision 1.6  2000/02/16  10:07:13  latex3
% added further documentation
% fixed bug by removing code from \xor_try_this_area: to
%   \pretests@success@action
% handle case of hitting special output penalty during trial or
%    page production
% handle case of \newpage ie penalty -10000
%
% Revision 1.5  2000/02/15 01:08:25  david
% dead code
%
% Revision 1.4  2000/02/13  22:40:13  latex3
% moved some stuff around and added macro environments
%
