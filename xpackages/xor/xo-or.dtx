%% \iffalse
%%
%% (C) Copyright 1999-2004 Frank Mittelbach, David Carlisle, Chris Rowley
%% All rights reserved.
%%
%% Not for general distribution. In its present form it is not allowed
%% to put this package onto CD or an archive without consulting the
%% the authors.
%% 
% \fi
%

%    \begin{macrocode}
\def\@tempa#1: #2.dtx,v #3 #4 #5 #6 #7${
  \ProvidesPackage{#2}[#4 #3 #5 #6]}
\@tempa$Id$
%    \end{macrocode}
%
% \subsection{A flowchart of the algorithm}
%
% Several output routines are employed.  Output routines (that is,
% macros to be used as the sole content of the primitive |\output|
% register) are named xxx@or. Typically a companion macro named
% setup@xxx is called to initialise the state (typically setting
% vsize) and to assign |\output|.
%
%
% [The flow chart has be cut into pieces and individual pieces are
%  shown below.]
%
% ^^A \input{xo-flow-chart.sty}  ^^A .sty to ease updating
%
% 
%
% Ignore white space in this package.
%    \begin{macrocode}
\IgnoreWhiteSpace
\InternalSyntaxOn
%    \end{macrocode}
%
%
%
%
% \subsection{General helper Routines}
%
%
% \begin{macro}{\split@skip}
% \begin{macro}{\check@for@fil}
% \begin{macro}{\get@plus@part}
% \begin{macro}{\get@minus@part}
%    |\split@skip| takes four aguments: a template key name (for error
%    recovery), a skip specification (e.g., either the value of a skip
%    register via |\the|\meta{register}, or a macro holding the
%    information, or the specification directly), and two dimen
%    registers. The skip specification is taken apart and the first
%    dimen register receives ``plus'' part and the second the
%    ``minus'' part. If the specification contains any |fil| parts an
%    error is generated since these values can't be assigned to a
%    dimen register.
%    \begin{macrocode}
\begingroup
%    \end{macrocode}
%    We employ the |\lowercase| trick to get certain letters with
%    |\catcode| 12 since we have to scan for them (they are what
%    |\the| outputs. So if we say |MINUS| below we get |minus| but all
%    |\catcode|d 12.
%    \begin{macrocode}
\catcode`\M=12
\catcode`\I=12
\catcode`\N=12
\catcode`\U=12
\catcode`\S=12
%    \end{macrocode}
%    We need |p| with |\catcode| 12 to scan for |pt| but we also need
%    |P| with |\catcode| 11 to be able to say |\PackageError|. So we
%    claim lowecase of |Z| is |p| and then say |ZT| and |ZLUS| below.
%    \begin{macrocode}
\catcode`\Z=12
\lccode`\Z=`\p
\catcode`\T=12
%    \end{macrocode}
%    And we need to scan for |FIL|:
%    \begin{macrocode}
\catcode`\L=12
\catcode`\F=12
%    \end{macrocode}
%    And the error message contains uppercase |V| and |O| and we want
%    to retain those.
%    \begin{macrocode}
\lccode`\V=`\V
\lccode`\O=`\O
%    \end{macrocode}
%    With the above prelims we now apply |\lowercase| to all the
%    definitions below, which will put the correctly |\catcode|d
%    strings in the parsing part of the macros.
%    \begin{macrocode}
\lowercase{
\gdef\split@skip #1#2#3#4{
%    \end{macrocode}
%    |#2| is the skip specification. To be sure that the strings
%    ``plus'', ``minus'', ``pt'' are always having |\catcode| 12 we
%    assign it to a register first. Otherwise a user supplied string
%    like |1in plus .5in| wouldn't be parsable since we are only
%    looking for |pt| and also because in this case the |\catcode|s of
%    |plus| would be 11.
%    \begin{macrocode}
  \@tempskipa#2\relax
%    \end{macrocode}
%    Then we pass this on to |\check@for@fil| which will make sure
%    that there isn't any |fil| present and if not does the rest of
%    the processing.
%    \begin{macrocode}
  \expandafter\check@for@fil \the\@tempskipa FIL\relax\check@for@fil
     {\the\@tempskipa}{#3}{#4}{#1}
 }
%    \end{macrocode}
%    
%    \begin{macrocode}
\gdef\check@for@fil #1FIL#2\check@for@fil#3#4#5#6{
  \ifx\relax#2
    \expandafter
      \get@minus@part #3MINUS 0ZT \get@minus@part{#4}{#5}
  \else
    #4\z@
    #5\z@
    \PackageError{template}{Value~ for~ key~ #6~ contains~ `fil(ll)'}
       {Only~ finite~ minus~ or~ plus~ parts~ are~ allowed~ for~ this~ key.}
  \fi
 }
%    \end{macrocode}
%    
%    \begin{macrocode}
\gdef\get@plus@part  #1ZLUS#2ZT#3\get@plus@part#4{
  #4=#2pt\relax
 }
%    \end{macrocode}
%    
%    \begin{macrocode}
\gdef\get@minus@part  #1MINUS#2ZT#3\get@minus@part#4#5{
  \get@plus@part #1ZLUS 0ZT\get@plus@part{#4}
  #5=#2pt\relax
 }
}
\endgroup
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
%
%
%
%
%
% \subsection{Special Output Routine Penalties}
%
%
% \begin{macro}{\output@collect@penalty}
%    Special penalty marking the point at which the collection OR ended.
%    \begin{macrocode}
\mathchardef\output@collect@penalty=20202
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\output@balance@penalty}
%    Special penalty marking the point at which the collection OR
%    should end collection because we want to balance the material.
%    \begin{macrocode}
\mathchardef\output@balance@penalty=10010
%    \end{macrocode}
% \end{macro}
%
%
% Other special penalties are inbetween -10000 and -10010. Those will
% not stop  the collection OR but are instead recorded along the way.
%
% \begin{macro}{\output@columnbreak@penalty}
%    Special penalty marking the point a forced column break was
%    requested by the user.
%    \begin{macrocode}
\mathchardef\output@columnbreak@penalty=10005
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\output@flush@float@penalty}
% Special penalty to trigger float flushing for one or more types.
%    \begin{macrocode}
\mathchardef\output@flush@float@penalty=10006
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\output@here@float@penalty}
% Special penalty for floats that should stay with their callout.
%    \begin{macrocode}
\mathchardef\output@here@float@penalty=10007
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\output@grid@align@penalty}
% Special penalty for places that should fall on the page grid.
%    \begin{macrocode}
\mathchardef\output@grid@align@penalty=10008
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \subsubsection{Utilities for Special Output Routine Penalties}
%
%
% \begin{macro}{\add@badly@guarded@penalty}
%    Put a special penalty into the output and guard it with a
%    box. The reason this macro is called |\add@badly@guarded@penalty|
%    is that such a box of size zero is still messing up spacing
%    caluclations. Why? Because when the penalty is reached on the MVL
%    the preceeding line has already be fully added (i.e., including
%    its depth). This means that \TeX{} might not reach it at all in
%    time! For example, if the preceeding line would be the last line
%    of the page the depth would not be taken into account yet, but by
%    the time we reach the special penalty it has been added to
%    |\pagetotal| and that may result in not fitting anymore onto the
%    page.
%
%    A solution would be to use a box that has the same depth as its
%    preceeding box and a negative height so that it effectively
%    doesn't modify the galley length. Easy, right?  The only problem
%    is that in case of |\vadjust| (and that is unfortunately the more
%    important case) we just don't know what the preceeding depth is,
%    since |\prevdepth| will always give us a friendly |-1000pt| in
%    that case (start of a vertical sub-list\ldots).
%
%    So not so easy after all. The way out of this dilemma turned out
%    to be complicated and involves a lot of strange corrective
%    actions in the collection process, see there for a replacement of
%    that box and what else can go wrong if one delves into messing
%    around with that part of \TeX.
%    \begin{macrocode}
\def\add@badly@guarded@penalty#1 {
  \ifvmode
    \nointerlineskip
    \vbox to\z@{\vss\the#1}\penalty-#1\relax
  \else
    \@bsphack
    \vadjust{\vbox to\z@{\vss\the#1}\penalty-#1\relax}
    \@esphack
  \fi
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\guard@box}
%    Could be moved into the previous macro.
%
%    The way it is written (using |\prevdepth|) this can only be used
%    in vertical mode! We have to carry over the |\prevdepth| and
%    append the box without adding any additional interline
%    space. Without it one gets nasty extra glue blobs of height
%    |\baselineskip| somewhere in the output.
%    \begin{macrocode}
\def\guard@box#1{
  \dimen@\prevdepth
  \nointerlineskip
  \vbox to0pt{\vss \rlap{#1}\kern\z@}
  \prevdepth\dimen@
}
%    \end{macrocode}
%    Better implementation? The above is wrong!\footnote{FIX!}
%    \begin{macrocode}
\def\guard@box#1{
  \dimen@\prevdepth
  \nointerlineskip
  \begingroup
    \setbox\z@\vbox to\z@{\vss \rlap{#1}}
    \dp\z@\dimen@
    \box\z@
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\remove@guard@box@from@cclv}
%    Remove a guard box again. This always happens in the OR and so we
%    hard code the box number for speed.
%
%    Chris thinks this needs a maxdepth setting.
%    \begin{macrocode}
\def\remove@guard@box@from@cclv{
    \global\setbox\@cclv \vbox{\boxmaxdepth\@maxdepth \unvbox\@cclv
                               \global\setbox\removed@guard@box\lastbox}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\readd@guarded@penalty}
%    Readding a guared penalty including the box that was removed
%    earlier. Probably not needed in the end either since the way it
%    is used at the moment we have a |\topskip| problem this
%    way.\footnote{FIX!!!!}
%    \begin{macrocode}
\def\readd@guarded@penalty#1 {
  \box\removed@guard@box
%FMi what about topskip?
  \penalty-#1\relax}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\removed@guard@box}
%    \begin{macrocode}
\newbox\removed@guard@box
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsection{Columns and their Data Structures}
%
% \begin{macro}{\g_xor_cols_int}
%    We are collecting stuff for a given number of columns. This
%    number of column is available in a count register.
%    \begin{macrocode}
\int_new:N \g_xor_cols_int 
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_curr_col_int}
%    Register denoting the column number of the current column while
%    we cut the galley etc. Should always be modified globally since
%    it is used within output routines.
%    \begin{macrocode}
\newcount\g_xor_curr_col_int
%    \end{macrocode}
% \end{macro}
%
%
%
% \DescribeMacro\g_xor_col_FOO_box
%    Per column number FOO we have one box register allocated in which
%    the column text from the galley is stored during trials and page
%    makeup.
%
% \DescribeMacro\g_xor_ht_col_FOO_dim
%    Per column number FOO we have dimen  register allocated which
%    holds the vertical target size for the column during the trials.
%
% \DescribeMacro\g_xor_t_floats_col_FOO_num
%    Per column number FOO we have a macro number in which we count
%    the number of top floats we have seen so far in this column. This
%    is used to implement |\pagesetup@float@area@sep| handling.
%
% \DescribeMacro\g_xor_b_floats_col_FOO_num
%    Per column number FOO we have a macro number in which we count
%    the number of bottom floats we have seen so far in this column. This
%    is used to implement |\pagesetup@float@area@sep| handling.
%
%
% \DescribeMacro\g_xor_t_delta_col_FOO_tlp
%    Per column number FOO we have a macro in which we record the
%    difference between the real size of all top floats (including
%    there separation spaces) and the nominal size which is used to
%    determine the vertical size of the remaining text column. The two
%    may differ if we do grid typesetting.
%
% \DescribeMacro\g_xor_b_delta_col_FOO_tlp
%    Same kind of delta is recorded per column for the bottom floats.
%
% \DescribeMacro\g_xor_flseq_type_BAR_col_FOO_num
%    For each float type BAR (e.g., |figure|, |table|, etc.) and each
%    column number FOO we have a macro which holds the highest float
%    sequence number for floats of type BAR allocated to column FOO or
%    zero if no float has been allocated so far.
%
% \DescribeMacro{\g_xor_flseq_type_BAR_col_0_num}
%    For each float type BAR (e.g., |figure|, |table|, etc.)
%    |\g_xor_flseq_type_BAR_col_0_num| holds the highest sequence number in columns of the
%    previous page.
%
% \DescribeMacro\g_xor_flseq_areas_top_type_BAR_col_FOO_num
%    |\g_xor_flseq_areas_top_type_BAR_col_FOO_num| is like
%    |\g_xor_flseq_type_BAR_col_FOO_num| but only stores information 
%    about floats allocated to top areas.
%
%

% \begin{macro}{\g_xor_col_1_box}
% \begin{macro}{\g_xor_col_2_box}
% \begin{macro}{\g_xor_col_3_box}
% \begin{macro}{\g_xor_col_4_box}
% \begin{macro}{\g_xor_col_5_box}
% \begin{macro}{\g_xor_col_6_box}
%    Need a box per column (currently fixed at six) to hold material
%    from the galley for this column.
%    \begin{macrocode}
\expandafter\newbox\csname g_xor_col_1_box\endcsname
\expandafter\newbox\csname g_xor_col_2_box\endcsname
\expandafter\newbox\csname g_xor_col_3_box\endcsname
\expandafter\newbox\csname g_xor_col_4_box\endcsname
\expandafter\newbox\csname g_xor_col_5_box\endcsname
\expandafter\newbox\csname g_xor_col_6_box\endcsname
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\g_xor_ht_col_1_dim}
% \begin{macro}{\g_xor_ht_col_2_dim}
% \begin{macro}{\g_xor_ht_col_3_dim}
% \begin{macro}{\g_xor_ht_col_4_dim}
% \begin{macro}{\g_xor_ht_col_5_dim}
% \begin{macro}{\g_xor_ht_col_6_dim}
%    Need a dimen\footnote{Could be a macro if we find ourselves to
%    use up too many dimens.} per column to hold its current vertical
%    target size.
%    \begin{macrocode}
\expandafter\newdimen\csname g_xor_ht_col_1_dim\endcsname
\expandafter\newdimen\csname g_xor_ht_col_2_dim\endcsname
\expandafter\newdimen\csname g_xor_ht_col_3_dim\endcsname
\expandafter\newdimen\csname g_xor_ht_col_4_dim\endcsname
\expandafter\newdimen\csname g_xor_ht_col_5_dim\endcsname
\expandafter\newdimen\csname g_xor_ht_col_6_dim\endcsname
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
%
%
% \subsubsection{Utilities for Columns and their Data Structures}
%
% \begin{macro}{\xor_forall_columns:n}
%    If we want to do something to data structures for all column we
%    can use the macro |\xor_forall_columns:n|. Within its argument the
%    current column is available in the register
%    |\g_xor_curr_col_int|. The macro takes some pains to restore the
%    original value of |\g_xor_curr_col_int| afterwards so that it can
%    be called recoursively.
%    \begin{macrocode}
\def\xor_forall_columns:n#1{
  \tlp_set:Nx \l_xor_saved_curr_col_tlp {\int_use:N \g_xor_curr_col_int}
  \int_gzero:N \g_xor_curr_col_int 
  \@whilenum \g_xor_curr_col_int<\g_xor_cols_int \do
     {\int_gincr:N \g_xor_curr_col_int
      #1
     }
  \int_gset:Nn \g_xor_curr_col_int \l_xor_saved_curr_col_tlp
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_cols_setup:}
%    \begin{macrocode}
\def_new:Npn \xor_cols_setup:{
%<*trace>
  \@tracepush{xor_cols_setup:}
%</trace>
%    \end{macrocode}
%    
%    \begin{macrocode}
  \tlp_gclear:N \g_xor_best_trial_status_tlp

  \xor_forall_columns:n
     {
      \global\csname g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim\endcsname\textheight
%    \end{macrocode}
%    
%    \begin{macrocode}
      \tlp_gput_right:No \g_xor_best_trial_status_tlp
        {
         \expandafter
         \global
           \csname g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim \endcsname
           \textheight
        }
%    \end{macrocode}
%    We haven't seen any top or bottom floats yet.
%    \begin{macrocode}
      \num_gclear:c {g_xor_t_floats_col_ \int_use:N\g_xor_curr_col_int
                     _num}
      \num_gclear:c {g_xor_b_floats_col_ \int_use:N\g_xor_curr_col_int
                     _num}
%    \end{macrocode}
%    For the same reason the delta values for top and bottom areas are
%    zeroed.\footnote{Using \texttt{\string\let} and
%    \texttt{\string\z@} in places like this would be more faster and
%    shorter, but it wouldn't work nicely in tracing as it would make
%    unexpandable macros. Perhaps the tracing versions should be made
%    specially.}
%    \begin{macrocode}
      \tlp_gset:cn {g_xor_t_delta_col_ \int_use:N\g_xor_curr_col_int _tlp}{0pt}
      \tlp_gset:cn {g_xor_b_delta_col_ \int_use:N\g_xor_curr_col_int _tlp}{0pt}
  }

%<*trace>
  \tr@ce{\meaning\g_xor_best_trial_status_tlp}
  \@tracepop{xor_cols_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \subsubsection{User Commands for Columns}
%
%
% \begin{macro}{\columnbreak}
%    And here is the user command formaking a column
%    break:\footnote{All this is stolen from \texttt{multicol.sty} and
%    there is still code that doesn't belong here.}  |\columnbreak| is
%    modelled after |\pagebreak| except that we generate a penalty
%    |-\output@columnbreak@penalty|.
%    \begin{macrocode}
\def\columnbreak{
%    \end{macrocode}
%    We have to ensure that it is only used within a multicolumn
%    environment since if that penalty would be seen by the unmodified
%    \LaTeX{} output routine strange things would happen.
%    \begin{macrocode}
 \ifnum\g_xor_cols_int<\tw@
  \PackageError{xoutput}
   {\noexpand\columnbreak~ in~ one-column~ mode}
   {???}
 \else
  \ifvmode
    \penalty -\output@columnbreak@penalty
  \else
    \@bsphack
    \vadjust{\penalty -\output@columnbreak@penalty}
    \@esphack
  \fi
 \fi}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
%
%
% \subsection{Float Areas and their Data Structures}
%
% Naming conventions for float areas is as follows:
% \begin{quote}
% \meta{identifier}\meta{start-column}\meta{span-count}.
% \end{quote}
% The \meta{identifier} is a single letter denoting the type of area,
% e.g., |t| for top, |b| for bottom. The \meta{span-count} is a single
% digit denoting the number of columns to span. The
% \meta{start-column} is a single digit\footnote{with a bit of care in
% the code this could be extended to allow more than one digit.}
% denoting the start column of the area. Thus |t32| is a top area
% starting at column three and spanning two columns ie three and four.
% A restriction due to the naming scheme is that currently no more than
% 9 columns are possible.
%
% Only a subset of the float areas is allowed to be popolated on a
% page. In essense the current algorithm does not support placements
% that result in splitting the text of a column due to a float (other
% than column `here' floats).\footnote{Perhaps this restriction is
% lifted one day.} This means that if $pcs$ ($p=\textrm{pos}$,
% $c=\textrm{column}$, $s=\textrm{span}$) is a float area that is
% being populated then it must prevent populating all float areas that
% satisfy either
% \[
%    pij  \textrm{ with }   i < c \leq i+j < c+s
% \]
% or
% \[
%    pij  \textrm{ with }   i \leq c+s < i+j \leq \verb=\g_xor_cols_int=
% \]
% The first formula describes the areas which partly overlap from the
% left, the second formula describes those that partly overlap from
% the right. Areas which are sub- or super-areas, e.g., \texttt{t13}
% and \texttt{t22} do not affect each other. The above restriction is
% necessary to prevent situations like
%\begin{verbatim}
%aaaaaaaaaaa 444
%aaaaaaaaaaa 444
%aaaaaaaaaaa 444
%111 222 bbbbbbb
%111 222 bbbbbbb
%111 222 bbbbbbb
%111 222 333 444
%111 222 333 444
%\end{verbatim}
%
%
% For each area |FOO| (e.g., |t13|) we keep a number of global
% variables to store relevant data. These are the following
%    variables\footnote{Not a consistent lot}:
%
% \DescribeMacro\g_xor_area_FOO_seq
%    Floats allocated to the area |FOO| by the page building process
%    are stored in the sequence |\g_xor_area_FOO_seq|.
%
% \DescribeMacro\g_xor_area_FOO_max_float_num
%    The maximum number of floats allowed in area |FOO| is stored in
%    the macro |\g_xor_area_FOO_max_float_num|.
%
% \DescribeMacro\g_xor_area_FOO_float_int
%
%    The number of floats currently allocated to area |FOO| is stored
%    in the count register |\g_xor_area_FOO_float_int|.\footnote{This is a
%    waste of registers!}
%
% \DescribeMacro\g_xor_FOO_class_close_clist
%    The areas that should be closed for floats of the same sequence class the
%    moment a float is placed into area |FOO|. This is a comma
%    separated list.
%
% \DescribeMacro\g_xor_FOO_all_close_clist
%    The areas that should be closed for all float sequence classes the
%    moment a float is placed into area |FOO|. This is a comma
%    separated list.
%
%
%
% \begin{macro}{\g_xor_areas_known_clist}
%    |\g_xor_areas_known_clist| are the areas known to the system.\footnote{or
%    something else, the semantics are still changing} Initialisation
%    is done when declaring individual areas.
%    \begin{macrocode}
\clist_new:N \g_xor_areas_known_clist
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_areas_used_clist}
%    |\g_xor_areas_used_clist| are the areas used by the current page setup.
%    Initialisation is done in the page setup template so the
%    definition below is arbitrary.
%    \begin{macrocode}
\clist_new:N \g_xor_areas_used_clist
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_free_floats_seq}
%    \begin{macrocode}
\seq_new:N \g_xor_free_floats_seq

% lazy tmp solution
\def\@elt#1{\seq_gput_right:Nn \g_xor_free_floats_seq{#1}}
\@freelist
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_active_floats_seq}
%    \begin{macrocode}
\seq_new:N \g_xor_active_floats_seq
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_mvl_floats_seq}
%    \begin{macrocode}
\seq_new:N \g_xor_mvl_floats_seq
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_area_DDD_seq}
%    The list of deferred floats (which we consider being an area in
%    some respects). And that area also needs a three-char name!
%    \begin{macrocode}
\seq_new:N \g_xor_area_DDD_seq
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_DDD_class_close_clist}
% \begin{macro}{\g_xor_DDD_all_close_clist}
%    \begin{macrocode}
\clist_new:N \g_xor_DDD_class_close_clist
\clist_new:N \g_xor_DDD_all_close_clist 
%%%%\def \g_xor_DDD_class_close_clist {\pagesetup@area@list}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\g_xor_this_class_tlp}
% \begin{macro}{\g_xor_this_caption_tlp}
% \begin{macro}{\g_xor_this_span_num_tlp}
% \begin{macro}{\g_xor_this_display_cnt_tlp}
% \begin{macro}{\g_xor_this_allowed_areas_tlp}
% \begin{macro}{\g_xor_this_type_tlp}
%    \begin{macrocode}
\tlp_new:Nn \g_xor_this_class_tlp{}
\tlp_new:Nn \g_xor_this_caption_tlp{}
\tlp_new:Nn \g_xor_this_span_num_tlp{}
\tlp_new:Nn \g_xor_this_display_cnt_tlp{}
\tlp_new:Nn \g_xor_this_allowed_areas_tlp{}
\tlp_new:Nn \g_xor_this_type_tlp{}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% 
%
% \begin{macro}{\g_xor_this_areas_open_clist}
% \begin{macro}{\g_xor_saved_this_areas_open_clist}
%    In |\g_xor_this_areas_open_clist| we store the float areas in which we will try
%    to place a float onto the current page. These areas are tried one
%    after another until the float is successfully placed or we run
%    out of areas. The list does not have any separator (as we assume
%    that all areas are denoted by a letter followed by two digits).
%
%    |\g_xor_saved_this_areas_open_clist| is the saved version needed for
%    backtracking if we encounter a flush point that can't be resolved.
%    \begin{macrocode}
\clist_new:N \g_xor_this_areas_open_clist
\clist_new:N \g_xor_saved_this_areas_open_clist
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_this_areas_closed_clist}
%    In |\g_xor_this_areas_closed_clist| we store the float areas which have been
%    closed for the current float while trying to place it. In this
%    list each area name is followed by a comma (to avoid spurious
%    matches). It is initialised with
%    |\g_xor_class_ \g_xor_this_class_tlp _areas_closed_clist| when 
%    we fetch a new float to try. Once the float is placed we write
%    the then current value back.
%    \begin{macrocode}
\clist_new:N \g_xor_this_areas_closed_clist
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_curr_page_areas_closed_clist}
%    In |\g_xor_curr_page_areas_closed_clist| we store the float areas which have been
%    closed for all float types. In this list each area name is
%    followed by a comma (to avoid spurious matches).
%    \begin{macrocode}
\clist_new:N \g_xor_curr_page_areas_closed_clist
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\g_xor_area_t11_float_int}
% \begin{macro}{\g_xor_area_t21_float_int}
% \begin{macro}{\g_xor_area_b11_float_int}
% \begin{macro}{\g_xor_area_b21_float_int}
%    The float counts are allocated dynamically when an area is
%    declared if they are not defined, but we have a few registers
%    left over from \LaTeX{}'s old OR so we might as well use them.
%    \begin{macrocode}
%\expandafter\int_new:c {g_xor_area_t11_float_int}
\let:cN {g_xor_area_t11_float_int} \@topnum
%\expandafter\int_new:c {b11_float_int}
\let:cN {g_xor_area_b11_float_int} \@botnum
%\expandafter\int_new:c {g_xor_area_t12_float_int}
\let:cN {g_xor_area_t12_float_int} \@dbltopnum
%\expandafter\int_new:c {g_xor_area_b12_float_int}
\let:cN {g_xor_area_b12_float_int} \@dblbotnum
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\g_xor_area_DDD_float_int}
%    And we need to declare the one for the defer area is that isn't
%    going through the normal initialisation process.
%    \begin{macrocode}
\int_new:N \g_xor_area_DDD_float_int
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\pagesetup@float@area@sep}
%    |\pagesetup@float@area@sep| is the separation to use between two
%    adjacent float areas.
%    \begin{macrocode}
\newskip\pagesetup@float@area@sep
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\pagesetup@float@text@sep}
%    |\pagesetup@float@text@sep| is the separation to use between
%    column text and adjacent float areas.
%    \begin{macrocode}
%\newskip\pagesetup@float@text@sep
\let\pagesetup@float@text@sep\textfloatsep % reuse register
\let\textfloatsep\@undefined
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\pagesetup@float@float@sep}
%    |\pagesetup@float@float@sep| is the separation to use between
%    two floats in the same float area.
%    \begin{macrocode}
%\newskip\pagesetup@float@float@sep
\let\pagesetup@float@float@sep\floatsep % reuse register
\let\floatsep\@undefined
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\pagesetup@float@text@shrink}
%    |\pagesetup@float@text@shrink| is the allowed shrinkability of
%    |\pagesetup@float@text@sep|. This is used if we are doing grid
%    typesetting and have to adjust the vertical size of the column.
%    \begin{macrocode}
\newdimen\pagesetup@float@text@shrink
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\pagesetup@float@inline@sep}
%    |\pagesetup@float@inline@sep| is the separation to use between
%    two floats in the same float area.
%    \begin{macrocode}
%\newskip\pagesetup@inline@float@sep
\let\pagesetup@float@inline@sep\intextsep % reuse register
\let\intextsep\@undefined
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pagesetup@float@inline@shrink}
%    |\pagesetup@float@inline@shrink| is the allowed shrinkability of
%    |\pagesetup@float@inline@sep|. This is used if we are doing grid
%    typesetting and have to adjust the vertical size of object to be
%    added, e.g., an inline float with its caption.
%    \begin{macrocode}
\newdimen\pagesetup@float@inline@shrink
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \subsubsection{Utilities for Float Areas and their Data Structures}
%
%
% \begin{macro}{\xor_area_setup:}
%    Initialise all float areas used within the current page setup.
%    \begin{macrocode}
\def_new:Npn \xor_area_setup: {
  \clist_map_inline:Nn
      \g_xor_areas_used_clist
      {
        \int_gzero:c  {g_xor_area_ ##1 _float_int} 
        \seq_gclear:c {g_xor_area_ ##1 _seq}
      }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_flseq_returned_num}
%    \begin{macrocode}
\num_new:N \g_xor_flseq_returned_num
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\first@of@type}
%    The macro |\first@of@type| takes a \meta{type} name as its first
%    argument and an \meta{area} area name as its second argument and
%    will return in the macro |\g_xor_flseq_returned_num| the sequence
%    number of the first float of type \meta{type} currently in
%    \meta{area}. If there is no float of type \meta{type} in this
%    area it will return |-1| (impossible sequence number).
%
%    Code is no longer used anywhere!
%    \begin{macrocode}
%<*obsolete>
\def\first@of@type#1#2{
 \begingroup
   \def\@tempb{#1}
   \num_gset:Nn \g_xor_flseq_returned_num {-1}
   \seq_map_inline:cn {g_xor_area_#2_seq}
                      {\expandafter\first@of@type@aux\the\toks ##1}

 \endgroup
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\first@of@type@aux}
%    This macro picks up the type definition in the data structure of
%    a float and compares it with the name started in |\@tempb|. If
%    they agree |\g_xor_flseq_returned_num| will get updated to
%    contain the sequence number of the float.
%    \begin{macrocode}
\def\first@of@type@aux#1#2#3#4#5#6#7{
  \def\@tempa{#6}
  \ifx\@tempa\@tempb
   \num_gset:Nn \g_xor_flseq_returned_num {#7}
   \gdef:Npn \seq_elt:w ##1\seq_elt_end: {}
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\last@of@type}
%    The macro |\last@of@type| takes a \meta{type} name as its first
%    argument and an \meta{area} area name as its second argument and
%    will return in the macro |\g_xor_flseq_returned_num| the sequence
%    number of the last float of type \meta{type} currently in
%    \meta{area}. If there is no float of type \meta{type} in this
%    area it will return |-1| (impossible sequence number).
%    \begin{macrocode}
\def\last@of@type#1#2{
 \begingroup
   \def\@tempb{#1}
   \num_gset:Nn \g_xor_flseq_returned_num {-1}

   \seq_map_inline:cn {g_xor_area_#2_seq}
                     {\expandafter\last@of@type@aux\the\toks ##1}
 \endgroup
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\last@of@type@aux}
%    \begin{macrocode}
\def\last@of@type@aux#1#2#3#4#5#6#7{
  \def\@tempa{#6}
  \ifx\@tempa\@tempb
    \num_gset:Nn \g_xor_flseq_returned_num {#7}
  \fi}
%</obsolete>
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_this_area_setup:o}
%
%   Whenever the algorithm works with some area as the current
%   candidate for putting a float into it uses the following commands
%   to reference this area:
%
% \DescribeMacro\g_xor_this_area_tlp
%   The macro |\g_xor_this_area_tlp| holds the name of the candidate area, e.g.,
%   it would expand to something like |t13|.
%
% \DescribeMacro\g_xor_this_area_type_tlp
%   The macro |\g_xor_this_area_type_tlp| holds the ``type'' of the area, e.g., |t|
%   in the above example.
%
% \DescribeMacro\g_xor_this_area_col_tlp
%   The macro |\g_xor_this_area_col_tlp| holds the starting column of the
%   area, e.g., |1| in the above example.
%
%
% \DescribeMacro\g_xor_this_area_span_tlp
%   The macro |\g_xor_this_area_span_tlp| holds the number of columns
%   spanned by the  area, e.g., |3| in the above example.
%
%    All the above macros are globally assigned when calling
%    |\xor_this_area_setup:o|. The argument is expanded (!) once since one
%    typical usage is to pick up the first area from an area like
%    |\g_xor_this_areas_open_clist| and pass a token list pointer as
%    the argument. If the area name is passed directly this doesn't
%    really hurt
%
%    \begin{macrocode}
\def\xor_this_area_setup:o #1 {
  \tlp_gset:No \g_xor_this_area_name_tlp {#1}
%    \end{macrocode}
%    This really relies on |\g_xor_this_area_name_tlp| containing exactly three
%    tokens (no error recovery if not).
%    \begin{macrocode}
%\show\g_xor_this_area_name_tlp 
  \expandafter\gassign@area@type@col@and@span@aux\g_xor_this_area_name_tlp 
}
\def\gassign@area@type@col@and@span@aux #1#2#3{
  \gdef \g_xor_this_area_type_tlp        {#1}  % type
  \gdef \g_xor_this_area_col_tlp  {#2}  % col
  \gdef \g_xor_this_area_span_tlp {#3}  % span
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\l_xor_update_col_int}
%    Local counter used in loops over columns.
%    \begin{macrocode}
\int_new:N \l_xor_update_col_int
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xor_update_this_area_span_cols:n}
%
%    If we have to do updates for all columns that are spanned by the
%    current target area we can call |\xor_update_this_area_span_cols:n|. It
%    loops through the columns (backwards!) with |\l_xor_update_col_int|
%    referring to the current 
%    column. Data structure updates have to be global as everything
%    happens within a group.
%    \begin{macrocode}
\def\xor_update_this_area_span_cols:n #1 {
  \begingroup
    \int_set:Nn \l_xor_update_col_int \g_xor_this_area_col_tlp
    \int_add:Nn \l_xor_update_col_int \g_xor_this_area_span_tlp
    \loop
    \ifnum \g_xor_this_area_col_tlp < \l_xor_update_col_int 
      \int_decr:N \l_xor_update_col_int
%<*trace>
      \tr@ce{looking~ at~ column:~ \the\l_xor_update_col_int}
%</trace>
      #1
    \repeat
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
%
% 
%
%
%
% \newpage
% \subsection{Collection Output Routine}
%
% \begin{description}
% \item[Entry:]  |\xor_collect_setup:|
% \item[Exit:]   |\xor_float_placement_setup:|
% \item[Prereq:] |\initialise@next@page| should have been called before.
% \item[Description:] Grab enough text (and float call-outs) to obtain
%    a galley big enough to form the next text page. The page goal is
%    set to a value high enough to ensure that in normal cases text
%    for all columns of the page is collected, i.e, we have a safety
%    margin of 5 extra lines per column.\footnote{This should be made
%    customisable for unusual jobs!}
%
%    If the output routine is triggered with a special penalty (in the
%    range of $-10000>p>-10010=|\output@balance@penalty|$) the penalty
%    is moved into the collection box |\partial@galley@box| without
%    further processing; otherwise the collection is ended and all
%    collected material is moved to |\@holdpg| for use in page
%    production.
%
% \item[Flow:] 
%\begin{footnotesize}
%\begin{verbatim}
%   \xor_collect_setup:
%           |
%           V
%  New OR: \xor_OR_collect:
%           |
%           |<-----------------------------------------
%           |                                         |
%  (natural end of collection reached?)               |
%           |           |                             |
%          yes          no                            |
%           |           |                             |
%           | (record special penalty and carry on)----
%           |           
%           V
%   \xor_float_placement_setup:
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%    Chris noted that |\@holdpg| never gets emptied.  This could be
%    done when the Collection OR is started for a new page (in this
%    next macro).\footnote{FIX}
%
% \begin{macro}{\xor_collect_setup:}
%    \begin{macrocode}
\def\xor_collect_setup:{
%<*trace>
  \@tracepush{xor_collect_setup:}
%</trace>
  \global\holdinginserts\@ne
%    \end{macrocode}
%    We set the |\vsize| for collection to the height of a single
%    column (plus a safety margin of currently five lines to allow for
%    vanishing space at margins) multiplied by the number of columns.
%    \begin{macrocode}
  \global\vsize\textheight
  \global\advance\vsize 5\baselineskip
  \global\multiply\vsize \g_xor_cols_int
%<*trace>
  \tr@ce{collection~vsize:~\the\vsize }
%</trace>
%    \end{macrocode}
%    Initialising the flush point handling:
%    \begin{macrocode}
  \@flushseenfalse
  \@flushfailfalse
%    \end{macrocode}
%    We may have to restart the collection (whenever we find a here or
%    a flush point) and we don't want to get extra space added via
%    |\topskip|. So we can either make |\topskip| zero during
%    collection (current strategy) or back it out whenever we restart.
%
%    We can't set topskip to zero now since a) we want a proper
%    |\topskip| for the first column and b) due to a bloody fix for the
%    old \LaTeX{} OR, a value of |0pt| is set to |1sp| in
%    |\begin{document}| and this results in adding |1sp| at every
%    special point\ldots no, we definitely do not want this! It took
%    me ages to find out why the grid design macros didn't work.
%    \begin{macrocode}
  \xdef\saved@topskip{\the\topskip}
%    \end{macrocode}
%    
%    \begin{macrocode}
  \global\output{\xor_OR_collect:}
%<*trace>
  \@tracepop{xor_collect_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\if@collecting@new@material}
%    There are actually two collecting modes: one when the recent
%    contributions are empty and we are really collecting material
%    that we haven't seen before and one where we collect material
%    that has been collected on a previous collection pass and has been
%    placed again on to the main vertical list. The reason why we need
%    to differentiate between the two is that in the second case we
%    have to handle the special penalties differently since by now
%    they are already surrounded by the proper guard boxes before and
%    after and we better do not disturb this fragile setup.
%    \begin{macrocode}
\newif\if@collecting@new@material
\def\@collecting@new@materialfalse
   {\global\let\if@collecting@new@material\iffalse}
\def\@collecting@new@materialtrue
   {\global\let\if@collecting@new@material\iftrue}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xor_OR_collect:}
%    The output routine during the collection phase assembles the
%    material until enough has been gathered to be sure to fill a
%    page. 
%    \begin{macrocode}
\def_new:Npn \xor_OR_collect:{
%<*trace>
  \@tracepush{xor_OR_collect:}
  \tr@ce{output~pen:~ \the\outputpenalty}
%{\x\showoutput\showbox255}
%</trace>
%    \end{macrocode}
%    We first look if the call to the OR is due to a special penalty.
%    \begin{macrocode}
   \@testfalse
   \ifnum\outputpenalty < -\@M
     \ifnum\outputpenalty > -\output@balance@penalty
       \@testtrue
     \fi
   \fi
   \if@test
%<*trace>
      \tr@ce{Forced~ break~(\the\outputpenalty)~ seen\on@line}
%</trace>
%    \end{macrocode}
%    Whenever a special penalty, i.e., one between $-10000 > p >
%    -10010$ is encountered we need some magic: 
%    \begin{itemize}
% \item We want to keep the the penalty in the collected material but
%      nevertheless carry on with the collection. Simply moving the
%      collected material to a separate box is not enough since then
%      we will restart the collection with an empty page and thus
%      receive a |\topskip| glue as well as probably losing material
%      if there is anything discardable after the special penalty.
% \item But putting a zero box back and doing something to fix the
%      problem with the  |\topskip| glue isn't good either in case we
%      later actually want to break after the line with special
%      penalty, since then we would start a page with our inserted
%      box, and in this case we would like to get a proper |\topskip|
%      and we would like to get rid of discardable stuff.
% \item And there is another problem, we need a guard box in front of
%      that special penalty, but this guard box should not be simply a
%      |\null| box (as it is right now added by
%      |\add@badly@guarded@penalty|) since that will result in wrong
%      page calculations because it will make \TeX{} add the depth of
%      the precious line to the page total which it shouldn't.
%    \end{itemize}
%    So what to do? First of all we remove the guard box in front of
%    the special penalty (which is now at the end of box 255) since we
%    want to replace that with something better, then we
%    store away the depth of box 255 since we need that in a minute.
%    \begin{macrocode}
      \remove@guard@box@from@cclv
%    \end{macrocode}
%    We really have to say |\dp\@cclv| not |\pagedepth|. The latter is
%    always zero in the OR which looks suspiciously like a bug or at
%    least an inconsistency when Don implemented the change from \TeX2
%    to \TeX3 (in \TeX2 |\page...| registers were useless in the OR,
%    now only |\pagedepth| seems to be left).
%    \begin{macrocode}
      \dimen@\dp\@cclv
%    \end{macrocode}
%    Then we subtract the size of the collected material from
%    |\vsize| since we will store it away in a separate box for a
%    while. Note that we have to use |\ht\@cclv| here not |\pagetotal|
%    since the latter might be to large because of that |\null|
%    box. The height of 255 on the other hand is, after the removal of
%    that box the natural height of the material.
%    \begin{macrocode}
      \global\advance\vsize-\ht\@cclv
%    \end{macrocode}
%    Now we append the material to |\partial@galley@box|, this is
%    straight forward.
%    \begin{macrocode}
      \global\setbox\partial@galley@box
               \vbox{\ifvoid\partial@galley@box
                     \else
                       \unvbox\partial@galley@box
                     \fi
                     \unvbox\@cclv
%    \end{macrocode}
%    But how to add the penalty and how to guard it? We need a box or
%    something to ensure the penalty doesn't get lost at a column
%    break but we also want to avoid that \TeX{} adds the depth of the
%    preceding line to |\pagetotal|. Fortunately we know this depth by
%    now (we have just stored it in |\dimen@|), something we didn't
%    know at the time the we added the penalty with
%    |\add@badly@guarded@penalty|. So we could back up and then add a
%    box with zero height and that depth. This way a break directly
%    after this line would have the same |\pagetotal| as a break at
%    the special penalty. In fact, instead of backing up using a
%    |\kern| or a |\vskip| we can simply make the height of the box
%    negative. The advantage is that this way we don't generate a
%    break point between the box and a preceding box and thus don't
%    have to use special precautions to prevent \TeX{} from breaking in
%    front of the guard box.\footnote{This statement is only true for
%    special penalties added using \texttt{\string\vadjust}, i.e., in
%    hmode. If the penalty was added between paragraphs then there
%    might be vertical space in front of the box. This might need
%    special handling too. CHECK!}
%    \begin{macrocode}
                     \setbox\z@\vbox to-\dimen@{}
                     \dp\z@\dimen@
                     \box\z@
                     \penalty\outputpenalty
                    }
%{\showoutput\batchmode\showbox\partial@galley@box\errorstopmode}
%    \end{macrocode}
%    So now we have put everthing we need into the
%    |\partial@galley@box|, but how do we restart our collection
%    process without running into the problems outlined above?
%
%    Well, right now on the recent contributions there will be a
%    penalty node (from our special penalty) which gets set to 10000
%    by \TeX{} followed perhaps by another penalty from the line
%    breaking followed probably by interline glue calculated to make
%    the next line of text fit vertically with the preceding one ---
%    and we don't want to loose that that glue if we are ending up in
%    the middle of a column. But we want to make it vanish if we
%    happen to finally break at the special penalty place.
%
%    So the trick is that we a) disable |\topskip| by setting it to
%    |-\maxdimen| (not zero this might be too large still) and b) we
%    add another of those funny boxes followed by a penalty of zero to
%    allow for a break after it.
%
%    If later on all this is put together again into a single box (in
%    |\@holdpg|) we will have the following sequence there:
%    \begin{itemize}
% \item text line (box) preceding the special penalty with depth $d$
%      or some other vertical material in which case $d=0\texttt{pt}$
% \item special box with height $-d$ and depth $d$
% \item special penalty, e.g. $-10008$
% \item |\topskip| glue of 0pt
% \item special box with height $-d$ and depth $d$
% \item |\penalty| 0
% \item |\penalty| 10000
% \item perhaps a |\penalty| and/or interline glue 
% \item perhaps the next text line (box)
%    \end{itemize}
%    Now if during later processing we hit the special penalty
%    |\pagetotal| has the same value as if we would have broken the
%    galley directly after the text line, in other words we do not see
%    the penalty too late (assume this happens to be the last line of
%    the column then if |\pagetotal| would also have the extra depth
%    added to it it might have been overfull and the penalty not being
%    considered at all for this column).
%
%    After the OR's have dealt with the special penalty, e.g., by
%    flushing some floats, etc. the penalty will be replaced by 10000
%    and thus the next time the galley is processed there is no
%    breakpoint between the two special boxes any more. As a result
%    the next potential breakpoint is the penalty 0 which again
%    results in exactly the same |\pagetotal| as before, i.e., if the
%    text line was the last line to fit in the column then this
%    breakpoint will still fit there. Thus if we break the column
%    there then the interline glue etc will vanish and \TeX{} will
%    insert |\topskip| glue (which has be set back to a normal value
%    by then). If on the other hand, this break point is not chosen
%    the interline glue will stay and thus the two text lines, before
%    and after the special penalty will sit one |\baselineskip| apart
%    just as they should.
%
%    Woah. What did Don said on page 125 of \textit{The \TeX{}book}?
%    (Deep breath.) You got that?\footnote{There are probably still
%    cases that aren't covered I fear and the need for an explicit
%    penalty 0 at the end is kind of toublesome, so we have to see if
%    this needs further refinements.}
%
%    And here is already the first case where the above method is not
%    appropriate: if we stumble across a |\output@columnbreak@penalty|
%    we need to discard any following glue, so we don't want a box
%    intervene here.\footnote{Once this is interfaced with the galley
%    code problems like this should vanish since then we can ensure
%    that all such penalties are added to the galley on at save
%    places. REDO THEN!}
%    \begin{macrocode}
      \global\topskip-\maxdimen  %  okay here?
      \if@collecting@new@material
        \ifnum \outputpenalty = -\output@columnbreak@penalty
        \else
          \setbox\z@\vbox to-\dimen@{}
          \dp\z@\dimen@
          \box\z@
          \penalty\z@
        \fi
      \fi
%    \end{macrocode}
%    
%    \begin{macrocode}
      \ifnum\outputpenalty=-\output@flush@float@penalty
%<*trace>
        \tr@ce{Forced~ break~ =~ flush~ float~ point}
%</trace>
        \@flushseentrue
      \fi
%    \end{macrocode}
%    Otherwise either the we reached the natural end of the
%    collection, or the point where we have been before (in case we
%    are recollecting previously seen material) or we reached an
%    |\output@balance@penalty|.
%    \begin{macrocode}
   \else
     \ifnum\outputpenalty = -\output@collect@penalty
%    \end{macrocode}
%    If we got an |-\output@collect@penalty| then we are at the point
%    to which the previous collection pass got. So, away with the
%    guard box, then everything back onto the MVL and as a penalty we
%    try to put what we have found in the previous collection pass.
%    \begin{macrocode}
       \remove@guard@box@from@cclv
       \unvbox\@cclv
%<*trace>
       \tr@ce{reinsert~penalty:~ \saved@outputpenalty\space 
        (unless~ 10000~ or~ <~ -9999)}
%</trace>
       \ifnum\saved@outputpenalty > -\@M
         \penalty
            \ifnum\saved@outputpenalty=\@M
               \z@
            \else
               \saved@outputpenalty\relax
            \fi
%    \end{macrocode}
%    We have a special situation to account for here: if we have a
%    |\pagebreak| that ended the collection last time then it might
%    still be the case that we haven't got to this point due to
%    floats. So we would need to put that penalty back. But only then,
%    and therese the catch!  The alternative is to not stop a
%    collection as such a point so that this problem doesn't arise in
%    the first place. Right now we lose the
%    penalty.\footnote{Unresolved situation. FIX!}
%    \begin{macrocode}
       \else
       \fi
%    \end{macrocode}
%    Finally we change the |@collecting@new@material| switch since we
%    are from now on looking at really new material.
%    \begin{macrocode}
       \@collecting@new@materialtrue
     \else
%    \end{macrocode}
%    Next case is not functional right now\ldots
%    \begin{macrocode}
       \ifnum\outputpenalty = -\output@balance@penalty
         \@balancetrue
%<*trace>
         \tr@ce{BALANCE:~ break~ seen\on@line}
%</trace>
         \xdef\saved@outputpenalty{0}
%    \end{macrocode}
%    This is now the point where the collection ended naturally: we
%    save the penalty that triggered it and combine the
%    |\partial@galley@box| if it contains material with the stuff now
%    in 255 and put everything into |\@holdpg|.
%    \begin{macrocode}
       \else
         \xdef\saved@outputpenalty{\the\outputpenalty}
       \fi
       \ifvoid\partial@galley@box
         \global \setbox\@holdpg\box\@cclv
       \else
%<*trace>
         \tr@ce{Re-adding~ forced~ break(s)~ for~ splitting}
%</trace>
         \global\setbox\@holdpg\vbox{
            \unvbox\partial@galley@box
            \unvbox\@cclv}
       \fi

%\showbox\@holdpg

       \if@balance
         \global\setbox\@holdpg\vbox{
            \unvbox\@holdpg 
            \penalty\outputpenalty % short for "-\output@balance@penalty"
            }
       \fi

       \mark@save@state
       \mark@update@structure
%
       \int_gzero:N \holdinginserts

       \global\topskip\saved@topskip

       \xor_float_placement_setup:

       \@collecting@new@materialfalse
     \fi
   \fi
%<*trace>
  \@tracepop{xor_OR_collect:}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\partial@galley@box}
%    Need a box to store the partially collected galley.
%    \begin{macrocode}
\newbox\partial@galley@box
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\xor_float_class_setup:n}
%
%    \begin{macrocode}
\def_new:Npn \xor_float_class_setup:n #1 {
%<*trace>
  \@tracepush{xor_float_class_setup:n}
%</trace>
  \count@0\LastMark{#1}
%<*trace>
  \tr@ce{count~ (#1) = \the\count@}
%</trace>
%    \end{macrocode}
%
%    Check: the close list should probably not be made empty but
%    initialised with all areas not on the allowed list!\footnote{FIX}
%    \begin{macrocode}
  \clist_gclear:c {g_xor_class_ #1 _areas_closed_clist}
%    \end{macrocode}
%
%    \begin{macrocode}
%<*trace>
  \tr@ce{allowed~ (#1) = \clist_use:c{g_xor_class_ #1 _areas_allowed_clist}}
  \tr@ce{closed~ (#1) = \clist_use:c{g_xor_class_ #1 _areas_closed_clist}}
%</trace>
%    \end{macrocode}
%
%    |\g_xor_flseq_type_figure_col_1_num| are macros that expands to the highest numbered
%    figure callout in this column (or zero if there is none).
%    |\g_xor_flseq_type_figure_col_0_num| is the highest value from
%    previous pages (or zero 
%    if there was never any float of this type).
%    \begin{macrocode}
  \xor_forall_columns:n {
    \ifnum \csname g_xor_flseq_type_#1_col_ \int_use:N\g_xor_curr_col_int _num
           \endcsname > \z@
      \num_gset_eq:cc {g_xor_flseq_type_#1_col_0_num}
                      {g_xor_flseq_type_#1_col_ \int_use:N\g_xor_curr_col_int _num}
      \num_gset:cn
                  {g_xor_flseq_type_#1_col_ \int_use:N\g_xor_curr_col_int _num}{0}
     \fi
%    \end{macrocode}
%    |\g_xor_flseq_areas_top_type_figure_col_1_num| is like |\g_xor_flseq_type_figure_col_1_num| but only stores
%    information about floats allocated to top areas.
%    \begin{macrocode}
     \num_gset:cn {g_xor_flseq_areas_top_type_#1_col_
                    \int_use:N\g_xor_curr_col_int _num}{0}
  }
%<*trace>
  \@tracepop{xor_float_class_setup:n}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \newpage
%
% \subsection{Placing Floats}
%
%
% \begin{description}
% \item[Entry:] |\xor_float_placement_setup:|
% \item[Exit:]  |\setup@grab@column@or| or |\setup@best@column@or|
% \item[Prereq:] 
% \item[Description:]
% \item[Flow:] 
%\begin{footnotesize}
%\begin{verbatim}
%      \xor_float_placement_setup:
%           |
%           V
%(2)--> \float@placement@loop
%           |
%       <run with floats?>
%           |      |
%          yes     no----------> \setup@grab@column@or
%           |
%           V
%       \trial@inner@loop
%           |
%           V
%   <current float successfully placed in previous trial?>
%      |                                     |
%     no                                    yes 
%      |                                     |
%  (means we now try                         V
%   again using different             \try@next@float  <-------------------
%   placement rules below )                  |                            |
%      |                                     |                            |
%      |                     <\g_xor_active_floats_seq empty?>            |
%      |                             |               |                    |
%      |                            no              yes                   |
%      |                             |               |                    |
%      |                             |               V                    |
%      |                          (get it) \xor_active_floats_seq_empty_action:
%      |                             |       (= \setup@best@column@or)    |
%      -------------v----------------                                     |
%                   |                                                     |
%   -----> \try@this@area (= \std@try@this@area, or                       | 
%   |               |        \relaxed@try@this@area)                      |
%   |               |                                                     |
%   |  <still open areas for current float type?>                         |
%   |         |                |                                          |
%   |        yes               no---------------(defer float)--------------
%   |         |                                                           |
%   |  (do some tests and perhaps                                         |
%   |    close area this way)                                             |
%   |         |                                                           |
%   |  <float allowed on this page/column (according to tests)?>          |
%   |         |                |                                          |
%   |        yes               no---------------(defer float)--------------
%   |         |
%   |   <current area got closed by any test?>
%   |      |                 |
%   |     yes                no
%   |      |                 |
%   | (select next area)     |                 
%   |      |                 |
%   --------                 V
%                 \pretests@success@action (\setup@grab@column@or)
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%
%
%
%
% \begin{macro}{\if@fail}
%    \begin{macrocode}
\newif\if@fail
\def\@failfalse{\global\let\if@fail\iffalse}
\def\@failtrue{\global\let\if@fail\iftrue}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_float_placement_setup:}
%    
%    \begin{macrocode}
\def_new:Npn \xor_float_placement_setup: {
% initialise before trial loop (needs work)
%<*trace>
  \@tracepush{xor_float_placement_setup:}
%</trace>
%    \end{macrocode}
%    A bit statistics: how many floats do we have on the
%    |\g_xor_active_floats_seq|?
%    \begin{macrocode}
%<*progress>
   \seq_map_inline:Nn
        \g_xor_active_floats_seq
        {\int_gincr:N\g_xor_trials_int}
   \progress@nl{STATS:~ floats~ waiting~ =~ \int_use:N\g_xor_trials_int
         \space on~ page~ \num_use:N \g_xor_page_absolute_num}
   \progress@separator
   \int_gzero:N \g_xor_trials_int
%</progress>
%    \end{macrocode}
%    We need the list of here floats during all trials. They are
%    therefore saved in |\g_xor_saved_here_floats_seq| at this point which is then
%    used to initialise |\g_xor_here_floats_seq| at the beginning of each trial.
%    \begin{macrocode}
    \glet:NN \g_xor_saved_here_floats_seq \g_xor_here_floats_seq
%    \end{macrocode}
%    
%    \begin{macrocode}
    \tighten@float@placement@conditions
%    \end{macrocode}
%    First time we run the |\float@placement@loop| we run it without
%    actually trying any floats (i.e., we are just cutting the
%    galley).\footnote{Could be improved: if there are no floats then
%    we run it once too often this way (per page) so\ldots}
%    \begin{macrocode}
    \run@with@floatsfalse
    \float@placement@loop
%<*trace>
  \@tracepop{xor_float_placement_setup:}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\float@placement@loop}
%    Place the galley box back on the MVL. Needs to be done via the
%    special output routine call |\mark@restore@state| to ensure that
%    \TeX's primitive marks reflect the `logical' previous page rather
%    than the previous actual output routine call.
%    \begin{macrocode}
\def\float@placement@loop{
%<*trace>
  \@tracepush{float@placement@loop}
%</trace>
%    \end{macrocode}
%
%    \begin{macrocode}
  \deadcycles\z@
  \glet:NN \xor_active_floats_seq_empty_action: \setup@best@column@or
  \glet:NN \pretests@success@action \setup@grab@column@or
%    \end{macrocode}
%
%    If we are doing trials we have to place a special penalty at the
%    end of the MVL but if we are cutting up the galley for
%    typesetting we don't want this penalty. Since at this point it is
%    not clear in which case we are we defer this action until
%    later.\footnote{This part of the documentation is no longer true,
%    we now add it below. CORRECT DOCU}
%
%    |\mark@restore@state| state is a special output routine those
%    only purpose is to reinitialise the state of the mark
%    mechanism. Its argument is executed at the of that OR.
%    \begin{macrocode}
  \mark@restore@state{
%    \end{macrocode}
%    Initialising the grabbing trials means putting the saved material
%    back onto the MVL and reinitialising the here float list.
%    \begin{macrocode}
    \unvcopy\@holdpg
    \ifnum\saved@outputpenalty > -1073741824\relax
       \add@badly@guarded@penalty\output@collect@penalty
    \fi
    \glet:NN \g_xor_here_floats_seq\g_xor_saved_here_floats_seq
%    \end{macrocode}
%    
%    The we can start the actual loop: if we run with floats we go to
%    |\trial@inner@loop| otherwise we immediately setup the grap
%    column OR.
%    \begin{macrocode}
    \ifrun@with@floats
      \trial@inner@loop
    \else
      \setup@grab@column@or
    \fi
    }
%<*trace>
  \@tracepop{float@placement@loop}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\trial@inner@loop}
%    Alternative entry into the float placement trial loop. This can
%    be used by setting |\@activelist@empty@action| and
%    |\pretests@success@action| to different values, e.g., for trying
%    float pages without the overhead of the grabcolumn output
%    routine, etc.
%    \begin{macrocode}
\def\trial@inner@loop{
%<*trace>
  \@tracepush{trial@inner@loop}
%</trace>
%    \end{macrocode}
%    If |\if@fail| is true we have already tried the current float
%    before. This means we either do a retry with relaxed conditions
%    (in which case the current area to try was suitably modified
%    beforhand) or else we have just started with a new float and
%    should try the first area of |\g_xor_this_areas_open_clist|.
%    \begin{macrocode}
  \if@fail
    \@failfalse
    \@flushfailfalse
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*progress>
    \int_gincr:N \g_xor_trials_int
%</progress>
%    \end{macrocode}
%    
%    \begin{macrocode}
    \xor_do_next:N \try@this@area
  \else
    \xor_do_next:N \try@next@float
  \fi
%<*trace>
  \@tracepop{trial@inner@loop}
%</trace>
  \xor_continue:
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g_xor_trials_int}
%    To gather statistics we count the number of trials per page.
%    \begin{macrocode}
%<*progress>
\int_new:N \g_xor_trials_int
%</progress>
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\try@this@area}
%    |\try@this@area| is |\let| to the right definition before it is
%    called so on top-level it is defined to be an error.
%    \begin{macrocode}
\let\try@this@area\ERROR
%    \end{macrocode}
% \end{macro}
%    
% \begin{macro}{\xor_try_next_area:}
%    |\xor_try_next_area:| first updates |\g_xor_this_areas_open_clist| by removing the
%    first area in this list and then calls |\try@this@area|. Thus it
%    should never be called if |\g_xor_this_areas_open_clist| is already empty.
%    \begin{macrocode}
\def\xor_try_next_area:{
  \clist_gpop:NN \g_xor_this_areas_open_clist \l_tmpa_tlp
%<*progress>
  \int_gincr:N \g_xor_trials_int
%</progress>
  \try@this@area
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_curr_float_box_tlp}
%    \begin{macrocode}
\tlp_new:Nn \g_xor_curr_float_box_tlp {\ERROR}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\try@next@float}
%    If there is still a float on the active list take it and try to
%    place it in the next open float area (which will be the same as
%    the current area after a successful trial). If there are no
%    floats left execute |\g_xor_best_trial_status_tlp| to return to that state then
%    switch to the bestcolumn output routine to begin typesetting
%    columns.
%    \begin{macrocode}
\def\try@next@float{
%<*trace>
  \@tracepush{try@next@float}
%</trace>
  \xor_pop_float:NNTF
     \g_xor_active_floats_seq
     \g_xor_curr_float_box_tlp
     {
%<*trace>
      \tr@ce{currbox:~ \g_xor_curr_float_box_tlp}
%</trace>
%<*progress>
      \progress{Float:~ \g_xor_curr_float_box_tlp}
%</progress>
      \expandafter\update@this@float@structure\the\toks\g_xor_curr_float_box_tlp
%<*trace>
      \tr@ce{g_xor_saved_this_areas_open_clist~(init):~ 
	     \g_xor_saved_this_areas_open_clist\space :=~\g_xor_this_areas_open_clist}
%</trace>
      \tlp_gset_eq:NN \g_xor_saved_this_areas_open_clist\g_xor_this_areas_open_clist
%<*progress>
      \int_gincr:N \g_xor_trials_int
%</progress>
      \try@this@area
     }
%    \end{macrocode}
%     no floats left\ldots
%    \begin{macrocode}
     {
%<*progress>
      \progress@nl {STATS:~ trials~ =~ \int_use:N\g_xor_trials_int}
      \int_gzero:N \g_xor_trials_int
%</progress>
      \xor_active_floats_seq_empty_action:
     }
%<*trace>
  \@tracepop{try@next@float}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \begin{macro}{\update@this@float@structure}
% Each float box has an associated token register storing several
% information fields.
% \begin{enumerate}
% \item[1] float caption (set by caption command)
% \item[2] Currently unused (could have callout page number, set by
% |\best@column@or|).
% \item[3] saved label string
% \item[4] `display counter' number (per-type count) set by float environment.
% \item[5] Allowed float areas (from default or optional arg.)
% \item[6] float type (currently this is the long name, eg figure) should
% probably be the single token name, to allow quicker testing.
% \item[7] float sequence number.
% \end{enumerate}
%
% This macro assumes that |\g_xor_curr_float_box_tlp| is the box number for this structure
%    \begin{macrocode}
\def\update@this@float@structure#1#2#3#4#5#6#7{
  \tlp_gset:Nn \g_xor_this_caption_tlp {#1}
  \tlp_gset:Nn \g_xor_this_span_num_tlp {#2}
  \tlp_gset:Nn \g_xor_this_display_cnt_tlp {#4}
  \tlp_gset:Nn \g_xor_this_allowed_areas_tlp {#5}
  \tlp_gset:Nn \g_xor_this_type_tlp {#6}
%    \end{macrocode}
%    From the type we infer the class:
%    \begin{macrocode}
  \tlp_gset_eq:Nc
       \g_xor_this_class_tlp {g_xor_type_ #6 _class_tlp}
  \num_gset:Nn \g_xor_this_flseq_num {#7}
%    \end{macrocode}
%    If we want to consider all areas for each float (and storing
%    closed areas via |\g_xor_class_|\meta{class}|_areas_closed_clist|
%    we have to 
%    initialise |\g_xor_this_areas_open_clist| to
%    |\g_xor_areas_used_clist| (which is 
%    derived from the |area-list| key.
%    \begin{macrocode}
  \clist_gset_eq:NN \g_xor_this_areas_open_clist \g_xor_areas_used_clist
%    \end{macrocode}
%        
%    \begin{macrocode}
  \clist_gset_eq:Nc \g_xor_this_areas_closed_clist
                    {g_xor_class_ \g_xor_this_class_tlp _areas_closed_clist}  % FMi tmp
  \tlp_gset_eq:NN \g_xor_this_float_box_tlp
                  \g_xor_curr_float_box_tlp
%<*trace>
\tr@ce{This~float~structure:}
\toks@{#1}\tr@ce{~{\the\toks@}}
\tr@ce{~{#2}}
\tr@ce{~{#3}}
\tr@ce{~{#4}}
\tr@ce{~{#5}}
\tr@ce{~{#6}}
\tr@ce{~{#7}}
\tr@ce{~g_xor_this_areas_open_clist~ <-~ \g_xor_this_areas_open_clist}
\tr@ce{~g_xor_this_areas_closed_clist~ <-~ \g_xor_this_areas_closed_clist}
%</trace>
%<*progress>
\progress{~{#7}}
\progress{~{#6}~(\g_xor_this_class_tlp)}
\progress{~{#4}}
%\progress{~{#2}}
%\progress{~{#3}}
%\progress{~{#5}}
\toks@{#1}\progress@nl{~{\the\toks@}}
%</progress>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\extract@this@float@actual@structure}
%    As used by Chris in xo-final. Should probably be replaced by the
%    one above or combined with the one above!\footnote{FIX!!}
%    \begin{macrocode}
\def \extract@this@float@actual@structure #1#2#3#4#5#6#7 {
  \tlp_gset:Nn \g_xor_this_caption_tlp {#1}
  \tlp_gset:Nn \g_xor_this_span_num_tlp {#2}
  \tlp_gset:Nn \g_xor_this_lael_key_tlp {#3}
  \tlp_gset:Nn \g_xor_this_display_cnt_tlp {#4}
  \tlp_gset:Nn \g_xor_this_allowed_areas_tlp {#5}
  \tlp_gset:Nn \g_xor_this_type_tlp {#6}
  \tlp_gset_eq:Nc
       \g_xor_this_class_tlp {g_xor_type_ #6 _class_tlp}
  \num_gset:Nn \g_xor_this_flseq_num {#7}
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\update@here@float@structure}
%
%    Similar to |\update@this@float@structure| but filling different
%    macros.\footnote{We only need some of those macros, so this
%    should be cleaned up at some stage.}
%
%    This macro assumes that |\g_xor_curr_float_box_tlp| is the box number for this
%    structure.
%
%    \begin{macrocode}
\def\update@here@float@structure#1#2#3#4#5#6#7{
  \tlp_gset:Nn \g_xor_here_caption_tlp {#1}
  \tlp_gset:Nn \g_xor_here_span_num_tlp {#2}
  \tlp_gset:Nn \g_xor_here_display_cnt_tlp {#4}
  \tlp_gset:Nn \g_xor_here_type_tlp {#6}
  \tlp_gset_eq:Nc
       \g_xor_here_class_tlp {g_xor_type_ #6 _class_tlp}
  \tlp_gset:Nn \g_xor_here_flseq_tlp {#7}
  \tlp_gset_eq:NN \g_xor_here_float_box_tlp \g_xor_curr_float_box_tlp
%<*trace>
\tr@ce{Here~object~structure:}
\toks@{#1}\tr@ce~{~{\the\toks@}}
\tr@ce{~{#2}}
\tr@ce{~{#3}}
\tr@ce{~{#4}}
\tr@ce{~{#5}}
\tr@ce{~{#6}}
\tr@ce{~{#7}}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\g_xor_page_float_int}
%    This integer keeps track on the total number of floats added to
%    the current plage
%    \begin{macrocode}
%\int_new:N \g_xor_page_float_int
\let:NN \g_xor_page_float_int \@colnum
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_this_captioned_float_box}
%    \begin{macrocode}
\newbox\g_xor_this_captioned_float_box
%    \end{macrocode}
% \end{macro}
%
%
%
% \newpage
%
% \subsection{Grab Column Output Routine}
%
% \begin{description}
% \item[Entry:] |\setup@grab@column@or|
% \item[Exit:]  |\setup@cleanup@or|
% \item[Prereq:] 
% \item[Description:]
% \item[Flow:] 
%\begin{footnotesize}
%\begin{verbatim}
%    \setup@grab@column@or
%            |
%    New OR: \grab@column@or      
%            |
%            V
%    \grab@column@loop <-------      
%            |                      
%    (when entering OR...)    
%            |                      
%    <end of collection reached?>
%         |          |          
%        yes        no                   
%         |          |
%         |     <col break requested?>
%         |          |        |
%         |         yes       no
%         |          |        |
%         |          |     <flush point encountered?>
%         |          |        |                  |
%         |          |       yes                 no
%         |          |        |                  |
%         |          | <flush point         <here point encountered?>
%         |          |      too early?>        |               |
%         |          |    |      |            yes              no
%         |          |   yes    no             |               |
%         |          |    |      |             ?               ?
%         |          |    | (ignore break)
%         |          |    |      |
%         |          |    |      |
% (end column now) <-------      |
%         |                      |
%         V                      |
%   <all cols produced?>         |
%      |           |             V
%     yes          no--------------------> (reenter \grab@column@loop)
%      |                           
% (store results of trial)                 
%      |                           
%      V
%    \setup@cleanup@or
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%
%
% \begin{macro}{\setup@grab@column@or}
% 
%    \begin{macrocode}
\def\setup@grab@column@or{
%<*trace>
  \@tracepush{setup@grab@column@or}
%</trace>
%    \end{macrocode}
%    
%    We just returned to the MVL the current galley. We now add a
%    special penalty to mark the point that we need to reach in order
%    to remove everything after the trial run.
%    This penalty has to be guarded against premature removal, e.g.,
%    if the algorithm would break exactly before it it would then be
%    discarded which we can't allow.\footnote{Penalty now added
%    earlier (normally). CORRECT DOCU}
%    \begin{macrocode}
   \ifnum\saved@outputpenalty = -1073741824\relax
     \add@badly@guarded@penalty\output@collect@penalty
   \fi
%    \end{macrocode}
%
%    \begin{macrocode}
  \@failfalse
  \int_gzero:N \g_xor_curr_col_int
%    \end{macrocode}
%    In case there is a flush penalty in the collection we have to
%    find out if we see it again during the trial. So we record the
%    number of flush points we see during the trial. Same happens for
%    here points.
%    \begin{macrocode}
  \num_gzero:N \g_xor_trial_flush_seen_num
  \num_gzero:N \g_xor_trial_here_seen_num
%    \end{macrocode}
%
%    Moved from |\try@this@area| as it should be executed
%    only if we really do a trial and thus back it out if
%    unsuccessful---this was a bug as it changed
%    |g_xor_flseq_type_|\meta{type}|_col_ |\meta{col}|_num| in cases we never came to this
%    point here but recursed)
%    \begin{macrocode}
  \ifrun@with@floats
%    \end{macrocode}
%    Depending on the policy a spanning float can be considered belong
%    to different columns. This influences the behaviour of the
%    call-out contraint tests and is determined by the code stored in
%    |\calculate@target@fl@column|.
%    \begin{macrocode}
    \calculate@target@fl@column
%    \end{macrocode}
%    |\calculate@target@fl@column| returns its calculated column
%    number in |\l_xor_target_col_num|.
%    \begin{macrocode}
    \num_gset_eq:Nc \g_xor_saved_flseq_num
                    {g_xor_flseq_type_ \g_xor_this_class_tlp _col_
                     \num_use:N \l_xor_target_col_num _num}
    \num_gset_eq:cN {g_xor_flseq_type_ \g_xor_this_class_tlp _col_
                     \num_use:N \l_xor_target_col_num _num}
                    \g_xor_this_flseq_num
%<*trace>
    \tr@ce{~g_xor_flseq_type_ \g_xor_this_class_tlp _col_ 
            \num_use:N \l_xor_target_col_num _num \space <-~ 
           \num_use:c{g_xor_flseq_type_ \g_xor_this_class_tlp _col_
                      \num_use:N \l_xor_target_col_num _num} }
%</trace>
%    \end{macrocode}
%    If we are adding to a top area we also have to update the
%    corresponding |\g_xor_flseq_areas_top_type_...| commands:
%    \begin{macrocode}
    \if t\g_xor_this_area_type_tlp
      \num_gset_eq:Nc \g_xor_saved_flseq_top_areas_num
                      {g_xor_flseq_areas_top_type_
                       \g_xor_this_class_tlp _col_ 
                       \num_use:N \l_xor_target_col_num _num}
      \num_gset_eq:cN
                      {g_xor_flseq_areas_top_type_
		       \g_xor_this_class_tlp _col_
  		       \num_use:N \l_xor_target_col_num _num}
                      \g_xor_this_flseq_num
%<*trace>
      \tr@ce{~g_xor_flseq_areas_top_type_ \g_xor_this_class_tlp _col_
                    \num_use:N \l_xor_target_col_num _num \space <-~ 
             \num_use:c {g_xor_flseq_areas_top_type_ \g_xor_this_class_tlp _col_
                         \num_use:N \l_xor_target_col_num _num} }
%</trace>
    \fi
  \fi
%    \end{macrocode}
%
%    If we have seen any flush points during collection we need to
%    save their current |min_col| positions in case we have to throw
%    away the current trial.
%    \begin{macrocode}
  \if@flushseen
    \count@\z@
    \@whilenum \g_xor_collect_flush_seen_num>\count@ \do
       { \int_incr:N \count@
         \num_gset_eq:cc
            {g_xor_saved_flush_ \the\count@ _min_col_num}
            {g_xor_flush_ \the\count@ _min_col_num}
%<*trace>
         \tr@ce{g_xor_saved_flush_ \the\count@ _min_col_num \space <-~
               \num_use:c{g_xor_flush_ \the\count@ _min_col_num}}
%</trace>
       }
  \fi
%    \end{macrocode}
%    
%    \begin{macrocode}
  \initialise@footins@action
%    \end{macrocode}
%
%    \begin{macrocode}
  \global\output{\grab@column@or}
  \grab@column@loop
%    \end{macrocode}
%
%    \begin{macrocode}
%<*trace>
  \@tracepop{setup@grab@column@or}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\calculate@target@fl@column}
% \begin{macro}{\calculate@target@fl@column@flexible}
% \begin{macro}{\calculate@target@fl@column@strict}
%    The purpose of |\calculate@target@fl@column| is to calculate
%    the column number for which the |\fl@|\meta{col}|@number| has to
%    be updated in case we place the current float into the area with
%    start column |\g_xor_this_area_col_tlp| and span-number
%    |\g_xor_this_area_span_tlp|. It returns the calculated number in
%    |\l_xor_target_col_tlp|.
%
%    For non-spanning floats it is simply returning
%    |\g_xor_this_area_col_tlp|. If we return this value also in case of
%    spanning floats then this means that we claim that the float has
%    be placed the first of its spanned columns. Alternatively we
%    could return the last of the spanned columns which would if the
%    |column| policy is in force, allow to place a float into |t12|
%    even if its call-out is in the second column.
%
%    The real value for |\calculate@target@fl@column| will be assigned
%    in the page setup template.
%    \begin{macrocode}
\let\calculate@target@fl@column \ERROR
%    \end{macrocode}
%    
%    And here are the two possibilities.
%    \begin{macrocode}
\def\calculate@target@fl@column@flexible {
    \num_set:Nn \l_xor_target_col_num \g_xor_this_area_col_tlp
    \num_add:Nn \l_xor_target_col_num \g_xor_this_area_span_tlp
    \num_decr:N \l_xor_target_col_num
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def\calculate@target@fl@column@strict {
    \num_set:Nn \l_xor_target_col_num \g_xor_this_area_col_tlp
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\ifrun@with@floats}
% \begin{macro}{\run@with@floatstrue}
% \begin{macro}{\run@with@floatsfalse}
%    
%    \begin{macrocode}
\newif\ifrun@with@floats
\def\run@with@floatsfalse{\global\let\ifrun@with@floats\iffalse}
\def\run@with@floatstrue{\global\let\ifrun@with@floats\iftrue}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\grab@column@loop}
%    The |\grab@column@or| output routine is responsible for
%    constructing one column of a layout trial.  The loop command
%    increments the column count and sets vsize to the target height
%    for the current column (which has already been set based on the
%    size and position of the floats in this trial layout.
%    \begin{macrocode}
\def\grab@column@loop{
%<*trace>
  \@tracepush{grab@column@loop}
%</trace>
  \int_gincr:N \g_xor_curr_col_int
  \global\vsize\csname g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim\endcsname
%<*trace>
  \@tracepop{grab@column@loop}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\some@column@or}
%    |\grab@column@or| and |\best@column@or| are sharing most of their
%    code which is therefore placed into a separate macro. At the
%    moment it takes 4 arguments: the name (``grab'' or ``best''),
%    what to do when we actually finish the column
%    (``|\grab@column@or@finish|'' or ``|\best@column@or@finish|''),
%    what to do for a flush point, and what to do when we encounter a
%    here float.\footnote{This code needs a bit of redesign to deal
%    properly with the case that we have stumbled upon one of the
%    special penalties. In this case we need to ensure that we also
%    remove the special box after the penalty in case we are at a
%    column break. This is not done right now so that in this case we
%    will not dicard material at the top of the column properly. FIX!!!!}
%    \begin{macrocode}
\def\some@column@or #1#2#3#4{
%<*trace>
   \@tracepush{#1@column@or}
   \tr@ce{output~pen:~ \the\outputpenalty}
   \tr@ce{#1~ col:~ \int_use:N\g_xor_curr_col_int\space of~ \int_use:N\g_xor_cols_int}
%</trace>
   \handle@case@of@premature@ending
   \handle@case@of@forced@pagebreak
%    \end{macrocode}
%    If the |\outputpenalty| is |-\output@flush@float@penalty| we
%    have reached a float flush point in the galley.
%    \begin{macrocode}
   \ifnum\outputpenalty=-\output@flush@float@penalty
     \num_gincr:N \g_xor_trial_flush_seen_num
%<*trace>
     \tr@ce{flush~ point~( \g_xor_trial_flush_seen_num,~
       affects:~ \clist_use:c {g_xor_flush_
                         \g_xor_trial_flush_seen_num _classes_clist},~
       mincol:~    \num_use:c {g_xor_flush_
                               \num_use:N \g_xor_trial_flush_seen_num
                               _min_col_num},~
       lastfloat:~ \num_use:c {g_xor_flush_
                               \num_use:N \g_xor_trial_flush_seen_num
                               _last_float_num}
            )~ reached}
%</trace>
%    \end{macrocode}
%    We then remove the guard box from the output (which is at the end
%    of box |\@cclv|.
%    \begin{macrocode}
     \remove@guard@box@from@cclv
%    \end{macrocode}
%    If the flush penalty moved to an earlier column than in the last
%    trial we end the current column (by calling
%    |\#1@column@or@finish|) and reinsert the penalty so that it will
%    be seen again if we do the next column.
%    \begin{macrocode}
     \ifnum\csname g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num\endcsname
           > \g_xor_curr_col_int
%<*trace>
       \tr@ce{g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num\space >~
              g_xor_curr_col_int~
              (\num_use:c {g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num}
               \space >~ \int_use:N \g_xor_curr_col_int)~ ->~ ending~ column}
%</trace>
       \num_gdecr:N \g_xor_trial_flush_seen_num
       \readd@guarded@penalty\output@flush@float@penalty
       #2
     \else
%    \end{macrocode}
%    Otherwise the flush point is in an acceptable position which
%    means we ignore it and carry on collecting material for the
%    current column. This is done be putting everything back onto the
%    MVL except the guard box and the penalty.\footnote{We lose a
%    potential break point here (acceptable?) See comments in
%    best@column@or!!}
%    \begin{macrocode}
%<*trace>
       \tr@ce{g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num~
              <=~ g_xor_curr_col_int~
              (\num_use:c {g_xor_flush_
                           \g_xor_trial_flush_seen_num _min_col_num}
              \space <=~ \int_use:N\g_xor_curr_col_int)}
%</trace>
%    \end{macrocode}
%    What exactly happens here (beside the above) depends on the
%    calling macro.
%    \begin{macrocode}
       #3
     \fi
   \else
%    \end{macrocode}
%    If it was not a flush point we might have a here point to take
%    care of. This is more or less like the code above.
%    \begin{macrocode}
     \ifnum\outputpenalty=-\output@here@float@penalty
       \num_gincr:N\g_xor_trial_here_seen_num
%<*trace>
       \tr@ce{here~ penalty~(\g_xor_trial_here_seen_num)~ reached}
%</trace>
       \remove@guard@box@from@cclv
       \ifnum\csname g_xor_here_ \g_xor_trial_here_seen_num
                     _min_col_num \endcsname
             > \g_xor_curr_col_int
%<*trace>
         \tr@ce{g_xor_here_ \g_xor_trial_here_seen_num _min_col_num \space >~g_xor_curr_col_int~
                (\num_use:c {g_xor_here_ \g_xor_trial_here_seen_num
                         _min_col_num}
                 \space >~ \int_use:N \g_xor_curr_col_int)~ ->~ ending~ column}
%</trace>
         \split@off@last@line
         \num_gdecr:N \g_xor_trial_here_seen_num
         \readd@guarded@penalty\output@here@float@penalty
         #2
       \else
         \@tempdima \pagegoal
         \advance\@tempdima -\pagetotal
         \ifdim \@tempdima <
                    \tlp_use:c
                        {g_xor_here_ \g_xor_trial_here_seen_num _required_space_tlp}
                     \relax
%<*trace>
           \tr@ce{g_xor_here_ \g_xor_trial_here_seen_num _required_space_tlp\space >~
                  \pagegoal-\pagetotal \space
                  (\tlp_use:c {g_xor_here_ 
                          \g_xor_trial_here_seen_num  _required_space_tlp}
                   \space >~ \the\pagegoal\space
                              -~ \the\pagetotal\space =~
                              \the\@tempdima)~ 
                  ->~ ending~ column}
%</trace>
           \split@off@last@line
           \num_gdecr:N\g_xor_trial_here_seen_num
           \readd@guarded@penalty\output@here@float@penalty
           #2
         \else
%<*trace>
           \tr@ce{g_xor_here_ \g_xor_trial_here_seen_num _required_space_tlp\space <=~
                  \pagegoal-\pagetotal \space
                  (\tlp_use:c {g_xor_here_ \g_xor_trial_here_seen_num _required_space_tlp}
                   \space <=~ \the\pagegoal\space
                              -~ \the\pagetotal\space =~
                              \the\@tempdima)~ 
                  ->~ accepting~ here~ point}
%</trace>
           \@reinserts
           \unvbox\@cclv
           \xor_pop_float:NNTF
             \g_xor_here_floats_seq
             \g_xor_curr_float_box_tlp
            {
%<*trace>
              \tr@ce{@currbox:~ \g_xor_curr_float_box_tlp}
%</trace>
              \expandafter\update@here@float@structure\the\toks\g_xor_curr_float_box_tlp
%    \end{macrocode}
%    Different things need to be done depending on the type of the
%    here point:
%    \begin{macrocode}
              \def\@tempa{mpar}
              \ifx\@tempa\g_xor_here_type_tlp
                \typeset@a@marginpar
              \else
                \def\@tempa{rspace}
                \ifx\@tempa\g_xor_here_type_tlp
                  % do nothing
                \else
                  #4
                \fi
              \fi
             }
%    \end{macrocode}
%    If there is no here object left the algorithm has screwed up
%    (i.e., a ``this can't happen'' situation).
%    \begin{macrocode}
            \ERROR
         \fi
       \fi
     \else
%    \end{macrocode}
%    If it is neither a flush nor a here point it might be a grid point:
%    \begin{macrocode}
       \ifnum\outputpenalty=-\output@grid@align@penalty
         \align@collected@galley@and@restart
%    \end{macrocode}
%    So we now know that it wasn't one of our special points so this
%    must have been a normal end of the galley:
%    \begin{macrocode}
       \else
         #2
       \fi
     \fi
   \fi
%<*trace>
  \@tracepop{#1@column@or}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\grab@column@or}
%    Here is the output routine used during trials, an instantiation
%    of |\some@column@or|.
%    \begin{macrocode}
\def\grab@column@or{\some@column@or{grab}
      \grab@column@or@finish
      \grab@column@or@flushcheck
      \check@and@typeset@a@here@float
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\grab@column@or@flushcheck}
%
%    The |\grab@column@or@flushcheck| code checks for restrictions
%    regarding the placement of the current float. It is called when
%    we just have encountered a flush float penalty while grabbing the
%    text for a column and now have to see which floats (if any) need
%    to be positioned before that flush point.
%    \begin{macrocode}
\def\grab@column@or@flushcheck{
%<*trace>
  \@tracepush{grab@column@or@flushcheck}
%</trace>
%    \end{macrocode}
%    If we are making a dry-run without floats then there is no need to
%    do much, so we skip all testing that involves flush points and
%    only do the cleanup actions at the end.
%    \begin{macrocode}
  \ifrun@with@floats
    \clist_if_in:coTF
         {g_xor_flush_\g_xor_trial_flush_seen_num _classs_clist}
         \g_xor_this_class_tlp
     {
%<*trace>
      \tr@ce{flush:~ class~ \g_xor_this_class_tlp\space in~
             {\clist_use:c {g_xor_flush_ \g_xor_trial_flush_seen_num _classes_clist}}}
%</trace>
%    \end{macrocode}
%    We store in |\count@| the float sequence number of the last float
%    that would be affected by the current flush penalty. This value
%    is then used in the tests below.
%    \begin{macrocode}
      \int_set:Nc \count@
                  {g_xor_flush_ \num_use:N \g_xor_trial_flush_seen_num
                   _last_float_num}
%    \end{macrocode}
%    
%    If the current float number is higher than float number stored in
%    |\g_xor_flush_|\meta{num}|_last_float_num| with the flush penalty, we are
%    dealing with a float whose call-out is after the flush penalty
%    and thus we have no restriction.
%    \begin{macrocode}
      \ifnum\g_xor_this_flseq_num > \count@
%<*trace>
        \tr@ce{???:\g_xor_this_flseq_num>\the\count@}
        \tr@ce{this~float~ past~flush~point}
%</trace>
      \else
%    \end{macrocode}
%    Otherwise check if this float is placed in an acceptable position
%    with respect to the current flush point. For this we run
%    different code depending on the ``fuzziness'' of the flush point
%    under check:
%    \begin{macrocode}
        \csname flush@fuzziness@\g_xor_trial_flush_seen_num \endcsname
      \fi
     }
     {
%<*trace>
      \tr@ce{flush:~ class~ \g_xor_this_class_tlp\space not~ in~
             {\clist_use:c {g_xor_flush_ \g_xor_trial_flush_seen_num _classes_clist}}}
%</trace>
     }
  \fi
%    \end{macrocode}
%    If we failed above we additionally record that the failure is
%    due to violating restrictions for a flush point.
%    \begin{macrocode}
  \if@fail
    \@flushfailtrue
%    \end{macrocode}
%
%    \begin{macrocode}
    \global\setbox\@cclv\box\voidb@x
    \global\setbox\footins\box\voidb@x
%    \end{macrocode}
%    We have to immediately abort the current trial otherwise a
%    flush point following in the galley might be encountered and
%    processed before we reach |\evaluate@results@of@trial|. That
%    would result in updating the wrong data structure there (due to
%    the fact that there it assumes that |\g_xor_trial_flush_seen_num|
%    refers to the flush point that is the reason for
%    failure).\footnote{Implementation could be improved!}
%    \begin{macrocode}
    \int_gset:Nn \g_xor_curr_col_int \g_xor_cols_int   
    \grab@column@or@finish
  \else
%    \end{macrocode}
%    If we haven't failed we might have to update the
%    |\g_xor_flush_|\meta{num}|_min_col_num| for the current flush point in case it
%    moved to a new column.
%    \begin{macrocode}
    \ifnum\csname g_xor_flush_ \g_xor_trial_flush_seen_num
                  _min_col_num\endcsname
         < \g_xor_curr_col_int
      \num_gset:cn
        {g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num}
        \g_xor_curr_col_int
%<*trace>
      \tr@ce{set~ g_xor_flush_ \g_xor_trial_flush_seen_num
                  _min_col_num :~
             \num_use:c {g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num}}
%</trace>
    \fi
%    \end{macrocode}
%    We have to return the collected footnotes first or else \TeX{}
%    might decide that it is better to break before
%    them.\footnote{Quite likely that this needs some refinement as it
%    might mess up vertical spacing in other respects. Look out for
%    other places where \texttt{\string\@reinserts} is used, if this
%    needs fixing.}
%    \begin{macrocode}
    \@reinserts
    \unvbox\@cclv
%    \end{macrocode}
%    What penalty to return???\footnote{FIX!!!}
%    \begin{macrocode}
%    \penalty\z@    % none i think now (in the current version) but this
                    % will change again
  \fi
%<*trace>
  \@tracepop{grab@column@or@flushcheck}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\flushcheck@page}
%    \begin{macrocode}
\def\flushcheck@page {
%<*trace>
    \tr@ce{OK:~flush~check~ (same~page)}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\flushcheck@spread}
%
%    This is actually a dummy definition. There is more to do if we
%    want to provide support for spreads!\footnote{Finish implementation}
%    \begin{macrocode}
\def\flushcheck@spread {
%<*trace>
    \tr@ce{OK:~flush~check~ (using~page~not~ spread)}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\flushcheck@strict}
%    \begin{macrocode}
\def\flushcheck@strict {
%<*trace>
  \@tracepush{flushcheck@strict}
%</trace>
%    \end{macrocode}
%    If strict flushing is required we look where the current float is
%    being placed. If it 
%    is placed in a column which is earlier than the current column
%    then it is definitely before the flush point and thus we are okay.
%    \begin{macrocode}
  \ifnum\g_xor_this_area_col_tlp<\g_xor_curr_col_int
%<*trace>
    \tr@ce{OK:~flush~check~
           (\g_xor_this_area_col_tlp<\int_use:N\g_xor_curr_col_int,~\g_xor_this_area_name_tlp)}
%</trace>
  \else
%    \end{macrocode}
%    Otherwise we test if the float is placed into the current
%    column. If this is the case it might be okay, but only if it is
%    not placed into the bottom area.
%    \begin{macrocode}
    \ifnum\g_xor_this_area_col_tlp=\g_xor_curr_col_int
%    \end{macrocode}
%    To test for the bottom area(s) means looking at the first token
%    in the area identifier. If it is |b| we are past the flush
%    point.\footnote{It might be an interesting extension to allow
%    relaxing the flush situation to allow the floats to appear
%    anywhere on the current column (on which the flush point ends up),
%    or even allowing that it only has to appear on the current page
%    or page spread.}
%    \begin{macrocode}
      \if b \g_xor_this_area_type_tlp
        \@failtrue
%<*progress>
        \progress@failed{area~ below~ flush~ point~
               (\g_xor_this_area_col_tlp=\int_use:N\g_xor_curr_col_int,~\g_xor_this_area_name_tlp)}
%</progress>
%<*trace>
        \tr@ce{Fail:~flush~check~
               (\g_xor_this_area_col_tlp=\int_use:N\g_xor_curr_col_int,~\g_xor_this_area_name_tlp)}
%    \end{macrocode}
%    Otherwise the float was placed into an area that is still before
%    the flush point.
%    \begin{macrocode}
      \else
        \tr@ce{OK:~flush~check~
               (\g_xor_this_area_col_tlp=\int_use:N\g_xor_curr_col_int,~\g_xor_this_area_name_tlp)}
%</trace>
      \fi
%    \end{macrocode}
%    If the float was neither placed before nor into the current
%    column we have to conclude that it was placed into a later column
%    which means it was placed after the flush point --- thus we fail.
%    \begin{macrocode}
    \else
      \@failtrue
%<*progress>
      \progress@failed{area~ after~ flush~ point~
             (\g_xor_this_area_col_tlp>\int_use:N\g_xor_curr_col_int,~\g_xor_this_area_name_tlp)}
%</progress>
%<*trace>
      \tr@ce{Fail:~flush~check~
             (\g_xor_this_area_col_tlp>\int_use:N\g_xor_curr_col_int,~\g_xor_this_area_name_tlp)}
%</trace>
    \fi
 \fi
%<*trace>
  \@tracepop{flushcheck@strict}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\flushcheck@column}
%    \begin{macrocode}
\def\flushcheck@column {
  \ifnum\g_xor_this_area_col_tlp>\g_xor_curr_col_int
    \@failtrue
%<*progress>
    \progress@failed{area~ after~ flush~ point~ column~
      (\g_xor_this_area_col_tlp>\int_use:N\g_xor_curr_col_int,~\g_xor_this_area_name_tlp)}
%</progress>
%<*trace>
    \tr@ce{Fail:~flush~check~
           (\g_xor_this_area_col_tlp>\int_use:N\g_xor_curr_col_int,~\g_xor_this_area_name_tlp)}
  \else
    \tr@ce{OK:~flush~check~
           (\g_xor_this_area_col_tlp<=\int_use:N\g_xor_curr_col_int,~\g_xor_this_area_name_tlp)}
%</trace>
  \fi
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\grab@column@or@finish}
%    \begin{macrocode}
\def\grab@column@or@finish{
%<*trace>
  \@tracepush{grab@column@or@finish}
%</trace>
%    \end{macrocode}
%    
%    \begin{macrocode}
   \mark@update@structure
%    \end{macrocode}
%    
%    \begin{macrocode}
   \deal@with@footins@action
%    \end{macrocode}
%
%    First check if there are some special constraints that should be
%    met (this is, for example, used to check if there are both bottom
%    floats and footnotes). If the constraints are not met don't
%    bother to check the callout/float constraints.
%    \begin{macrocode}
   \if@fail\else
     \ifrun@with@floats
       \check@some@constraints
     \fi
   \fi
   \if@fail\else
%    \end{macrocode}
%     For each float sequence class, call |\check@callout@constraints|
%    this will be set via a call to a pagesetup template to do an
%    appropriate check on the float placement relative to float
%    call-out.
%    \begin{macrocode}
     \ifrun@with@floats
       \seq_map:NN \g_xor_float_classes_seq
                   \check@callout@constraints
     \fi
   \fi
%    \end{macrocode}
%
%    Throw the text away (it will be reset later if this trial is
%    in fact chosen).
%    \begin{macrocode}
   \global\setbox\@cclv\box\voidb@x
   \global\setbox\footins\box\voidb@x
%    \end{macrocode}
%    After the last column we evaluate the results of the trial (and
%    if the result looks ok remember it as a candidate for the final
%    solution). We then switch to the `clean up' OR which will
%    collect up the main vertical list as far as the special penalty
%    marking the end of the collection pass, to clear the MVL for the
%    next trial.  If this isn't the last column, set up the next
%    column.
%    \begin{macrocode}
   \ifnum\g_xor_curr_col_int=\g_xor_cols_int
     \evaluate@results@of@trial
     \setup@cleanup@or
   \else
     \grab@column@loop
   \fi
%<*trace>
  \@tracepop{grab@column@or@finish}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\handle@case@of@premature@ending}
%    Next |\ifnum| is a fix that needs rethinking: what is the best
%    approach if we hit the penalty which denotes the end of the
%    collected galley too early, e.g., in the middle of a trial using
%    |\grab@column@or| or when producing the final columns with
%    |\best@column@or|? Current solution gets the stuff out, but is it
%    probably not the best solution.
%    correct?
%    \begin{macrocode}
\def\handle@case@of@premature@ending{
  \ifnum\outputpenalty=-\output@collect@penalty
    \remove@guard@box@from@cclv
    \readd@guarded@penalty\output@collect@penalty
  \fi
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\check@some@constraints}
%    By default there are no additional constraints to check for.
%    \begin{macrocode}
\let\check@some@constraints\relax
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\evaluate@results@of@trial}
%
%    The purpose of |\evaluate@results@of@trial| is to determine if
%    the current trial is a potential candiate for the final solution
%    and if so store it away. We can determine if the trial failed by
%    looking at the switch |@fail|.
%    \begin{macrocode}
\def\evaluate@results@of@trial{
%<*trace>
  \@tracepush{evaluate@results@of@trial}
%</trace>
%    \end{macrocode}
%    
%    \begin{macrocode}
  \ifrun@with@floats
    \ifx\try@this@area\std@try@this@area
      \count@\g_xor_trial_here_seen_num\relax
      \int_add:Nn \count@ \g_xor_page_float_int
      \ifnum \pagesetup@max@float@num < \count@
%<*trace>
        \tr@ce{Failed:~ area~ +~ here~ floats~ exceed~ max~ floats}
%</trace>
%<*progress>
        \progress@failed{area~ +~ here~ floats~ exceed~ max~ floats}
%</progress>
        \@failtrue
      \fi
    \fi
  \fi
%    \end{macrocode}
%    
%    \begin{macrocode}
  \if@fail
%<*trace>
    \tr@ce{fail:~true}
%</trace>
%    \end{macrocode}
%    If the trial has failed we have to distinguish two cases:
%    \begin{itemize}
%    \item
%      There has been a request for flushing out floats up to a
%      certain float somewhere
%      and the current float belongs to the list of floats to flush.
%    \item
%      There has been no such request.
%    \end{itemize}
%    
%    If there have been flush points we need to restore their
%    |min_col| values since we might have updated them.
%    \begin{macrocode}
    \if@flushseen
       \int_zero:N \count@
       \@whilenum \g_xor_collect_flush_seen_num>\count@ \do
          { \int_incr:N \count@
            \num_gset_eq:cc
                {g_xor_flush_ \the\count@ _min_col_num}
                {g_xor_saved_flush_ \the\count@ _min_col_num}
%<*trace>
            \tr@ce{g_xor_flush_ \the\count@ _min_col_num\space <-~
                  \num_use:c {g_xor_flush_ \the\count@ _min_col_num} ~
                  (restore) }
%</trace>
          }
    \fi

    \if@flushfail
%<*trace>
      \tr@ce{flushfail:~true}
%</trace>
%    \end{macrocode}
%    If we have failed and |\try@this@area| is already the ``relaxed''
%    version we have to artificially move the offending flush point to
%    the next column and hope that this way we get ourselves some new
%    options (worst case is that eventually the flush point is removed
%    from the page in which case we can as a last resort defer the
%    float).
%    \begin{macrocode}
      \ifx\try@this@area\relaxed@try@this@area

        \num_gincr:c {g_xor_flush_ \g_xor_trial_flush_seen_num
                      _min_col_num}
%<*trace>
        \tr@ce{g_xor_flush_ \g_xor_trial_flush_seen_num _min_col_num ~ <-~
               \num_use:c {g_xor_flush_
                           \g_xor_trial_flush_seen_num _min_col_num}
              }
%</trace>
%<*progress>
    \progress@failed{flush~ point~ \g_xor_trial_flush_seen_num\space
                     moved~ to~ column~ 
                     \num_use:c {g_xor_flush_
                                 \g_xor_trial_flush_seen_num _min_col_num}
                    }
%</progress>
      \else

        \ifx\g_xor_saved_this_areas_open_clist\@empty
%<*debug>
          \tr@ce{g_xor_saved_this_areas_open_clist:~empty ????????}
%</debug>
          \ERROR
        \else
          \clist_gset_eq:NN \g_xor_this_areas_open_clist \g_xor_saved_this_areas_open_clist
%<*trace>
          \tr@ce{~g_xor_this_areas_open_clist~ <-~ \g_xor_this_areas_open_clist \space (reopen)}
%</trace>
        \fi
        \relax@float@placement@conditions
      \fi
    \else
%<*trace>
      \tr@ce{flushfail:~false}
%</trace>
      \clist_gpop:NN \g_xor_this_areas_open_clist \l_tmpa_tlp
    \fi

%<*trace>
    \tr@ce{open:~\g_xor_this_areas_open_clist}

    \tr@ce{restore:~last~allocated:~\g_xor_saved_flseq_num}
%</trace>
%    \end{macrocode}
%    To restore the previous state we have to recalculate the target
%    |fl@| column.
%    \begin{macrocode}
      \calculate@target@fl@column
      \num_gset_eq:cN {g_xor_flseq_type_ \g_xor_this_class_tlp _col_
                       \num_use:N \l_xor_target_col_num _num}
                       \g_xor_saved_flseq_num
%<*trace>
      \tr@ce{~g_xor_flseq_type_ \g_xor_this_class_tlp _col_
                       \num_use:N \l_xor_target_col_num _num \space <-~ 
             \g_xor_saved_flseq_num \space (restored)}
%</trace>
%    \end{macrocode}
%    And if we tried a top area we also have to restored the
%    corresponding |tfl@| macro.
%    \begin{macrocode}
      \if t\g_xor_this_area_type_tlp
        \num_gset_eq:cN {g_xor_flseq_areas_top_type_ \g_xor_this_class_tlp _col_
                         \num_use:N \l_xor_target_col_num _num}
                         \g_xor_saved_flseq_top_areas_num
%<*trace>
        \tr@ce{~g_xor_flseq_areas_top_type_ \g_xor_this_class_tlp _col_
                    \num_use:N \l_xor_target_col_num _num \space <-~ 
               \g_xor_saved_flseq_top_areas_num \space (restored)}
%</trace>
      \fi
%    \end{macrocode}
%    And we better don't forget to restore the heights.\footnote{This
%    is most likely buggy: I seem to restore all column values but i think
%    i don't save all of them! FIX!!!!}
%    \begin{macrocode}
    \xor_update_this_area_span_cols:n
      {
%<*trace>
      \tr@ce{restore:~saved@col@ht@ \int_use:N \l_xor_update_col_int :~
             \csname saved@col@ht@ \int_use:N \l_xor_update_col_int\endcsname}
%</trace>
      \global\csname g_xor_ht_col_ \int_use:N \l_xor_update_col_int _dim\endcsname
             \csname saved@col@ht@ \int_use:N \l_xor_update_col_int\endcsname\relax
      \tlp_gset_eq:cc
          {g_xor_       \g_xor_this_area_type_tlp _delta_col_ 
                        \int_use:N \l_xor_update_col_int _tlp}
          {g_xor_saved_ \g_xor_this_area_type_tlp _delta_col_
                        \int_use:N \l_xor_update_col_int _tlp}
%<*trace>
      \tr@ce{GRID (delta):~ column~\int_use:N \l_xor_update_col_int
                            \g_xor_this_area_type_tlp :~
             \tlp_use:c {g_xor_saved_ \g_xor_this_area_type_tlp
  	                 _delta_col_
                         \int_use:N \l_xor_update_col_int _tlp}
             \space  (restore) }
%</trace>
      }
  \else
%<*trace>
    \tr@ce{fail:~false}
%</trace>
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*progress>
    \let\progress@inform@later\@empty
%</progress>
%    \end{macrocode}
%    If this trial is valid and we haven't seen all flush penalties
%    again we must have pushed them  to the next page. We record
%    this fact by setting |\g_xor_flush_..._min_col_num| to |\maxdimen|.
%    \begin{macrocode}
    \if@flushseen
      \int_set:Nn \count@ \g_xor_collect_flush_seen_num
      \loop
      \ifnum \g_xor_trial_flush_seen_num < \count@
        \num_gset:cn {g_xor_flush_ \the\count@ _min_col_num} \maxdimen
%<*trace>
           \tr@ce{g_xor_flush_ \the\count@ _min_col_num \space <-~ maxdimen}
%</trace>
        \advance\count@\m@ne
      \repeat
%    \end{macrocode}
%    If there has been a flush point (ie if |\g_xor_trial_flush_seen_num| und
%    thus |\count@| is greater than 0) we test whether or not the
%    float recently placed was the last one affected by the last flush
%    point on the current page and if so tighten the float placement
%    setting again.\footnote{correct logic?}
%    \begin{macrocode}
%<*progress>
     \let\progress@inform@later\@empty
%</progress>
     \ifrun@with@floats
       \ifnum \count@ > \z@
         \ifnum \csname g_xor_flush_
                        \num_use:N \g_xor_trial_flush_seen_num
                        _last_float_num\endcsname
                 =
                \g_xor_this_flseq_num \relax
%<*trace>
           \tr@ce{flush:~ last~float~affected~ by~ flush~ point~
                  \num_use:N \g_xor_trial_flush_seen_num\space placed~ ->~
                  use~ partly~ normal~ placement~ conditions~ again}
%</trace>
%<*progress>
           \def\progress@inform@later{
              \progress@nl{->~ past~ flush~ point:~ -->~ 
                           tighten~ conditions~ again}
              \progress@nl{}
           }
%</progress>
           \partly@tighten@float@placement@conditions
         \fi  
       \fi
     \fi
%    \end{macrocode}
%    Having placed a float we need to update |\g_xor_flush_max_classes_clist| to
%    reflect which float types are affected by the flush points
%    currently on the page as this might be needed when trying to
%    place or rather defer the next float.
%
%    So we loop and concatenate all |\g_xor_flush_|\meta{num}|_classes_clist| that
%    belong to flush points on the current page. This might result in
%    the list containing types several times but for the test we need
%    to do this doesn't make any difference (and it is far faster than
%    unifying the list).
%    \begin{macrocode}
      \count@\z@
      \clist_gclear:N \g_xor_flush_max_classes_clist
      \loop
      \ifnum \g_xor_trial_flush_seen_num > \count@
        \int_incr:N \count@
        \clist_gconcat:NNc
           \g_xor_flush_max_classes_clist
           \g_xor_flush_max_classes_clist
           {g_xor_flush_ \the\count@ _classes_clist}
%<*trace>
        \tr@ce{g_xor_flush_max_classes_clist~ <-~ \g_xor_flush_max_classes_clist}
%</trace>
      \repeat
    \fi
%    \end{macrocode}
%    
%    With this algorithm a trial which passed so far is always
%    considered to be better than previous trials (meaning more floats
%    on the page are better). So we always update the best trial data
%    (unless this was the run without adding floats in which case we
%    only change the |run@with@floats| switch.
%    \begin{macrocode}
    \ifrun@with@floats
      \update@best@trial
%<*progress>
      \progress@inform@later
%</progress>
    \else
      \run@with@floatstrue
    \fi
  \fi
%<*trace>
  \@tracepop{evaluate@results@of@trial}
%</trace>
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_saved_flseq_num}
% \begin{macro}{\g_xor_saved_flseq_top_areas_num}
%    \begin{macrocode}
\num_new:N \g_xor_saved_flseq_num
\num_new:N \g_xor_saved_flseq_top_areas_num
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \subsection{Best Trial Data}
%
%
% \begin{macro}{\g_xor_best_trial_status_tlp}
%    \begin{macrocode}
\tlp_new:Nn \g_xor_best_trial_status_tlp {}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\update@best@trial}
%    Not all of this belongs into this macro!\footnote{redistribute}
%    \begin{macrocode}
\def\update@best@trial{
%<*trace>
  \@tracepush{update@best@trial}
%</trace>
%<*progress>
  \progress@nl{->~ accepted}
%</progress>
  \tlp_gclear:N \g_xor_best_trial_status_tlp
  \xor_forall_columns:n{
     \tlp_gput_right:No \g_xor_best_trial_status_tlp
        {
         \expandafter
         \global
           \csname g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim\expandafter\endcsname
           \the\csname g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim\endcsname
        }
    }
%    \end{macrocode}
%
% Frank says this needs to be documented (the rest of the code is self evident)
% |\g_xor_this_float_box_tlp| is |\let| to |\g_xor_curr_float_box_tlp| which is defed to a chardefed
% token from  newinsert. so this is OK. honest.
%    \begin{macrocode}
    \seq_gput_right:co {g_xor_area_\g_xor_this_area_name_tlp _seq}
                       \g_xor_this_float_box_tlp
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*trace>
    \tr@ce{g_xor_curr_page_areas_closed_clist~ \g_xor_curr_page_areas_closed_clist\space +~
           "\clist_use:c{g_xor_ \g_xor_this_area_name_tlp _all_close_clist}"}
    \tr@ce{g_xor_this_areas_closed_clist~ \g_xor_this_areas_closed_clist\space +~
           "\clist_use:c{g_xor_ \g_xor_this_area_name_tlp _class_close_clist}"}
%</trace>
    \clist_gput_right:NC \g_xor_curr_page_areas_closed_clist
                         {g_xor_ \g_xor_this_area_name_tlp _all_close_clist}
    \clist_gput_right:NC \g_xor_this_areas_closed_clist
                         {g_xor_ \g_xor_this_area_name_tlp _class_close_clist}
%    \end{macrocode}
%
%    Check: why the remark "tmp"?\footnote{FIX}
%    \begin{macrocode}
        \clist_gset_eq:cN {g_xor_class_ \g_xor_this_class_tlp _areas_closed_clist} % FMi tmp
                          \g_xor_this_areas_closed_clist
%    \end{macrocode}
%
%    \begin{macrocode}
  \int_gincr:N \g_xor_page_float_int
  \int_gincr:c {g_xor_area_ \g_xor_this_area_name_tlp _float_int}
%    \end{macrocode}
%
%    Since the trial was successful, we have to update the the macros
%    that hold the number of top or bottom floats we have seen so far
%    in each column.\footnote{Code for this is similar to the one in
%    construct@and@test@col@ht and elsewhere; perhaps there should be
%    a subroutine for it!}
%    \begin{macrocode}
  \xor_update_this_area_span_cols:n
     {
      \num_gincr:c
         {g_xor_ \g_xor_this_area_type_tlp _floats_col_
          \int_use:N \l_xor_update_col_int _num}
%<*trace>
       \tr@ce{g_xor_ \g_xor_this_area_type_tlp
              _floats_col_ \int_use:N \l_xor_update_col_int _num <-~
              \num_use:c {g_xor_ \g_xor_this_area_type_tlp
                          _floats_col \int_use:N \l_xor_update_col_int _num}
         }
%</trace>
     }
%    \end{macrocode}
%
%    \begin{macrocode}
%<*trace>
  \tr@ce{\meaning\g_xor_best_trial_status_tlp}
  \tr@ce{area:~\g_xor_this_area_name_tlp\space \csname g_xor_area_ \g_xor_this_area_name_tlp _seq \endcsname}
  \@tracepop{update@best@trial}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%

%
%
% \newpage
%
% \subsection{Best Column Output Routine}
%
% \begin{description}
% \item[Entry:] |\setup@best@column@or|
% \item[Exit:]  |\xor_collect_setup:|
% \item[Prereq:] 
% \item[Description:]
% \item[Flow:] 
%\begin{footnotesize}
%\begin{verbatim}
%    \setup@best@column@or
%            |
%    New OR: \best@column@or      
%            |
%            V
%    \best@column@loop <-------      
%            |                      
%    (when entering OR...)    
%            |                      
%    <end of collection reached?>
%         |          |          
%        yes        no                   
%         |          |
%         |     <col break requested?>
%         |          |        |
%         |         yes       no
%         |          |        |
%         |          |     <flush point encountered?>
%         |          |        |                  |
%         |          |       yes                 no
%         |          |        |                  |
%         |          | <flush point         <here point encountered?>
%         |          |      too early?>        |               |
%         |          |    |      |            yes              no
%         |          |   yes    no             |               |
%         |          |    |      |             ?               ?
%         |          |    | (ignore break)
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
%         |          |    |      |
% (end column now) <-------      |
%         |                      |
%         V                      |
%   <all cols produced?>         |
%      |           |             V
%     yes          no--------------------> (reenter \best@column@loop)
%      |                           
% (produce final page)                 
%      |                           
%      V
%  \initialise@next@page
%      |
%      V
% (try to make float pages)            
%      |                           
%      V                           
%  \xor_collect_setup:
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%
% After the best trial is chosen the `best@column@or' output routines
% are executed. Structurally this is similar to the grab column output
% routines used during the trials, but this time information
% about the float placements is recorded in the float area lists
% and also optionally in float placement control files.
%
% \begin{macro}{\setup@best@column@or}
%    This is the initialisation code for producing the final best set
%    of columns (via the @best@column@or output routine).
%    \begin{macrocode}
\def\setup@best@column@or{
%<*trace>
 \@tracepush{setup@best@column@or}
% Elsewhere now:
% \tr@ce{reinsert~penalty:~ \saved@outputpenalty\space (unless~ 10000)}
%</trace>
%   \penalty
%      \ifnum\saved@outputpenalty=\@M
%         \z@
%      \else
%         \saved@outputpenalty\relax
%      \fi 
   \int_gzero:N \g_xor_curr_col_int
   \num_gzero:N \g_xor_trial_flush_seen_num
   \num_gzero:N \g_xor_trial_here_seen_num
   \perhaps@write@placements@to@fpl@file
   \g_xor_best_trial_status_tlp
%    \end{macrocode}
%    
%    \begin{macrocode}
   \initialise@footins@action
%    \end{macrocode}
%    
%    \begin{macrocode}
   \global\output{\best@column@or}
   \best@column@loop
%<*trace>
 \@tracepop{setup@best@column@or}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\best@column@loop}
%    \begin{macrocode}
\def\best@column@loop{
%<*trace>
  \@tracepush{best@column@loop}
%</trace>
  \int_gincr:N \g_xor_curr_col_int
  \global\vsize\csname g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim\endcsname
%<*trace>
  \tr@ce{vsize~ <-~ \the\vsize }
  \@tracepop{best@column@loop}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\best@column@or}
%    Here is the output routine used when preparing the final columns,
%    an instantiation of |\some@column@or|. In contrast to the version
%    used for |\grab@column@or| it doesn't do the tests.
%    \begin{macrocode}
\def\best@column@or{\some@column@or{best}
      \best@column@or@finish
      {
       \@reinserts
       \unvbox\@cclv
%    \end{macrocode}
%    Next line not okay! we need to add a penalty here but which one?
%    Or we need a different mechanism using either |\holdinginserts|
%    or a partial box line in collection OR.\footnote{FIX!!! there is
%    also another place like this!}
%    \begin{macrocode}
%       \penalty\z@  %FMi?
      }
      {
       \perhaps@write@to@fpl@file{
           \@spaces Area:~hhh^^J
           \expandafter\perhaps@write@placements@to@fpl@file@aux\the\toks\g_xor_curr_float_box_tlp}
       \typeset@a@here@float
      }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\best@column@or@finish}
%
%    \begin{macrocode}
\def\best@column@or@finish{
%<*trace>
  \@tracepush{best@column@or@finish}
%</trace>
  \mark@update@structure
%    \end{macrocode}
%    
%    \begin{macrocode}
  \deal@with@footins@action
%    \end{macrocode}
%
% save all marks here\footnote{not done yet!}
%
% add floats and footnotes etc to collected column   
%
%    \begin{macrocode}
  \produce@final@column
%    \end{macrocode}
%
%    \begin{macrocode}
  \ifnum\g_xor_curr_col_int=\g_xor_cols_int
    \produce@final@page
    \initialise@next@page
    \try@float@pages
    \place@deferred@floats
    \xor_collect_setup:
%{\showoutput\showlists}
  \else
    \best@column@loop
  \fi
%<*trace>
  \@tracepop{best@column@or@finish}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\initialise@next@page}
%    Initialises the column heights to text height. Clear the float
%    area lists, zero holdinginserts to allow footnote texts to arrive
%    in the insertion box.
%    \begin{macrocode}
\def\initialise@next@page{
%<*trace>
  \@tracepush{initialise@next@page}
%</trace>
%
%    \end{macrocode}
%    
%    \begin{macrocode}
  \xor_cols_setup:
%    \end{macrocode}
%    
%    \begin{macrocode}
  \xor_area_setup:
%    \end{macrocode}
%    
%    \begin{macrocode}
  \int_gzero:N \g_xor_page_float_int
%    \end{macrocode}
%    
%    \begin{macrocode}
  \initialise@flush@data
%    \end{macrocode}
%    
%    \begin{macrocode}
  \initialise@here@data
%    \end{macrocode}
%    
%    \begin{macrocode}
  \initialise@footins@action
%    \end{macrocode}
%    
%    Nothing is closed when we are at the start of a page.
%    \begin{macrocode}
  \clist_gclear:N \g_xor_curr_page_areas_closed_clist
%    \end{macrocode}
%    
%    \begin{macrocode}
  \seq_map:NN \g_xor_float_classes_seq
              \xor_float_class_setup:n
%
% for safety
 \tlp_gset_eq:NN \g_xor_this_float_box_tlp \@undefined
%<*trace>
  \@tracepop{initialise@next@page}
%</trace>
  }
%    \end{macrocode}
%  \end{macro}
%
%
%
% \begin{macro}{\handle@case@of@forced@pagebreak}
%    This is related to |\handle@case@of@premature@ending| but we have
%    to return the penalty only if we haven't reached the last column.
%    If we don't do this we would start collecting material in the
%    middle of final page generation!
%    \begin{macrocode}
\def \handle@case@of@forced@pagebreak{
  \ifnum\g_xor_curr_col_int<\g_xor_cols_int
    \ifnum\outputpenalty=-\@M
      \@emptycol
    \fi
  \fi

  \ifnum\outputpenalty=-\output@balance@penalty
%<*trace>
    \tr@ce{BALANCE:~ end~ point~ seen~ again}
%</trace>
    \remove@guard@box@from@cclv
    \ifnum\g_xor_curr_col_int<\g_xor_cols_int
       \@emptycol
    \fi
  \fi
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \newpage
%
% \subsection{Cleanup Output Routine}
%
% \begin{description}
% \item[Entry:] |\setup@cleanup@or|
% \item[Exit:]  |\float@placement@loop|
% \item[Prereq:] 
% \item[Description:]
%    Responsible for discarding unused text still on Main Vertical
%    List After the end of a trial. It eats everything until it sees
%    the special penalty marking the end of the last collection output
%    routine. This output routine may need to be called several times
%    in succession due to forced penalties in the galley.
% \item[Flow:] 
%\begin{footnotesize}
%\begin{verbatim}
%    \setup@cleanup@or
%           |
%           V
%    New OR: \cleanup@or
%           |
%           V
% <special outputpenalty reached?> --> \float@placement@loop
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%
% \begin{macro}{\setup@cleanup@or}
%    \begin{macrocode}
\def\setup@cleanup@or{
  \global\vsize\maxdimen
  \global\output{\cleanup@or}
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cleanup@or}
%    In the actual output routine we grab text and throw it away until
%    we see the special output penalty. Then we prepare for the trials
%    to place the floats properly.
%    \begin{macrocode}
\def\cleanup@or{
%<*trace>
 \@tracepush{cleanup@or}
 \tr@ce{output~pen:~ \the\outputpenalty}
%</trace>
%    \end{macrocode}
%    Throw everything away \ldots
%    \begin{macrocode}
 \global\setbox\@cclv\box\voidb@x
 \global\setbox\footins\box\voidb@x
%    \end{macrocode}
%    \ldots\ until we see the special output penalty again.
%    \begin{macrocode}
 \ifnum\outputpenalty=-\output@collect@penalty
   \float@placement@loop
 \fi
%<*trace>
 \@tracepop{cleanup@or}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \newpage
%
% \subsection{Making float pages}
%
%
% \begin{description}
% \item[Entry:] |\try@float@pages|
% \item[Exit:]  --- (this happens within the OR)\\
%    On exit |\g_xor_area_DDD_seq| will be empty and the floats not being put
%    onto float pages are moved to |\g_xor_active_floats_seq| (those that have
%    their call outs on previous pages) and |\g_xor_mvl_floats_seq| (those that
%    have their call outs still on the MVL).
% \item[Prereq:] |\g_xor_area_DDD_seq| contains the float to work on; all other
%    areas are empty.
% \item[Description:]
% \item[Flow:] 
%\begin{footnotesize}
%\begin{verbatim}
%   \try@float@pages
%         |
%         V
%  <\g_xor_area_DDD_seq has floats?>
%      |          |
% ----no         yes       
% |               |
% |               V
% |  (split \g_xor_area_DDD_seq into \g_xor_active_floats_seq and \g_xor_mvl_floats_seq;
% |   setup trial conditions)
% |               |
% |               V
% |           \try@float@page <-------------
% |               |                        |
% |          <float page produced?>        |
% |             |         |                |
% |            no        yes               |
% |             |         |                |
% |             |     (output page)        |
% |             |         |                |
% |             |     (move new \g_xor_area_DDD_seq  |
% |             |      to \g_xor_active_floats_seq)    |
% |             |         |                |
% |             |         ------------------
% |             |
% |             |
% |   (restore float conditions before last trial)
% |             |
% |   (restore trial condition to normal)
% |             |
% ------------->|
%               |
%               V
%\end{verbatim}
%\end{footnotesize}
% \end{description}
%
%
%
% \begin{macro}{\try@float@pages}
% 
%    \begin{macrocode}
\def\try@float@pages {
%<*trace>
  \@tracepush{try@float@pages}
%</trace>
%<-trace>  \seq_if_empty:NF
%<+trace>  \seq_if_empty:NTF
    \g_xor_area_DDD_seq
%<+trace>       { \tr@ce{no~ deferred~ floats} }
    {
      \glet:NN \xor_active_floats_seq_empty_action: \relax
      \glet:NN \pretests@success@action \floatpage@pretests@success@action
%    \end{macrocode}
%    this is only a tmp: we just use |\relaxed@try@this@area| but of
%    course there should be different rules for float pages (and
%    different float areas and \ldots)
%    \begin{macrocode}
      \global\let\try@this@area\relaxed@try@this@area
%    \end{macrocode}
%
%    First thing to do is to split the list of deferred floats into
%    those that have ther callouts already typeset (on previous pages)
%    and those that we have only seen because we looked a bit
%    ahead. For making float pages we can only use the former.
%    \begin{macrocode}
      \seq_map:NN \g_xor_area_DDD_seq
                  \split@defer@list
      \seq_gclear:N\g_xor_area_DDD_seq
%    \end{macrocode}
%    Now we loop until we fail to make float pages. The actual work is
%    done in the macro |\try@float@page|.
%    \begin{macrocode}
    \@floatpagetrue
    \loop
    \if@floatpage
      \begingroup % no nesting of \loop without grouping ...
%    \end{macrocode}
%    
%    A bit statistics: how many floats do we have on the
%    |\g_xor_active_floats_seq|?
%    \begin{macrocode}
%<*progress>
     \seq_map_inline:Nn
       \g_xor_active_floats_seq
       {\int_gincr:N\g_xor_trials_int}
   \progress@nl{}
   \progress@separator
   \progress@nl{STATS:~ floats~ waiting~ =~ \int_use:N\g_xor_trials_int
         \space on~ page~ \num_use:N \g_xor_page_absolute_num \space (float~ page)}
   \progress@separator
   \int_gzero:N \g_xor_trials_int
%</progress>
%    \end{macrocode}
%    \begin{macrocode}
        \try@float@page   
      \endgroup
    \repeat
%    \end{macrocode}
%    Once we are finished we have to return to normal trial
%    conditions, so\ldots
%    \begin{macrocode}
    \global\let\try@this@area\std@try@this@area
   }
%<*trace>
  \@tracepop{try@float@pages}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%  
% \begin{macro}{\try@float@page}
%    This macro tries to build a single float page from the floats in
%    |\g_xor_active_floats_seq|. If it fails it (tries to) restores the state of
%    the floats. If it succeeds it will output a float page and returns.
%    \begin{macrocode}
\def\try@float@page {
%<*trace>
  \@tracepush{try@float@page}
%</trace>
%    \end{macrocode}
%    Save the current state in case of failure then run the float
%    placement loop (setup for this loop should have happened
%    earlier).
%    \begin{macrocode}
  \save@current@float@state
  \trial@inner@loop
%
%\typeout{float.list.after.trial}
%\showfloatlists
%
%    \end{macrocode}
%    Loop through all ``text columns'' and add up their heights. This
%    is again only done to have some sort of measure for float pages
%    and should be removed once some real code gets into this part.
%    \begin{macrocode}
  \dimen@\z@
  \xor_forall_columns:n{
%<*trace>
    \tr@ce{\ht\int_use:N\g_xor_curr_col_int=\the \csname
            g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim \endcsname}
%</trace>
    \advance\dimen@ \csname
            g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim\endcsname
                  }
%    \end{macrocode}
%
%    If the sum of all white space is more than 300pt :-)
%    \begin{macrocode}
  \ifdim \dimen@ > 300pt \relax
%    \end{macrocode}
%    we fail
%    \begin{macrocode}
    \@floatpagefalse
%<*trace>
    \tr@ce{float~page~failed}
%</trace>
%<*progress>
    \progress@failed{no~ float~ page~ made}
    \progress@nl{}
%</progress>
%    \end{macrocode}
%    Return to the previous state (and as can be seen by using
%    |\initialise@next@page|) this needs some work; the latter might
%    in fact do too much like calling
%    |\initialise@flush@num|!\footnote{FIX}
%    \begin{macrocode}
    \saved@float@state
%    \end{macrocode}
%    To avoid having |\initialise@flush@num| do anything harmful we
%    set |\g_xor_trial_flush_seen_num| to zero at this point.\footnote{This
%    needs fixing properly!} And the same is necessary for
%    |\initialise@here@num|.
%    \begin{macrocode}
    \num_gzero:N \g_xor_trial_flush_seen_num
    \num_gzero:N \g_xor_trial_here_seen_num
    \initialise@next@page
  \else
%    \end{macrocode}
%    Otherwise we claim we have  a good float page.
%    \begin{macrocode}
%<*trace>
    \tr@ce{float~page~succeeded}
    \tr@ce{We~ better~ output~ something~ now~ ...}
%</trace>
%<*progress>
    \progress@nl{succeeded}
    \progress@nl{}
%</progress>
%    \end{macrocode}
%    producing this page is rubbish as well but it can't be written
%    before we have parameters and rules for making float pages.
%    \begin{macrocode}
    \xor_forall_columns:n{
      \global\setbox\csname g_xor_col_ \int_use:N\g_xor_curr_col_int _box\endcsname
        \vbox to \csname g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim\endcsname{}
      \produce@final@column
    }
    \perhaps@write@placements@to@fpl@file
    \produce@final@page
    \initialise@next@page
%    \end{macrocode}
%    But the final lines are for real: if we did succeed we need to
%    provide a new |\g_xor_active_floats_seq| for the next potential float page.
%    It should be the floats we deferred while trying to make the
%    current float page followed by the floats that are still on the
%    active list (i.e., those we haven't even tried for the current
%    page).
%    \begin{macrocode}
    \seq_gconcat:NNN \g_xor_active_floats_seq
                     \g_xor_area_DDD_seq
                     \g_xor_active_floats_seq
    \seq_gclear:N \g_xor_area_DDD_seq
  \fi
%
%\typeout{float.list.after.shipout.float.page.or.fail}
%\showfloatlists
%
%<*trace>
  \@tracepop{try@float@page}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\if@floatpage}
% \begin{macro}{\@floatpagefalse}
% \begin{macro}{\@floatpagetrue}
%    Switch which is set to true while we are in the process of making
%    float pages and haven't failed.
%    \begin{macrocode}
\newif\if@floatpage
\def\@floatpagefalse{\global\let\if@floatpage\iffalse}
\def\@floatpagetrue{\global\let\if@floatpage\iftrue}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\save@current@float@state}
%
%    Save the current state of affairs concerning
%    floats\footnote{Needs more work, there are now other data
%    structures that should be saved if this is every going to be of
%    much use. (its current usage actually could be achieved with
%    simpler means). FIX or fold!}. In case of failure return to
%    this state by executing |\saved@float@state|.
%    \begin{macrocode}
\def\save@current@float@state {
%<*trace>
  \@tracepush{save@current@float@state}
%</trace>
%%% FMi tmp
\let\seq_elt:w\relax
\let\seq_elt_end:\relax
  \xdef\saved@float@state{\gdef\noexpand\g_xor_active_floats_seq{\g_xor_active_floats_seq}}
  \xor_forall_columns:n {
    \tlp_gput_right:No \saved@float@state
        { \expandafter \global
            \csname g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim\expandafter\endcsname
            \the \csname g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim\endcsname
%    \end{macrocode}
%    No final |\relax| needed since this is followed by area data. And
%    if there are no areas we wouldn't call this code, would we?
%    \begin{macrocode}
        }
  }
%    \end{macrocode}
%    Save current state of all used float areas by looping though them.
%    \begin{macrocode}
  \clist_map:NN \g_xor_areas_used_clist \save@area@info
  \save@area@info {DDD}
%<*trace>
  \tr@ce{saved:~ \meaning\saved@float@state}
  \@tracepop{save@current@float@state}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\save@area@info}
%    THIS MAKES USE OF AREAS STORED WITHOUT SEPARATOR RIGHT NOW!
%    Save information about area and recourse.
%    \begin{macrocode}
\def\save@area@info#1{
\begingroup
  \let\seq_elt:w\relax
  \let\seq_elt_end:\relax
    \edef\@tempa {
       \exp_not:N \int_gset:cn
          {g_xor_area_ #1 _float_int}
          {\int_use:c {g_xor_area_ #1 _float_int} }
%    \end{macrocode}
%
%    \begin{macrocode}
% FMI fix, see above
       \gdef \expandafter\noexpand \csname g_xor_area_#1_seq \endcsname
          {\csname g_xor_area_#1_seq\endcsname}
    }
    \tlp_gput_right:No \saved@float@state \@tempa
\endgroup
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\saved@float@state}
%    To return to the saved float state execute |\saved@float@state|.
%    \begin{macrocode}
\let\saved@float@state\@empty
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\split@defer@list}
%
%    Split |\g_xor_area_DDD_seq| list, moving those floats whose callouts have
%    been typeset to |\g_xor_active_floats_seq| for consideration for (one day)
%    float pages, and for allocating to text page float areas.
%
%    Floats whose callouts are still on MVL are placed on |\g_xor_mvl_floats_seq|.
%    \begin{macrocode}
\def\split@defer@list #1 {
%%% local????? FIX
  \def\g_xor_curr_float_box_tlp{#1}
  \expandafter\extract@this@float@actual@structure\the\toks #1
%<*trace>
  \tr@ce { #1:~\LastMark{\g_xor_this_class_tlp}~ ???~\g_xor_this_flseq_num }
%</trace>
  \ifnum 0\LastMark{\g_xor_this_class_tlp} < \g_xor_this_flseq_num
%<*trace>
    \tr@ce {#1:~ not~ really~ defered }
%</trace>
    \seq_gput_right:Nn \g_xor_mvl_floats_seq #1
  \else
%<*trace>
    \tr@ce {#1:~ callout~ has~ been~ typeset}
%</trace>
    \seq_gput_right:Nn \g_xor_active_floats_seq #1
  \fi
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsection{Preassign deferred floats}
%
%
%
% \begin{macro}{\place@deferred@floats}
%
%    The |\place@deferred@floats| is supposed to distribute from
%    previous pages (i.e., from the top of |\g_xor_area_DDD_seq| or more exactly
%    those currently on the |\g_xor_active_floats_seq| since the
%    |\g_xor_area_DDD_seq| was 
%    already split when trying to build float pages) into the areas
%    of the page to be build. After all we know that for those floats
%    the call outs are on previous pages so testing for them
%    is unnecessary and we could save time by bypassing this stuff.
%
%    On the other hand if we have flush points in the upcoming text
%    all our placements might be wrong, so perhaps this doesn't really
%    save so much time after all and the extra complication might not
%    be worth the effort.
%
%    Perhaps a compromise is to make a first column grab without any
%    floats to see if we end up with a flush point (not implemented).
%
%    So if we don't do this then the only thing we need to do at this
%    point is to move the floats from the |\g_xor_mvl_floats_seq| to the end of
%    the |\g_xor_active_floats_seq|.
%    \begin{macrocode}
\def\place@deferred@floats {
%<*trace>
  \@tracepush{place@deferred@floats}
%</trace>
  \seq_gconcat:NNN \g_xor_active_floats_seq
                   \g_xor_active_floats_seq
                   \g_xor_mvl_floats_seq
  \seq_gclear:N \g_xor_mvl_floats_seq
%\showfloatlists
%<*trace>
  \@tracepop{place@deferred@floats}
%</trace>
}
%    \end{macrocode}
%
%
%    Here is an alternate definition which does the preassigning but
%    it would need to be extended by checking for flush points or by a
%    flag that ensures that if we later encounter a flush point that
%    we know we could backtrack if necessary (e.g., the preassignment
%    might have already deferred some floats past the flush
%    point).\footnote{Extend, fix, or get rid of.}
%    \begin{macrocode}
\iffalse % we don't do it right now
\def\place@deferred@floats {
%<*trace>
  \@tracepush{place@deferred@floats}
%</trace>
%\showfloatlists
  \glet:NN \xor_active_floats_seq_empty_action: \relax
  \glet:NN \pretests@success@action \floatpage@pretests@success@action
  \trial@inner@loop
  \seq_gconcat:NNN \g_xor_active_floats_seq
                   \g_xor_area_DDD_seq
                   \g_xor_mvl_floats_seq
  \seq_gclear:N \g_xor_area_DDD_seq
  \seq_gclear:N \g_xor_mvl_floats_seq
%\showfloatlists
%<*trace>
  \@tracepop{place@deferred@floats}
%</trace>
}
\fi
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\floatpage@pretests@success@action}
% Version of |\pretests@success@action| for use in initial phase
% when previously deferred floats are being allocated to float areas.
%    \begin{macrocode}
\def\floatpage@pretests@success@action{
%<*trace>
  \@tracepush{floatpage@pretests@success@action}
%</trace>
  \update@best@trial
  \trial@inner@loop
%<*trace>
  \@tracepop{floatpage@pretests@success@action}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \newpage
%
% \subsection{Support for Balancing}
%
% Code in this section (and related code in other sections) is not
% used at the moment and will most likely be replaced with something
% completely different.
%
% \begin{macro}{\if@balance}
%    |@balance| is set to true if we encounter a balance penalty
%    during collection. 
%    \begin{macrocode}
\newif\if@balance
\def\@balancefalse{\global\let\if@balance\iffalse}
\def\@balancetrue{\global\let\if@balance\iftrue}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\balancecolumns}
%
%    \begin{macrocode}
\def\balancecolumns {
  \add@badly@guarded@penalty\output@balance@penalty
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \newpage
%
% \subsection{Support for Flush Points}
%
%
% \begin{macro}{\if@flushseen}
% \begin{macro}{\if@flushfail}
%
%    |@flushseen| is set to true if we encounter a flush penalty
%    during collection. 
%
%    |@flushfail| is set to true if we fail a trial due to placing the
%    float after the flush penalty.
%    \begin{macrocode}
\newif\if@flushseen
\def\@flushseenfalse{\global\let\if@flushseen\iffalse}
\def\@flushseentrue{\global\let\if@flushseen\iftrue}
\newif\if@flushfail
\def\@flushfailfalse{\global\let\if@flushfail\iffalse}
\def\@flushfailtrue{\global\let\if@flushfail\iftrue}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\flushfloats}
%
% Possible variants:
%   
%    Flush only one (some) types.
%    
%    Fuzzyflush or, more precisely, flush-to-this-column 
%      or -page or -spread.\footnote{Right now "spread" is not implemented.}
%
%    Parts of the flushpenalty (all types) data structure:
%
%    |\g_xor_flush_|\meta{num}|_min_col_num|
%    |\saved@flush@min@col@|\meta{num}
%    |\flush@prev@float@num@|\meta{num}\footnote{what is this Chris?}
%    
%    |\g_xor_collect_flush_seen_num| is the number of these so that 
%    \meta{num} has range [1, |\g_xor_collect_flush_seen_num|]
%
%    In addition, whilst doing an fp trial we need |\g_xor_trial_flush_seen_num|
%    to record that we have, in this trial so far, seen the
%    flush points [1, |\g_xor_trial_flush_seen_num|].
%
%
%    \begin{macrocode}
\DeclareDocumentCommand\flushfloats { o O{strict} }
  { \flush@floats {#1} {#2} }
%    \end{macrocode}
%    
%    \begin{macrocode}
\def\flush@floats #1 #2 {
  \add@badly@guarded@penalty\output@flush@float@penalty
%    \end{macrocode}
%    
%    \begin{macrocode}
  \num_gincr:N\g_xor_collect_flush_seen_num
%    \end{macrocode}
%    
%    \begin{macrocode}
  \num_gset:cn {g_xor_flush_ \g_xor_collect_flush_seen_num _min_col_num}{1}
%    \end{macrocode}
%    
%    \begin{macrocode}
  \num_gset:cn
      {g_xor_flush_ 
       \num_use:N \g_xor_collect_flush_seen_num
       _last_float_num}
      {\the\float@sequence@count}
%    \end{macrocode}
%    If |#1| is |\NoValue| the current flush point affects all float
%    sequence classes, thus we store in
%    |\g_xor_flush_|\meta{num}|_classes_clist| a list of all float sequence
%    classes separated by semicolons. Otherwise we assume that we got
%    a single float type(!) as argument and flush the corresponding
%    class.
%    \begin{macrocode}
  \IfNoValueTF{#1}{
%FMi tmp!
    \def\seq_elt:w ##1\seq_elt_end:{##1,}
    \expandafter\xdef
      \csname g_xor_flush_ \g_xor_collect_flush_seen_num
              _classes_clist \endcsname 
      {\g_xor_float_classes_seq}
   }
   {\expandafter\ifx\csname g_xor_type_ #1 _class_tlp\endcsname
                    \relax
      \ErrorArgumentNotAFloatType
    \else
      \clist_gset_eq:cc
         {g_xor_flush_ \g_xor_collect_flush_seen_num _classes_clist}
         {g_xor_type_ #1 _class_tlp}
    \fi
   }
%    \end{macrocode}
%    The argument |#2| holds the fuzziness of the flush point which
%    currently can be either |strict|, |column| or |page|.
%    We link |\flush@fuzziness@|\meta{num} to the code stored in
%    |\flushcheck@#2| after making sure that such code
%    exists.\footnote{Improve error handling (as elsewhere)}
%    \begin{macrocode}
  \@ifundefined {flushcheck@#2}
    \userinputERROR
    {\global\expandafter\let
        \csname flush@fuzziness@\g_xor_collect_flush_seen_num \expandafter \endcsname 
        \csname flushcheck@#2\endcsname
%<*trace>
        \tr@ce{flush@fuzziness@\g_xor_collect_flush_seen_num \space
            =:~ \expandafter\noexpand\csname flushcheck@#2\endcsname
               }
%</trace>
    }
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\clearpage}
%    \LaTeX's |\clearpage| command now looks like this:
%    \begin{macrocode}
\def\clearpage{ \flushfloats \newpage }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\doubleclearpage}
%    \LaTeX's |\doubleclearpage| command also needs a new
%    definition:\footnote{But not this one :-) FIX!}
%    \begin{macrocode}
\def\doubleclearpage{ \clearpage }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_collect_flush_seen_num}
%    The number |\g_xor_collect_flush_seen_num| records the number of flush
%    points we have have seen during collection.
%    \begin{macrocode}
\num_new:N \g_xor_collect_flush_seen_num
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_trial_flush_seen_num}
%    The number |\g_xor_trial_flush_seen_num| records the number of flush
%    points we have seen so far during a trial, i.e., it will be
%    initialised to zero at the beginning of the trial and advanced by
%    one for each flush point encountered.
%    \begin{macrocode}
\num_gzero:N \g_xor_trial_flush_seen_num
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_flush_NUN_last_float_num}
% \begin{macro}{\g_xor_flush_NUM_min_col_num}
% \begin{macro}{\g_xor_flush_NUM_classes_clist}
% \begin{macro}{\flush@fuzziness@xxx}
%
%    For each flush point we have a data structure in which we store
%    relevant information. This data structure is provided by a set of
%    macros which can be accessed by using the number of the current
%    flush point and constructing |\csname|s from it, e.g., to get at
%    the ``flush min col'' for the flush point with number 3 would be
%    |\csname g_xor_flush_3_min_col_num\endcsname|.

%    |\g_xor_flush_|\meta{num}|_min_col_num| holds the column number in which we
%    last seen the flush penalty while trying to find a solution for
%    the current page. This is initialised to 1 in |\xor_OR_collect:| when
%    a flush penalty is encountered during collection (since 1 is the
%    earliest column in which the flush penalty finally may fall). By
%    adding additional floats to the page the penalty might move to a
%    later column but normally not back to an earlier
%    one\footnote{There is a possibility that this happens if there is
%    enough space vanishing at the new break.}  If we end up with the
%    flush penalty moving backwards we force a break at this point
%    until we reach the column where it was before. The reason for
%    this action is that we might have allocated floats to later
%    columns that would otherwise end after after the flush penalty.
%    
%    If by adding floats to the trials the flush penalty is moved to
%    the next page we set |\g_xor_flush_|\meta{num}|_min_col_num| to
%    |\maxdimen|. The actual test to see if a flush penalty still
%    belongs to the current page is to check against |\g_xor_curr_col_int|
%    (so |\g_xor_curr_col_int+1| would be sufficient, but using
%    |\maxdimen| avoids calculations.
%    
%    |\g_xor_flush_|\meta{num}|_classes_clist| holds a comma separated
%    list of float types which
%    are affected by the current flush point.
%
%    |\flush@fuzziness@|\meta{num} holds the fuzziness associated with
%    the flushpoint, valid values are |strict| and |page|.
%
%    By defining (some of) them on top-level we avoid unnecessary
%    entries on the savestack since they would otherwise be
%    constructed (locally) first within the output routine (when doing
%    |\ifx| testing), resulting in |\relax| being stored on the
%    savestack.
%    \begin{macrocode}
\let_new:cN {g_xor_flush_1_last_float_num} \ERROR
\let_new:cN {g_xor_flush_1_classes_clist}  \ERROR
\let_new:cN {g_xor_flush_1_min_col_num}    \ERROR
\let_new:cN {flush@fuzziness@1 } \ERROR
\let_new:cN {g_xor_flush_2_last_float_num} \ERROR
\let_new:cN {g_xor_flush_2_classes_clist}  \ERROR
\let_new:cN {g_xor_flush_2_min_col_num}    \ERROR
\let_new:cN {flush@fuzziness@2 } \ERROR
\let_new:cN {g_xor_flush_3_last_float_num} \ERROR
\let_new:cN {g_xor_flush_3_classes_clist}  \ERROR
\let_new:cN {g_xor_flush_3_min_col_num}    \ERROR
\let_new:cN {flush@fuzziness@3 } \ERROR
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\g_xor_flush_max_classes_clist}
%    |\g_xor_flush_max_classes_clist| holds the concatenation of all
%    |\g_xor_flush_|\meta{num}|_classes_clist| on the page currently
%    constructed. This information is needed in case we get to a new
%    float and the preliminary tests suggests that it needs to be
%    deferred. In that case we need to know which flush points have
%    been seen previously to decide whether or not we can defer the
%    new float.
%    \begin{macrocode}
\clist_new:N \g_xor_flush_max_classes_clist
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\initialise@flush@data}
%    \begin{macrocode}
\def \initialise@flush@data{
%<*trace>
  \@tracepush{initialise@flush@data}
%</trace>
%    \end{macrocode}
%    Does this need any documentation?
%
%    Well, we have to get rid of all information relating to flush
%    float penalties that have been typeset on the previous page and
%    move the remaining ones (if any) to the front.
%    \begin{macrocode}
  \int_set:Nn \count@ \g_xor_collect_flush_seen_num 
  \int_add:Nn \count@ {-\g_xor_trial_flush_seen_num }
%<*trace>
  \tr@ce{g_xor_collect_flush_seen_num~
         =~ \g_xor_collect_flush_seen_num\space <-~
            \the\count@  }
%</trace>
%    \end{macrocode}
%    Something wrong here if we get negative values!
%    \begin{macrocode}
%<*debug>
  \ifnum\count@<\z@ \ERROR \fi
%</debug>
%    \end{macrocode}
%    
%    \begin{macrocode}
  \num_gset:Nn \g_xor_collect_flush_seen_num {%\the ok? FMi
               \count@}
%    \end{macrocode}
%    
%    \begin{macrocode}
  \@tempcnta\g_xor_trial_flush_seen_num
  \@tempcntb\z@
  \loop
  \ifnum \@tempcntb < \count@

    \int_incr:N \@tempcnta
    \int_incr:N \@tempcntb
%<*trace>
    \tr@ce{flush@fuzziness@\the\@tempcntb\space
           =~ \expandafter \noexpand
              \csname flush@fuzziness@\the\@tempcntb\endcsname\space
           <-~ \expandafter \noexpand
              \csname flush@fuzziness@\the\@tempcnta \endcsname
          }
    \tr@ce{g_xor_flush_ \the\@tempcntb _last_float_num\space
           =~ \num_use:c {g_xor_flush_ 
                          \the\@tempcntb
                          _last_float_num}
           \space <-~
           \num_use:c {g_xor_flush_ \the\@tempcnta
                       _last_float_num}
          }
    \tr@ce{g_xor_flush_ \the\@tempcntb _classes_clist\space
           =~ \clist_use:c {g_xor_flush_ \the\@tempcntb _classes_clist} \space <-~
              \clist_use:c {g_xor_flush_ \the\@tempcnta _classes_clist}
          }
    \tr@ce{g_xor_flush_ \the\@tempcntb _min_col_num \space <-~ 1}
%</trace>
    \global\expandafter\let 
      \csname flush@fuzziness@\the\@tempcntb \expandafter\endcsname
      \csname flush@fuzziness@\the\@tempcnta \endcsname

    \num_gset_eq:cc
      {g_xor_flush_ \the\@tempcntb _last_float_num}
      {g_xor_flush_ \the\@tempcnta _last_float_num}

    \clist_gset_eq:cc
      {g_xor_flush_\the\@tempcntb _classes_clist}
      {g_xor_flush_\the\@tempcnta _classes_clist}

    \num_gset:cn {g_xor_flush_ \the\@tempcntb _min_col_num}{1}
  \repeat
%    \end{macrocode}
%    
%    \begin{macrocode}
  \clist_gclear:N \g_xor_flush_max_classes_clist
%    \end{macrocode}
%    Need to reset |\g_xor_trial_flush_seen_num| in case the current macro
%    is called again too early, e.g., if it is called to initialize a
%    float page and then again to initialize a text page.
%    \begin{macrocode}
  \num_gzero:N \g_xor_trial_flush_seen_num
%<*trace>
  \@tracepop{initialise@flush@data}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsection{Support for Here Points}
%
% A ``Here Point'' is a place in the galley at which something is
% supposed to happen. For example, a marginal note needs to be
% attached to the column, or a float needs to be inserted into the
% column (here float), or it needs to be made sure that from that
% point on there is still a certain amount of space available in the
% column.
%
% With each here point there is associated a float structure (i.e. a
% box and its corresponding |\toks| register) although in most cases
% only parts of that structure is used. In addition each here point
% has an associated dimension which denotes the amount of available
% space which is required after the here point in the column to allow
% to place the here point into this column. If this requirement is not
% met the here point is moved to the next column (or page) by ending
% the current column prematurely at the last legal breakpoint before
% the here point (not at the here point itself\footnote{It should be
% considered to allow breaking directly at the here point in special
% cases, i.e., specified at the here point declaration.}). This
% behaviour will ensure that a line of text preceding the here point
% will also be moved to the next column or page which is important in
% case of marginals and similar situations. In case of here floats it
% might not be a requirements so perhaps this should be made
% customisable.
%
% At the moment the ``type'' in the float structure is used to define
% the type of here point. E.g.,
% \begin{description}
% \item[mpar] denotes a marginal
% \item[rspace] denotes a requested space
% \item[figure,table,\ldots] all normal float types identify the here
% point as belonging to a here float.
% \end{description}
% The down side of this approach is that ``mpar'' can't be used as a
% float type  any longer and the whole approach might be too difficult
% to extend this way. This needs certainly needs a cleanup.
%
% It  is quite likely that there will be additional values that need
% storing on a per here point basis. For this reason the code below
% provides the requiredspace as a data structure external to the float
% structure. Otherwise it could probably be integrated therein.
%
% When a here point is encountered while making columns for a trial or
% for the final page, its requirements are checked. If they are
% fulfilled then a here-point-type specific function will update the
% column material (e.g. by adding a here float or a marginal).
%
% Here points are in many aspects like flush points. So most of the
% code below should not be very surprising.
%
% \begin{macro}{\g_xor_collect_here_seen_num}
%    The number |\g_xor_collect_here_seen_num| records the number of here
%    points we have have seen during collection.
%    \begin{macrocode}
\num_new:N \g_xor_collect_here_seen_num
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_xor_trial_here_seen_num}
%    The number |\g_xor_trial_here_seen_num| records the number of here
%    points we have seen so far during a trial, i.e., it will be
%    initialised to zero at the beginning of the trial and advanced by
%    one for each here point encountered.
%    \begin{macrocode}
\def\g_xor_trial_here_seen_num{0}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_here_floats_seq}
%    |\@elt| list of floats that should appear at a here point.
%    \begin{macrocode}
\seq_new:N \g_xor_here_floats_seq
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xor_saved_here_floats_seq}
%    Saved version of the |\g_xor_here_floats_seq| while we run a through the
%    float placement trial since we need the full |\g_xor_here_floats_seq| again in
%    the next trial.
%    \begin{macrocode}
\seq_new:N \g_xor_saved_here_floats_seq
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xor_add_here_point:Nn}
%    |\xor_add_here_point:Nn| adds a here point to the MVL. It takes two
%    arguments: the box reference associated with the here point and
%    the vertical space that needs to be reserved for the material
%    added.
%    \begin{macrocode}
\def\xor_add_here_point:Nn #1#2{
%    \end{macrocode}
%    we get passed a tlp containing the float box so we need to expand
%    it once before putting it into the sequence.
%    \begin{macrocode}
  \seq_gput_right:No \g_xor_here_floats_seq #1
%    \end{macrocode}
%    
%    \begin{macrocode}
  \num_gincr:N\g_xor_collect_here_seen_num
%    \end{macrocode}
%    
%    \begin{macrocode}
  \num_gset:cn {g_xor_here_ \g_xor_collect_here_seen_num _min_col_num}{1}
%    \end{macrocode}
%    
%    \begin{macrocode}
  \setlength\dimen@{#2}
  \tlp_gset:cx
       {g_xor_here_ \g_xor_collect_here_seen_num _required_space_tlp}
       {\the\dimen@}
%    \end{macrocode}
%    
%    \begin{macrocode}
  \add@badly@guarded@penalty\output@here@float@penalty
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\initialise@here@data}
%    \begin{macrocode}
\def \initialise@here@data{
%<*trace>
  \@tracepush{initialise@here@data}
%</trace>
%    Does this need any documentation?
%
%    Well, we have to get rid of all information relating to here
%    float penalties that have been typeset on the previous page and
%    move the remaining ones (if any) to the front.
%    \begin{macrocode}
  \int_set:Nn \count@ \g_xor_collect_here_seen_num
  \int_add:Nn \count@ {-\g_xor_trial_here_seen_num }
%<*trace>
  \tr@ce{g_xor_collect_here_seen_num~
         =~ \g_xor_collect_here_seen_num\space <-~
            \the\count@  }
%</trace>
%    \end{macrocode}
%    Something wrong hereif we get negative values!
%    \begin{macrocode}
%<*debug>
  \ifnum\count@<\z@ \ERROR \fi
%</debug>
%    \end{macrocode}
%    
%    \begin{macrocode}
  \num_gset:Nn \g_xor_collect_here_seen_num \count@
%    \end{macrocode}
%    
%    \begin{macrocode}
  \@tempcnta\g_xor_trial_here_seen_num
  \@tempcntb\z@
  \loop
  \ifnum \@tempcntb < \count@

    \int_incr:N \@tempcnta
    \int_incr:N \@tempcntb
%<*trace>
    \tr@ce{g_xor_here_ \the\@tempcntb _required_space_tlp\space
           =~ \tlp_use:c {g_xor_here_ \the\@tempcntb _required_space_tlp}\space <-~
              \tlp_use:c {g_xor_here_ \the\@tempcnta _required_space_tlp}
          }
    \tr@ce{g_xor_here_ \the\@tempcntb _min_col_num \space <-~ 1}
%</trace>
    \tlp_gset_eq:cc
       {g_xor_here_ \the\@tempcntb _required_space_tlp}
       {g_xor_here_ \the\@tempcnta _required_space_tlp}

    \num_gset:cn {g_xor_here_ \the\@tempcntb _min_col_num}{1}
  \repeat
%<*trace>
  \@tracepop{initialise@here@data}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\split@off@last@line}
%
%    When a here point doesn't fit onto the current page or column for
%    some reason it will be moved into the next column. In some cases,
%    e.g., when the here point is associated with the line before it
%    (as, for example, in marginals) it is necessary to move the line
%    also to the later column.
%
%    The purpose of |\split@off@last@line| (to be called inside the
%    OR) is to split box 255 at the latest possible breakpoint before
%    the end and return the material following this breakpoint to the
%    MVL.
%
%    The idea is as follows: if we subtract 1sp from the height of
%    box 255 and also subtract all of its internal shrinkability and
%    then split it to this height it can't any longer reach the final
%    breakpoint (by 1sp). Thus it will settle with some earlier
%    breakpoint and chances are very very good that this will be the
%    prefinal one.
%    \begin{macrocode}
\def \split@off@last@line{
%<*trace>
  \@tracepush{split@off@last@line}
  \tr@ce{goal:~ \the\pagegoal;~ total:~ \the\pagetotal;~ shrink:~
         \the\pageshrink}
  \tr@ce{ht255:~ \the\ht255;~ dp255:~ \the\dp255}
%</trace>
%    \end{macrocode}
%    
%
%    \begin{macrocode}
 \dimen@\ht\@cclv
%    \end{macrocode}
%    Looking at |\ht255| should be the same as |\pagetotal-\pagedepth|
%    or not?\footnote{Doesn't seem to be the case, bug in the code,
%    the program, or in my thinking? (seems to be a bug in \TeX:
%    pagedepth is always zero in the OR!)}
%    \begin{macrocode}
 \advance\dimen@-\pageshrink
 \advance\dimen@-1sp
%{\showoutput\showbox\@cclv}
%    \end{macrocode}
%    Before splitting we have to ensure that the maximum depth is not
%    larger than the maximum depth allowed on the MVL.
%    \begin{macrocode}
 \splitmaxdepth\@maxdepth
 \setbox\z@\vsplit\@cclv to\dimen@
%{\showoutput\showbox\z@}
%{\showoutput\showbox\@cclv}
%    \end{macrocode}
%
%    Before we now |\unvbox| 255 back onto the MVL we have to make sure
%    that the sum of its vertical dimensions plus the requested space
%    for the current here point is smaller than a full column height.
%
%    If we don't do that we might end up with a situation where we are
%    pushing the two from column to columns since they will never fit.
%    \begin{macrocode}
 \dimen@\csname
           g_xor_here_ \g_xor_trial_here_seen_num _required_space_tlp
        \endcsname
        \relax
 \advance\dimen@\ht\@cclv
 \advance\dimen@\dp\@cclv
%    \end{macrocode}
%    If the sum is too large we reduce the required space for the here
%    point and complain (not really done yet the latter).
%    \begin{macrocode}
 \ifdim \dimen@ > \textheight
   \ERROR-HERE-TOO-LARGE
   \dimen@\textheight
   \advance\dimen@-\ht\@cclv
   \advance\dimen@-\dp\@cclv
   \tlp_gset:cx
           {g_xor_here_ \g_xor_trial_here_seen_num _required_space_tlp}
        {\the\dimen@}
 \fi
%    \end{macrocode}
%    So now we can |\unvbox| and then move the top from the split back
%    into 255 (essentially to have it taken out of that register by
%    the code following, but such is life).
%    \begin{macrocode}
 \unvbox\@cclv
 \global\setbox\@cclv\box\z@
%<*trace>
  \@tracepop{split@off@last@line}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{Support for Grid Points}
%
%
%
%
% \begin{macro}{\align@collected@galley@and@restart}
%    |\align@collected@galley@and@restart| is called inside
%    |\some@column@or| when we have encountered a grid point. It is
%    supposed to align the current line with the text grid and then
%    restarts the galley processing.
%
%    We do this by putting the material gathered so far into a box of
%    appropriate size, and then push this pack onto the recent
%    contributions for reconsideration.
%    \begin{macrocode}
\def \align@collected@galley@and@restart {
%<*trace>
  \@tracepush{align@collected@galley@and@restart}
  \tr@ce{GRID:~ page~ goal~\space\space\space =~ \the\pagegoal}
  \tr@ce{GRID:~ page~ total~\space\space =~ \the\pagetotal}
  \tr@ce{GRID:~ page~ depth~\space\space =~ \the\pagedepth}
  \tr@ce{GRID:~ page~ shrink~\space =~ \the\pageshrink}
  \tr@ce{GRID:~ page~ stretch~ =~ \the\pagestretch}
  \tr@ce{GRID:~ page~ fil~ stretch~ =~ \the\pagefilstretch}
  \tr@ce{GRID:~ page~ fill~ stretch~ =~ \the\pagefillstretch}
  \tr@ce{GRID:~ page~ filll~ stretch~ =~ \the\pagefillstretch}
  \tr@ce{GRID:~ ht~ 255~\space =~ \the\ht\@cclv}
  \tr@ce{GRID:~ dp~ 255~\space =~ \the\dp\@cclv}
%</trace>
%    \end{macrocode}
%    As a first step we remove the guard box since it has now served
%    its purpose.
%    \begin{macrocode}
  \remove@guard@box@from@cclv
%    \end{macrocode}
%    Then we calculate the distance to nearby grid points.
%    \begin{macrocode}
  \snap@to@grid{\ht\@cclv}\pagesetup@grid@point@sep
%    \end{macrocode}
%    So the next step is to make a decision which grid point to
%    use. The strategy used below can probably be refined
%    further\ldots
%
%    First we test if the next grid point down makes us fall off the
%    page\footnote{We should use \texttt{\string\pagegoal} for the
%    test I think, not the commented out construct below, since in
%    case of footnotes the available space for text might has be
%    reduced!}, if so\ldots
%    \begin{macrocode}
  \ifdim \returned@size > \pagegoal
          %  \csname g_xor_ht_col_ \int_use:N\g_xor_curr_col_int _dim\endcsname % not!
%    \end{macrocode}
%    \ldots we better try using the previous grid point.
%    \begin{macrocode}
    \ifdim \returned@lower@delta@size < \pageshrink
%    \end{macrocode}
%    If the |\pageshrink| allows us to reach the previous point then
%    use it.
%    \begin{macrocode}
% can use it: do so
%<*trace>
      \tr@ce{GRID:~ outside~ page,~ choosing~ lower~ grid~ point}
%</trace>
      \global\let \returned@size \returned@lower@size
      \xdef \returned@delta@size {-\returned@lower@delta@size }
    \else
%    \end{macrocode}
%    Otherwise, ouch \ldots{} what now? Can this happen? Unfortunately
%    yes, it seems to happen, for example, when we are trying to place
%    floats.\footnote{Analyse this situation and decide on a course of
%    action if necessary.}
%    \begin{macrocode}
      \OuchERROR
    \fi
%    \end{macrocode}
%    Otherwise we are in the normal case, i.e., somewhere in the
%    middle of the page.
%    \begin{macrocode}
  \else
%    \end{macrocode}
%    So now we can in principle choose either grid point. The code
%    below makes the decision based on which grid point is closer but
%    chooses the previous point only if |\pageshink| allows
%    it.\footnote{One could also have a look at the available
%    stretchability and base the decision on the resulting badness,
%    this might in fact be the more appropriate way!}
%    \begin{macrocode}
    \ifdim \returned@lower@delta@size < \returned@delta@size \relax
      \ifdim \returned@lower@delta@size < \pageshrink
%<*trace>
        \tr@ce{GRID:~ choosing~ lower~ grid~ point}
%</trace>
        \global\let \returned@size \returned@lower@size
        \xdef \returned@delta@size {-\returned@lower@delta@size }
      \fi
    \fi
  \fi
%<*trace>
  \tr@ce{GRID:~ adjustment:~ \the\ht\@cclv\space ->~ \returned@size}
%</trace>
%    \end{macrocode}
%    Whatever the decision was, we finally bundle up all material in a
%    box with the vertical size being that of the chosen grid point
%    (no |\maxdepth| setting in this case) and return this box to the
%    MVL followed by any footnotes found in that process. These
%    footnotes are reinserted so that they will be reconsidered but
%    since we have no break point between the box and them they will
%    be considered as a unit.
%    \begin{macrocode}
  \vbox to\returned@size{\unvbox\@cclv}
  \@reinserts
%    \end{macrocode}
%    We know that the material returned to the MVL is followered
%    immediately by a box of size zero followed by a penalty thus
%    there will be a breakpoint in the right place (or so we hope) so
%    that the box plus the following footnotes will still fit into the
%    column when reprocessed.
%    \begin{macrocode}
%<*trace>
  \@tracepop{align@collected@galley@and@restart}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\OuchERROR}
%    This part of the code (as far as I can see right now) will be
%    executed if there is some larger display object (ie off grid)
%    which will just fit onto the page unaligned but not if we align
%    to the next grid point. The reason for this is that somewhere on
%    the column there are also footnotes for example, which result in
%    the column not being an integral number of grid lines.
%    \begin{macrocode}
\def\OuchERROR{
%<*trace>
  \tr@ce{Failed:~grid~ overflowing~ column~ \int_use:N\g_xor_curr_col_int}
%</trace>
%<*progress>
  \progress@failed{next~ possible~ grid~ point~ in~ column~
                     \int_use:N\g_xor_curr_col_int\space outside~ page}
%</progress>
%    \end{macrocode}
%    I think essentially what is needed here is to split the column
%    just before the current line, ie, using something like
%    |\split@off@last@line| (except that this only works for here
%    points right now) and this move the grid align penalty to the
%    next column.\footnote{Not done! FIX}
%    \begin{macrocode}
%  \split@off@last@line
%  \(re)???add@guarded@penalty\output@grid@align@penalty
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\std@AlignToGrid}
%    This is the definition for |\AlignToGrid| if we are really doing
%    grid based layout.
%    \begin{macrocode}
\def\std@AlignToGrid{
  \add@badly@guarded@penalty\output@grid@align@penalty
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\IgnoreAlignToGrid}
% \begin{macro}{\ObeyAlignToGrid}
%    |\IgnoreAlignToGrid| will turn off automatic grid alignment for a
%    while, while |\ObeyAlignToGrid| will turn it on again. This is
%    needed in commands that want to set something outside the grid
%    and then realign afterwards, e.g., a heading. If that heading
%    would follow, say, a list that issued a |\AlignToGrid| to be
%    executed on the next paragraph, that |\AlignToGrid| would
%    effectively appear on the heading title thus forcing that to be
%    on a grid line, which is typically not intended. So the heading
%    macro first says |\IgnoreAlignToGrid| then typesets the material
%    which should be not aligned, then says |\ObeyAlignToGrid| and
%    prepares to install its own |\AlignToGrid| (typically after the
%    first line of text via |\everypar|).
%    \begin{macrocode}
\def\IgnoreAlignToGrid{
  \global\let\AlignToGrid\relax
}
\def\ObeyAlignToGrid{
   \global\let\AlignToGrid\std@AlignToGrid
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\AlignToGrid}
%    |\AlignToGrid| is the command that inserts a grid point which
%    triggers alignment to the text grid for the current line (if we
%    are doing grid based design). It should be set in the page setup
%    so the default is an error.
%    \begin{macrocode}
\let\AlignToGrid\ERROR
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\TextAlignToGrid}
%    In nearly all cases the alignment should be done for a text line,
%    so we provide this abbreviation which starts horizontal mode if
%    necessary.
%    \begin{macrocode}
\def\TextAlignToGrid{ \leavevmode \AlignToGrid }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \subsection{Initialisations}
%
%    The initialisation at begin document isn't properly done
%    yet. Some bits are done unnecessarily here (by calling
%    initialisation commands that do too much and some bits are
%    problably still in the wrong place. Furthermore the column data
%    initialisation needs to be resolved properly. Right now we
%    hardwire a maximum of 6 columns down there and initialise the
%    data structures for all the potential columns independently of
%    whether or not they are ever being used.\footnote{SORT OUT! FIX}
%    \begin{macrocode}
\AtBeginDocument{
  \begingroup
    \int_gset:Nn \g_xor_cols_int 6
    \xor_cols_setup:
%    \end{macrocode}
%    More column data stuff which needs to be set only the very first
%    time!
%    \begin{macrocode}
    \xor_forall_columns:n {
%    \end{macrocode}
%    
%    \begin{macrocode}
%FMi ##1?
       \seq_map_inline:Nn \g_xor_float_classes_seq
              {
               \num_gset:cn {g_xor_flseq_type_#1_col_
                             \int_use:N\g_xor_curr_col_int _num}{0}
               \num_gset:cn {g_xor_flseq_areas_top_type_#1_col_
                             \int_use:N\g_xor_curr_col_int _num}{0}
              }
    }
%    \end{macrocode}
%    
%    The default for the allowed float positions should be all areas known (not only those
%    currently used!)
%    \begin{macrocode}
    \seq_map_inline:Nn \g_xor_float_classes_seq
       { 
        \tlp_gset_eq:cN
            {g_xor_type_ #1 _allowed_areas_tlp}
            \g_xor_areas_known_clist
        \num_gset:cn {g_xor_flseq_type_#1_col_0_num}{0}
       }
  \endgroup
%    \end{macrocode}
%    
%    \begin{macrocode}
%  \initialise@next@page
%    \end{macrocode}
%    Start the document by collecting text.
%    \begin{macrocode}
  \@collecting@new@materialtrue
  \xor_collect_setup:
}
%    \end{macrocode}
%
%
% \endinput
\endinput
%
% $Log$
% Revision 1.4  2004/10/03 15:36:03  mittelba
% more cleanup ... tedious ...
%
% Revision 1.3  2004/10/01 21:46:40  mittelba
% many further updates, still a lot to do
%
% Revision 1.2  2004/09/27 20:06:20  mittelba
% in the middle of normalizing to expl3 syntax
%
% Revision 1.1  2001/07/26 19:55:12  latex3
% original web distrib
%
% Revision 1.53  2000/08/11 07:14:25  latex3
% added header
%
% Revision 1.52  2000/08/11 06:49:21  latex3
% untabify
%
% Revision 1.51  2000/08/11 06:46:48  latex3
% change logic for handling special penalties once more (and still not
% okay)
%
% Revision 1.50  2000/08/06 19:03:44  latex3
% change initialisation at \begin{document}
% fix \columnbreak
%
% Revision 1.49  2000/08/04 13:58:16  latex3
% documented issue when grid point overflows column
%
% Revision 1.48  2000/08/04 10:22:31  latex3
% added \split@skip (probably not final version)
%
% Revision 1.47  2000/07/26 20:37:03  latex3
% working version of grid points (text grids)
%
% Revision 1.46  2000/07/21 13:52:13  latex3
% more renaming for float sequence class concept
%
% Revision 1.45  2000/07/19 17:12:08  latex3
% introduced float sequence class concept
% added variables for float area separation
%
% Revision 1.44  2000/07/10 19:24:59  latex3
% some start at supporting "balance points" (unfinished).
% added \xor_cols_setup:.
% getting rid of extra empty page at end due to old defnition of
% \clearpage.
%
% Revision 1.43  2000/07/04 19:45:40  latex3
% fix GRID stuff (restore all values as needed)
%
% Revision 1.42  2000/07/01 16:07:26  latex3
% use \xor_update_this_area_span_cols:n
% integrate code to support grid design (first draft)
%
% Revision 1.41  2000/06/29 17:40:44  latex3
% introduced \xor_this_area_setup:o
%
% Revision 1.40  2000/06/26 15:16:15  latex3
% prototype support for \pagesetup@float@area@sep
%
% Revision 1.39  2000/06/22 20:07:51  latex3
% renamed some macros to get them more uniform
%
% Revision 1.38  2000/06/22 10:59:57  latex3
% Included support for writing fpl files
%
% Revision 1.37  2000/06/21 09:55:41  latex3
% fix typo
%
% Revision 1.36  2000/06/19 19:03:56  latex3
% make \num_gincr:N and \num_gdecr:N behave (not update \count@)
% cleanup flushing (if fail only move flush point one column)
%
% Revision 1.35  2000/06/18 14:59:50  latex3
% docu updates (and a bug fix due to typo)
%
% Revision 1.34  2000/06/16 11:21:14  latex3
% rename \construct@and@test@col@height to \construct@and@test@col@ht
% rename \construct@and@test@col@heights to \construct@and@test@col@hts
% rename \cl@height1 to \@col@ht@1 (etc)
%
% Revision 1.33  2000/06/16 11:05:25  latex3
% implemented tfl@ support (top area float sequences)
% support float-callout-span-constraint
% more documentation
%
% Revision 1.32  2000/06/15 15:20:16  latex3
% implemented new semantics for area names
%
% Revision 1.31  2000/06/15 09:32:18  latex3
% added mising \end{macro}'s
%
% Revision 1.30  2000/06/13 20:44:25  latex3
% guard the output@collect@penalty
% implemented fuzzy flushing (except for spreads)
%
% Revision 1.29  2000/06/06 11:03:21  latex3
% before attempting fuzzyflush
%
% Revision 1.28  2000/05/03 20:17:31  latex3
% need more info about here floats
%
% Revision 1.27  2000/05/03 18:45:40  latex3
% fix bugs: always have a trial run wihtout floats to initialise here
% and flush points; reset \g_xor_trial_flush_seen_num after using it to update
% the data structures on a new pages; have adding to the defer area
% close other areas :-)
% more documentation
%
% Revision 1.26  2000/04/27 19:50:11  latex3
% some stats gathered now
% combine \grab@column@or and \best@column@or as far as possible
% some bug fixes and additional documentation
%
% Revision 1.25  2000/04/21 19:08:43  latex3
% code cleanup
% additional documentation
% fixes for here points
% support for footnote setup
%
% Revision 1.24  2000/04/11 21:06:06  latex3
% basically Chris's 1.24 plus my changes
%
% Revision 1.24  2000/04/10  16:41:14  car2
% typos, comments and guardbox removal
%
% Revision 1.23  2000/04/09 20:02:00  latex3
% fix topskip problem in collection
% added first draft of marginpar support
%
% Revision 1.22  2000/04/08 09:47:06  latex3
% first draft of here point implementation
% code cleanup
% further documentation
%
% Revision 1.21  2000/03/31 17:12:41  latex3
% disable preplacing deferred floats (until caption handling is fixed)
% fix float page handling
% ensure that float pages don't add additional captions (don't mind that
% the float page comes out even worse)
%
% Revision 1.20  2000/03/26 21:05:11  latex3
% work on float pages
% some renaming in particular \try@this@area
%   and \xor_try_next_area:
% some more documentation
%
% Revision 1.19  2000/03/24 15:34:27  latex3
% version that starts supporting spans (still a hack yet)
%
% Revision 1.18  2000/03/22 15:51:11  latex3
% some normalisations of names
% moved code around
% lot of updates
%
% Revision 1.17  2000/03/17 20:26:40  latex3
% more fixes to flushing (looks good now)
%
% Revision 1.16  2000/03/16 10:28:29  latex3
% partial and full flush working for the first time
%
% Revision 1.15  2000/03/05 19:36:53  latex3
% some renaming
% support multiple columns (6 max right now)
% fix flush float logic (hopefully)
%
% Revision 1.14  2000/02/28 23:41:14  david
% deadcycles
%
% Revision 1.13  2000/02/27 15:39:53  david
% *** empty log message ***
%
% Revision 1.12  2000/02/27 15:12:00  david
% 2nd attempt at flush floats (working as far as implemented)
%
% Revision 1.11  2000/02/27 11:26:35  david
% first attempt at flush floats
%
% Revision 1.10  2000/02/26 18:20:09  david
% added pre-allocation of deferred floats to float areas
%
% Revision 1.9  2000/02/21 23:25:11  david
% t11|t22 support in optional argument
%
% Revision 1.8  2000/02/19 23:14:58  david
% chris' doc fix
%
% Revision 1.7  2000/02/16  13:40:40  latex3
% added 3col support
%
% Revision 1.6  2000/02/16  10:07:13  latex3
% added further documentation
% fixed bug by removing code from \try@this@area to 
%   \pretests@success@action
% handle case of hitting special output penalty during trial or
%    page production
% handle case of \newpage ie penalty -10000
%
% Revision 1.5  2000/02/15 01:08:25  david
% dead code
%
% Revision 1.4  2000/02/13  22:40:13  latex3
% moved some stuff around and added macro environments
%
