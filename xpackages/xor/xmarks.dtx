% \iffalse
%%
%% (C) Copyright 1999, 2004 Frank Mittelbach
%% All rights reserved.
%%
%% Not for general distribution. In its present form it is not allowed
%% to put this package onto CD or an archive without consulting the
%% the authors.
%% 
%    \begin{macrocode}
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{
%<*dtx>
  \ProvidesFile{#2.dtx}
%</dtx>
%<package>\ProvidesPackage{#2}
%<driver>\ProvidesFile{#2.drv}
  [#4 #3 #8 (#6)]}
\next$Id$
       {multiple marks}
%    \end{macrocode}
%
%<*driver>
 \documentclass{ltxdoc}
%
 \begin{document}
 \DocInput{xmarks.dtx}
 \end{document}
%</driver>
%
% \fi
%
%
% \GetFileInfo{xmarks.dtx}
%
% \title{The \textsf{xmarks} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi}
% \date{\filedate}
%
%  \maketitle
%
% \tableofcontents
%
%
%
% \section{Mark algorithm}
%
% To allow for completely independent marks we use the following
% procedure:
% \begin{itemize}
% \item
%   For every mark of type \meta{type} we have a queue that holds every mark
% info found in memory. Every info is associated with a unique number,
% i.e., we simply count them. The queue always holds at least one item
% which is the previous mark info, i.e., the last mark for that type on
% the previous page.
%
% \item
%   We use \TeX's internal mark mechanism only to record the associated
% numbers for marks for every type on the current page.
%
% \item
%  For every \meta{type} we record the info-number that belongs to the last
% mark of the previous page.
%
% \item
%  By looking at \TeX's internal |\botmark| we can determine the
% info-number of the last mark for every \meta{type} that is on the current
% page.
%
% \item
%   The difference between this number and the info-number from the last
% page gives us the number of marks for every \meta{type} on the current page.
%
% \item
%   That way we are able to decide how to extract items from the queue so
% that first, last, and previous mark for every type can be accessed.
%  \begin{itemize}
%  \item
%    If the difference is zero, no new marks have been added on the
% current page, therefore the only item on the corresponding mark type
% queue holds the info that should be previous, first, and last mark of
% this type for the current page.
%  \item
%    If the difference is one, then the first item in the queue represents
% the info that should become the previous mark (it will be popped off)
% and the second item (which will be kept, since it will become the
% previous mark for the next page) should become first and last mark for
% the current page.
%  \item
%    Otherwise we had at least two marks for this type on the current page.
% Therefore, the first item in the queue will become previous mark (popped
% off), the second will become first mark (popped off), then we pop off
% all but the last item in the queue, which will become last mark, by only
% looking at it.
%  \end{itemize}
%  In other words every queue should hold only one item after this part of
% the algorithm has acted.
% After this is done we save the info-numbers given by |\botmark|
% as the info-numbers of the last page, so that they are available next time.
%
% \item
%   Putting a mark into the galley therefore means to put its info to the
% right of the corresponding queue, increment the current info-number for
% \meta{type} by one and putting a \TeX{} mark into the galley holding the
% current info-numbers for all \meta{types}.
%
%  \end{itemize}
%
%
% \subsection{Restrictions}
%
% One restriction in using this algorithm without further refinements
% is that for every \meta{type} there will be an upper limit of marks allowed
% within one document. This upper limit is given by |\maxdimen| which is
% probably high enough to ignore it, but it could be improved by resetting
% the info numbers whenever all marks have found their way onto the
% current page.
%
% Another restriction is that one better not changes from linearily
% processing the data for the main galley, or, if one modifies that
% processing one needs to carefully adjust the data structures for the
% marks as well. The problem being that the individual marks within a
% preprocessed galley will stay there forever (and thus can be parsed
% several times), the external data structures, e.g., the plists and
% the sequences however need manual corrections in that case.
%
% \subsection{Implementation}
%
% The original implementation was done on a portable PC in a train
% sometime in 1992/93 and is just a straight implementation of the
% above algorithm using plists to hold the current and the last
% info-numbers. The whole stuff could be done much better by analysing
% the algorithm combining common parts (a lot of thing have be done
% twice, etc.) and recoding the rest in a better way.
%
% The implementation below is more or less a straight adaption
% of that code, so it still needs a rewrite one day. It is based on
% modules implementing ``queues'', ``property lists'', and ``quarks''
% most of which have been published as experimental code with a
% slightly different surface syntax, i.e., as \texttt{l3seq.sty},
% \texttt{l3prop.sty}, and \texttt{l3quark.sty}.
%
% New stuff:
%    \begin{macrocode}
\RequirePackage{ldcsetup}
\IgnoreWhiteSpace
%    \end{macrocode}
%
%
%
%
%
%
%
%
%
% \subsection{Commands for manipulating marks}
%
%
%
%  \begin{macro}{\trace_mark}
%  \begin{macro}{\trace_mark_internal}
%  \begin{macro}{\tracingmarks}
%    Tracing is done when |\tracingmarks| is positive.
%    \begin{macrocode}
%<*trace>
\def_new:Npn \trace_mark#1{\ifnum \tracingmarks > \z@
      \typeout{Marks:~ #1~ \on@line}\fi}
\def_new:Npn \trace_mark_internal#1{\ifnum\tracingmarks>\@ne
      \typeout{Marks:~ #1}\fi}
\newcount\tracingmarks
%</trace>
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\xmark_new:N}
%  \begin{macro}{\xmark_new:c}
%    Defines a new mark label and retrieval token list pointer.
%    \begin{macrocode}
\def_new:Npn \xmark_new:c {\exp_args:Nc\xmark_new:N}
\def_new:Npn \xmark_new:N#1{
%<*trace>
   \trace_mark
       {new~mark:~\string#1}
%</trace>
%    \end{macrocode}
%    We make sure that the argument is still free and allocate the
%    corresponding queue. To avoid problems with the use of such tlp's
%    when they are used before the first |\xmark_update_structure| we initialize
%    them in a way that |\xmark_previous| and the like will accept them even
%    then.
%    \begin{macrocode}
   \newcommand* #1 {{}{}{}}
   \seq_new:c{ g_xmark_\string#1_seq}
%    \end{macrocode}
%    The last info-number for this type will be set to |1| This value
%    is actually arbitrary and we could use |-\maxdimen+1| to get the
%    range doubled.
%    \begin{macrocode}
   \prop_gput:NNn \g_xmark_last_plist #1 {1}
%    \end{macrocode}
%    More important is that the starting value for the current
%    info-number is one less then the one used above.
%    \begin{macrocode}
   \prop_gput:NNn\g_xmark_curr_plist#1{0}
%    \end{macrocode}
%    We now put the very first mark of this type in. This mark will be
%    empty. This will initialize the queue (now holding the empty previous
%    mark) increment the current info number, so that last and current are
%    now equal and also puts a \TeX{} mark into the galley will the
%    additional type present.
%    \begin{macrocode}
   \xmark_put:Nn#1{}%
%    \end{macrocode}
%    \begin{macrocode}
   \tlp_gput_right:No \xmark_save_state: {
      \expandafter\global\expandafter\let
                 \csname g_xmark_saved_\string#1_seq\expandafter\endcsname
                 \csname g_xmark_\string#1_seq\endcsname}
   \tlp_gput_right:Nn \g_xmark_restore_state_internal_tlp {
      \expandafter\global\expandafter\let
                 \csname g_xmark_\string#1_seq\expandafter\endcsname
                 \csname g_xmark_saved_\string#1_seq\endcsname}
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
%
%  \begin{macro}{\xmark_save_state:}
%  \begin{macro}{\g_xmark_restore_state_internal_tlp}
%    Save and restore the current state of the mark data
%    structure. The commands will be extended by |\xmark_new:N|. They are
%    needed if part of the main galley is being reused or several
%    times parsed.
%    \begin{macrocode}
\tlp_new:Nn \xmark_save_state:{%
      \glet:NN \g_xmark_saved_curr_plist\g_xmark_curr_plist
      \glet:NN \saved_mark_last_plist\g_xmark_last_plist}
\tlp_new:Nn \g_xmark_restore_state_internal_tlp{%
      \glet:NN \g_xmark_curr_plist\g_xmark_saved_curr_plist
      \glet:NN \g_xmark_last_plist\saved_mark_last_plist}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\xmark_OR_restore_state:n}
%    |\xmark_OR_restore_state:n| will restore the state of the mark
%    mechanism to the one saved by |\xmark_save_state:|. It has to be
%    called inside an output routine and as it needs an output routine
%    of its own to restore the |\xmark| status of the bottom mark (so
%    that \TeX{} correctly updates the mark registers in case it
%    doesn't find a mark in box 255) it has an argument which is
%    executed inside that output routine to regain control.
%
%    The code in the argument has to set |\output| to a new output
%    routine! If not you are in trouble.
%
%    \begin{macrocode}
\def_new:Npn \xmark_OR_restore_state:n#1{%
%<*trace>
  \@tracepush{mark_OR_restore_state:n}
%</trace>
%    \end{macrocode}
%    We first restore the external data structures by calling
%    |\g_xmark_restore_state_internal_tlp|. Then we have to ensure that \TeX's
%    idea of what the current |\botmark| is, corresponds to what it
%    was when we saved the state. Back then it was the contents of
%    |\g_xmark_last_plist| so we are now adding an empty box and then
%    mark with is contents
%    onto the MVL followed by a penalty that ensures we trigger the
%    output routine and then specify a tiny little output routine
%    whose sole purpose is to get that mark processed.
%    \begin{macrocode}
      \g_xmark_restore_state_internal_tlp
      \hbox{}%
%    \end{macrocode}
%    We have to protect |\g_xmark_last_plist| from expanding too far
%    inside the |\xmark| so we first put it into a token register
%    before applying |\mark|.
%    \begin{macrocode}
      \@temptokena\expandafter{\g_xmark_last_plist}%
%<*trace>
      \trace_mark_internal{restoring~ botmark~ \the\@temptokena}%
%</trace>
      \mark
         {\the\@temptokena}
      \penalty-20203\relax
%    \end{macrocode}
%    We are not setting |\vsize| assuming its positive. So the moment
%    we return from the current output routine (we are hopefully in
%    right now) we should very very soon find the above penalty and
%    then trigger the output routine we are about to define now.
%
%    In that output routine we have a quick test for the
%    |\outputpenalty| just to ensure that we really grabbed what we
%    are supposed to grab. Then we throw away the contents of box 255
%    since all we wanted todo is to get |\botmark| set back to the
%    value of our mark above. Finally we execute whatever got passed
%    along as argument one to regain control. Since current |\output|
%    has a rather funny definition the code in that argument better
%    change that back to something that does a little bit more
%    typesetting.
%    \begin{macrocode}
      \global\output{%
%<*trace>
  \@tracepush{mark_restore_state_or}
%</trace>
         \ifnum-20203=\outputpenalty\else \ERROR \fi
         \box_gset_eq:NN \@cclv \voidb@x
         #1%
%<*trace>
  \@tracepop{mark_restore_state_or}
%</trace>
        }%
%<*trace>
  \@tracepop{mark_OR_restore_state:n}
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\xmark_put:Nn}
%  \begin{macro}{\xmark_put:Nc}
%    To put a mark into the current horizontal or vertical \TeX{} list
%    we first update |\g_xmark_curr_plist| and then put its value into the
%    mark without any further expansion. (The code could be
%    optimized!)
%    \begin{macrocode}
\def_new:Npn \xmark_put:cn {\exp_args:Nc \xmark_put:Nn }
%<-trace>\def_new:Npn \xmark_put:Nn#1{%    % wtest hack }
%<*trace>
\def_new:Npn \xmark_put:Nn#1#2{
   \tlp_set:Nn \l_tmpa_tlp {#2}
   \trace_mark
       {set~\string#1~<-~\tlp_to_str:N\l_tmpa_tlp}
%</trace>
%    \end{macrocode}
%    First we have to update the current info number for this type. The
%    code is a bit complicated because we have to get the number from the
%    the plist update it and then put it back. If we  would keep the numbers
%    differently this could be improved, probably at the cost of more macro
%    names.
%    \begin{macrocode}
   \@temptokena\expandafter{\g_xmark_curr_plist}
   \prop_get:NNN\g_xmark_curr_plist#1\@tempa
%<*debug>
   \ifx\q_no_value\@tempa
      \ERROR
   \fi
%</debug>
   \int_set:Nn \l_tmpa_int \@tempa
   \int_incr:N \l_tmpa_int
   \prop_gput:NNo \g_xmark_curr_plist
                  #1
                  {\int_use:N \l_tmpa_int}
%    \end{macrocode}
%    Now we want to put this plist into a \TeX{} mark. We need a
%    one-level expansion, otherwise our pkeys would expand which would
%    produce chaos. So we save it in a toks register.
%    \begin{macrocode}
   \@temptokena\expandafter{\g_xmark_curr_plist}
   \mark
       {\the\@temptokena}
%    \end{macrocode}
%   Finally we shouldn't forget to put the info at the right of the
%   corresponding queue.
%   Without tracing we can omit the second argument to
%   this function.
%    \begin{macrocode}
%<*trace>
   \seq_gput_right:cn{g_xmark_\string#1_seq}{#2}
%</trace>
%<-trace>   \seq_gput_right:cn{ g_xmark_\string#1_seq}%
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\xmark_put:Nnn}
%    \begin{macrocode}
\def_new:Npn \xmark_put:Nnn#1#2#3{
   \xmark_put:Nn#1{#2#3}}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\xmark_update_structure}
%    This function is for use in output routines to initialize the marks
%    at the beginning. It is only useful after \TeX{} internally has
%    updated |\botmark|.
%    \begin{macrocode}
\def_new:Npn \xmark_update_structure{
%    \end{macrocode}
%    We map a function over all keys in |\g_xmark_last_plist|, in other
%    words over all types of marks. This routine will set the marks for
%    all types. Finally we set the plist |\g_xmark_last_plist| to the
%    plist that was stored in |\botmark|, i.e., to the
%    info-numbers from this page.
%    \begin{macrocode}
  \prop_map:NN\g_xmark_last_plist\xmark_retrieve_single:Nn
  \expandafter\gdef\expandafter\g_xmark_last_plist\expandafter{\botmark}
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\xmark_retrieve_single:Nn}
%    This function will be mapped over the plist containing the info-numbers
%    from the last page. This means that |#1| will be the key (which is
%    simply our type token list pointer and |#2| is the value, i.e. the
%    info-number from the last page for this type.
%    \begin{macrocode}
\def_new:Npn \xmark_retrieve_single:Nn#1#2{
%<*trace>
   \trace_mark_internal
       {queue~for~\string#1~ before:~`\tlp_to_str:c{ g_xmark_\string#1_seq}'}
%</trace>
%    \end{macrocode}
%    We retrieve the info number for this type from |\botmark|
%    and store the difference in |\l_tmpa_int|.
%    \begin{macrocode}
   \@temptokena\expandafter{\botmark}%
%<*trace>
   \trace_mark_internal{picking~ up~ from~ output~ \the\@temptokena}%
%</trace>
   \prop_get:NNN\botmark#1\@tempa
%<*debug>
   \ifx\q_no_value\@tempa
      \ERROR
   \fi
%</debug>
   \int_set:Nn \l_tmpa_int \@tempa
   \int_sub:Nn \l_tmpa_int {#2}
%<*trace>
   \trace_mark_internal
       {found~\int_use:N \l_tmpa_int\space entries~ for~ \string#1~
        (new~\@tempa;~old~#2)}
%</trace>
%    \end{macrocode}
%    Then we decide what to do depending on its value.
%    We use |\@tempa|, |\@tempb|, and |\@tempc| to
%    temporarily hold the previous, first and last mark for this type.
%    \begin{macrocode}
   \ifcase\l_tmpa_int
%    \end{macrocode}
%    If there haven't been any new marks we leave the queue alone,
%    peeking only at its top element and using it for all three marks.
%    \begin{macrocode}
     \seq_top:cN{ g_xmark_\string#1_seq}\@tempa
     \let\@tempb\@tempa
     \let\@tempc\@tempa
   \or
%    \end{macrocode}
%    When there was one mark of this type, we pop one item for the
%    previous mark of this type, and use the remaining item for first
%    and last mark.
%    \begin{macrocode}
     \seq_gpop:cN{ g_xmark_\string#1_seq}\@tempa
     \seq_top:cN{ g_xmark_\string#1_seq}\@tempb
     \let\@tempc\@tempb
   \else
%    \end{macrocode}
%    If we had more than one mark for this type we pop one mark for the
%    previous mark of this type, then pop another mark for the first
%    mark of this type, then pop all but the last item and use the last
%    item as the last mark of this type, keeping it as before on the
%    queue.
%    \begin{macrocode}
     \seq_gpop:cN{ g_xmark_\string#1_seq}\@tempa
     \seq_top:cN{ g_xmark_\string#1_seq}\@tempb
     \@whilenum \l_tmpa_int>\@ne\do
        {\int_decr:N \l_tmpa_int
         \seq_gpop:cN{ g_xmark_\string#1_seq}
            \@tempc
        }
     \seq_top:cN{ g_xmark_\string#1_seq}\@tempc
   \fi
%    \end{macrocode}
%    After this process all values for previous, first and last mark for
%    this type are found so that we can store them in the tlp
%    representing this type for further processing.
%    \begin{macrocode}
   \@temptokena\expandafter{\@tempa}
   \@temptokenb\expandafter{\@tempb}
   \@temptokenc\expandafter{\@tempc}
   \edef#1{{\the\@temptokena}{\the\@temptokenb}{\the\@temptokenc}}
%<*trace>
   \trace_mark
       {in~output:~\string#1~->~\tlp_to_str:N#1}
%    \end{macrocode}
%    At this point the queue should show only one item.
%    \begin{macrocode}
   \trace_mark_internal
       {queue~ for~\string#1~after:~`\tlp_to_str:c{ g_xmark_\string#1_seq}'}
%</trace>
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\@temptokenb}
%  \begin{macro}{\@temptokenc}
%    \begin{macrocode}
\newtoks\@temptokenb
\newtoks\@temptokenc
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\g_xmark_curr_plist}
%  \begin{macro}{\g_xmark_last_plist}
%    Here are the allocations for the two plists used.
%    \begin{macrocode}
\prop_new:N \g_xmark_curr_plist
\prop_new:N \g_xmark_last_plist
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
%
%
%
%
%  \begin{macro}{\xmark_get_first:N}
%  \begin{macro}{\xmark_get_last:N}
%  \begin{macro}{\xmark_get_previous:N}
%    To retrieve the first, last or previous page mark, we
%    grap the appropriate value stored in the tlp. The marks are stored
%    in the tlp in the order previous, first, last mark. These functions
%    should be used only in output routines after |\xmark_retrieve| has
%    acted, otherwise their value will be wrong. They are all fully
%    expandable.
%
%    Actually, they may bomb when tracing is included and we have
%    material that doesn't work corretly within a write.
%    \begin{macrocode}
%<*trace>
\def_new:Npn \xmark_get_first:N#1{
       \expandafter\use_choice_ii:nnn #1
       \trace_mark_internal{use~first~\string#1~=~
            `\expandafter\use_choice_ii:nnn #1'}
}
\def_new:Npn \xmark_get_last:N#1{
   \expandafter\use_choice_iii:nnn #1
   \trace_mark_internal{use~ last~ \string#1~ =~
       `\expandafter\use_choice_iii:nnn #1'}
}
\def_new:Npn \xmark_get_previous:N#1{
   \expandafter\use_choice_i:nnn #1
   \trace_mark_internal{use~prev~\string#1~ =~
       `\expandafter\use_choice_i:nnn #1'}
}
%</trace>
%<-trace>\def_new:Npn \xmark_get_first:N{%
%<-trace>       \expandafter\use_choice_ii:nnn }
%<-trace>\def_new:Npn \xmark_get_last:N{%
%<-trace>       \expandafter\use_choice_iii:nnn }
%<-trace>\def_new:Npn \xmark_get_previous:N{%
%<-trace>       \expandafter\use_choice_i:nnn }
%    \end{macrocode}
%    above version in trace case doesn't work always!
%    \begin{macrocode}
\def:Npn \xmark_get_first:N{%
       \expandafter\use_choice_ii:nnn }
\def:Npn \xmark_get_last:N{%
       \expandafter\use_choice_iii:nnn }
\def:Npn \xmark_get_previous:N{%
       \expandafter\use_choice_i:nnn }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
% \begin{macro}{\DeclareMarkType}
%    \begin{macrocode}
\def_new:Npn \DeclareMarkType#1{
  \xmark_new:c {mark_#1}}
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\PutMark}
%    \begin{macrocode}
\def_new:Npn \PutMark#1{
   \@ifundefined{mark_#1}{\ERROR}{}
   \xmark_put:cn {mark_#1}}
%    \end{macrocode}
%  \end{macro}
%
%
% \begin{macro}{\PreviousMark}
%    \begin{macrocode}
\def_new:Npn \PreviousMark#1{
  \expandafter\xmark_get_previous:N\csname mark_#1\endcsname}
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\FirstMark}
%    \begin{macrocode}
\def_new:Npn \FirstMark#1{
  \expandafter\xmark_get_first:N\csname mark_#1\endcsname}
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\LastMark}
%    \begin{macrocode}
\def_new:Npn \LastMark#1{
  \expandafter\xmark_get_last:N\csname mark_#1\endcsname}
%    \end{macrocode}
%  \end{macro}
%
% \Finale
%
\endinput
%
% $Log$
% Revision 1.5  2004/10/30 18:41:37  mittelba
% further cleanup
%
% Revision 1.4  2004/10/03 22:43:59  mittelba
% more updates ... still not getting closer ...
%
% Revision 1.3  2004/10/03 15:35:36  mittelba
% more cleanup ... tedious ...
%
% Revision 1.2  2004/10/01 21:46:19  mittelba
% many further updates, still a lot to do
%
% Revision 1.1  2001/07/26 19:55:12  latex3
% original web distrib
%
% Revision 1.6  2000/06/13 20:47:23  latex3
% docu update
% inlined quarks code
%

