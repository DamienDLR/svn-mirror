% \iffalse
%%
%% (C) Copyright 1999, 2009 Frank Mittelbach, LaTeX3 Project
%%
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xlists bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
%% 
%<*dtx>
          \ProvidesFile{xlists.dtx}
%</dtx>
%<package>\RequirePackage{expl3}
%<package>\ProvidesExplPackage{xlists}{2007/09/20}{v0.16}{generic lists}
%<driver>\ProvidesFile{xlists.drv}
% \fi
%         \ProvidesFile{xlists.dtx}
%          [2007/09/20 v0.16 generic lists]
%
% \iffalse
%<*driver>
 \documentclass{ltxdoc}
 \usepackage{textcomp}
 \usepackage{ldcdoc}
 \EnableCrossrefs \CodelineIndex

\DeclareDocumentEnvironment{inlineenumerate}
   { }
   { \UseInstance{list}{inlineenumerate} \NoValue \NoValue \BooleanFalse }
   { \EndThisList }

\DeclareInstance{list}{inlineenumerate}{inline}{
  pre-hmaterial-setup  = \UseTemplate{hmaterial}{std}
                             {penalty=0,space=\DelayEvaluation 1em},
 item-hmaterial-setup  = \UseTemplate{hmaterial}{std}
                             {penalty=-300,space=\DelayEvaluation .5em},
 item-post-hmaterial-setup  = \UseTemplate{hmaterial}{std}
                             {penalty=10000,space=5pt},
 post-hmaterial-setup  = \UseTemplate{hmaterial}{std}
                             {penalty=0,space=\DelayEvaluation 1em},
  item-label-text    = \alph{enumi}.\@,
  item-label-format  = \textbf{#1},
  counter-id    = enumi,
}
 \begin{document}
 \DocInput{xlists.dtx}
 \end{document}
%</driver>
% \fi
%
%
% \GetFileInfo{xlists.dtx}
%
% \title{The \textsf{xlists} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi}
% \date{\filedate}
%
%  \maketitle
%
% \tableofcontents
% 
% \section{Interfaces}
%
% \begin{TemplateInterfaceDescription}{list}
%
%   \TemplateArgument{1}
%       {String to calculate the value for left margin indentation
%       (using the normal item-label formatting information) or
%       \NoValue{} in which case 
%        the default from the list instance is used --- in case of
%        inline lists this value is always ignored.}
%
%   \TemplateArgument{2}
%       {Symbol/string to be used as item label or \NoValue{} in
%        which the default from the list is used.}
%
%   \TemplateArgument{3}
%       {If \BooleanFalse, a list using a counting mechanism will start
%        counting with 1. If \BooleanTrue it continues with the
%        current value of the respective counter --- with non-counting
%        lists the argument is always ignored.}
%
%   \TemplateSemantics
%
% Outer shell for a list-like environment. It is supposed to set up
% |\ListItem| as the starting point for ``item''s within the list, and
% is supposed to be finished of with |\EndThisList| (so it better
% adjusts that one as well).
%
% \end{TemplateInterfaceDescription}
%
%
% \begin{TemplateInterfaceDescription}{labelposition}
%
%   \TemplateArgument{0}{---}
%
%   \TemplateSemantics
%
%    Sets up certain parameters that define the position of the item
%    label. Can make use of the following internal parameter to do
%    this: |\leftmargin|. However, this is only possible if
%    |\DelayEvaluation| is used on such a key (since |\leftmargin|
%    receives its value at runtime!)
%
% \end{TemplateInterfaceDescription}
%
%
% \section{Examples}
%
% Setting up a standard enumerate environment using the `list'
% template type, i.e., no optional arguments which means all three
% arguments of the template receive a |\NoValue| or |\BooleanFalse| value. 
% The list is
% ended via |\EndThisList|.
%\begin{verbatim}
%\DeclareDocumentEnvironment{enumerate}
%   {  }
%   { \UseInstance{list}{enumerate} \NoValue \NoValue \BooleanFalse }
%   { \EndThisList }
%\end{verbatim}
% 
% Items within the list template type are started using |\ListItem| an
% interface to this with one optional argument is the following:
%\begin{verbatim}
%\DeclareDocumentCommand \item
%   { o }
%   { \ListItem {#1} }
%\end{verbatim}
% 
% Next environment continues a previous `enumerate' by specifying
% |\BooleanTrue| as the third argument:
%\begin{verbatim}
%\DeclareDocumentEnvironment{enumerate*}
%   {  }
%   { \UseInstance{list}{enumerate} \NoValue \NoValue \BooleanTrue }
%   { \EndThisList }
%\end{verbatim}
% 
% A slightly non-standard itemize environment where the optional arg
% specifies an alternate label:
%\begin{verbatim}
%\DeclareDocumentEnvironment{itemize}
%   { o }
%   { \UseInstance{list}{itemize} \NoValue {#1} \BooleanFalse }
%   { \EndThisList }
%\end{verbatim}
% 
% And finally a non-standard description environment where the
% optional argument specifies the size of left
% indentation.\footnote{One probably does want to specify a string to
% be measured instead but not now\ldots}
%\begin{verbatim}
%\DeclareDocumentEnvironment{description}
%   { o }
%   { \UseInstance{list}{description} {#1} \NoValue \BooleanFalse }
%   { \EndThisList }
%\end{verbatim}
% 
%
% \StopEventually{}
% 
% \section{Implementation}
%
% Set up certain defaults including to ignore white space
% within the body of this package.
%    \begin{macrocode}
%<*package>
\RequirePackage{galley2,xmaterial}
%    \end{macrocode}
%
% \begin{macro}{\trace}
%    A comand for tracing under e\TeX{}
%    (useful stuff those extra debug flags).
%    \begin{macrocode}
\cs_new:Npn\trace{\tracingassigns=1\tracingall}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{ListItem implementation}
%
%
% \begin{macro}{\ListItem}
%    The |\ListItem| command is the class file interface for starting
%    the next item within an instance of type `list', e.g., calling it
%    within |\item| on the document level. Since it should only work
%    within such a list its definition on top level is to produce an
%    error message.
%    \begin{macrocode}
\cs_new:Npn\ListItem #1{
  \@latex@error{Lonely~ \string\item--perhaps~ a~ missing~
        list~ environment}\@ehc}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\list@item}
%    The |\list@item| is the real code for |\ListItem| when within a
%    list environment. It uses the following hooks which have to be
%    set up by any list template: |\item@init@hook| (initialisation at
%    start), |\item@measure@and@format@hook| (measuring and outputing
%    or preparing for output of label), and
%    |\item@inner@pre@code@hook| (code to run at start of any inner
%    item, i.e., between two items).
%
%    Perhaps should get a * argument
%    as well, that kills off label formatting (?).
%    \begin{macrocode}
\cs_new:Npn\list@item #1 
{
  \GAL_typeout:n{Item~ seen \on@line}
%
%    \end{macrocode}
%
%    First we look at the mandatory argument. If it is not |\NoValue|
%    we overwrite the |\item@label| declaration from the list
%    template. At the same time we record whether or not we've seen a
%    user overwrite.
%    \begin{macrocode}
  \IfNoValueTF{#1}   \@noitemargtrue
                    { \@noitemargfalse \cs_set:Npn\item@label{#1} }
%
%    \end{macrocode}
%
%    We then set up initial stuff if specified by the list environment
%    \begin{macrocode}
  \item@init@hook
%    \end{macrocode}
%
%    The rest of the code depends on the state we are in: if we are at
%    the top of the list, i.e., seeing the first item we have two
%    cases to consider. A) an outer item label is not yet set in which
%    case we either have to output it first or do some item
%    accumulation and B) there is no such dangling item and we have to
%    set the first item of the current list which is not supposed to
%    get any extra space on top.
%    \begin{macrocode}
  \bool_if:NTF \g_new_list_bool
    {
%    \end{macrocode}
%    Now the list isn't any longer `new' since we have seen a first
%    item. So look at the |\g_in_labellist_bool| flag and if true run code the
%    potentially outputs the dangling item.
%    \begin{macrocode}
    \bool_gset_false:N \g_new_list_bool
    \bool_if:NT \g_in_labellist_bool
      {
       \GAL_typeout:n{in_labellist~ case \on@line}
       \do@accumulate@item
      }
%    \end{macrocode}
%    Whatever happened above we now have to deal with the first item
%    in the current list, i.e., with the one that isn't supposed to
%    add inter-item space etc.
%    \begin{macrocode}
    \item@base@code
%    \end{macrocode}
%    If not at the beginning of the list we output an ``inner'' item.
%    \begin{macrocode}
  }{
    \item@inner@code
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\item@base@code}
%    The |\item@base@code| code is not only used for the first item of
%    a list but is part of all item code.
%    \begin{macrocode}
\cs_new:Npn\item@base@code {
  \GAL_typeout:n{item@base@code~used \on@line}
%    \end{macrocode}
%     Depending on the fact that the |\ListItem| argument was user
%    specified or not we might have to step the list-counter is there
%    is any.
%    \begin{macrocode}
  \if@noitemarg
    \@noitemargfalse
    \if@nmbrlist
      \refstepcounter\@listctr
    \fi
  \fi
%    \end{macrocode}
%    Then we prepare to format and measure the item label.
%    \begin{macrocode}
  \item@measure@and@format@hook
%    \end{macrocode}
%    And that's about it, except for ignoring any spaces and |\par|s
%    that may follow.
%    \begin{macrocode}
  \GAL_ignore_pars:n
     {Something's~ wrong--perhaps~ a~ missing~
      end of list?}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\item@inner@code}
%    This code is run by any item other than the first one.
%    \begin{macrocode}
\cs_new:Npn\item@inner@code {
  \GAL_typeout:n{item@inner@code~used \on@line}
%    \end{macrocode}
%    First we run |\item@inner@pre@code@hook| to handle spacing etc
%    and then invoke |\item@base@code| to do the rest.
%    \begin{macrocode}
  \item@inner@pre@code@hook
  \item@base@code
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{EndThisList implementation}
%
%
% \begin{macro}{\EndThisList}
%    The |\EndThisList| command is the common ending for all instances
%    of type list. It has two hooks which need to be set up by any
%    list template: |\endthislist@finish@item@hook| and
%    |\endthislist@finish@list@hook|.
%    \begin{macrocode}
\cs_new:Npn\EndThisList {
%    \end{macrocode}
%    If we are still in a new list then we have an error condition:
%    \begin{macrocode}
  \bool_if:NT \g_new_list_bool
             { \@noitemerr \ListItem\NoValue }
%    \end{macrocode}
%
%    Next we run code that finishes the previous item if necessary.
%    \begin{macrocode}
  \endthislist@finish@item@hook 
%    \end{macrocode}
%
%    Then restore the galley state.
%    \begin{macrocode}
  \GAL_restore_galley_state:
%    \end{macrocode}
%
%    Finally we run code that finishes the list, e.g., puts out spaces
%    and penalties or whatever.
%    \begin{macrocode}
  \endthislist@finish@list@hook 
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Low-level code}
%
% \begin{macro}{\item@accumulate@right}
%    The |\item@accumulate@right| macro either does nothing (default)
%    in which case items are accumulated on the same line if an item
%    of some list immediately starts with a sub-list, or it starts and
%    ends a paragraph in which case the unset outer item is placed on
%    the page.
%    \begin{macrocode}
\let\item@accumulate@right\@empty
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\item@output@dangling}
%    The |\item@output@dangling| macro makes sure a dangling label is
%    set. At this point one could add additional code that sets up the
%    galley structure so that the distance to the next item (which
%    immediately follows) is flexible via parameters. For now we just
%    ensure that we don't separate the two items.
%    \begin{macrocode}
\cs_new:Npn\item@output@dangling {
       \noindent \par 
       \GAL_set_break:n 1  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_in_label_bool}
%    The |\g_in_label_bool| switch is set to true for the time an item label
%    has be set up but is still waiting to be placed. It is tested at
%    various places to ensure that this item label is not lost by
%    mistake.
%    Since the switch is always being set globally we code this within
%    the mutator commands.
%    \begin{macrocode}
\bool_new:N \g_in_label_bool
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_in_labellist_bool}
%    If a list starts directly after an item of a super-list the flag
%    |\g_in_labellist_bool| is set to true.\footnote{This replaces the
%    \texttt{@noparlist} and \texttt{@noparitem} flags in 2e lists.}
%    \begin{macrocode}
\bool_new:N \g_in_labellist_bool
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_new_list_bool}
%    The |\g_new_list_bool| switch is set to true for the time a new list is
%    started until the first item is seen. It is used to check for
%    error conditions, e.g., a paragraph start without an |\ListItem|
%    first, or the end of the list without ever setting anything. It
%    is also used to distinguish the first item of a list from the
%    others.
%    Since the switch is always being set globally we code this within
%    the mutator commands.
%    \begin{macrocode}
\bool_new:N \g_new_list_bool
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\ListDepth}
%    The counter |\ListDepth| holds the current
%    list depth, it gets updated in |\list@init| before the list
%    parameters are assigned.
%    \begin{macrocode}
\let\ListDepth\@listdepth  % we reuse some old LaTeX counter right now
\int_zero:N\ListDepth
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{List template implementation}
%
%    The template `labelposition' is used within the declaration for
%    the list template so we have to declare its type up front (or get
%    a nasty internal error message! --- something that could perhaps
%    be improved.)
%
%    \begin{macrocode}
\DeclareObjectType{labelposition}{0}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareObjectType{list}{3}
%    \end{macrocode}
%    \begin{macrocode}
\DeclareTemplateInterface{list}{vertical}{3}{
%    \end{macrocode}
%    The right hand sides of the keys currently use commands and
%    registers already available in \LaTeX{} as far as possible. This
%    makes the code looks in parts a bit inconsistent and should
%    (perhaps) change!
%    \begin{macrocode}
  left-margin-width      : length   ,
  right-margin-width     : length   ,
  pre-penalty            : integer  ,
  pre-sep                : skip     ,
  item-penalty           : integer  ,
  item-sep               : skip     ,
  post-penalty           : integer  ,
  post-sep               : skip     ,
%    \end{macrocode}
%    next three instance setups fully specify internal para stuff.
%    alternatively one could of a single hj-setup (if we stay with
%    that template type) or ...?
%    \begin{macrocode}
  justification-setup    : instance {justification} ,
  linebreak-setup        : instance {linebreak}     ,
  hyphenation-setup      : instance {hyphenation}   ,
%    \end{macrocode}
%    \begin{macrocode}
  par-sep                : skip            ,
  item-label-text        : tokenlist       ,
  item-label-format      : function 1 = #1 ,
  label-position-setup   : instance {labelposition} = right ,
%    \end{macrocode}
%    The key for dealing with wide labels is inconsistent compared to
%    the previous one: both should probably have the same type one
%    day.
%    \begin{macrocode}
  widelabel-action       : function 0 = \runinwidelabel ,
%    \end{macrocode}
%    We support the notion that a list starts with an implicit item
%    (perhaps this is a rubbish idea (it doesn't save space
%    either)). In the current implementation setting this switch to
%    true means that the first item \emph{is} truly implicit not that
%    it is optional, i.e., if the list nevertheless starts with a
%    |\ListItem| on document level it will result in two list
%    labels. One could implement this differently so that one as an
%    ``optional first item'' switch.
%    \begin{macrocode}
  item-implicit-boolean         : choice {true, false} ,
%    \end{macrocode}
%    Two switches control whether the current list allows to
%    accumulate item labels on its left and/or right. The default is
%    to allow accumulation.
%    \begin{macrocode}
  item-accumulate-right-boolean  : choice {true, false} ,
  item-accumulate-left-boolean   : choice {true, false} ,
%    \end{macrocode}
%    If the list should have ``numbered'' labels we specify a counter
%    name at this point.
%    \begin{macrocode}
  counter-id                     : tokenlist ,
 }


\skip_new:N \botsep
\cs_new:Npn \list@justification {}
\tl_new:N   \item@label
\cs_new:Npn \item@label@format #1 {}
\cs_new:Npn \item@label@pos {}
\cs_new:Npn \item@wide@label {}
\tl_new:N   \@listctr

\DeclareTemplateCode{list}{vertical}{3}{
%    \end{macrocode}
%    The right hand sides of the keys currently use commands and
%    registers already available in \LaTeX{} as far as possible. This
%    makes the code looks in parts a bit inconsistent and should
%    (perhaps) change!
%    \begin{macrocode}
  left-margin-width      =  \leftmargin,
  right-margin-width     =  \rightmargin,
  pre-penalty            =  \@beginparpenalty,
  pre-sep                =  \topsep,
  item-penalty           =  \@itempenalty,
  item-sep               =  \itemsep,
  post-penalty           =  \@endparpenalty,
  post-sep               =  \botsep,
%    \end{macrocode}
%    next three instance setups fully specify internal para stuff.
%    alternatively one could of a single hj-setup (if we stay with
%    that template type) or ...?
%    \begin{macrocode}
  justification-setup =  \list@justification,
  linebreak-setup     =  \list@linebreak,
  hyphenation-setup   =  \list@hyphenation,
%    \end{macrocode}
%    \begin{macrocode}
  par-sep                =  \parsep,
  item-label-text        =  \item@label,
  item-label-format      =  \item@label@format,
  label-position-setup   =  \item@label@pos,
%    \end{macrocode}
%    The key for dealing with wide labels is inconsistent compared to
%    the previous one: both should probably have the same type one
%    day.
%    \begin{macrocode}
  widelabel-action       = \item@wide@label,
%    \end{macrocode}
%    We support the notion that a list starts with an implicit item
%    (perhaps this is a rubbish idea (it doesn't save space
%    either)). In the current implementation setting this switch to
%    true means that the first item \emph{is} truly implicit not that
%    it is optional, i.e., if the list nevertheless starts with a
%    |\ListItem| on document level it will result in two list
%    labels. One could implement this differently so that one as an
%    ``optional first item'' switch.
%    \begin{macrocode}
  item-implicit-boolean   = {
    true  =  {\cs_set:Npn\item@implicit@code{\item\relax}} ,
    false =
  },
%    \end{macrocode}
%    Two switches control whether the current list allows to
%    accumulate item labels on its left and/or right. The default is
%    to allow accumulation.
%    \begin{macrocode}
  item-accumulate-right-boolean = {
    true  =          ,
    false = {\cs_set:Npn\item@accumulate@right{\item@output@dangling}}
  } ,
  item-accumulate-left-boolean  = {
    true  =          ,
    false = {\cs_set:Npn\do@accumulate@item{\item@output@dangling}}
  } ,
%    \end{macrocode}
%    If the list should have ``numbered'' labels we specify a counter
%    name at this point.
%    \begin{macrocode}
  counter-id      = \@listctr,
 }
 {
%    \end{macrocode}
%    The list init code was/is intended to hold the common setup stuff
%    for different list template implementations (this is right now a
%    little muddled so once we have additional templates we might want
%    to revise this and either merge this and part of the following
%    code or run everything inline or \ldots).
%    \begin{macrocode}
  \list@init
     \item@init@vertical
     \item@measure@and@format@vertical
     \item@inner@pre@code@vertical
     \endthislist@finish@item@vertical
     \endthislist@finish@list@vertical
%    \end{macrocode}
%
%    In case we are still in hmode from a previous para we issue a
%    |\par|. This may have to come earlier, i.e., before saving the
%    galley state, but i think not.
%    \begin{macrocode}
  \par
%    \end{macrocode}
%
%    At this point we are ready to do the key parameter assignments.
%    \begin{macrocode}
  \DoParameterAssignments
%    \end{macrocode}
%
%    Next task is to look at the mandatory arguments of the
%    template. If the first arg is not |\NoValue| it is supposed to be
%    an overwrite for the |\leftmargin| value which is set by the
%    \key{left-margin-width} key:
%    \begin{macrocode}
  \IfNoValueF{#1} { \settowidth\leftmargin{\item@label@format{#1}} }
%    \end{macrocode}
%
%    Second argument is an overwrite for the \key{item-label-text} key
%    if it is not |\NoValue|.
%    \begin{macrocode}
  \IfNoValueF{#2} { \cs_set:Npn\item@label{#2} }
%    \end{macrocode}
%
%    If there was no \key{counter-id} key we set the |@nmbrlist| flag
%    to false. Otherwise we have to look at argument three and if this
%    is |\BooleanFalse| we reset the counter to zero .
%    \begin{macrocode}
  \ifx\@listctr\@empty 
     \@nmbrlistfalse
  \else 
     \@nmbrlisttrue
     \IfBooleanF{#3} { \setcounter\@listctr\z@ }
  \fi
%    \end{macrocode}
%
%    Setting up the measure is happening next\ldots
%    \begin{macrocode}
  \GAL_add_SGPV_measure:nn \leftmargin { -\leftmargin -\rightmargin }
%    \end{macrocode}
%    \ldots followed by setting up a h\&j (if so specified).
%    \begin{macrocode}
  \GAL_set_SGPV_dimension:nn v \parsep
  \list@justification
  \list@linebreak
  \list@hyphenation
%    \end{macrocode}
%
%    If we have an item label from an outer list still to be set we
%    have to adjust its position within the |\@labels| box since we
%    are going to output that box further to the right (by
%    |\leftmargin|) than was assumed when this label was put in.
%    \begin{macrocode}
  \bool_if:NTF \g_in_label_bool
   {
    \global\setbox\@labels\hbox{\hskip -\leftmargin
                                \unhbox\@labels
                                \hskip \leftmargin}%
%    \end{macrocode}
%    If not we are at the beginning of an ordinary list and we prepare
%    for putting some vertical space and some penalty on top of
%    it.\footnote{Current implementation makes no difference between a
%    list on its own and a list within a paragraph.}
%    \begin{macrocode}
   }{
    \GAL_max_DGPV_dimension:nn v \topsep
    \GAL_set_penalty:n       \@beginparpenalty
   }
%    \end{macrocode}
%    Finally output code for an implicit first item if requested and
%    ignore spaces and |\par|s for a while. And that means let
%    |\ListItem| take over.
%    \begin{macrocode}
  \item@implicit@code
  \GAL_ignore_pars:n
     {Something's~ wrong--perhaps~ a~ missing~
      \protect\item}
 }
%    \end{macrocode}
%
%
% \begin{macro}{\list@init}
%    This |\list@init| is the core for setting up any list structure
%    whether vertical or horizontal. It takes the following five
%    arguments all of which should be macro code:
%    \begin{enumerate}
%    \item initial code to be run at start of each item
%    \item code to measure and format a current item
%    \item code to run at start of every inner item (ie other than the
%      first)
%    \item code to finish off last item of the list
%    \item code to finish off list itself
%    \end{enumerate}
%    \begin{macrocode}
\cs_new:Npn\list@init #1#2#3#4#5{
%    \end{macrocode}
%    First we initialise |\ListItem| (this is really only necessary on
%    the first level but test for it would take more time than doing
%    the assignment). In addition we initialize the hooks into
%    |\ListItem| and |\EndThisList| from the supplied arguments. Here
%    |\cs_set:Npn| is used to \begin{inlineenumerate} \item allow to pass
%    arguments which are from the keyword parameters (ie not yet set
%    up) and \item to allow for inline definitions rather than passing
%    external macro names as arguments. \end{inlineenumerate}
%    \begin{macrocode}
  \let\ListItem\list@item
  \cs_set:Npn\item@init@hook{#1}
  \cs_set:Npn\item@measure@and@format@hook{#2}
  \cs_set:Npn\item@inner@pre@code@hook{#3}
  \cs_set:Npn\endthislist@finish@item@hook{#4}
  \cs_set:Npn\endthislist@finish@list@hook{#5}
%    \end{macrocode}
%
%    Then we test to see if we got nested lists without an item
%    inbetween. If so try a crude error recovery by issuing |\ListItem|
%    (though that is called at a different grouping level)
%    \begin{macrocode}
  \bool_if:NT \g_new_list_bool
    { \@noitemerr \ListItem\NoValue }
%    \end{macrocode}
%
%    If there is a dangling item from an outer list we have to set the
%    |\g_in_labellist_bool|. Instead of testing |\g_in_label_bool| we use its status
%    directly:
%    \begin{macrocode}
  \bool_set_eq:NN \g_in_labellist_bool \g_in_label_bool
%    \end{macrocode}
%
%    Then save the current galley state to be able to
%    restore it after the list.\footnote{Checking for hmode at this
%    point would allow to destinguish between a list that lives on its
%    own and a list that is part of a paragraph---not done.}
%    \begin{macrocode}
  \GAL_save_galley_state:
%    \end{macrocode}
%    We also record the list level we are in (though not used) and set
%    a collection name for list so that inner lists can have their own
%    declarations.\footnote{The more i think about that the more i
%    think this is rubbish. probably better is to have the instance
%    name within the document-environment declaration already  use
%    different names depending on the level (and the font size?) ---
%    think!}
%    \begin{macrocode}
  \int_incr:N \ListDepth 
%<*trace>
  \typeout{On~list~level:~\the\ListDepth}
%</trace>
%  \UseCollection{list}{L\the\ListDepth}
%    \end{macrocode}
%
%    We now set the |\g_new_list_bool| flag (to be reset within the next item)
%    and add code to the galley so that a paragraph start without an
%    item first will signal an error. However recovery in that case is
%    trickier, we can just add |\ListItem| as it would come in the
%    middle of executing the galley interface.\footnote{Needs some
%    thought.}
%    \begin{macrocode}
  \bool_gset_true:N \g_new_list_bool
  \GAL_appendto_DGPV_thing:nn q { \bool_if:NT \g_new_list_bool
                                    { \@noitemerr 
                                      \bool_gset_false:N \g_new_list_bool }
                                }
%    \end{macrocode}
%
%    Some defaults: a) implicit items are not allowed by default and
%    b) list do not have numbers unless explicitly asked for.
%    \begin{macrocode}
  \let \item@implicit@code \@empty
  \let \@listctr       \@empty
%    \end{macrocode}
%
%    Some further defaults: Item label accumulation is decided in
%    parts by the outer list
%    type, eg a description list might decide to forbid accumulation
%    at its right, so we have to pick up the value before running
%    |\DoParameterAssignments|. So if the outer list decides that
%    accumulation is allowed the current list might still turn it off
%    and when the outer list has already turned it off it will stay
%    turned off.
%    \begin{macrocode}
  \let \do@accumulate@item \item@accumulate@right
%    \end{macrocode}
%    Thus the default for |\item@accumulate@right| has to be:
%    \begin{macrocode}
  \let \item@accumulate@right \@empty
%    \end{macrocode}
%    Actually, the last assignment is only necessary for vertically
%    oriented lists but it doesn't do harm to set it up always.
%
%    The default for setting up a h\&j is to use whatever is 
%    currently in effect.
%    \begin{macrocode}
  \let \list@justification \@empty
  \let \list@linebreak     \@empty
  \let \list@hyphenation   \@empty
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Vertical list item code}
%
% \begin{macro}{\item@init@vertical}
%    We then set up the position values for the item label within its
%    box by running the corresponding instance code. This is done here
%    as it is needed within the various branches below.
%    \begin{macrocode}
\cs_new:Npn \item@init@vertical  {\item@label@pos}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\item@measure@and@format@vertical}
%    \begin{macrocode}
\cs_new:Npn \item@measure@and@format@vertical {
  \sbox\@tempboxa{\item@l@action
                  \item@label@format\item@label
                  \item@r@action}
%    \end{macrocode}
%    The item label now stored in |\@boxtempa| is combined with any
%    dangling label already in |\@labels|. Depending on the width of
%    the box and the desired |\labelwidth| we either invoke
%    |\item@wide@label| or set the item into a box of width
%    |\labelwidth| followed by the separation to the text (which is
%    thus part of the box).
%    \begin{macrocode}
  \global\setbox\@labels\hbox{
    \unhbox\@labels
    \hskip \itemindent
    \hskip -\labelwidth
    \hskip -\labelsep
    \ifdim \wd\@tempboxa >\labelwidth
      \item@wide@label  % has to use \@tempboxa
    \else
      \hbox to\labelwidth {\unhbox\@tempboxa}
    \fi
    \hskip \labelsep}
%    \end{macrocode}
%    So now the item label is waiting to be set inside \@labels. To
%    get this onto the page we put this box into the approrpiate
%    galley datastructure and also set |\g_in_label_bool| to true to signal
%    that a label is waiting.
%    \begin{macrocode}
  \bool_gset_true:N\g_in_label_bool
  \GAL_set_object:n {\box\@labels \penalty \z@  % parametrize penalty?
                     \bool_gset_false:N\g_in_label_bool}
%    \end{macrocode}
%    We also cancel any indentation for the next paragraph by setting 
%    a switch.
%    \begin{macrocode}
  \GAL_set_DGPV_thing:nn i \@ne
}
%    \end{macrocode}
% \end{macro}
%
%


% \begin{macro}{\item@inner@pre@code@vertical}
%    \begin{macrocode}
\cs_new:Npn \item@inner@pre@code@vertical {
%    \end{macrocode}
%    Since we are now somewhere down in the list we first have to make
%    sure that the previous item was already placed onto the page
%    since if there was an item without any text we don't want to end
%    up with having it combined with the next one. So if necessary
%    let's start a paragraph (it is completely irrelevant how we do
%    this. Using |\noindent| might be a bit faster than |\leavevmode|.
%    \begin{macrocode}
  \bool_if:NT \g_in_label_bool
              { \noindent }
%    \end{macrocode}
%    The other check we have to make is finishing a previous paragraph
%    if there is any (and there might be one, for example from the
%    code above or from the |\ListItem| being placed directly below a
%    paragraph text as is often the case. (The |\unskip| is \LaTeXe{}
%    code and at this time of the day I'm not sure it is necessary at
%    this point. If not one could just always issue a |\par| though
%    this code below is a little faster as |\par| has a quite complex
%    definition these days.)
%    \begin{macrocode}
  \ifhmode
    \unskip\unskip \par
  \fi
%    \end{macrocode}
%    Having dealt with the prelims we now update the galley structure
%    to get the inter-item penalty and skip added.
%    \begin{macrocode}
  \GAL_max_DGPV_dimension:nn v \itemsep
  \GAL_set_penalty:n       \@itempenalty
}
%    \end{macrocode}
% \end{macro}
%
%


% \begin{macro}{\endthislist@finish@item@vertical}

%    \begin{macrocode}
\cs_new:Npn \endthislist@finish@item@vertical {
%    \end{macrocode}
%    If we are still within |\g_in_label_bool| then the last |\ListItem| did
%    not contain any horizontal material. Thus we start a paragraph to
%    get the label onto the page.
%    In any case we then finish any still unset paragraph.
%    \begin{macrocode}
  \bool_if:NT \g_in_label_bool  { \noindent }
  \ifhmode \par \fi
}
%    \end{macrocode}
% \end{macro}
%
%

% \begin{macro}{\endthislist@finish@list@vertical}

%    \begin{macrocode}
\cs_new:Npn  \endthislist@finish@list@vertical {
%    \end{macrocode}
%
%    Don't add extra vertical spacing after an |\g_in_labellist_bool|.
%    However, this should probably be parametrised instead of being
%    fixed.
%    \begin{macrocode}
  \bool_if:NF \g_in_labellist_bool
   {
    \GAL_max_DGPV_dimension:nn v \botsep
    \GAL_set_penalty:n       \@endparpenalty
   }
}
%    \end{macrocode}
% \end{macro}
%
%
% \section{An alternative template setup (different keys)}
% 
% This is a setup which might appeal to some people, eg with much more
% OO in it :-). But then it might obscure the things --- provide both
% styles?
%
%
% \subsection{A second vertical list template implementation}
%
% We need some text here or else we get a strange toc (see bug reports
% in NOTES)
%
% There  are no comments in the code but changes to the other
% implementation are marked using |% <---|.
%
%    \begin{macrocode}
\DeclareTemplateInterface{list}{vertical2}{3}{
  measure-setup        : instance {measure}        ,
  pre-vmaterial-setup  : instance {vmaterial}      ,
 item-vmaterial-setup  : instance {vmaterial}      ,
 post-vmaterial-setup  : instance {vmaterial}      ,
  justification-setup  : instance {justification}  ,
  linebreak-setup      : instance {linebreak}      ,
  hyphenation-setup    : instance {hyphenation}    ,
  par-sep              : skip                      ,
  item-label-text      : tokenlist = \textbullet]  ,
  item-label-format    : function 1 =  #1          ,
  label-position-setup : instance {labelposition} = right ,
%    \end{macrocode}
%    The key for dealing with wide labels is inconsistent compared to
%    the previous one: both should probably have the same type one day.
%    \begin{macrocode}
  widelabel-action     : function 0 = \runinwidelabel ,
  item-implicit-boolean          : choice {true, false} ,
  item-accumulate-right-boolean  : choice {true, false} ,
  item-accumulate-left-boolean   : choice {true, false} ,
  counter-id           : tokenlist ,
 }

\DeclareTemplateCode{list}{vertical2}{3}{
  measure-setup        = \list@measure,
  pre-vmaterial-setup  = \list@top@vmaterial,
 item-vmaterial-setup  = \list@item@vmaterial,
 post-vmaterial-setup  = \list@bot@vmaterial,
  justification-setup  = \list@justification,
  linebreak-setup      = \list@linebreak,
  hyphenation-setup    = \list@hyphenation,
  par-sep              = \parsep,
  item-label-text      = \item@label,
  item-label-format    = \item@label@format,
  label-position-setup = \item@label@pos,
%    \end{macrocode}
%    The key for dealing with wide labels is inconsistent compared to
%    the previous one: both should probably have the same type one day.
%    \begin{macrocode}
  widelabel-action        = \item@wide@label,
  item-implicit-boolean   = {
    true  =  {\cs_set:Npn\item@implicit@code{\item\relax}} ,
    false =
  },
  item-accumulate-right-boolean = {
    true  =          ,
    false = {\cs_set:Npn\item@accumulate@right{\item@output@dangling}}
  } ,
  item-accumulate-left-boolean  = {
    true  =          ,
    false = {\cs_set:Npn\do@accumulate@item{\item@output@dangling}}
  } ,
  counter-id      = \@listctr,
 }
 {
  \list@init
     \item@init@vertical
     \item@measure@and@format@vertical
     \item@inner@pre@code@vertical@II
     \endthislist@finish@item@vertical
     \endthislist@finish@list@vertical@II
  \DoParameterAssignments
  \IfNoValueF{#2} { \cs_set:Npn\item@label{#2} }
  \ifx\@listctr\@empty
     \@nmbrlistfalse
  \else
     \@nmbrlisttrue
     \IfBooleanF{#3} { \setcounter\@listctr\z@ }
  \fi
  \list@measure {#1}                           % <-----
  \setSGPVdimension:nn v \parsep
  \list@justification
  \list@linebreak
  \list@hyphenation
  \bool_if:NTF \g_in_label_bool
   {
    \global\setbox\@labels\hbox{\hskip -\leftmargin
                                \unhbox\@labels
                                \hskip \leftmargin}%
   }{
    \list@top@vmaterial                        % <-----
   }
  \item@implicit@code
  \GAL_ignore_pars:n
     {Something's~ wrong--perhaps~ a~ missing~
      \protect\item}
 }
\cs_new:Npn  \endthislist@finish@list@vertical@II {   % <-----
  \bool_if:NF \g_in_labellist_bool
   {
    \list@bot@vmaterial                        % <-----
   }
}
\cs_new:Npn\item@inner@pre@code@vertical@II {         % <-----
  \bool_if:NTF \g_in_label_bool
               {  \noindent    }
  \ifhmode
    \unskip\unskip \par
  \fi
  \list@item@vmaterial                         % <-----
}
%    \end{macrocode}
%
% \subsection{Wide item implementation}
%
% Using commands for the next bits and pieces is inconsistent. should
% be handled similarily to the template `labelposition' but i haven't
% made up my mind on how exactly yet and i needed something to run
%
% \begin{macro}{\flushrightwidelabel}
%    \begin{macrocode}
\cs_new:Npn\flushrightwidelabel{\hbox to \labelwidth{\hss\box\@tempboxa}}
\cs_new:Npn\runinwidelabel{\box\@tempboxa}
\cs_new:Npn\newlinewidelabel{\parbox[b]{\labelwidth}{{\rlap{\box\@tempboxa}\mbox{}}}}
\cs_new:Npn\topdownwidelabel{\raisebox{0pt}[1ex][0pt]{\makebox[\labelwidth][l]
              {\parbox[t]{\labelwidth}{\hspace{0pt}\unhbox\@tempboxa}}}}
\cs_new:Npn\bottomupwidelabel{\parbox[b]{\labelwidth}{\hspace{0pt}\unhbox\@tempboxa}}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Labelposition template implementation}
%
% Again have some text here or else the toc will get the heading
% several times.
%    \begin{macrocode}
\DeclareTemplateInterface{labelposition}{std}{0}
{
  label-sep      : skip       = 5pt  ,
  label-width    : length     = \DelayEvaluation \leftmargin - \labelsep ,
  label-indent   : length     = 0pt  ,
  label-l-action : function 0 = \hss ,
  label-r-action : function 0 =      ,
}

\tl_new:N \item@l@action
\tl_new:N \item@r@action

\DeclareTemplateCode{labelposition}{std}{0}
{
  label-sep     = \labelsep       ,
  label-width   = \labelwidth     ,
  label-indent  = \itemindent     ,
  label-l-action= \item@l@action  ,
  label-r-action= \item@r@action  ,
}
{
  \DoParameterAssignments
}
%    \end{macrocode}
%
%
% \section{Inline lists}
%
%
%    \begin{macrocode}
\DeclareTemplateInterface{list}{inline}{3}{
  pre-hmaterial-setup      : instance {hmaterial} ,
 item-hmaterial-setup      : instance {hmaterial} ,
 item-post-hmaterial-setup : instance {hmaterial} , 
 post-hmaterial-setup      : instance {hmaterial} ,
  item-label-text          : tokenlist            ,  
  item-label-format        : function 1 = #1      ,
  item-implicit-boolean    : choice {true, false} ,
  counter-id               : tokenlist           ,
 }

\DeclareTemplateCode{list}{inline}{3}{
  pre-hmaterial-setup      = \list@pre@hmaterial,
 item-hmaterial-setup      = \list@item@pre@hmaterial,
 item-post-hmaterial-setup = \list@item@post@hmaterial,
 post-hmaterial-setup      = \list@post@hmaterial,
  item-label-text          = \item@label,
  item-label-format        = \item@label@format,
  item-implicit-boolean    = {
    true  =  {\cs_set:Npn\item@implicit@code{\item\relax}} ,
    false =
  },
  counter-id              = \@listctr,
 }
 {
  \list@init
      \@empty
      \item@measure@and@format@inline
      \list@item@pre@hmaterial
      \@empty
      \list@post@hmaterial
  \DoParameterAssignments
  \IfNoValueF{#2} { \cs_set:Npn\item@label{#2} }
  \ifx\@listctr\@empty
     \@nmbrlistfalse
  \else
     \@nmbrlisttrue
     \IfBooleanF{#3} { \setcounter\@listctr\z@ }
  \fi
  \list@pre@hmaterial                          % <-----
  \item@implicit@code
  \GAL_ignore_pars:n
     {Something's~ wrong--perhaps~ a~ missing~
      \protect\item}
 }


\cs_new:Npn\item@measure@and@format@inline {
  \item@label@format\item@label 
  \list@item@post@hmaterial
}


%    \end{macrocode}
%
%
%    \begin{macrocode}

\endinput
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \Finale
%
% \endinput

% vertical spacing case that \item has to handle:
%
% 1) first item of list
% 1.1) no outer label pending
% 1.1.1) text before is normal
% 1.1.2) text before was a heading
%
% 1.2) outer label not yet set
% 1.2.1) both labels go on same line
% 1.2.2) inner label should go on next line
%
% 2) middle item of list
%
% the following is (should be?) output in the various cases (only leaves):
%
% 1.1.1) 
%        \addpenalty\@beginparpenalty
%        \addvspace{\@topsep - \parskip}
%
% 1.1.2) 
%        \addpenalty10000    ????? missing
%        \addvspace{\@outerparskip  - \parskip}
%
% 1.2.1) 
%        \vspace{\@outerparskip  - \parskip}
%   note: this is actually done as 
%     \@tempskipa\lastskip
%     \vskip -\lastskip
%     \advance\@tempskipa\@outerparskip
%     \advance\@tempskipa -\parskip
%     \vskip\@tempskipa
%   so that any following \addvspace sees the full vertical space (i
%   guess) only that i don't understand how such an \addvspace could
%   be generated in that case. cany clues anybody?
%
% 1.2.2) 
%  note: this case is not supported by std list envs
%        \addpenalty10000    ????? missing
%        \addvspace{\@outerparskip  - \parskip}


