% \iffalse
%% File xfm.dtx 
%% (C) Copyright 2001, 2004 Frank Mittelbach, LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3a of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xfrontm bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %% 
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{%
  \def\fileversion{#3}%
  \def\filedate{#4}%
  \ProvidesPackage{#2}[#4 #3 #5 #6]%
}
\next$Id$
          {}
% \fi
%
% \iffalse
%
% still to clean up:
%
% \z@
% \null
% \footins
% \vskip
% \relax
% \AtEndDocument
% \insert
% \protected@xdef
% \begingroup \endgroup
%
%
%    \end{macrocode}
%
%<*driver>
 \documentclass{ltxdoc}
%
 \begin{document}
 \catcode`\_=11
 \catcode`\:=11
 \DocInput{xfm.dtx}
 \end{document}
%</driver>
%
% \fi
%
%
% \title{The \textsf{xfm} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi}
% \date{\filedate}
%
%  \maketitle
%
% \tableofcontents
%
%
% \begin{abstract}
%    This document describes a front matter model and implementation
%    for \LaTeX.
%
%    As of today a large portion of the documentation is incorrect,
%    sorry folks, for example the original \verb=\author= command was
%    generalised to allow any kind of front matter structures of this
%    type, but the documentation still talks about \verb=\author= and
%    |address| keyword instead of ``some keyword'' of ``a front matter
%    structure'' \ldots\ one day
% \end{abstract}
%
% \section{Introduction}
%
%
% \subsection{Layout Areas}
%
% Conceptually the front matter consists of so called ``layout areas''
% or ``layout block'' which receive textual data from the syntax
% elements such as the |\title| command or the author declarations
% (i.e., the |\author| command).
%
% A ``layout area'' is vertically oriented, which means that it starts
% out in vertical mode and finishes of in vertical mode by pre- and
% appending a |\par| command. Textual data which is put into it will
% not contain direct formatting information at that point but instead
% will be surrounded by functions with one argument responsible for the
% formatting. For example, an address will appear as
%\begin{verbatim}
%    \xfm_format_key_address:n {Zedernweg 62, 55128 Mainz, Germany}
%\end{verbatim}
% in such a ``layout area''. 
%
% 
% \subsubsection{Area Declaration}
%
%\DescribeMacro\DeclareFMArea
% Areas are declared by |\DeclareFMArea| as follows:
%\begin{verbatim}
%    \DeclareFMArea{<name>}
%     {
%       area-required-boolean    = <true or false>,
%       area-measure-setup       = <horizontal galley parameters>,
%       area-bb-skip             = <vertical separation to prev block>,
%
%       head-text                = <fixed heading text>,
%       head-font                = <font for heading>,
%       head-format              = <format of heading>,
%       head-justification-setup = <how to justify heading>,
%
%       head-text-bb-skip        = <vertical separation between head/text>,
%       head-text-h-skip         = <horizontal separation between head/text>,
%
%       text-font                = <font for text>,
%       text-pshape-setup        = <special parshape if necessary>,
%       text-justification-setup = <how to justify text>,
%       text-firstindent-boolean = <indent first paragraph?>,
% }
%\end{verbatim}
% The |basebase-skip| key defines the distance between the first baseline in
% the area and the last baseline of an earlier area (if there is
% one).\footnote{For very complex layouts where the areas are not
% essentially following each other that key seems slightly odd, but
% for most type of layouts the placement within the area setup is
% appropriate (and it is easier to implement this way).} By default it
% is the value of |fontbaseline| so that areas follow each other
% without any special space.
%
% The |fontsize| and the |fontbaseline| keys define some important
% properties of the body font. There need to be others and all those
% should probably be combined somehow and offered as |font-setup|.
%
% The |justification-setup| defines the paragraph justification used
% for area. If we go with the galley2 type of templates (without
% actually using them) then we probably also need something like
% |pshape-setup|.
%
% Finally |required-boolean| defines whether or not that area needs
% filling. An unfilled area is ignored including the whitespace
% preceding it, but if the area is required we will get an error
% message.
% 
% 
% 
% \subsubsection{Element Separation}\label{sec:eltsep}
%
% The ``textual elements'' in the areas will be internally separated
% from each other by functions taking three arguments:
%\begin{verbatim}
%    \xfm_area_sep:nnn {addresses}{key!address}{marker!addresses}
%\end{verbatim}
% The first argument is the name of the area itself, the second
% describes the nature of the previous element (an address in the
% example), and the third describes the nature of the following
% element (a marker with the name |addresses| in the example).
% If there is no previous element the second argument contains the
% string |START| and if there is no further element the third argument
% contains the string |END|.
%
% Having these separator functions it is possible to describe in
% detail the formatting that should happen between two elements in an
% area as well as allowing special actions to be taken before the
% first element and after the last element.
%
% \DescribeMacro\DeclareFMObjectSep
% The actions of the separator functions are declared using a number
% of |\DeclareFMObjectSep| each taking four arguments: the area to
% which they apply, the ``descriptive name'' of the previous element,
% the ``descriptive name'' of the following element, and the action to
% take if we are between two such elements (i.e., if the three
% arguments of |\xfm_area_sep:nnn| match the first three arguments in
% the |\DeclareFMObjectSep| declaration. Instead of a ``descriptive
% name'' one can use a |*| which means any element.
%
% As a simple example consider the author names appearing in such a
% list being denoted by |key!name|\footnote{How to determine which
% elements have what name we cover later.} then separating them by
% comma could be done as follows:
%\begin{verbatim} 
%  \DeclareFMObjectSep{authors}{START}{key!name}   {}
%  \DeclareFMObjectSep{authors}{*}    {key!name}   {, }
%  \DeclareFMObjectSep{authors}{*}    {END}        {}
%\end{verbatim} 
% This is admittedly a simple example; especially in this case we
% typically have the need to handle the situation of two elements
% specially, e.g., adding \verb*= and = in that case but
% \verb*=, and =  between the last two authors if there are more 
% than two.\footnote{It remains to be seen if this kind of extra
% complication asks for a  even more generic solution or if it can be
% suitably handled with the current concepts.}
%
% As a second example consider markers being added after author names
% to refer to email address, thanks, and the like. The following
% specification will put a small space before the first marker,
% separate the markers by a raised comma (the marker itself is better
% be raised as well in that case :-) and finishes the set of markers
% for one author by a raised close parenthesis.
%\begin{verbatim}
%  \DeclareFMObjectSep{authors}
%                    {*}            {marker!thanks}{\,}
%  \DeclareFMObjectSep{authors}
%                    {marker!thanks}{marker!thanks}{\textsuperscript{,}}
%  \DeclareFMObjectSep{authors}
%                    {marker!thanks}{*}            {\textsuperscript{)}}
%\end{verbatim} 
%
% The use of the |*| in the |\DeclareFMObjectSep| declaration needs
% some further explanation. Consider the following three declarations:
%\begin{verbatim}
%  \DeclareFMObjectSep{authors}{A}{*}{do-A}
%  \DeclareFMObjectSep{authors}{*}{B}{do-B}
%  \DeclareFMObjectSep{authors}{A}{C}{do-C}
%  \DeclareFMObjectSep{authors}{*}{*}{do-D}
%\end{verbatim}
% If we are between two elements then it is first checked if there is
% a declaration for this exact combination (thus not involving stars).
% If this is the case then the corresponding action is executed and
% nothing else. Therefore if we are between |A| and |C| the algorithm
% executes |do-C| and ignores that the first and the last of the above
% rules would match the situation as well.
%
% However, if the exact match is not found, the algorithm first tries
% to finds a rule with the second element replaced by a star (and if
% found executes its action) and then regardless of the result for
% that search also looks for a rule with the first element being
% replaced by a star. 
%
% If there was at least one match involving one star processing stops
% otherwise the algorithm makes a final attempt and looks for a rule
% with both elements replaced by stars.
%
% Thus for |A| followed by |B| we execute |do-A| and then |do-B|,
% while for |A| followed by |D| we execute only |do-A|, for |C|
% followed by |B| we would execute |do-B|, and for |C| followed by |C|
% we would execute |do-D| (assuming that the above are the only rules
% involving |A|, |B|, and |C|).
%
%
% \subsubsection{Processing and Formatting}
%
% \DescribeMacro\xfm_add_element:nnn
% \DescribeMacro\xfm_add_element:nno
% To add an element to some area the command |\xfm_add_element:nnn|
% can be used as follows:
%\begin{verbatim} 
%  \xfm_add_element:nnn {authors} {key!name}{Frank Mittelbach}
%\end{verbatim} 
% where the first argument specifies the target area, the second the
% ``descriptive name'' for the element, and the third the actual
% data. This command and its companion (which is the same except that
% last argument is expanded once) are intended for internal use, so
% the argument would usually contain |#1| and the like rather than
% fixed data. 
%
% The target area should have been declared; the ``descriptive name''
% can in be any string, though to be useful there should be a sensible
% convention (the one used by this setup is explained below).
%
% The commands append at the right by first adding an element
% separation command (as explained in the previous section) followed
% by contents of the third argument. Thus formatting commands such as
% |\xfm_format_key_address:n| need to be part of that third argument
% if necessary.
%
%
% The areas are formatted by executing an instance of type |textarea|
% and the name of that area, e.g.,
%\begin{verbatim} 
%  \UseInstance{textarea}{thanks}
%\end{verbatim}
% would typeset the contents of an area named |thanks| at the current
% point.
%
% \DescribeMacro\xfm_typeset_area_list:n
% This command expects a comma separated list of areas and formats one
% after each other by calling |\UseInstance{textarea}{...}| if they
% exist, otherwise it ignores the area(s). 
%
% \DescribeMacro\xfm_typeset_insertion_area_list:nN
% This command expects a comma separated list of areas and an
% insertion class (such as footins) and formats one
% after each other into that class by calling
% |\UseInstance{textarea}{...}| if they 
% exist, otherwise it ignores the area(s). 
%
% Should perhaps combined with the previous command for normal areas.
%
%
% As mentioned above the elements are formatted using commands with
% one argument. The definition for these commands are part of the
% declarations that set up the data sources from which the text comes,
% e.g., keys of the |\author| commands gets distributed to areas and
% the formatting for the key value is described with the key declaration.
%
%
%
%
%
%
% \subsection{Markers}
%
% Some of the information distributed to different areas need to be
% linked to other areas, e.g., you might want to link an author name
% appearing in the |authors| area with its address (appearing, for
% example, in the |addresses| area) as well as with its email address
% and homepage information (both appearing, say, as footnotes on the
% bottom of the page).
%
% \DescribeMacro\DeclareFMMarker
% This is done by linking this data via ``markers'' which are declared
% using the |\DeclareFMMarker| declaration as follows:
%\begin{verbatim}
%  \DeclareFMMarker{<name>}
%   {
%     marker-type   = <display-type-of-marker>,
%     source-format = <presentation-in-sourcearea>,
%     target-format = <presentation-in-target-area>,
%   }
%\end{verbatim}
% Markers are internally represented as counters, with the
% |marker-type| we define the general display properties of the
% marker, e.g., as arabic numbers or as footnote symbols , etc.
% The |source-format| describes for formatting in the source area
% (link start) while the |target-format| describes the formatting in
% the target area (if different from the formatting in the source
% area).\footnote{not used below ... FIX}
%
% For example, we might have |\textsuperscript{\normalfont#1}| as
% formatting  in the source area, but perhaps |#1)| in the target
% area. Both |-format| keys apply to a single reference to a marker,
% if several such marker reference appear in succession in an area,
% they are separated by element separator functions and thus the
% formatting between them can be specified via this concept.
%
%
%
%
% \subsection{Author Data}
%
% Author data is perhaps the most complicated information in the front
% matter because it contains several items that need special treatment
% in most layout styles. This package provides a single input syntax
% while supporting the various layout conventions required by
% different journals.
%
% 
% \subsubsection{Author Data Input Specification}
% 
% \DescribeMacro\author 
% Author data is entered in the source document using the |\author|
% command:
% \begin{verbatim}
% \author{<name>}{
%   address    = <author address> ,
%   altaddress = <alternate author address> ,
%   homepage   = <author home page> ,
%   email      = <author email address> ,
%   thanks     = <thanks and attributions> ,
%   ...
% }
% \end{verbatim}
% 
% The keywords in the second argument to the |\author| command are an
% extensible set; they are declared by document class (or in the
% preamble). For the sake of portability, a suitable default set
% should be provided.
% 
% Keywords used but not declared result in an error. Declaring
% keywords on the other hand does not necessarily mean that the value
% is going to be used by the class.
% 
% 
% \subsubsection{Declaring keywords for the author command}
% 
% \DescribeMacro\DeclareAuthorKeyword
% Keywords available within the second argument of the |\author|
% command are declared using |\DeclareAuthorKeyword| as follows:
% \begin{verbatim}
% \DeclareAuthorKeyword{<keyword>}
%   {
%    value-required-boolean = <true-or-false>,
%    value-targetarea-id    = <area-name>,
%    value-combine-boolean  = <true-or-false>,
%    marker-id                = <marker-name>,
%    marker-sourcearea-id    = <area-name>,
%   }
% \end{verbatim}
% Not every keyword within the |\author| command represents a required
% value. We might require that every author has an address but
% probably not every author has an email address. By specifying that
% |value-required-boolean| is |false| for a keyword we instruct the front
% matter algorithm that it is permissable when this particular keyword
% is missing in an author declaration. If this is set to |true| the
% algorithm checks if that keyword is present for every author and if
% not will issue an error message. (The default is |true|.)
% 
% To get a keyword formatted at some point it needs a target area in
% which it gets typeset; this area is specified by
% |value-targetarea-id |. If this contains no value the declared keyword
% will be accepted but ignored.
% 
% If the value of the author keyword has to be linked with some other
% data we need a marker which can be specified by the |marker-id|. If
% a |marker-id| is given the corresponding marker will be used in two
% places:
% \begin{itemize}
% \item in the |value-targetarea-id | before the author keyword value is
%   inserted there
% \item in the |marker-sourcearea-id| at the current point in that area.
% \end{itemize}
% The formatting used for the marker depends on the declarations for
% this marker. The |marker-id| has no effect if the whole author
% keyword is ignored (i.e., if the |value-targetarea-id | is empty).
% 
% The default for the |marker-sourcearea-id| is the area named |authors|
% which by convention holds the author names.
% 
% In some cases identical data in certain areas (for certain keys)
% should be combined. This can be requested on the author keyword
% level by setting the flag |value-combine-boolean| to |true|. In this case
% all data flagged with the same marker is searched to find an already
% existing entry with the same value. If this value is found then the
% corresponding marker label is used instead of generating a new
% one. Note that if a marker is used for linking data in different
% target areas (which is probably a bad idea in the first place) then
% the identical string might be found in any of these target areas!
% 
% There is the interesting question where to put a flag like
% |value-combine-boolean|. Putting it onto an area sounds interesting but
% consider the following scenario: both thanks and address go to the
% footnote area at the bottom of the page and two authors thank their
% wives named Lisa. To conserve space we want to combine identical
% addresses, do we also want to have the line ``With thanks to Lisa''
% be combined into a single line?
% 
% 
% \subsubsection{Processing data for one author}
% 
% General processing of individual author data is identical for all
% styles. Its purpose is to collect referencing information that link
% the author name author data not formatted and ``close by'', e.g.,
% url information later formatted as a footnote, and prepare for this
% data to be processable in a later stage.
% 
% \begin{itemize}
% \item Clear the temporary marker reference list.
% \item Process the author data in a specified keyword order (this order
%   is stored in the template value \texttt{keyword-order}).
% \item For each keyword determine if it has a value and if so
%   \begin{itemize}
%   \item append an appropriate marker reference to the marker reference
%     list
%   \item postprocess the keyword value by appending it together with
%     its marker reference to an area list for later formatting (if
%     necessary---the data might already be present).
%   \end{itemize}
% \end{itemize}
% 
% After this process the temporary marker reference list can (and
% should) be used to format marker information that should be attached
% to the author name. The area lists are global to this processing,
% ie., their contents will not be cleared.
% 
%
%
%
% \section{Question, Issues, and Ideas}
%
% This is a set of comments on the concepts and the implementation in
% random order.
%
% \begin{itemize}
%
% \item The more I work with templates the more I (mis)use the
%    template interface to provide key/value parsing, e.g., define a
%    declaration command such as |\DeclareFMMarker| which does
%    nothing else than declaring a template instance and immediately
%    executing it. After that this instance is never going to be
%    used again. This really calls for providing an interface for such
%    action which internally generates some anonymous instance which
%    is removed from storage immediately afterwards.
%
% \item Just realised that the fake templates would get much simpler
%    if I pass the name as a template argument rather than as a
%    key. Should probably update them all but not tonight.
%
% \item Perhaps it is a good idea to provide the interface to markers
%   in a more general way as a generic interface to counters since
%   there as well something like |source-format| and |target-format|
%   would make sense for many of them as well.
%
% \item The current use of markers needs one more layer of
%    abstraction, i.e., rather than passing around the display value
%    of the marker it would be better to pass around a reference to it
%    and determine the real value at the very last moment. This would
%    allow to get independent usages of the same marker, e.g., via
%    direct |\thanks| commands in sync with those produced when author
%    key values are distributed to areas.
% \end{itemize}
%
%
%
%
% \section{Implementation}
%
%    To implement the front matter code we need the |template| code as
%    well as some general purpose stuff implementing property lists
%    and the like which is coming from |xtools|.
%
%    \begin{macrocode}
%<*package>
\NeedsTeXFormat{LaTeX2e}[1998/12/01]
\RequirePackage{ldcsetup}[2001/07/24]
\RequirePackage{xtools}  [2001/07/24]
\RequirePackage{template}[2001/07/24]
\RequirePackage{xfmgalley}
\RequirePackage{l3int}
\InternalSyntaxOn
%    \end{macrocode}
%    
% Extra stuff that belongs to the basic l3expl macros:
%    \begin{macrocode}
\let:NN  \cs_show:N \tex_show:D
\def:Npn \cs_show:c {\exp_args:Nc\cs_show:N}

\def:Npn \glet:cN {\exp_args:Nc\glet:NN}

\let:NN  \cs_meaning:N \tex_meaning:D
\def:Npn \cs_meaning:c {\exp_args:Nc\cs_meaning:N}

\def:Npn \tlp_gset:cx {\exp_args:Ncx\tlp_gset:Nn}

\def:Npn \tlp_gset_eq:cN {\exp_args:Nc\tlp_gset_eq:NN}

\let:NN \if_tlp_eq:NN \if_meaning:NN   %%% good idea?

\let:NN \tlp_use:c \use:c

% this actually expands second arg automatically once:

\def_long:Npn \cntrl_for_loop:Non #1#2#3 {
  \expandafter\def\expandafter\@fortmp\expandafter{#2}%
  \ifx\@fortmp\@empty \else
    \expandafter\@forloop#2,\@nil,\@nil\@@#1{#3}\fi}

% either the above or the next is inconsistent in naming:

\def:Npn \cntrl_for_loop:NcT {\exp_args:NNc\cntrl_for_loop:Non}

\def:Npn \cs_eq:NNT #1#2 {
  \if_meaning:NN #1#2
    \exp_after:NN \use:n
  \else:
    \exp_after:NN \use_none:n
  \fi:
}

\def:Npn \cs_eq:cNT {\exp_args:Nc \cs_eq:NNT}
%    \end{macrocode}
%
%
% \subsection{Layout Areas}
%
%
% \subsubsection{Area declaration}
%
% \DescribeMacro\g_xfm_FOO_list_tlp
%    For an area named |FOO| the tlp |\g_xfm_FOO_list_tlp| holds all
%    formatting instructions to be used when the corresponding area
%    instance is executed. (After execution this list is cleared so an
%    area can be used un a loop, if in the loop filling and using is
%    alternated.)
%
% \DescribeMacro\g_xfm_FOO_last_tlp
%    For an area |FOO| the tlp |\g_xfm_FOO_last_tlp| holds the
%    descriptive name of the last element that was added. This is used
%    when computing the separator function that is placed between two
%    such elements.
%
% \DescribeMacro\XFMShowAreas
%    The |\XFMShowAreas| is indented as a debugging aid and shows the
%    current contents of each area.
%
%
% \begin{macro}{textarea (template/type)}
%    Areas are internally implemented as instances of templates so we
%    start by declaring a template type for this. As a typical
%    ``setup'' type this type has no arguments.
%    \begin{macrocode}
\DeclareTemplateType{textarea}{0}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\DeclareFMArea}
%    The |\DeclareFMArea| is the designer interface to area
%    declaration, the first argument is the area name and the second
%    is a list of key/values. This hides the fact that we use template
%    instances for areas but it is also here because we do want to do
%    some code execution when the area is declared and some when it is
%    used.
%
%    \begin{macrocode}
\def:Npn \DeclareFMArea #1#2{
%    \end{macrocode}
%    Each area has a tlp which holds the contents of the area. It is
%    initially empty.
%    \begin{macrocode}
  \tlp_gclear:c{g_xfm_ #1 _list_tlp}
%    \end{macrocode}
%    As a primitive form of debugging during development we provide a
%    |\show| of the area tlp contents so we add the new area to the
%    |\XFMShowAreas| macro (this is clearly code which will vanish one
%    day).
%    \begin{macrocode}
%<*trace>
  \tlp_gput_right:No
     \XFMShowAreas
     {\cs_show:c {g_xfm_ #1 _list_tlp} }
%</trace>
%    \end{macrocode}
%    To be able to add proper element separator commands into the area
%    we need to initialise the tlp that keeps track of the last
%    element seen:
%    \begin{macrocode}
  \tlp_gset:cn{g_xfm_ #1 _last_tlp}{START}
%    \end{macrocode}
%    And finally we declare a template instance, passing area name
%    under the key |area-id| and the second argument as the remaining
%    key/values.
%    \begin{macrocode}
  \DeclareInstance{textarea}{#1}{std}{ area-id = #1,  #2 }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \begin{macro}{\XFMShowAreas}
%    The debugging command |\XFMShowAreas| shows the current contents
%    of all areas, the output is rather unreadable---need something
%    better in the end. We have to initialise this or else the
%    |\tlp_gput_right:No| in |\DeclareFMArea| will fail.
%    \begin{macrocode}
%<*trace>
\tlp_new:Nn \XFMShowAreas {}
%</trace>
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{textarea/std (template)}
%    The purpose of this instance is to format the contents of an area
%    and prepare for its reuse (if necessary).
%
%    Keys and their names for this template need further thought, they
%    are neither complete nor good.
%    \begin{macrocode}
\DeclareTemplate{textarea}{std}{0}{
   area-id               =n \l_textarea_id_tlp,
   area-required-boolean =s {}
                            {\let:NN \textarea_missing_value:\relax},
   area-measure-setup    =i {measure} \textarea_measure:n,

   area-bb-skip            =L  \l_textarea_BBskip_tlp,
   head-text               =f0 \l_textarea_head_text_tlp,
   head-font               =f0 \l_textarea_head_font_tlp,
   head-format             =f1 \textarea_head_format:n,
   head-justification-setup=i {justification} [center]
                                  \textarea_head_justification:,
   head-text-h-skip         =L  \l_textarea_text_hskip_tlp,
   head-text-bb-skip        =L  \l_textarea_text_BBskip_tlp,

   text-font                =f0 \l_textarea_text_font_tlp,
   text-justification-setup =i {justification} [centerfirst-adjust]
                                        \textarea_text_justification:,
   text-pshape-setup        =i {pshape} \textarea_text_pshape,
   text-firstindent-boolean =s {}{\let:NN \textarea_text_handle_indent:
                                  \gal_remove_next_parindent: },

 }
 {
%    \end{macrocode}
%    
%    \begin{macrocode}
  \let:NN \textarea_measure:n \use_none:n
  \tlp_set_eq:NN\l_textarea_BBskip_tlp    \baselineskip
%    \end{macrocode}
%    The default for |\textarea_missing_value:| is to call an error
%    routine which tells the user that contents for this area is
%    required but not provided by the document.
%    \begin{macrocode}
  \def:Npn \textarea_missing_value:
           { \xfm_error_decl:nn {area} \l_textarea_id_tlp }

  \let:NN \textarea_text_pshape\relax

  \tlp_set:Nn    \l_textarea_text_BBskip_tlp \baselineskip
  \tlp_set_eq:NN \l_textarea_text_hskip_tlp  \NoValue
  \tlp_clear:N   \l_textarea_text_font_tlp 

  \tlp_set_eq:NN \l_textarea_head_text_tlp \NoValue
  \tlp_clear:N   \l_textarea_head_font_tlp

  \let:NN \textarea_head_format:n \use:n
  \let:NN \textarea_text_handle_indent: \relax
%    \end{macrocode}
%    
%    \begin{macrocode}
  \DoParameterAssignments
%    \end{macrocode}
%    
%    If the area contents is empty we execute
%    |\textarea_missing_value:| which, by default, will generate an
%    error message, but if the declaration set |required-boolean| to
%    |false| it will do nothing.
%    \begin{macrocode}
  \tlp_eq:cNTF {g_xfm_ \l_textarea_id_tlp _list_tlp} \c_empty_tlp
    \textarea_missing_value:
%    \end{macrocode}
%    If it is non-empty we have to typeset it:
%    \begin{macrocode}
   {
%    \end{macrocode}
%    First thing to do is to append the final separator command since
%    this is still missing.
%    \begin{macrocode}
    \xfm_add_element_sep:nn \l_textarea_id_tlp {END}
%    \end{macrocode}
%    The actual typesetting is done in a group so that font changes
%    etc are kept local to the area.
%    \begin{macrocode}
    \begingroup
      \par
      \textarea_measure:n \NoValue

      \tlp_eq:NNTF \l_textarea_head_text_tlp \NoValue
        {
         \tlp_set_eq:NN 
            \l_textarea_text_BBskip_tlp \l_textarea_BBskip_tlp
         \textarea_text_handle_indent:
        }
        {
         \begingroup
	   \l_textarea_head_font_tlp
	   \UseBBskip\l_textarea_BBskip_tlp
	   \tlp_eq:NNF \l_textarea_text_hskip_tlp \NoValue
                       \textarea_text_handle_indent:
	   \textarea_head_format:n
	      \l_textarea_head_text_tlp
         \endgroup
         \textarea_head_justification:
        }
%    \end{macrocode}
%    We need to set up the body font for the area \emph{before} we
%    call |\UseBBskip| since the latter needs to know the upcoming
%    baselineskip value to make the right calculations.
%    \begin{macrocode}
      \tlp_eq:NNF \l_textarea_text_hskip_tlp \NoValue
                  { \hskip \l_textarea_text_hskip_tlp }
      \l_textarea_text_font_tlp
      \tlp_eq:NNT \l_textarea_text_hskip_tlp \NoValue
         { \par
            \UseBBskip\l_textarea_text_BBskip_tlp
         }
%    \end{macrocode}
%    Then we set up justification and finally typeset the area
%    contents followed by a |\par| to ensure that we return to
%    vertical mode.
%    \begin{macrocode}
      \textarea_text_pshape
      \textarea_text_justification:
 \cs_show:c{ g_xfm_ \l_textarea_id_tlp _list_tlp }
      \use:c { g_xfm_ \l_textarea_id_tlp _list_tlp }
      \par
    \endgroup
%    \end{macrocode}
%
%    After that we have to reinitialise the area to allow reuse (as
%    well as to save space). We can do this within the |\else| part
%    since we can assume that an empty contents means that we are
%    still having an initialised version (if not something will break :-).
%    \begin{macrocode}
    \tlp_gclear:c{g_xfm_ \l_textarea_id_tlp _list_tlp}
    \tlp_gset:cn {g_xfm_ \l_textarea_id_tlp _last_tlp}
                 {START} % provide restart
   }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xfm_error_decl:nn}
%    The current error handling is BAD and the texts are wrong, so
%    there\ldots
%    \begin{macrocode}
\def:Npn  \xfm_error_decl:nn #1#2
    {\PackageError{xfm}{No~ contents~ in~ #1~ `#2'~ missing}
                       \@eha % needs real help message
    }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsubsection{Element Formatting and Separation}
%
% \DescribeMacro{\xfm_AREA-A-B}
%    The action to be taken between two elements |A| and |B| in an
%    area named |AREA| is stored in |\xfm_AREA-A-B|. |AREA|, |A| and |B| are
%    either descriptive names or |*|s denoting ``any name''.
%
% \DescribeMacro{\xfm_AREA-A}
%    The formatting for element |A| in an
%    area named |AREA| is stored in |\xfm_AREA-A|. |AREA| and |A|  are
%    either descriptive names or |*|s denoting ``any name''.
%
% \begin{macro}{\DeclareFMObjectSep}
%    The |\DeclareFMObjectSep| stores away the information in the
%    appropriate tlp.
%    \begin{macrocode}
\def:Npn \DeclareFMObjectSep #1#2#3#4 { \tlp_gset:cn{xfm_#1-#2-#3}{#4} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareFMObjectFormat}
%    |\DeclareFMObjectFormat| desclares the formatting for element |#2|
%    in area |#1|. The formatting code has one argument and we pick it
%    up implicitly so that we can use `|#1|' in the third argument.
%    \begin{macrocode}
\def:Npn \DeclareFMObjectFormat #1#2 { \gdef:cpn {xfm_#1-#2} ##1 }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\xfm_add_element:nnn}
% \begin{macro}{\xfm_add_element:nno}
%    |\xfm_add_element:nnn| takes an area name as first argument, an
%    (descriptive) element name as second argument, and the element
%    value as third and updates the area tlp with this information by
%    adding an appropriate element separator function followed by the
%    third argument with its formatter function.
%    \begin{macrocode}
\def:Npn \xfm_add_element:nnn #1#2#3 {
%    \end{macrocode}
%    Add the separator function first\ldots
%    \begin{macrocode}
  \xfm_add_element_sep:nn {#1}{#2}
%    \end{macrocode}
%    \ldots then add the third argument to the area tlp.
%    \begin{macrocode}
  \tlp_gput_right:cn
     { g_xfm_#1_list_tlp }
     { \xfm_area_value:nnn{#1}{#2}{#3} }
}
%    \end{macrocode}
%    |\xfm_add_element:nno| is the more common variant which expands
%    the third argument once before adding it.
%    \begin{macrocode}
\def:Npn \xfm_add_element:nno #1#2#3 {
  \xfm_add_element_sep:nn {#1}{#2}
%    \end{macrocode}
%    Because we don't know the length of the first two arguments to
%    |\xfm_area_value:nnn| we add the expanded third argument in a
%    separate step.
%    \begin{macrocode}
  \tlp_gput_right:cn
     { g_xfm_#1_list_tlp }
     { \xfm_area_value:nnn {#1}{#2} }
  \tlp_gput_right:co
     { g_xfm_#1_list_tlp }
     { \exp_after:NN { #3 } }
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
% \begin{macro}{\xfm_add_element_sep:nn}
%    |\xfm_add_element_sep:nn| takes an area name as first argument
%    and an element name as second argument and appends the line
%\begin{verbatim}
%   \xfm_area_sep:nnn {<area>} {<last-element>} {<upcoming-element>}
%\end{verbatim}
%    to the area tlp.
%    \begin{macrocode}
\def:Npn \xfm_add_element_sep:nn #1#2 {
%    \end{macrocode}
%    We have to get the contents of |\g_xfm_|\meta{area}|_last_tlp|
%    into the area tlp and the easiest way to do this is via full
%    expansion.
%    \begin{macrocode}
  \tlp_set:Nx \l_tmpa_tlp
     { \exp_not:N \xfm_area_sep:nnn 
                 { #1 }
                 { \use:c {g_xfm_ #1 _last_tlp} }
                 { #2 }
     }
%    \end{macrocode}
%    After that we can update |\g_xfm_|\meta{area}|_last_tlp| to point
%    to the new name.
%    \begin{macrocode}
  \tlp_gset:cn{g_xfm_ #1 _last_tlp}{#2}
%    \end{macrocode}
%    Finally we add the contents of |\l_tmpa_tlp| to the area tlp.
%    \begin{macrocode}
  \tlp_gput_right:co
     {g_xfm_ #1 _list_tlp}
     \l_tmpa_tlp
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xfm_area_value:nnn}
%    |\xfm_area_value:nnn| picks up an area name and a descriptive
%    element name and finds the formatting for it. Then it applies
%    that to the third argument which is the element's value.
%    \begin{macrocode}
\def:Npn \xfm_area_value:nnn #1#2 {
%<*trace>
  \typeout{XFM:~ Element~ formatting:~ #1-#2}
%</trace>
  \cs_free:cTF{xfm_#1-#2}
    {
     \cs_free:cTF{xfm_*-#2}
        {
%<*trace>
         \typeout{\@spaces nothing~ found}
%</trace>
	 \use:n
        }
	{
%<*trace>
         \typeout{\@spaces\space xfm_*-#2~=~
                  \cs_meaning:c {xfm_*-#2} }
%</trace>
         \use:c {xfm_*-#2}
        }
    }
    {
%<*trace>
     \typeout{\@spaces\space xfm_#1-#2~=~
                  \cs_meaning:c {xfm_#1-#2} }
%</trace>
     \use:c {xfm_#1-#2}
    }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfm_area_sep:nnn}
%    The |\xfm_area_sep:nnn| is the area separator function apearing
%    between elements in the area. It is a huge bunch of tests to find
%    out which combinations of element names and stars is defined and
%    which of them needs execution. See section \ref{sec:eltsep} for
%    an explanation of the logic.
%    \begin{macrocode}
\def:Npn \xfm_area_sep:nnn #1#2#3 {
%<*trace>
  \typeout{XFM:~ Element~ separation:~ #1-#2-#3}
%</trace>
  \cs_free:cTF{xfm_#1-#2-#3}
    {
      \cs_free:cTF{xfm_#1-#2-*}
        {
          \cs_free:cTF{xfm_#1-*-#3}
            {
              \cs_free:cTF{xfm_#1-*-*}
                {
%<*trace>
                 \typeout{\@spaces nothing~ found}
%</trace>
                }
                {
%<*trace>
                 \typeout{\@spaces\space xfm_#1-*-*~=~
                          \cs_meaning:c {xfm_#1-*-*} }
%</trace>
                 \use:c {xfm_#1-*-*}
                }
            }
            {
%<*trace>
             \typeout{\@spaces\space xfm_#1-*-#3~=~
                      \cs_meaning:c {xfm_#1-*-#3} }
%</trace>
             \use:c {xfm_#1-*-#3}
            }
        }
        {
%<*trace>
          \typeout{\@spaces\space xfm_#1-#2-*~=~
                   \cs_meaning:c {xfm_#1-#2-*} }
%</trace>
          \use:c {xfm_#1-#2-*}
          \cs_free:cF{xfm_#1-*-#3}
            {
%<*trace>
             \typeout{\@spaces\space xfm_#1-*-#3~=~
                      \cs_meaning:c {xfm_#1-*-#3} }
%</trace>
             \use:c {xfm_#1-*-#3}
            }
        }
    }
    {
%<*trace>
     \typeout{\@spaces\space xfm_#1-#2-#3~=~
              \cs_meaning:c {xfm_#1-#2-#3} }
%</trace>
     \use:c {xfm_#1-#2-#3}
    }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \subsection{Markers}
%
% As mentioned above markers are essentially \LaTeX{} counters with a
% few additions. Here is a list of internals structures set up when a
% marker named |FOO| is declared.
%
% \DescribeMacro\c@FOO
%    The current value of the marker is stored in the count register
%    |\c@FOO|.
%
% \DescribeMacro\theFOO
%    The basic display representation of the marker is given by
%    |\theFOO|.
%
% \DescribeMacro\g_xfm_FOO_prop
%    For each marker |FOO| we maintain a property list
%    |\g_xfm_FOO_prop| in which we put under the key
%    |\mark-|\meta{marker-num} the following data
%\begin{verbatim}
%  { <display-value> }{ <target-text> }
%\end{verbatim}
%    which is needed if we want combine reference to identical text.
%
%    This property list will change with a different implementation,
%    see ``Questions, Issues'' section!
%
% \DescribeMacro\xfm_format_source_marker_FOO:n
%    A command with one argument which describes the formatting to be
%    applied to the marker value if used in the source area.
%
% \DescribeMacro\xfm_format_target_marker_FOO:n
%    A command with one argument which describes the formatting to be
%    applied to the marker value if used in a target area.
%
%
% \begin{macro}{\DeclareFMMarker}
%    The |\DeclareFMMarker| simply hides the fact that the
%    key/value parsing is done via a template. It declares an instance
%    and immediately executes it.
%    \begin{macrocode}
\def:Npn \DeclareFMMarker #1#2{
  \UseTemplate{FMmarkersetup}{std}{#2}{#1}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{FMmarkersetup (template type)}
%    Here is the template type declaration.
%    \begin{macrocode}
\DeclareTemplateType{FMmarkersetup}{1}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{FMmarkersetup/std (template)}
%    The purpose of this template is to set up the marker data
%    structures.
%    \begin{macrocode}
\DeclareTemplate{FMmarkersetup}{std}{1}{
   marker-type   =f0 \l_FMmarker_type_tlp,
   default-format=f1 \FMmarker_default_format:n,
   target-format =f1 \FMmarker_target_format:n,
 }
 {
%    \end{macrocode}
%    As defaults we use |\arabic| for the |marker-type|, |#1| for the
%    |default-format| |\@firstofone|.
%    \begin{macrocode}
   \tlp_set:Nn \l_FMmarker_type_tlp           {\arabic}
   \let:NN  \FMmarker_default_format:n \use:n
%    \end{macrocode}
%    
%    \begin{macrocode}
   \DoParameterAssignments
%    \end{macrocode}
%    Make a new \LaTeX{}  counter with the name of the marker; due to
%    this the declaration is currently not modifiable once it is
%    given!
%    \begin{macrocode}
   \newcounter {#1}
   \gdef:cpx {the#1} { \exp_not:o \l_FMmarker_type_tlp {#1} }
%    \end{macrocode}
%    Provide the special property list that we need for combining
%    references.
%    \begin{macrocode}
   \prop_new:c {g_xfm_ #1 _prop}
%    \end{macrocode}
%    We store the source format in the appropriate command:
%    \begin{macrocode}
   \glet:cN
      {xfm_ *-marker!#1}
      \FMmarker_default_format:n
 }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \subsection{Front Matter Structure Data}
%
% 
% \subsubsection{Strcuture Input Specification}
% 
%
% \begin{macro}{\author}
%    The |\author| command stores the key/values as properties in a
%    property list which is named |\g_xfm_structure_|\meta{num}|_prop| where
%    \meta{num} is a sequence number which we get from incrementing
%    the counter |\g_xfm_structure_int|. Thus that counter will tell us the
%    number of authors seen in total.

%    In addition we store the current value of that counter in the
%    queue |\g_xfm_authors_queue| so that this queue will initially hold
%    the value $1,\ldots,n$ if we have $n$ authors in total.
%
%    Thus we can loop through this queue if we want to process the
%    authors. Also, if authors need to be sorted by address, we can
%    remove values from this queue once they are processed and thus
%    keep track of the authors still unprocessed.
%
%    The key names are of the form |\xfm_key_|\meta{name-of-key}.
%    \begin{macrocode}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g_xfm_structure_int}
%    We count the |\author| commands seen in the counter
%    |\g_xfm_structure_int|. At a later stage the counter is used to denote
%    the number of authors during processing, e.g., when sorting by
%    address it denotes the number of authors found for the current
%    address.
%    \begin{macrocode}
\int_new:N \g_xfm_structure_int
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xfm_structure_parse_keyword_code:n}
%    |\xfm_structure_parse_keyword_code:n| is the code used to evaluate a key
%    using |\setkeys{xfm}|, i.e., for each keyword \meta{key} we want
%    to allow in the second argument of |\authors| we need to |\let|
%    the macro name |\KV@xfm-|\meta{structure}|@|\meta{key} to this
%    macro (this is done in the declaration of keys for the |\author|
%    command below).
%
%    We could have used |\define@key| in that declaration but since
%    the code is the same for all keys using a direct |\let| saves a
%    lot of space.
%
%    The purpose of the code is to store the key value as a property
%    in the property list for the current author using the property
%    key |\xfm_key_|\meta{key}.
%
%    The macro has an argument but we can make it implicit and have
%    |\prop_gput:ccn| to pick it up as its third argument.
%
%    If anybody wonders what the |\@tempa| is doing\marginpar{DANGER:
%    bad dependency to keyval package} in the second argument to
%    |\prop_gput:ccn| \ldots : it holds the value of the parsed key (so
%    this is totally dependent on the implementation of |\setkeys|,
%    urg, which should offer a proper interface to the currently
%    parsed key name but doesn't).
%
%    \begin{macrocode}
\def:Npn \xfm_structure_parse_keyword_code:n {
  \prop_gput:ccn  
     {g_xfm_structure_ \int_use:N\g_xfm_structure_int _prop}
     {xfm_key_\@tempa}
}
%    \end{macrocode}
% \end{macro}
%
%
% 
% 
% \subsubsection{Declaring keywords for a structure command}
% 
% To declare a keyword |FOO| for the front matter structure BAR we have to set
%    up a number of internal data structures.
%
% \DescribeMacro{\KV@xfm-BAR@FOO}
%    The |\KV@xfm-BAR@FOO| command is the parsing routine for
%    \texttt{keyval} to capture the keyword |FOO| within the structure |BAR|.
%
%
% \DescribeMacro\xfm_format_key_FOO:n
%    The macro |\xfm_format_key_FOO:n| holds the formatting
%    instructions for the key value when it is passed into the target
%    area.
%
% \DescribeMacro\xfm_find_marker_BAZ-FOO:Nn
%    The macro |\xfm_find_marker_BAZ-FOO:Nn| executed if we try to find an
%    already existing value to combine marker information, |BAZ| is
%    the target area for |FOO| (recall that there can be more than one
%    such area per keyword). It will be
%    either |\let| to |\xfm_find_marker:Nn| (in which case we try to
%    combine) or to |\use_none:n| (in which case we  loop but only through
%    data away --- not very efficient)
%
% \DescribeMacro{\xfm_process_key_author-FOO:N}
%    The macro |\xfm_process_key_author-FOO:N| stores the code that is
%    executed when we try to distribute this particular key value to
%    some target area. It is either a call to
%    |\xfm_append_keyval:nnN| or to
%    |\xfm_linkappend_keyval_nnnnN| with all but the last
%    arguments fixed. Which of the two is used depends on the
%    value for the |marker-id|: if we don't have markers we
%
%
%
% \begin{macro}{\DeclareFMKeyword}
%    |\DeclareFMKeyword| takes the name of a structure (without
%    backslash) as first argument, the name of a keyword for this
%    structure as second argument and the specification what to do for
%    this keyword as a third argument.
%    \begin{macrocode}
\def:Npn \DeclareFMKeyword #1#2#3{
 \UseTemplate{keywordsetup}{std}{#3}{#1}{#2}
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{keywordsetup (template type)}
%    Arguments are structure and keyword names.
%    \begin{macrocode}
\DeclareTemplateType{keywordsetup}{2}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{keywordsetup/std (template)}
%    The purpose of this template is to register a keyword for a front
%    matter structure command and set up the necessary data
%    structures.
%    \begin{macrocode}
\DeclareTemplate{keywordsetup}{std}{2}{
   value-targetarea-id    =n  \l_keysetup_target_area_id_tlp,
   value-required-boolean =s  {}
                              {\let:NN \keysetup_missing_key:\relax},
   value-combine-boolean  =s  {\let:NN \keysetup_combine_boolean:Nn
                                       \xfm_find_marker:Nn}
                              {},
   value-format           =f1 \keysetup_keyword_format:n,
   marker-id              =n  \l_keysetup_marker_id_tlp,
   marker-sourcearea-id   =n  \l_keysetup_source_area_id_tlp,

   value-targetarea-id2   =n  \l_keysetupii_target_area_id_tlp,
   value-format2          =f1 \keysetupii_keyword_format:n,
   value-combine-boolean2 =s  {\let:NN \keysetupii_combine_boolean:Nn
                                       \xfm_find_marker:Nn}
                              {},
   marker-sourcearea-id2  =n  \l_keysetupii_source_area_id_tlp,
   marker-id2             =n  \l_keysetupii_marker_id_tlp,

   value-targetarea-id3   =n  \l_keysetupiii_target_area_id_tlp,
   value-combine-boolean3 =s  {\let:NN \keysetupiii_combine_boolean:Nn
                                       \xfm_find_marker:Nn}
                              {},
   value-format3          =f1 \keysetupiii_keyword_format:n,
   marker-sourcearea-id3  =n  \l_keysetupiii_source_area_id_tlp,
   marker-id3             =n  \l_keysetupiii_marker_id_tlp,

 }
 {
%    \end{macrocode}
%    Start by setting up (sensible?) defaults: by default we don't
%    have a marker and we format the key value by simply passing it on
%    unchanged --- easy.
%    \begin{macrocode}
   \tlp_clear:N \l_keysetup_marker_id_tlp
   \tlp_clear:N \l_keysetupii_marker_id_tlp
   \tlp_clear:N \l_keysetupiii_marker_id_tlp
   \let:NN \keysetup_keyword_format:n    \use:n
   \let:NN \keysetupii_keyword_format:n  \use:n
   \let:NN \keysetupiii_keyword_format:n \use:n
%    \end{macrocode}
%    If no |marker-sourcearea-id| for the marker is given we assume that the
%    author name will go to the area |authors| and that the marker
%    reference therefore should be there too --- less clear.
%    \begin{macrocode}
   \tlp_set:Nn  \l_keysetup_source_area_id_tlp {authors}
   \tlp_clear:N \l_keysetupii_source_area_id_tlp
   \tlp_clear:N \l_keysetupii_target_area_id_tlp
   \tlp_clear:N \l_keysetupiii_source_area_id_tlp
   \tlp_clear:N \l_keysetupiii_target_area_id_tlp
%    \end{macrocode}
%    By default declared front matter structure keys are required,
%    which may be the wrong way round.
%    \begin{macrocode}
   \def:Npn \keysetup_missing_key: {\xfm_error_key:nn{#1}{#2}}
%    \end{macrocode}
%    By default we do not combine entries.
%    \begin{macrocode}
   \let:NN \keysetup_combine_boolean:Nn\use_none:nn
   \let:NN \keysetupii_combine_boolean:Nn\use_none:nn
   \let:NN \keysetupiii_combine_boolean:Nn\use_none:nn
%    \end{macrocode}
%    
%    \begin{macrocode}
   \DoParameterAssignments
%    \end{macrocode}
%    Registering the keyword means linking the \texttt{keyval} parsing
%    routine to the default parsing routine for front matter structure
%    keywords.
%    \begin{macrocode}
   \glet:cN
      {KV@xfm-#1@ #2}
      \xfm_structure_parse_keyword_code:n
%    \end{macrocode}
%    We stored the main target area externally since we need it for
%    sorting.\footnote{Rethink general mechanism!}
%    \begin{macrocode}
   \tlp_gset_eq:cN
      {xfm_target_area_ #1-#2 _tlp}
      \l_keysetup_target_area_id_tlp
%    \end{macrocode}
%    
%    \begin{macrocode}
   \glet:cN
      {xfm_find_marker_ \l_keysetup_target_area_id_tlp - #2 :Nn}
      \keysetup_combine_boolean:Nn
%    \end{macrocode}
%    
%    \begin{macrocode}
   \glet:cN
      {xfm_ \l_keysetup_target_area_id_tlp -key! #2}
      \keysetup_keyword_format:n
%    \end{macrocode}
%    
%    \begin{macrocode}
   \tlp_eq:NNF \l_keysetupii_target_area_id_tlp \c_empty_tlp
     {
      \glet:cN
	{xfm_ \l_keysetupii_target_area_id_tlp -key! #2}
	\keysetupii_keyword_format:n
      \glet:cN
	{xfm_find_marker_ \l_keysetupii_target_area_id_tlp - #2 :Nn}
	\keysetupii_combine_boolean:Nn
     }

   \tlp_eq:NNF \l_keysetupiii_target_area_id_tlp \c_empty_tlp
     {
      \glet:cN
	{xfm_ \l_keysetupiii_target_area_id_tlp -key! #2}
	\keysetupiii_keyword_format:n
      \glet:cN
	{xfm_find_marker_ \l_keysetupiii_target_area_id_tlp - #2 :Nn}
	\keysetupiii_combine_boolean:Nn
     }
%    \end{macrocode}
%    
%    \begin{macrocode}
   \gdef:cpx {xfm_process_key_ #1-#2 :N}
      ##1
      {
       \if_tlp_eq:NN \l_keysetup_marker_id_tlp\c_empty_tlp
           \exp_not:N\xfm_append_keyval:nnN
           {#2}
       \else:
           \exp_not:N\xfm_linkappend_keyval:nnnnN
           {#2}
           {\l_keysetup_marker_id_tlp}
           {\l_keysetup_source_area_id_tlp}
       \fi:
           {\l_keysetup_target_area_id_tlp}
           ##1

       \tlp_eq:NNF \l_keysetupii_target_area_id_tlp \c_empty_tlp
         {
          \if_tlp_eq:NN \l_keysetupii_marker_id_tlp \c_empty_tlp
            \exp_not:N\xfm_append_keyval:nnN
              {#2}
          \else:
            \exp_not:N\xfm_linkappend_keyval:nnnnN
              {#2}
              {\l_keysetupii_marker_id_tlp}
              {\l_keysetupii_source_area_id_tlp}
          \fi:
              {\l_keysetupii_target_area_id_tlp}
              ##1
         }

       \tlp_eq:NNF \l_keysetupiii_target_area_id_tlp \c_empty_tlp
         {
          \if_tlp_eq:NN \l_keysetupiii_marker_id_tlp \c_empty_tlp
             \exp_not:N\xfm_append_keyval:nnN
              {#2}
          \else:
             \exp_not:N\xfm_linkappend_keyval:nnnnN
              {#2}
              {\l_keysetupiii_marker_id_tlp}
              {\l_keysetupiii_source_area_id_tlp}
          \fi:
              {\l_keysetupiii_target_area_id_tlp}
              ##1
         }
   }
 }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xfm_error_key:nn}
%    Raise an error when a required keyword (|#2|) in the front matter
%    structure |#1| is missing. Could and should give better help one
%    day.
%    \begin{macrocode}
\def:Npn \xfm_error_key:nn #1#2 {
  \PackageError{xfm}{Required~ keyword~`#2'~missing~ in~
     front~ matter~ structure~ `#1'}\@eha}
%    \end{macrocode}
% \end{macro}
%
%
% 
% 
% \subsubsection{Processing data of one author}
%
%
% \begin{macro}{\xfm_distribute_structure_data:nn}
%    This macro takes the reference to one author as an argument and
%    processes for this author all keywords specified in
%    |\g_xfm_author_keyword_order_tlp|, i.e., distributes their values
%    to appropriate title areas as specified by the keyword instance
%    (including references if requested).
%    \begin{macrocode}
\def:Npn \xfm_distribute_structure_data:nn #1#2 {
%    \end{macrocode}
%    Loop over the keyword names in |#1|
%    and\ldots
%    \begin{macrocode}
  \cntrl_for_loop:NcT
     \l_tmpa_tlp 
     {g_xfm_ #1 _keyword_order_tlp}
     {
%    \end{macrocode}
%    \ldots call for each keyword the command that holds the code to
%    distribute and manipulate the keyword value is present. This
%    command requires the authors property list so we construct it as
%    well.
%    \begin{macrocode}
     \tlp_eq:cNTF {xfm_process_key_ #1-\l_tmpa_tlp :N} \relax
%    \end{macrocode}
%    Runtime checking like this bad, should be checked in the template
%    code!\footnote{FIX!}
%    \begin{macrocode}
        { \PackageError{xfm}{Undeclared~ keyword:~ \l_tmpa_tlp}\@eha }
        {
          \use:cc{xfm_process_key_ #1-\l_tmpa_tlp :N}
                 {g_xfm_structure_ #2 _prop}
        }
    }
}
%    \end{macrocode}
% \end{macro}
%
% The macro
% |\xfm_process_key_|\meta{structure-name}|-|\meta{key-name}|:N| in
% the above loop is supposed to distribute the key value to a target
% area according to the specification given in the declaration for
% this key. This is done in one of two ways: the simple form simply
% adds the value as an element to an area and makes sure that it is
% properly separated by a separator function (as explained in the
% section on areas) --- this is done by calling
% |\xfm_append_keyval:nnN| with appropriate arguments.
%
% The more complicated form also
% handles linking the information with some other area by putting
% marker elements into both --- this is done by calling
% |\xfm_linkappend_keyval:nnnnN| with appropriate arguments.
%
% Some attempt was made to make these two macros independent of the
% particular |\author| key data structure. However, this isn't fully
% done so more work is needed if the macros should be usable on
% non-author property lists.
%
%
% \begin{macro}{\xfm_append_keyval:nnN}
%    The |\xfm_append_keyval:nnN| command takes three arguments: a key
%    name, a target area name, and a property list in which we look up
%    the key.
%    \begin{macrocode}
\def:Npn \xfm_append_keyval:nnN #1#2#3 {
%    \end{macrocode}
%    As a first step look up the key in the property list assuming
%    that the property list key is constructed from the key name by
%    prepending |\xfm_key_|. The result is stored in
%    |\g_xfm_result_tlp|.
%    \begin{macrocode}
  \prop_gget:NcN
     #3
     {xfm_key_#1}
     \g_xfm_result_tlp
%    \end{macrocode}
%    Check if we have found this key at all (otherwise we now have the
%    quark |\q_no_value| in |\g_xfm_result_tlp|):
%    \begin{macrocode}
  \quark_if_no_value:NTF \g_xfm_result_tlp
%    \end{macrocode}
%    If the key was not found we execute the code that was set up when
%    the key was registered. It will either be |\relax| or generate an
%    error if the key is required.
%    \begin{macrocode}
     { \use:c {xfm_missing_key_#1:} }
%    \end{macrocode}
%    If the key was found we add its value to the target area.
%    \begin{macrocode}
     { \xfm_add_element:nno {#2} {key!#1} \g_xfm_result_tlp }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\xfm_linkappend_keyval:nnnnN}
%    \begin{macrocode}
% key-name, marker-name, sourcearea-name, target-area-name, author-prop 
% #1      , #2         , #3                #4                #5


\def:Npn \xfm_linkappend_keyval:nnnnN #1#2#3#4#5 {
  \prop_gget:NcN
     #5
     {xfm_key_#1}
     \g_xfm_result_tlp

%    \end{macrocode}
%    If the key was specified we have a value in |\g_xfm_result_tlp|,
%    otherwise the key is missing and we may or may not have to do
%    something about that.
%    \begin{macrocode}
  \quark_if_no_value:NTF \g_xfm_result_tlp
%    \end{macrocode}
%    Do whatever is required if the key is missing token at this point
%    (the code is in the macro being constructed):
%    \begin{macrocode}
     { \use:c {xfm_missing_key_#1:} }
%    \end{macrocode}
%    
%    \begin{macrocode}
     {
      \tlp_set_eq:NN \l_xfm_result_tlp \q_no_value

      \prop_map:cc 
          {g_xfm_ #2 _prop}
          {xfm_find_marker_#4-#1:Nn}

      \quark_if_no_value:NT \l_xfm_result_tlp
%    \end{macrocode}
%    
%    Value does not exist, so make new mark:
%    \begin{macrocode}
        {
          \stepcounter{#2}
          \protected@xdef
             \g_xfm_resultiii_tlp { \use:c{the#2} }

%    \end{macrocode}
%    Next bit of code adds an entry to the property list
%    |#2|, this could be done manually which would be faster but less
%    understandable.
%
%    First start the value of the marker number and the text as two
%    brace groups in |\g_xfm_resultii_tlp|
%    \begin{macrocode}
          \tlp_gset:No 
             \g_xfm_resultii_tlp 
             { \exp_after:NN { \g_xfm_resultiii_tlp } }
          \tlp_gput_right:No
             \g_xfm_resultii_tlp 
             { \exp_after:NN { \g_xfm_result_tlp } }
%    \end{macrocode}
%    Then put all of that into the property list:
%    \begin{macrocode}
          \prop_gput:cco
             {g_xfm_ #2 _prop}
             {mark-\the\value{#2}}
             \g_xfm_resultii_tlp

%    \end{macrocode}
%    
%    \begin{macrocode}
          \xfm_add_element:nno {#4} {marker!#2} \g_xfm_resultiii_tlp

          \xfm_add_element:nno {#4} {key!#1} \g_xfm_result_tlp

        }
%    \end{macrocode}
%    At this point the mark reference is definitely in
%    |\l_xfm_result_tlp| so we can append it to the
%    to the source area.
%    \begin{macrocode}

      \xfm_add_element:nno {#3} {marker!#2} \g_xfm_resultiii_tlp

     }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\g_xfm_result_tlp}
% \begin{macro}{\g_xfm_resultii_tlp}
% \begin{macro}{\g_xfm_resultiii_tlp}
% \begin{macro}{\l_xfm_result_tlp}
%    Some temporary storage bins three globally used one locally (but
%    this is mainly a historical fact.
%    \begin{macrocode}
\tlp_new:Nn\g_xfm_result_tlp{}
\tlp_new:Nn\g_xfm_resultii_tlp{}
\tlp_new:Nn\g_xfm_resultiii_tlp{}
\tlp_new:Nn\l_xfm_result_tlp{}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\xfm_find_marker:Nn}
%    \begin{macrocode}
%    This bit of code finds an already existing marker with a value
%    equal to the text stored in |\g_xfm_result_tlp|.
%    \begin{macrocode}
\def:Npn \xfm_find_marker:Nn #1 #2 {
  \tlp_gset:No \g_xfm_resultii_tlp  { \use_choice_ii:nn #2 }
  \tlp_gset:No \g_xfm_resultiii_tlp { \use_choice_i:nn  #2 }
  \tlp_eq:NNT \g_xfm_result_tlp\g_xfm_resultii_tlp
    { \tlp_set:Nn \l_xfm_result_tlp {#1}
      \let:NN \prop_map_funct:Nn \use_none:nn
    }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \subsection{Remaining Document Commands}
%
%
%
% \begin{macro}{\xfm_structure_loop:n}
% \begin{macro}{\xfm_structure_loop:nN}
%    |\xfm_structure_loop:n| loops through an structure queue (i.e.,
%    |\g_xfm_#1_queue|) and applies
%    |\xfm_distribute_structure_data:nn{#1}| to each structure element
%    in the queue.
%
%    |\xfm_structure_loop:nN| is the variant that needs to be used if
%    the queue name is not standard (i.e., not the one corresponding
%    to the structure), for example, during sorting.
%    \begin{macrocode}
\def:Npn \xfm_structure_loop:n #1 {
  \xfm_structure_loop:cn
     {g_xfm_ #1 _queue}
     {#1}
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def:Npn \xfm_structure_loop:cn {\exp_args:Nc \xfm_structure_loop:Nn}
\def:Npn \xfm_structure_loop:Nn #1#2 {
  \queue_map:Nn
    #1
    { \xfm_distribute_structure_data:nn{#2}{##1} }
%    \end{macrocode}
%    A bit of debugging (at the moment):
%    \begin{macrocode}
  \XFMShowAreas
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
% \subsection{Algorithm for sorting by address}
% 
% The author numbers are stored in a queue which at the start simply
% contains the numbers $1$ to $n$ if we have $n$ authors in the preamble
% specified.
% 
% The algorithm works on this queue in the following way:
% \begin{itemize}
% \item Check if the |authors| queue is empty; if so processing stops.
% \item Otherwise remove the first element from the |authors| queue and
%   retrieve its address and store its value in |curr-address|.
% \item Store the element as the first element of the queue
%   |curr-queue|.
% \item Clear the queue |remaining-authors|.
% \item Set the counter |author-cnt| to 1.
% \item Now loop through the remainder of the queue |authors| and do the
%   following:
%   \begin{itemize}
%   \item If for the current element the address is the same as
%     |cur-address| append the current element to |curr-queue| and
%     advance |author-cnt| by one.
%   \item Otherwise append the current element to the queue
%     |remaining-authors|.
%   \end{itemize}
% \item Replace the contents of the |authors| queue by the contents of
%   the |remaining-authors| queue.
% \end{itemize}
% At this point in time we have the following situation:
% \begin{itemize}
% \item Queue |curr-address| contains the current address.
% \item Tlp |curr-queue| contains the authors having this address.
% \item |author-cnt| contains the number of authors in this queue
% \item Queue |authors| contains the remaining authors having addresses
%   not yet processed.
% \end{itemize}
% This means that we can now format the authors in |curr-queue| and then
% restart the algorithm processing any remaining authors started in the
% |authors| queue.
% 
% \subsubsection{Processing the \texttt{curr-queue}}
% 
% The authors in |curr-queue| will be processed in the normal way, i.e.,
% by looping through all keywords of interest (with the exception of
% |address| since that is the same for all authors in the queue) and
% appending their values to appropriate areas.
% 
% As a result we will get:
% \begin{itemize}
% \item The authors names followed by any labels in
%   |\g_xfm_authors_list_tlp|.
% \item The address still in |curr-address|.
% \item Any other keyword values the desired area lists, e.g., if
%   |thanks| is moved to the |footnote-area| its value will be appended
%   there in the form
% \begin{verbatim}
%   \xfm_format_key_thanks:nn{<label-number>}{<text>}
% \end{verbatim}
%   allowing further formatting at this point as desired.
% \end{itemize}
% 
% By default we only append data to the areas. This means that if an
% area is to be intended to belong solemnly to the group of authors
% currently processed (i.e., those in |curr-queue|) then it is the
% responsibility the processing code to clear those areas.
% 
% For example, if the layout is to be something like this:
% \begin{verbatim}
%    <Author1>, <Author2>, and <Author3>
% 
%    <Main address for all authors above>
%    <data special to individual authors referenced via labels>
% 
%    <Author4>, ...
% \end{verbatim}
% then the area receiving the ``special data'' needs to be cleared after
% processing to avoid that its contents shows up again below
% |<Author4>|. On the other hand, data going into the footnote area does
% not need this treatments since the latter area is processed only once
% at the very end.
% 
% 
%
%
% \begin{macro}{\g_xfm_curr_sort_queue}
% \begin{macro}{\g_xfm_remaining_sort_queue}
%    Two queues are used when sorting some queue by a key:
%    |\g_xfm_curr_sort_queue| receives elements matching the current
%    key value while |\g_xfm_remaining_sort_queue| receives those
%    which do not match and need further processing at a later
%    stage.
%    \begin{macrocode}
\queue_new:N\g_xfm_curr_sort_queue
\queue_new:N\g_xfm_remaining_sort_queue
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\g_xfm_curr_sort_value_tlp}
%    In |\g_xfm_curr_sort_value_tlp| we store the value of a key when
%    doing sorting by this key.
%    \begin{macrocode}
\tlp_new:Nn \g_xfm_curr_sort_value_tlp{}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\xfm_structure_sorted_by:nnn}
%    \begin{macrocode}
\def:Npn \xfm_stucture_sorted_by:nnn #1#2 {
   \xfm_structure_sorted_by:ccnnn
     {g_xfm_ #1 _queue}
     {xfm_key_ #2}
     {#1}
     {#2}
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xfm_structure_sorted_by:NNnnn}
%    The |\xfm_structure_sorted_by:NNnnn| macro takes formatting
%    instructions as its argument: those which should be processed
%    when all authors with a certain address have been found.
%    \begin{macrocode}
\def:Npn \xfm_structure_sorted_by:ccnnn 
         {\exp_args:Ncc\xfm_structure_sorted_by:NNnnn}
\def:Npn \xfm_structure_sorted_by:NNnnn #1#2#3#4#5 {
%    \end{macrocode}
%    We start by looking if the queue |#1| is empty,
%    if so we have done all that is needed and return immediately
%    (this ends the recursive call below).
%    \begin{macrocode}
  \queue_empty:NTF #1
    {}
%    \end{macrocode}
%    Otherwise we prepare for finding the next batch of authors with
%    the same address. For this we clear the queue
%    |\g_xfm_curr_sort_queue| which will receive all authors found.
%    The queue |\g_xfm_remaining_sort_queue| doesn't need clearing
%    since it is empty at this point (see below).
%    \begin{macrocode}
    {
     \queue_gclear:N \g_xfm_curr_sort_queue
%    \end{macrocode}
%    Then we pop the top element from |#1| and store
%    the result in |\g_xfm_result_tlp| and also put it into the queue
%    |\g_xfm_curr_sort_queue|.
%    \begin{macrocode}
     \queue_gpop:NN
       #1
       \g_xfm_result_tlp
     \queue_gadd:No
       \g_xfm_curr_sort_queue
       \g_xfm_result_tlp
%    \end{macrocode}
%    Next step is to retrieve the keyword value for this structure and
%    store it in |\g_xfm_curr_sort_value_tlp|.
%    \begin{macrocode}
     \prop_gget:cNN
       {g_xfm_structure_ \g_xfm_result_tlp _prop}
       #2
       \g_xfm_curr_sort_value_tlp

%    \end{macrocode}
%    If the key was not in we have a problem (perhaps the solution is
%    to make this key required if you want to sort by it :-) --- have
%    to think it through, for the moment we just balk.
%    \begin{macrocode}
     \quark_if_no_value:NT
        \g_xfm_curr_sort_value_tlp
        {
         \PackageError{xfm}{Keyword~ `#4'~ for~ sorting~ missing~ in~
           structure~ `#3'}\@eha
         \tlp_gset:Nn \g_xfm_curr_sort_value_tlp {<MISSING~KEY>}
        }
%    \end{macrocode}
%    Since we have found the first author for this address we set the
%    |\g_xfm_structure_int| to 1.
%    \begin{macrocode}
     \int_gset:Nn \g_xfm_structure_int \c_one
%    \end{macrocode}
%    Now we loop through the remaining elements in the queue
%    |#1| each time determining whether or not the
%    element under inspection has the same address as stored in
%    |\g_xfm_curr_sort_value_tlp| and if so add it to
%    |\g_xfm_curr_sort_queue|. Otherwise we add it to the queue
%    |\g_xfm_remaining_sort_queue|. This is done by mapping
%    |\xfm_find_key_value:Nn#2| over the queue |#1|.
%    \begin{macrocode}
     \queue_map:Nn
       #1
       { \xfm_find_key_value:Nn #2 {##1} }
%    \end{macrocode}
%    Once we are finished with this we can move the authors from the
%    |\g_xfm_remaining_sort_queue| back to |#1|
%    for the next iteration. After that this temporary queue can be
%    cleared.
%    \begin{macrocode}
     \glet:NN #1 \g_xfm_remaining_sort_queue
     \queue_gclear:N \g_xfm_remaining_sort_queue
%    \end{macrocode}
%    A bit debugging stuff at this point:
%    \begin{macrocode}
%<*trace>
     \cs_show:N \g_xfm_curr_sort_queue
     \cs_show:N #1
%</trace>
%    \end{macrocode}
%    Now we loop through all the elements in |\g_xfm_curr_sort_queue|
%    and distribute their key values into the appropriate areas.
%    \begin{macrocode}
     \xfm_structure_loop:Nn
       \g_xfm_curr_sort_queue
       {#3}
%    \end{macrocode}
%
%    The\marginpar{WRONG: this is still done correctly only for
%    addresses area and address keyword!!! FIXME} 
%    next bit of code isn't really as it should be (I guess) but
%    we have a problem here: if |value-combine-boolean| was set to |false|
%    for the |address| key we end up with the current address several
%    times in the |\g_xfm_addresses_list_tlp| which makes the |address|
%    area basically unusable.
%
%    But why use this area in the first place and not
%    |\g_xfm_curr_sort_value_tlp| which contains the current address?
%    Well, for one we can have the situation that alternate addresses
%    should also go into that area, perhaps mixed with emails etc. But
%    this only makes sense if the |address| key is set up in a way
%    that it appears only once, i.e., if |value-combine-boolean| for it is
%    set to |true|.
%
%    So the current logic is as follows:
%    \begin{itemize}
%    \item
%      If |value-combine-boolean| is |false| for the key used in
%      sorting then the 
%      current key value will be the only text appearing the
%      corresponding target area; if any other keys contribute to that
%      area --- 
%      tough, their values get overwritten.
%    \item
%      Otherwise keys are distributed into any area in the normal
%      fashion.
%    \end{itemize}
%    First we store the target-area of the sort key in
%    |\g_xfm_curr_target_area_tlp| since it is needed several times below.
%    \begin{macrocode}
    \tlp_gset:Nx \g_xfm_curr_target_area_tlp
         { \use:c {xfm_target_area_ #3-#4 _tlp} }
%    \end{macrocode}
%    
%    The status of the |value-combine-boolean| key for current sort
%    key can be found by looking at
%    |\xfm_find_marker_|\meta{target-area}|-|\meta{sort-key}|:Nn|. If
%    it equals |\use_none:nn|, then we haven't
%    been asked to combine values for this key.
%    \begin{macrocode}
    \cs_eq:cNT {xfm_find_marker_ \g_xfm_curr_target_area_tlp -#4 :Nn}
               \use_none:nn
%    \end{macrocode}
%    So this is the case when we overwrite whatever was added to
%    |\g_xfm_|\meta{target-area}|_list_tlp| and replace it by a single
%    value and its separator function:
%    \begin{macrocode}
      {
       \tlp_gset:cx {g_xfm_ \g_xfm_curr_target_area_tlp _list_tlp}
         {
           \exp_not:N
           \xfm_area_sep:nnn   {\g_xfm_curr_target_area_tlp} {START}{key!#4}
           \exp_not:N
           \xfm_area_value:nnn {\g_xfm_curr_target_area_tlp} {key!#4}
         }
%    \end{macrocode}
%    Adding the actual value is done in a separate step since we can't
%    use |\xdef| with unknown data.
%    \begin{macrocode}
       \tlp_gput_right:co
         { g_xfm_ \g_xfm_curr_target_area_tlp _list_tlp }
         { \exp_after:NN { \g_xfm_curr_sort_value_tlp } }
      }
%    \end{macrocode}
%
%    So finally we are ready to do some formatting:
%    \begin{macrocode}
     #5
%    \end{macrocode}
%    And then recourse if necessary:
%    \begin{macrocode}
     \xfm_structure_sorted_by:NNnnn #1 #2 {#3} {#4} {#5}
    }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\xfm_find_key_value:Nn}
%    The |\xfm_find_key_value:Nn| is the code that tries to find elements
%    with the same key value as the one given in
%    |\g_xfm_curr_sort_value_tlp|. The first argument is the internal
%    key and the second is a pointer to a
%    structure property list name as we store it in the structure queues.
%    \begin{macrocode}
\def:Npn \xfm_find_key_value:Nn #1#2 {
%    \end{macrocode}
%    First we retrieve the key value for the current element and
%    store it in |\g_xfm_result_tlp|.
%    \begin{macrocode}
  \prop_gget:cNN
    {g_xfm_structure_ #2 _prop}
    #1
    \g_xfm_result_tlp
%    \end{macrocode}
%    If this value corresponds to what is stored in
%    |\g_xfm_curr_sort_value_tlp| we add the current element to the
%    |\g_xfm_curr_sort_queue| queue and increment the counter
%    counting the number of elements found.
%    \begin{macrocode}
  \tlp_eq:NNTF \g_xfm_result_tlp \g_xfm_curr_sort_value_tlp
    {
     \int_gincr:N \g_xfm_structure_int
     \queue_gadd:Nn \g_xfm_curr_sort_queue {#2}
    }
%    \end{macrocode}
%    Otherwise we add the current element to the the queue of remaining
%    elements, i.e., |\g_xfm_remaining_sort_queue|.
%    \begin{macrocode}
    {
     \queue_gadd:Nn \g_xfm_remaining_sort_queue {#2}
    }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \section{Stuff}
%
%
%
%
%    
%    \begin{macrocode}
\def:Npn \NoValue{-NoValue-}
%    \end{macrocode}
%
%
%    \begin{macrocode}
\DeclareTemplateType{titlesetup}{0}

\DeclareTemplate{titlesetup}{authorbyaddress}{0}{
   authorinfo-keyword-list  =+f0 \g_xfm_authorinfo_keyword_order_tlp,
   articleinfo-keyword-list =+f0 \g_xfm_articleinfo_keyword_order_tlp,
   top-areas-list           =+f0 \g_xfm_top_areas_tlp,
   author-areas-list        =+f0 \g_xfm_authors_areas_tlp,
   bottom-areas-list        =+f0 \g_xfm_bottom_areas_tlp,
   footins-areas-list       =+f0 \g_xfm_footins_areas_tlp,
   end-areas-list           =+f0 \g_xfm_end_areas_tlp,
   title-post-v-skip        =+L  \g_xfm_title_postvskip_tlp,
 }
 {

   \tlp_gset:Nn \g_xfm_authorinfo_keyword_order_tlp {name,address,thanks}
   \tlp_gset:Nn \g_xfm_articleinfo_keyword_order_tlp{title,subtitle,thanks}

   \tlp_gclear:N \g_xfm_footins_areas_tlp
   \tlp_gclear:N \g_xfm_end_areas_tlp

   \tlp_gset_eq:NN \g_xfm_title_postvskip_tlp \z@

   \DoParameterAssignments

   \xfm_structure_loop:n {articleinfo}

   \null % right start?

   \xfm_typeset_area_list:o \g_xfm_top_areas_tlp

   \xfm_stucture_sorted_by:nnn
     {authorinfo}
     {address}
     { \xfm_typeset_area_list:o \g_xfm_authors_areas_tlp  }

   \xfm_typeset_area_list:o \g_xfm_bottom_areas_tlp

   \xfm_typeset_insertion_area_list:oN 
     \g_xfm_footins_areas_tlp
     \footins

   \vskip \g_xfm_title_postvskip_tlp \scan_stop:

   \AtEndDocument{ \xfm_typeset_area_list:o\g_xfm_end_areas_tlp }
 }




\DeclareTemplate{titlesetup}{std}{0}{
   authorinfo-keyword-list  =+f0 \g_xfm_authorinfo_keyword_order_tlp,
   articleinfo-keyword-list =+f0 \g_xfm_articleinfo_keyword_order_tlp,
   top-areas-list           =+f0 \g_xfm_top_areas_tlp,
   footins-areas-list       =+f0 \g_xfm_footins_areas_tlp,
   end-areas-list           =+f0 \g_xfm_end_areas_tlp,
   lhead-areas-list         =+f0 \g_xfm_lhead_areas_tlp,
   rhead-areas-list         =+f0 \g_xfm_rhead_areas_tlp,
   title-post-v-skip        =+L  \g_xfm_title_postvskip_tlp,
 }
 {

   \tlp_gset:Nn\g_xfm_authorinfo_keyword_order_tlp{name,address,thanks}
   \tlp_gset:Nn\g_xfm_articleinfo_keyword_order_tlp{title,subtitle,thanks}

   \let\g_xfm_top_areas_tlp\@empty
   \let\g_xfm_footins_areas_tlp\@empty
   \let\g_xfm_end_areas_tlp\@empty
   \let\g_xfm_lhead_areas_tlp\@empty
   \let\g_xfm_rhead_areas_tlp\@empty

   \let\g_xfm_title_postvskip_tlp\z@

   \DoParameterAssignments

   \xfm_structure_loop:n {articleinfo}
   \xfm_structure_loop:n {authorinfo}

   \null % right start?

   \xfm_typeset_area_list:o \g_xfm_top_areas_tlp

   \xfm_typeset_insertion_area_list:oN 
     \g_xfm_footins_areas_tlp
     \footins

   \vskip \g_xfm_title_postvskip_tlp \scan_stop:

   \AtEndDocument{ \xfm_typeset_area_list:o\g_xfm_end_areas_tlp } 
 }

%    \end{macrocode}
%    
%    
%    \begin{macrocode}
\def:Npn \maketitle{
  \UseInstance{titlesetup}{maketitle}
}
%    \end{macrocode}
%    
%    
%    \begin{macrocode}
\def:Npn \xfm_typeset_area_list:o #1 {
  \cntrl_for_loop:Non \l_tmpb_tlp {#1}
    {
      \IfExistsInstanceTF{textarea}\l_tmpb_tlp
      { \UseInstance{textarea}\l_tmpb_tlp }
      \relax
    }
}
%    \end{macrocode}
%    
%    
%    \begin{macrocode}
\def:Npn \xfm_typeset_insertion_area_list:on #1#2 {
  \cntrl_for_loop:Non \l_tmpb_tlp {#1}
    {
     \IfExistsInstanceTF{textarea}\l_tmpb_tlp
      {
       \tlp_eq:cNF {g_xfm_ \l_tmpb_tlp _list_tlp}
                   \c_empty_tlp
% actually here we would need to test for required area perhaps???
                   { \insert #2 
                             { \UseInstance{textarea}\l_tmpb_tlp }
           }
      }
      \relax
    }
}


%    \end{macrocode}
%    
%    now where is this used? (document)
%    \begin{macrocode}
%--------START-----------
\def:Npn \XFMSplitOnComma #1#2#3 {
  \glet:NN \xfm_split_code \c_empty_tlp
  \cntrl_for_loop:Non \l_tmpa_tlp {#1}
    {
     \exp_after:NN \xfm_split_code
     \exp_after:NN #3\exp_after:NN {\exp_after:NN \ignorespaces\l_tmpa_tlp}
     \gdef\xfm_split_code{#2}
    } 
}

%    \end{macrocode}
%    
%    
%    \begin{macrocode}

\newcommand*\UseBBskip[1]
  {  \ifhmode
       \par
     \fi
     \setlength\@tempskipa{#1 - \parskip - \baselineskip}
     \vskip\@tempskipa
  }
%    \end{macrocode}
%    
%    \begin{macrocode}


% #1 value-target-area
% #2 text-type (keyword)
% #3 marker-name
% #4 value picked up

\def:Npn \dothanks #1#2#3#4 {
  \stepcounter{#3}
  \protected@xdef
    \g_xfm_resultiii_tlp { \cs:w the#3 \cs_end: }

  \xfm_add_element:nno {#1} {marker!#3} \g_xfm_resultiii_tlp

  \xfm_add_element:nnn {#1} {key!#2} {#4}

  \xfm_area_sep:nnn   \l_textarea_id_tlp {SUB} {marker!#3}
  \xfm_area_value:nnn \l_textarea_id_tlp {marker!#3} \g_xfm_resultiii_tlp 
  \xfm_area_sep:nnn   \l_textarea_id_tlp {marker!#3} {SUB}
}

%    \end{macrocode}
%    
% \begin{macro}{\DeclareFMStructure}
%    \begin{macrocode}
\def:Npn \DeclareFMStructure #1#2{
 \UseTemplate{structuresetup}{std}
   {#2}{#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{structuresetup (template type)}
%    \begin{macrocode}
\DeclareTemplateType{structuresetup}{1}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{structuresetup/std (template)}
%    \begin{macrocode}
\DeclareTemplate{structuresetup}{std}{1}{
  accepted-keyword-list =f0 \l_structuresetup_accepted_list_tlp,
 }
 {
  \tlp_clear:N \l_structuresetup_accepted_list_tlp

  \DoParameterAssignments

  \def:cpn {#1} ##1 {
    \int_gincr:N \g_xfm_structure_int
    \prop_new:c
       {g_xfm_structure_ \int_use:N\g_xfm_structure_int _prop}
    \queue_gadd:co
       {g_xfm_ #1 _queue}
       {\int_use:N\g_xfm_structure_int}
    \setkeys{xfm-#1}{##1}
  }
  \queue_new:c {g_xfm_ #1 _queue}

%    \end{macrocode}
%    The way it is now the contents of |\l_structuresetup_accepted_list_tlp|
%    needs to be a comma separated list \emph{without} blanks. In
%    practise this probably needs to be allowed since normally blanks
%    are ignored in templates.\footnote{FIX}
%    \begin{macrocode}
  \cntrl_for_loop:Non \l_tmpa_tlp \l_structuresetup_accepted_list_tlp
     {
      \glet:cN
         { KV@xfm-#1@ \l_tmpa_tlp }
         \xfm_structure_parse_keyword_code:n
%    \end{macrocode}
%    The above ensures that the keyword will get parsed properly and
%    the one below ensures that by default we do nothing with it
%    during processing.
%    \begin{macrocode}
      \glet:cN
         { xfm_process_key_ #1-\l_tmpa_tlp :N }
         \use_none:n
    }
 }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}



% use: \xfm_gget_object_count:nN {name}\g_xfm_author_cnt_tlp

\def:Npn \xfm_gget_object_count:nnN #1#2#3 {
  \begingroup
    \int_set:Nn \l_tmpa_int\z@
    \def:Npn \l_tmpa_tlp {key!#2}
    \let:NN  \xfm_area_sep:nnn\use_none:nnn
    \def:Npn \xfm_area_value:nnn ##1##2##3 {
      \def:Npn \l_tmpb_tlp {##2}
      \tlp_eq:NNT \l_tmpa_tlp\l_tmpb_tlp
                  { \int_incr:N \l_tmpa_int }
    }
    \tlp_use:c {g_xfm_ #1 _list_tlp}
    \tlp_gset:Nx #3 {\int_use:N \l_tmpa_int}
  \endgroup
}

\tlp_new:Nn \g_xfm_author_cnt_tlp {0}

\int_new:N  \l_xfm_typeset_objects_cnt
\int_set:Nn \l_xfm_typeset_objects_cnt{0}

\def:Npn \FMAuthorSeparation {
  \ifnum \g_xfm_author_cnt_tlp = \z@
    \xfm_gget_object_count:nnN{authors}{name}\g_xfm_author_cnt_tlp
    \l_xfm_typeset_objects_cnt\@ne
  \else
    \advance\l_xfm_typeset_objects_cnt\@ne
  \fi
  \ifnum \l_xfm_typeset_objects_cnt = \g_xfm_author_cnt_tlp \relax
    \ifcase \l_xfm_typeset_objects_cnt
    \or
    \or   % =2
       \space and~
    \else
       ,~ and~
    \fi
    \global\let\g_xfm_author_cnt_tlp\z@
  \else
    ,~
  \fi
}


% note that spaces at the arguments' edges will vanish unless
% explicitly given as |\space| not |~| this is due to the template
% getting rid of them on either side (i think, not checked)

\DeclareTemplateType{XFMobjectsep}{0}
\DeclareTemplate{XFMobjectsep}{std}{0}{
  area-id     =f0 \objectsep_area_tlp,
  keyword-id  =f0 \objectsep_keyword_tlp,
  first-action       =f0 \objectsep_first_action,
  medial-action      =f0 \objectsep_medial_action,
  last-of-two-action =f0 \objectsep_lastoftwo_action,
  last-action        =f0 \objectsep_last_action,
 }
 {

  \DoParameterAssignments

%\traceon

  \ifnum \g_xfm_author_cnt_tlp = \z@
    \exp_after:NN 
    \xfm_gget_object_count:nnN
    \exp_after:NN 
        \objectsep_area_tlp
    \exp_after:NN 
        {\objectsep_keyword_tlp}
        \g_xfm_author_cnt_tlp
    \l_xfm_typeset_objects_cnt\@ne
    \objectsep_first_action
  \else
    \advance\l_xfm_typeset_objects_cnt\@ne

    \ifnum \l_xfm_typeset_objects_cnt = \g_xfm_author_cnt_tlp \relax
      \ifcase \l_xfm_typeset_objects_cnt
      \or
      \or   % =2
	 \objectsep_lastoftwo_action
      \else
	 \objectsep_last_action
      \fi
      \global\let\g_xfm_author_cnt_tlp\z@
    \else
      \objectsep_medial_action
    \fi
  \fi
 }
%    \end{macrocode}

%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \endinput
\endinput
%
% $Log$
% Revision 1.40  2004/11/13 21:59:29  mittelba
% new license (LPPL)
%
% Revision 1.39  2004/09/18 10:04:23  mittelba
% cleanup using expl3 --- not finished
%
% Revision 1.38  2001/07/24 20:38:38  latex3
% use \InternalSyntaxOn now
%
% Revision 1.37  2001/06/24 20:01:38  latex3
% removed \_for definition
%
% Revision 1.36  2001/06/16 16:45:48  latex3
% converted to :_ syntax
%
% Revision 1.34  2001/05/11 07:14:19  latex3
% added a \null on top of page
%
% Revision 1.33  2001/05/10 21:02:34  latex3
% a bit additional maketitle handling
%
% Revision 1.32  2001/05/07 13:45:19  latex3
% some updating to sorted@by alogrithm (needs further work)
%
% Revision 1.31  2001/05/07 10:19:41  latex3
% added some tracing to element formatting an separation
%
% Revision 1.30  2001/05/07 08:45:43  latex3
% made value-combine-boolean depended on the marker used (not sure if
% the whole thing needs rewriting ...)
%
% Revision 1.29  2001/05/06 18:01:49  latex3
% extended keyword setup to distribute to three areas
% some cleanup
% added draft for "plain" title template
%
% Revision 1.28  2001/05/06 12:28:18  latex3
% now support formatting of values via \DeclareFMObjectFormat
%
% Revision 1.27  2001/05/05 19:31:10  latex3
% use \UseTemplate instead of ANONYMOUS instances
%
% Revision 1.26  2001/05/05 14:46:40  latex3
% lot of keyword renamings
%
% Revision 1.25  2001/04/29 21:07:13  latex3
% added further logic to text areas allowing runin headings and other
% frills
%
% Revision 1.24  2001/04/27 16:43:09  latex3
% after before attempting to distribute key values to several areas
%
% Revision 1.23  2001/04/27 10:13:39  latex3
% before attempting to distribute key values to several areas
%
% Revision 1.22  2001/04/27 07:52:06  latex3
% end of days work, one hour after midnight
%
% Revision 1.21  2001/04/26 21:07:58  latex3
% \DeclareFMStructure added
% sorting generalised
%
% Revision 1.20  2001/04/26 14:58:12  latex3
% started with a maketitle template
%
% Revision 1.19  2001/04/15 08:27:18  latex3
% more author data documentation
%
% Revision 1.18  2001/04/14 12:38:59  latex3
% documentation for title markers
%
% Revision 1.17  2001/04/14 09:54:15  latex3
% area documentation
%
% Revision 1.16  2001/04/13 15:23:16  latex3
% further code cleanup and document
% version before introducing \xfm@add@element@nno in the code
%
% Revision 1.15  2001/04/12 08:15:48  latex3
% used separate key (on maketitle) to denote keyword order when
% processing authors
%
% Revision 1.14  2001/04/12 07:39:24  latex3
% fixed author counting when doing sort by address
%
% Revision 1.13  2001/04/08 21:19:25  latex3
% first attempt to get sorting by address to work in real life
%
% Revision 1.12  2001/04/07 16:58:10  latex3
% some code cleanup, some more documentation
% added the possibility to have \thanks and the like within other
% keyword values
%
% Revision 1.11  2001/04/06 20:24:40  latex3
% more documentation, being burned by having lost the afternoons work
% we save more often :-(
%
% Revision 1.10  2001/04/06 19:11:53  latex3
% let's save some documentation
%
% Revision 1.9  2001/04/06 15:45:36  latex3
% *** empty log message ***
%
% Revision 1.8  2001/04/05 14:23:40  latex3
% first attempt to solve the author-and issue
% some code cleanup
%
% Revision 1.7  2001/04/05 11:00:52  latex3
% started to add area element separator code
%
% Revision 1.6  2001/04/05 09:20:19  latex3
% support combining key values in areas
%
% Revision 1.5  2001/04/03 20:28:43  latex3
% more templates, more generalisation ('orrible results :-)
%
% Revision 1.4  2001/04/02 06:46:45  latex3
% first template approach for author keys
%
% Revision 1.3  2001/04/01 13:33:34  latex3
% sort by address works first time
%
% Revision 1.2  2001/04/01 09:24:20  latex3
% now we can do at least author block followed by address block with all
% other data distributed appropriately to whatever area is desired (eg
% thanks area etc.)
%

% \endinput



%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{}
%    \begin{macrocode}


%
%
% \begin{macro}{}
%    \begin{macrocode}

%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
