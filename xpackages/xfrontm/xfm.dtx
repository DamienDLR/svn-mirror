% \iffalse
%%
%% (C) Copyright 2001 Frank Mittelbach
%% All rights reserved.
%%
%% Not for general distribution. In its present form it is not allowed
%% to put this package onto CD or an archive without consulting the
%% the authors.
%% 
%    \begin{macrocode}
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{
%<*dtx>
  \ProvidesFile{#2.dtx}
%</dtx>
%<package>\ProvidesPackage{#2}
%<driver>\ProvidesFile{#2.drv}
  [#4 #3 #8 (#6)]}
\next$Id$
       {multiple marks}
\iffalse
%    \end{macrocode}
%
%<*driver>
 \documentclass{ltxdoc}
%
 \begin{document}
 \DocInput{xfm.dtx}
 \end{document}
\fi
%</driver>
%
% \fi
%
%
% \GetFileInfo{xfm.dtx}
%
% \title{The \textsf{xfm} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi}
% \date{\filedate}
%
%  \maketitle
%
% \tableofcontents
%
%
%
% \section{Intro}
%
%
%    \begin{macrocode}
\RequirePackage{ldcsetup}
\RequirePackage{xtools}
\RequirePackage{template}
\IgnoreWhiteSpace
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \tlp@gset@cn #1{\global\@namedef{#1}}

\def \tlp@gput@right@No #1#2 {
  \expandafter \tlp@gput@right@Nn \expandafter #1 \expandafter { #2 }}

\def \queue@if@in@NoTF #1#2{\expandafter \queue@if@in@NnTF
                            \expandafter #1 \expandafter {#2}}

\def \queue@map@NN #1#2{
  \let \queue@map@funct@n #2
  \expandafter\queue@map@aux@w #1\queue@elt\q@stop\queue@eelt}
\def \queue@map@aux@w \queue@elt#1\queue@eelt{
  \ifx #1\q@stop \else
    \queue@map@funct@n {#1}
    \expandafter\queue@map@aux@w
  \fi}

\def \queue@empty@NTF #1 {
  \ifx#1\@empty
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
}

\def \prop@gput@Nco #1#2#3{
  \expandafter\prop@gput@NNn \expandafter #1 
                          \csname #2 \expandafter \endcsname
                          \expandafter { #3 } }

\def \prop@gput@cNo #1{
  \expandafter\prop@gput@NNo \csname #1\endcsname
}
%    \end{macrocode}
%
%
%
%
%
%
%    \begin{macrocode}
\newcount\xfm@authors

\def\author#1#2{
  \advance\xfm@authors\@ne
  \prop@new@c 
     {xfm@author@\the\xfm@authors}
  \prop@gput@cNn  
     {xfm@author@\the\xfm@authors}
     \xfm@key@name
     {#1}
  \queue@gadd@No
     \xfm@authors@queue
     {\the\xfm@authors}
  \setkeys{xfm}{#2}
}

\queue@new@N\xfm@authors@queue

% this is what we could have done via \define@key ...
% one argument implicit (picked up by |\prop@gput@ccn|)
%
%\def \xfm@author@keyword@code@n #1 {
\def \xfm@author@keyword@code@n {
  \prop@gput@ccn  
     {xfm@author@\the\xfm@authors}
     {xfm@key@\@tempa}
%     {#1}
}


%    \end{macrocode}
%    
%    \begin{macrocode}

\tlp@new@Nn\xfm@result@tlp{}
\tlp@new@Nn\xfm@resultii@tlp{}
\tlp@new@Nn\xfm@resultiii@tlp{}
\tlp@new@Nn\xfm@resultiv@tlp{}



% author-prop, key, key-format, missing-key-action,
% #1           #2   #3          #4              
%
% target-tlp,              marker-counter
% #5           #6          #7         
%
%
\def\distribute@author@key@NNNNNN #1#2#3#4#5#6#7#8#9 {
  \prop@get@NNN
     #1
     #2
     \xfm@result@tlp

%    \end{macrocode}
%    If the key was specified we have a value in |\xfm@result@tlp|,
%    otherwise the key is missing and we may or may not have to do
%    something about that.
%    \begin{macrocode}
  \quark@if@no@value@NTF \xfm@result@tlp
%    \end{macrocode}
%    Do whatever is required if the key is missing (this is a single
%    token at this point!)
%    \begin{macrocode}
     #4
%    \end{macrocode}
%    
%    \begin{macrocode}
     {
      \let\xfm@resultii@tlp\q@no@value

      \prop@map@cN 
          {xfm@ #7 @prop}
          #5

      \quark@if@no@value@NT \xfm@resultii@tlp
%    \end{macrocode}
%    
%    Value does not exist, so make new mark:
%    \begin{macrocode}
        {
          \stepcounter{#7}
          \protected@edef
             \xfm@resultiv@tlp { \csname the#7 \endcsname }

%    \end{macrocode}
%    Next bit of code adds an entry to the property list
%    |#7|, this could be done manually which would be faster but less
%    understandable.
%
%    First start the value of the marker number and the text as two
%    brace groups in |\xfm@resultiii@tlp|
%    \begin{macrocode}
          \tlp@gset@No 
             \xfm@resultiii@tlp 
             { \expandafter { \xfm@resultiv@tlp } }
          \tlp@gput@right@No
             \xfm@resultiii@tlp 
             { \expandafter { \xfm@result@tlp } }
%    \end{macrocode}
%    Then put all of that into the property list:
%    \begin{macrocode}
          \prop@gput@cco
             {xfm@ #7 @prop}
             {mark-\the\value{#7}}
             \xfm@resultiii@tlp

%    \end{macrocode}
%    
%    \begin{macrocode}
          \xfm@add@element@sep@nn {#8} {#7}
%    \end{macrocode}
%    
%    \begin{macrocode}
          \tlp@gput@right@No
             #6
             { \csname xfm@format@target@marker@ #7 @n \expandafter
               \endcsname  \expandafter {\xfm@resultiv@tlp}  }

          \xfm@add@element@sep@nn {#8} {#9}

          \tlp@gput@right@No
             #6
             { \expandafter #3 \expandafter {\xfm@result@tlp}  }

        }
%    \end{macrocode}
%    At this point the mark reference is definitely in
%    |\xfm@resultii@tlp| so we can append it to the
%    |\xfm@authors@list@tlp|.
%    \begin{macrocode}

      
      \xfm@add@element@sep@nn {authors} {#7}

      \tlp@gput@right@No
         \xfm@authors@list@tlp
         { \csname xfm@format@source@marker@ #7 @n \expandafter
           \endcsname \expandafter {\xfm@resultiv@tlp}  }

     }
}

%    \end{macrocode}
%    This bit of code finds an already existing marker with a value
%    equal to the text stored in |\xfm@result@tlp|.
%    \begin{macrocode}
\def \xfm@find@marker@Nn #1 #2 {
  \tlp@gset@No\xfm@resultiii@tlp{ \@secondoftwo #2 }
  \tlp@gset@No\xfm@resultiv@tlp { \@firstoftwo  #2 }
  \ifx \xfm@result@tlp\xfm@resultiii@tlp
    \tlp@set@Nn\xfm@resultii@tlp{#1}
    \let \prop@map@funct@Nn \@gobbletwo
  \fi
}


% author-prop, key-name, marker-name, target-area
% #1         , #2      , #3         , #4

\def \distribute@author@key@Nnnn #1#2#3#4  {
  \expandafter
  \distribute@author@key@NNNNNN 
    \expandafter
      #1
      \csname xfm@key@#2             \expandafter \endcsname
      \csname xfm@format@key@#2@n    \expandafter \endcsname
      \csname xfm@missing@key@#2@    \expandafter \endcsname
      \csname xfm@find@marker@#2@Nn  \expandafter \endcsname
      \csname xfm@#4@list@tlp \endcsname 
      {#3}
      {#4}
      {#2}
}

% author-prop, key-name, target-area
% #1         , #2      , #3

\def \append@author@key@Nnn #1#2#3 {
  \expandafter
  \append@author@key@NNNN
    \expandafter
      #1
      \csname xfm@key@#2             \expandafter \endcsname
      \csname xfm@format@key@#2@n    \expandafter \endcsname
      \csname xfm@missing@key@#2@    \expandafter \endcsname
      \csname xfm@#3@list@tlp \endcsname 
      {#3}{#2}
} 


% author-prop, key, key-format, missing-key-action, target-tlp
% #1           #2   #3          #4                  #5
%
\def \append@author@key@NNNN #1#2#3#4#5#6#7 {
  \prop@get@NNN
     #1
     #2
     \xfm@result@tlp

  \quark@if@no@value@NTF \xfm@result@tlp
% if the key is required we have to do something here
     #4
     {
      \xfm@add@element@sep@nn {#6} {#7}
      \tlp@gput@right@No
	 #5
	 { \expandafter #3 \expandafter { \xfm@result@tlp } }
     }
}


\def\distribute@author@data@N #1 {

  \xfm@handle@keys@N #1

%  \xfm@show@areas@
}


\def\distribute@author@data@n #1 {
  \expandafter 
  \distribute@author@data@N 
     \csname xfm@author@ #1 \endcsname
}


\def \DoAuthorLoop {
  \xfm@authors@loop@N
    \xfm@authors@queue
}
\def \xfm@authors@loop@N #1 {
  \queue@map@NN
    #1
    \distribute@author@data@n

  \xfm@add@element@sep@nn {authors} {END}

\xfm@show@areas@
}

\queue@new@N\xfm@currauthors@queue
\queue@new@N\xfm@remainingauthors@queue
\tlp@new@Nn \xfm@curraddresses@tlp{}

\def \DoSortByAddress {
  \queue@empty@NTF
    \xfm@authors@queue
    {}
    {
     \queue@gclear@N\xfm@currauthors@queue

     \queue@gpop@NN
       \xfm@authors@queue
       \xfm@result@tlp

     \prop@get@cNN
       {xfm@author@\xfm@result@tlp}
       \xfm@key@address
       \xfm@curraddresses@tlp

     \queue@gadd@No
       \xfm@currauthors@queue
       \xfm@result@tlp
     
     \queue@map@NN
       \xfm@authors@queue
       \xfm@find@address@n

     \global\let\xfm@authors@queue\xfm@remainingauthors@queue
     \queue@gclear@N\xfm@remainingauthors@queue

\show\xfm@currauthors@queue
\show\xfm@authors@queue

\tlp@gset@Nn\xfm@addresses@list@tlp{}
\tlp@gset@Nn\xfm@authors@list@tlp{}

     \xfm@authors@loop@N
       \xfm@currauthors@queue

%do formatting here:

     \DoSortByAddress
    }
}


\def \xfm@find@address@n #1 {
  \prop@get@cNN
    {xfm@author@#1}
    \xfm@key@address
    \xfm@result@tlp
  \ifx \xfm@result@tlp\xfm@curraddresses@tlp
    \queue@gadd@Nn\xfm@currauthors@queue{#1}
  \else
    \queue@gadd@Nn\xfm@remainingauthors@queue{#1}
  \fi
}

%    \end{macrocode}
%
%
% \section{Template interface}
%
%    \begin{macrocode}

\def\DeclareTitleMarker #1#2{
 \DeclareInstance{titlemarkersetup}{#1}{std}
   { marker-id = #1,  #2 }
 \UseInstance{titlemarkersetup}{#1}
}
\DeclareTemplateType{titlemarkersetup}{0}

\DeclareTemplate{titlemarkersetup}{std}{0}{
   marker-id     =n  \titlemarker@id,
   marker-type   =f0 \titlemarker@type,
   source-format =f1 \titlemarker@source@format,
   target-format =f1 \titlemarker@target@format,
 }
 {
   \def\titlemarker@type{\arabic}

   \DoParameterAssignments

   \newcounter \titlemarker@id
   \expandafter\xdef\csname the\titlemarker@id\endcsname
      {\expandafter\noexpand\titlemarker@type{\titlemarker@id}}

   \expandafter\show\csname the\titlemarker@id\endcsname

   \prop@new@c {xfm@ \titlemarker@id @prop}

   \global\expandafter\let 
      \csname xfm@format@source@marker@ \titlemarker@id @n \endcsname
      \titlemarker@source@format

   \global\expandafter\let 
      \csname xfm@format@target@marker@ \titlemarker@id @n \endcsname
      \titlemarker@target@format

 }




\def\DeclareAuthorKeyword #1#2{
 \DeclareInstance{authorkeywordsetup}{#1}{std}
   { keyword-id = #1,  #2 }
 \UseInstance{authorkeywordsetup}{#1}
}
\DeclareTemplateType{authorkeywordsetup}{0}

\DeclareTemplate{authorkeywordsetup}{std}{0}{
   keyword-id            =n  \authorkeysetup@id,
   target-area-id        =n  \authorkeysetup@target@area@id,
   marker-id             =n  \authorkeysetup@marker@id,
   required-boolean      =s  {}
                             {\let\authorkeysetup@missing@key\relax},
   combine-boolean       =s  {\let\authorkeysetup@combine@boolean
                              \xfm@find@marker@Nn}
                            {},
   keyword-format        =f1 \authorkeysetup@keyword@format,
 }
 {

   \let\authorkeysetup@marker@id\@empty
   \def\authorkeysetup@format##1{##1~ }
   \def\authorkeysetup@missing@key{\ERRORkeyMissing\authorkeysetup@id}

   \let\authorkeysetup@combine@boolean\@gobbletwo


   \DoParameterAssignments

   \global\expandafter\let 
      \csname KV@xfm@ \authorkeysetup@id\endcsname
      \xfm@author@keyword@code@n

   \global\expandafter\let 
      \csname xfm@format@key@ \authorkeysetup@id @n \endcsname
      \authorkeysetup@keyword@format

   \global\expandafter\let 
      \csname xfm@find@marker@ \authorkeysetup@id @Nn \endcsname
      \authorkeysetup@combine@boolean


   \edef\@tempa{
     \noexpand\xfm@handle@keys@N{####1}
     \ifx\authorkeysetup@marker@id\@empty
       \noexpand\append@author@key@Nnn ####1
       {\authorkeysetup@id}
     \else
       \noexpand\distribute@author@key@Nnnn ####1
       {\authorkeysetup@id}
       {\authorkeysetup@marker@id}
     \fi
       {\authorkeysetup@target@area@id}
   }
   \def\@tempb{\gdef\xfm@handle@keys@N####1}
   \expandafter\expandafter\expandafter\@tempb
   \expandafter\expandafter\expandafter
      {\@tempa}

%\show\xfm@handle@keys@N
 }


\let\xfm@handle@keys@N\@gobble

\def\ERRORkeyMissing#1 {\PackageError{xfm}{Keyword~`#1'~missing~ in~
                      \noexpand\author command}\@eha}
%    \end{macrocode}
%
%
%
%
%
%
%    \begin{macrocode}

\tlp@new@Nn\xfm@show@areas@{}


\def\DeclareTitleArea #1#2{
 \DeclareInstance{titleareasetup}{#1}{std}
   { area-id = #1,  #2 }
 \UseInstance{titleareasetup}{#1}
}
\DeclareTemplateType{titleareasetup}{0}

\DeclareTemplate{titleareasetup}{std}{0}{
   area-id            =n  \areasetup@id,
 }
 {
  \DoParameterAssignments

  \tlp@gclear@c{xfm@ \areasetup@id @list@tlp}
  \tlp@gput@right@No
     \xfm@show@areas@
     {\expandafter \show \csname xfm@ \areasetup@id @list@tlp \endcsname }

  \tlp@gset@cn{xfm@ \areasetup@id @last@tlp}{START}
 }

%    \end{macrocode}
%    
%    \begin{macrocode}
\def \DeclareAreaSep #1#2#3#4{
 \global\@namedef{xfm@#1-#2-#3}{#4}
}

\def \xfm@add@element@sep@nn #1#2 {
  \edef \@tempa
     { \noexpand \xfm@area@sep@nnn 
                 { #1 }
                 { \csname xfm@ #1 @last@tlp \endcsname }
                 { #2 }
     }
  \tlp@gset@cn{xfm@ #1 @last@tlp}{#2}
  \expandafter
  \tlp@gput@right@No
     \csname xfm@ #1 @list@tlp \endcsname
     \@tempa
}

\def\xfm@area@sep@nnn #1#2#3 {
  \@ifundefined{xfm@#1-#2-#3}
    {
      \@ifundefined{xfm@#1-#2-*}
	{
	  \@ifundefined{xfm@#1-*-#3}
	    {
	      \@ifundefined{xfm@#1-*-*}
		{}
		{ \csname xfm@#1-*-* \endcsname }
	    }
	    { \csname xfm@#1-*-#3 \endcsname }
	}
	{ \csname xfm@#1-#2-* \endcsname
	  \@ifundefined{xfm@#1-*-#3}
	    {}
	    { \csname xfm@#1-*-#3 \endcsname }
        }
    }
    { \csname xfm@#1-#2-#3 \endcsname }
}
%    \end{macrocode}
%
%
%
%
%
%
%
%
%    \begin{macrocode}
\DeclareTemplateType{maketitlesetup}{0}

\DeclareTemplate{maketitlesetup}{plain}{0}{
 }
 {
   \DoParameterAssignments
 }


\long\def \maketitle {

  \centerline{TITLE}
  \par

  \DoAuthorLoop
%  \DoSortByAddress

  \xfm@authors@list@tlp
  \par

  \xfm@thanks@list@tlp

 
}

%    \end{macrocode}

%
% \endinput
\endinput
%
% $Log$
% Revision 1.7  2001/04/05 11:00:52  latex3
% started to add area element separator code
%
% Revision 1.6  2001/04/05 09:20:19  latex3
% support combining key values in areas
%
% Revision 1.5  2001/04/03 20:28:43  latex3
% more templates, more generalisation ('orrible results :-)
%
% Revision 1.4  2001/04/02 06:46:45  latex3
% first template approach for author keys
%
% Revision 1.3  2001/04/01 13:33:34  latex3
% sort by address works first time
%
% Revision 1.2  2001/04/01 09:24:20  latex3
% now we can do at least author block followed by address block with all
% other data distributed appropriately to whatever area is desired (eg
% thanks area etc.)
%
