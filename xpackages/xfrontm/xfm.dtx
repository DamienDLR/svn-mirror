% \iffalse
%%
%% (C) Copyright 2001 Frank Mittelbach
%% All rights reserved.
%%
%% Not for general distribution. In its present form it is not allowed
%% to put this package onto CD or an archive without consulting the
%% the authors.
%% 
%    \begin{macrocode}
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{
%<*dtx>
  \ProvidesFile{#2.dtx}
%</dtx>
%<package>\ProvidesPackage{#2}
%<driver>\ProvidesFile{#2.drv}
  [#4 #3 #8 (#6)]}
\next$Id$
       {multiple marks}
%\iffalse
%    \end{macrocode}
%
%<*driver>
 \documentclass{ltxdoc}
%
 \begin{document}
 \DocInput{xfm.dtx}
 \end{document}
%\fi
%</driver>
%
% \fi
%
%
% \GetFileInfo{xfm.dtx}
%
% \title{The \textsf{xfm} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi}
% \date{\filedate}
%
%  \maketitle
%
% \tableofcontents
%
%
%
% \section{Introduction}
%
%
% \section{Implementation}
%
%    \begin{macrocode}
\RequirePackage{ldcsetup}
\RequirePackage{xtools}
\RequirePackage{template}
\IgnoreWhiteSpace
%    \end{macrocode}
%    
%
%
% \subsection{Document Commands}
%
% \begin{macro}{\title}
%    \begin{macrocode}
\renewcommand*\title{\@dblarg\@xtitle}
\def\@xtitle[#1]#2{
  \tlp@gset@Nn \xfm@shorttitle@tlp {#1} % unused so far
  \tlp@gset@Nn \xfm@title@list@tlp {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\subtitle}
%    \begin{macrocode}
\newcommand*\subtitle[1]{
  \tlp@gset@Nn \xfm@subtitle@list@tlp{#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\author}
%    The |\author| command stores the key/values as properties in a
%    property list which is named |\xfm@author@|\meta{num} where
%    \meta{num} is a sequence number which we get from incrementing
%    the counter |\xfm@authors|. Thus that counter will tell us the
%    number of authors seen in total.

%    In addition we store the current value of that counter in the
%    queue |\xfm@authors@queue| so that this queue will initially hold
%    the value $1,\ldots,n$ if we have $n$ authors in total.
%
%    Thus we can loop through this queue if we want to process the
%    authors. Also, if authors need to be sorted by address, we can
%    remove values from this queue once they are processed and thus
%    keep track of the authors still unprocessed.
%
%    The key names are of the form |\xfm@key@|\meta{name-of-key}.
%    \begin{macrocode}
\def\author#1#2{
%    \end{macrocode}
%    Advance the counter and make a new property list.
%    \begin{macrocode}
  \global\advance\xfm@authors\@ne
  \prop@new@c 
     {xfm@author@\the\xfm@authors}
%    \end{macrocode}
%    Add the name of the author (which is in argument |#1|) under the
%    key name |\xfm@key@name|.
%    \begin{macrocode}
  \prop@gput@cNn  
     {xfm@author@\the\xfm@authors}
     \xfm@key@name
     {#1}
%    \end{macrocode}
%    Add the value of counter |\xfm@authors| to the queue |\xfm@authors@queue|.
%    \begin{macrocode}
  \queue@gadd@No
     \xfm@authors@queue
     {\the\xfm@authors}
%    \end{macrocode}
%    Now parse the keys (which will put their values into the property
%    list). The code for parsing keys is defined on a per key basis in
%    |\DeclareAuthorKeyword| below.
%    \begin{macrocode}
  \setkeys{xfm}{#2}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xfm@authors}
%    We count the |\author| commands seen in the counter
%    |\xfm@authors|. At a later stage the counter is used to denote
%    the number of authors during processing, e.g., when sorting by
%    address it denotes the number of authors found for the current
%    address.
%    \begin{macrocode}
\newcount\xfm@authors
%    \end{macrocode}
% \end{macro}
%


% \begin{macro}{\xfm@authors@queue}
%    In |\xfm@authors@queue| we keep a reference to property lists set
%    up for authors. The queue stores only the \meta{number} part of the
%    property list name, so to get at the property list we have to
%    construct |\xfm@author@|\meta{queue-val}.
%
%    \begin{macrocode}
\queue@new@N\xfm@authors@queue
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfm@author@keyword@code@n}
%    |\xfm@author@keyword@code@n| is the code used to evaluate a key
%    using |\setkeys{xfm}|, i.e., for each keyword \meta{key} we want to
%    allow in the second argument of |\authors| we need to |\let| the
%    macro name |\KV@xfm@|\meta{key} to this macro (this is done in the
%    declaration of keys for the |\author| command below).
%
%    We could have used |\define@key| in that declaration but since
%    the code is the same for all keys using a direct |\let| saves a
%    lot of space.
%
%    The purpose of the code is to store the key value as a property
%    in the property list for the current author using the property
%    key |\xfm@key@|\meta{key}.
%
%    The macro has an argument but we can make it implicit and have
%    |\prop@gput@ccn| to pick it up as its third argument.
%
%    If anybody wonders what the |\@tempa| is doing\marginpar{DANGER:
%    bad dependency to keyval package} in the second argument to
%    |\prop@gput@ccn| \ldots: it holds the value of the parsed key (so
%    this is totally dependent on the implementation of |\setkeys|,
%    urg, which should offer a proper interface to the currently
%    parsed key name but doesn't).
%
%    \begin{macrocode}
\def \xfm@author@keyword@code@n {
  \prop@gput@ccn  
     {xfm@author@\the\xfm@authors}
     {xfm@key@\@tempa}
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \begin{macro}{\xfm@authors@loop@N}
%    |\xfm@authors@loop@N| loops through an author queue (e.g.,
%    |\xfm@authors@queue|) and applies |\xfm@distribute@author@data@n|
%    for each author in the queue.
%    \begin{macrocode}
\def \xfm@authors@loop@N #1 {
  \queue@map@NN
    #1
    \xfm@distribute@author@data@n
%    \end{macrocode}
%    A bit of debugging (at the moment):
%    \begin{macrocode}
  \XFMShowAreas
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
% \begin{macro}{\DoAuthorLoop}
%    |\DoAuthorLoop| is a straight application of
%    |\xfm@authors@loop@N| and will probably vanish again (or at least
%    change its name.
%    \begin{macrocode}
\def \DoAuthorLoop { \xfm@authors@loop@N \xfm@authors@queue }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
%
%
% \begin{macro}{\xfm@distribute@author@data@n}
%    \begin{macrocode}
\def\xfm@distribute@author@data@n #1 {
  \expandafter 
  \xfm@handle@keys@N
     \csname xfm@author@ #1 \endcsname
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
% \begin{macro}{\xfm@handle@keys@N}
%    \begin{macrocode}
\let\xfm@handle@keys@N\@gobble
%    \end{macrocode}
% \end{macro}

%
% \begin{macro}{\xfm@distribute@author@key@Nnnn}
%    \begin{macrocode}
% author-prop, key-name, marker-name, target-area-name
% #1         , #2      , #3         , #4

\def\xfm@distribute@author@key@Nnnn #1#2#3#4 {
  \prop@get@NcN
     #1
     {xfm@key@#2}
     \xfm@result@tlp

%    \end{macrocode}
%    If the key was specified we have a value in |\xfm@result@tlp|,
%    otherwise the key is missing and we may or may not have to do
%    something about that.
%    \begin{macrocode}
  \quark@if@no@value@NTF \xfm@result@tlp
%    \end{macrocode}
%    Do whatever is required if the key is missing token at this point
%    (the code is in the macro being constructed):
%    \begin{macrocode}
     { \csname xfm@missing@key@#2@ \endcsname }
%    \end{macrocode}
%    
%    \begin{macrocode}
     {
      \let\xfm@resultii@tlp\q@no@value

      \prop@map@cc 
          {xfm@ #3 @prop}
          {xfm@find@marker@#2@Nn}

      \quark@if@no@value@NT \xfm@resultii@tlp
%    \end{macrocode}
%    
%    Value does not exist, so make new mark:
%    \begin{macrocode}
        {
          \stepcounter{#3}
          \protected@edef
             \xfm@resultiv@tlp { \csname the#3 \endcsname }

%    \end{macrocode}
%    Next bit of code adds an entry to the property list
%    |#3|, this could be done manually which would be faster but less
%    understandable.
%
%    First start the value of the marker number and the text as two
%    brace groups in |\xfm@resultiii@tlp|
%    \begin{macrocode}
          \tlp@gset@No 
             \xfm@resultiii@tlp 
             { \expandafter { \xfm@resultiv@tlp } }
          \tlp@gput@right@No
             \xfm@resultiii@tlp 
             { \expandafter { \xfm@result@tlp } }
%    \end{macrocode}
%    Then put all of that into the property list:
%    \begin{macrocode}
          \prop@gput@cco
             {xfm@ #3 @prop}
             {mark-\the\value{#3}}
             \xfm@resultiii@tlp

%    \end{macrocode}
%    
%    \begin{macrocode}
          \xfm@add@element@sep@nn {#4} {marker:#3}
%    \end{macrocode}
%    
%    \begin{macrocode}
          \tlp@gput@right@co
             { xfm@#4@list@tlp }
             { \csname xfm@format@target@marker@ #3 @n \expandafter
               \endcsname  \expandafter {\xfm@resultiv@tlp}  }

          \xfm@add@element@sep@nn {#4} {key:#2}

          \tlp@gput@right@co
             { xfm@#4@list@tlp }
             { \csname xfm@format@key@#2@n \expandafter \endcsname
               \expandafter {\xfm@result@tlp}  }

        }
%    \end{macrocode}
%    At this point the mark reference is definitely in
%    |\xfm@resultii@tlp| so we can append it to the
%    |\xfm@authors@list@tlp|.
%    \begin{macrocode}

      
      \xfm@add@element@sep@nn {authors} {marker:#3}

      \tlp@gput@right@No
         \xfm@authors@list@tlp
         { \csname xfm@format@source@marker@ #3 @n \expandafter
           \endcsname \expandafter {\xfm@resultiv@tlp}  }

     }
}

\tlp@new@Nn\xfm@result@tlp{}
\tlp@new@Nn\xfm@resultii@tlp{}
\tlp@new@Nn\xfm@resultiii@tlp{}
\tlp@new@Nn\xfm@resultiv@tlp{}




%    \end{macrocode}
%    This bit of code finds an already existing marker with a value
%    equal to the text stored in |\xfm@result@tlp|.
%    \begin{macrocode}
\def \xfm@find@marker@Nn #1 #2 {
  \tlp@gset@No\xfm@resultiii@tlp{ \@secondoftwo #2 }
  \tlp@gset@No\xfm@resultiv@tlp { \@firstoftwo  #2 }
  \ifx \xfm@result@tlp\xfm@resultiii@tlp
    \tlp@set@Nn\xfm@resultii@tlp{#1}
    \let \prop@map@funct@Nn \@gobbletwo
  \fi
}





\def \xfm@append@author@key@Nnn #1#2#3 {
  \prop@get@NcN
     #1
     {xfm@key@#2}
     \xfm@result@tlp

  \quark@if@no@value@NTF \xfm@result@tlp
% if the key is required we have to do something here
     { \csname xfm@missing@key@#2@ \endcsname }
     {
      \xfm@add@element@sep@nn {#3} {key:#2}
      \tlp@gput@right@co
	 { xfm@#3@list@tlp }
	 { \csname xfm@format@key@#2@n \expandafter \endcsname 
           \expandafter { \xfm@result@tlp } }
     }
}







\queue@new@N\xfm@currauthors@queue
\queue@new@N\xfm@remainingauthors@queue
\tlp@new@Nn \xfm@curraddresses@tlp{}

\def \DoSortByAddress #1 {
  \queue@empty@NTF
    \xfm@authors@queue
    {}
    {
     \queue@gclear@N\xfm@currauthors@queue

     \queue@gpop@NN
       \xfm@authors@queue
       \xfm@result@tlp

     \prop@get@cNN
       {xfm@author@\xfm@result@tlp}
       \xfm@key@address
       \xfm@curraddresses@tlp

     \queue@gadd@No
       \xfm@currauthors@queue
       \xfm@result@tlp
     
     \global\xfm@authors\@ne

     \queue@map@NN
       \xfm@authors@queue
       \xfm@find@address@n

     \global\let\xfm@authors@queue\xfm@remainingauthors@queue
     \queue@gclear@N\xfm@remainingauthors@queue

\show\xfm@currauthors@queue
\show\xfm@authors@queue

%     \tlp@gset@Nn\xfm@addresses@list@tlp{} % gets filled but is not needed
%
%     \tlp@gset@Nn\xfm@authors@list@tlp{}
%     \tlp@gset@Nn\xfm@authors@last@tlp{START}

     \xfm@authors@loop@N
       \xfm@currauthors@queue

%\show\xfm@find@marker@addresses@Nn

    \ifx\xfm@find@marker@address@Nn\@gobbletwo
      \let \xfm@addresses@list@tlp \xfm@curraddresses@tlp
    \fi

%do formatting here:
     #1

     \DoSortByAddress{#1}
    }
}


\def \xfm@find@address@n #1 {
  \prop@get@cNN
    {xfm@author@#1}
    \xfm@key@address
    \xfm@result@tlp
  \ifx \xfm@result@tlp\xfm@curraddresses@tlp
    \global\advance\xfm@authors\@ne
    \queue@gadd@Nn\xfm@currauthors@queue{#1}
  \else
    \queue@gadd@Nn\xfm@remainingauthors@queue{#1}
  \fi
}

%    \end{macrocode}
%
%
% \section{Template interface}
%
%    \begin{macrocode}

\def\DeclareTitleMarker #1#2{
 \DeclareInstance{titlemarkersetup}{#1}{std}
   { marker-id = #1,  #2 }
 \UseInstance{titlemarkersetup}{#1}
}
\DeclareTemplateType{titlemarkersetup}{0}

\DeclareTemplate{titlemarkersetup}{std}{0}{
   marker-id     =n  \titlemarker@id,
   marker-type   =f0 \titlemarker@type,
   source-format =f1 \titlemarker@source@format,
   target-format =f1 \titlemarker@target@format,
 }
 {
   \def\titlemarker@type{\arabic}

   \DoParameterAssignments

   \newcounter \titlemarker@id
   \expandafter\xdef\csname the\titlemarker@id\endcsname
      {\expandafter\noexpand\titlemarker@type{\titlemarker@id}}

   \prop@new@c {xfm@ \titlemarker@id @prop}

   \global\expandafter\let 
      \csname xfm@format@source@marker@ \titlemarker@id @n \endcsname
      \titlemarker@source@format

   \global\expandafter\let 
      \csname xfm@format@target@marker@ \titlemarker@id @n \endcsname
      \titlemarker@target@format

 }




\def\DeclareAuthorKeyword #1#2{
 \DeclareInstance{authorkeywordsetup}{#1}{std}
   { keyword-id = #1,  #2 }
 \UseInstance{authorkeywordsetup}{#1}
}
\DeclareTemplateType{authorkeywordsetup}{0}

\DeclareTemplate{authorkeywordsetup}{std}{0}{
   keyword-id            =n  \authorkeysetup@id,
   target-area-id        =n  \authorkeysetup@target@area@id,
   marker-id             =n  \authorkeysetup@marker@id,
   required-boolean      =s  {}
                             {\let\authorkeysetup@missing@key\relax},
   combine-boolean       =s  {\let\authorkeysetup@combine@boolean
                              \xfm@find@marker@Nn}
                             {},
   keyword-format        =f1 \authorkeysetup@keyword@format,
 }
 {

   \let\authorkeysetup@marker@id\@empty
   \def\authorkeysetup@format##1{##1~ }
   \def\authorkeysetup@missing@key{\ERRORkeyMissing\authorkeysetup@id}

   \let\authorkeysetup@combine@boolean\@gobbletwo


   \DoParameterAssignments

   \global\expandafter\let 
      \csname KV@xfm@ \authorkeysetup@id\endcsname
      \xfm@author@keyword@code@n

   \global\expandafter\let 
      \csname xfm@format@key@ \authorkeysetup@id @n \endcsname
      \authorkeysetup@keyword@format

   \global\expandafter\let 
      \csname xfm@find@marker@ \authorkeysetup@id @Nn \endcsname
      \authorkeysetup@combine@boolean


   \edef\@tempa{
     \noexpand\xfm@handle@keys@N{####1}
     \ifx\authorkeysetup@marker@id\@empty
       \noexpand\xfm@append@author@key@Nnn ####1
       {\authorkeysetup@id}
     \else
       \noexpand\xfm@distribute@author@key@Nnnn ####1
       {\authorkeysetup@id}
       {\authorkeysetup@marker@id}
     \fi
       {\authorkeysetup@target@area@id}
   }
   \def\@tempb{\gdef\xfm@handle@keys@N####1}
   \expandafter\expandafter\expandafter\@tempb
   \expandafter\expandafter\expandafter
      {\@tempa}

%\show\xfm@handle@keys@N
 }



\def\ERRORkeyMissing#1 {\PackageError{xfm}{Keyword~`#1'~missing~ in~
                      \noexpand\author command}\@eha}
\def\ERRORDeclarationMissing#1 
    {\PackageError{xfm}{Declaration~ for~ `#1'~ missing}\@eha}
%    \end{macrocode}
%
%
%
%
%
%
%    \begin{macrocode}

\tlp@new@Nn\XFMShowAreas{}


\def\DeclareTitleArea #1#2{
  \tlp@gclear@c{xfm@ #1 @list@tlp}
  \tlp@gput@right@No
     \XFMShowAreas
     {\expandafter \show \csname xfm@ #1 @list@tlp \endcsname }

  \tlp@gset@cn{xfm@ #1 @last@tlp}{START}

 \DeclareInstance{titlearea}{#1}{std}
   { area-id = #1,  #2 }
% \UseInstance{titlearea}{#1}
}
\DeclareTemplateType{titlearea}{0}

\DeclareTemplate{titlearea}{std}{0}{
   area-id             =n  \areasetup@id,
   BBskip              =L  \areasetup@BBskip,
   fontsize            =L  \areasetup@fontsize,
   fontbaseline        =L  \areasetup@fontbaseline,
   justification-setup =i {justification}  \areasetup@justification,
   required-boolean    =s  {}
                           {\let\areasetup@missing@value\relax},
 }
 {

  \def\areasetup@BBskip{\baselineskip}
  \def\areasetup@fontsize{\f@size}
  \def\areasetup@fontbaseline{\f@baselineskip}

  \def\areasetup@missing@value{\ERRORDeclarationMissing\areasetup@id}

  \DoParameterAssignments
  
  \expandafter
  \ifx\csname xfm@ \areasetup@id @list@tlp
      \endcsname \@empty

    \areasetup@missing@value

  \else

    \xfm@add@element@sep@nn \areasetup@id {END}

    \begingroup
      \fontsize\areasetup@fontsize\areasetup@fontbaseline\selectfont
      \UseBBskip\areasetup@BBskip
      \areasetup@justification
      \csname xfm@ \areasetup@id @list@tlp \endcsname
      \par
    \endgroup
  \fi

% cleanup after use (more to do):

  \tlp@gclear@c{xfm@ \areasetup@id @list@tlp}
  \tlp@gset@cn {xfm@ \areasetup@id @last@tlp}{START} % provide restart
 }

%    \end{macrocode}
%    
%    \begin{macrocode}
\def \DeclareElementSep #1#2#3#4{
 \global\@namedef{xfm@#1-#2-#3}{#4}
}

\def \xfm@add@element@sep@nn #1#2 {
  \edef \@tempa
     { \noexpand \xfm@area@sep@nnn 
                 { #1 }
                 { \csname xfm@ #1 @last@tlp \endcsname }
                 { #2 }
     }
  \tlp@gset@cn{xfm@ #1 @last@tlp}{#2}
  \expandafter
  \tlp@gput@right@No
     \csname xfm@ #1 @list@tlp \endcsname
     \@tempa
}

\def\xfm@area@sep@nnn #1#2#3 {
  \@ifundefined{xfm@#1-#2-#3}
    {
      \@ifundefined{xfm@#1-#2-*}
	{
	  \@ifundefined{xfm@#1-*-#3}
	    {
	      \@ifundefined{xfm@#1-*-*}
		{}
		{ \csname xfm@#1-*-* \endcsname }
	    }
	    { \csname xfm@#1-*-#3 \endcsname }
	}
	{ \csname xfm@#1-#2-* \endcsname
	  \@ifundefined{xfm@#1-*-#3}
	    {}
	    { \csname xfm@#1-*-#3 \endcsname }
        }
    }
    { \csname xfm@#1-#2-#3 \endcsname }
}
%    \end{macrocode}
%
%
%
%
%
%
%
%
%    \begin{macrocode}
\DeclareTemplateType{maketitlesetup}{0}

\DeclareTemplate{maketitlesetup}{plain}{0}{
 }
 {
   \DoParameterAssignments
 }




\def \maketitle {
   \XFMtitleblock
}

\def \XFMtitleblock {
  \XFMTypesetArea{title}
  \XFMTypesetArea{authors}
}

\long\def \maketitle {

  \xfm@typeset@area{title}

  \xfm@typeset@area{subtitle}

%  \DoAuthorLoop
  \DoSortByAddress
    {
  \xfm@typeset@area{authors}
  \xfm@typeset@area{addresses}
  \xfm@typeset@area{altaddresses}
    }



  \xfm@typeset@area{date}

  \IfExistsInstanceTF{titlearea}{thanks}
    {
     \insert\footins{
       \UseInstance{titlearea}{thanks}
     }
    }
    \relax
 
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \xfm@typeset@area #1 {
  \IfExistsInstanceTF{titlearea}{#1}
    {\UseInstance{titlearea}{#1}}
    \relax
}
%    \end{macrocode}
%    
%    
%    \begin{macrocode}

\def \XFMSplitOnComma #1#2#3 {
  \global\let\xfm@split@code\@empty
  \@for\@tempa:=#1\do {
     \expandafter\xfm@split@code
     \expandafter#3\expandafter{\expandafter\ignorespaces\@tempa}
     \gdef\xfm@split@code{#2}
  }
}

%    \end{macrocode}
%    
%    \begin{macrocode}

\newcount\xfm@typeset@authors
\xfm@typeset@authors=1

\def\AuthorSeparation {
  \advance\xfm@typeset@authors\@ne
  \ifnum\xfm@authors = \tw@
     and~
  \else
     \ifnum\xfm@typeset@authors = \xfm@authors
       ,~ and~
     \else
       ,~
     \fi
  \fi
}
%    \end{macrocode}
%    
%    \begin{macrocode}


\DeclareTemplateType{justification}{0}

\DeclareTemplate{justification}{std}{0}{
  startskip      =L  \startskip ,
  leftskip       =l  \leftskip ,
  rightskip      =l  \rightskip ,
  parfillskip    =l  \parfillskip ,
  spaceskip      =l  \spaceskip ,
  xspaceskip     =l  \xspaceskip ,
  linefillskip   =L  \linefillskip ,
  parindent      =l  \parindent ,
 }{
  \DoParameterAssignments
  \@rightskip\rightskip
 }

\DeclareInstance{justification}{center}{std}
   {parindent  =0pt,
    rightskip  =\fill,
    leftskip   =\fill,
    startskip  =0pt,
    parfillskip=0pt
}


\DeclareInstance{justification}{flushleft}{std}
   {parindent  =0pt,
    rightskip  =\fill,
    leftskip   =0pt,
    startskip  =0pt,
    parfillskip=0pt
}

\newcommand*\UseBBskip[1]
  {\ifvmode
    \setlength\@tempskipa{#1 - \parskip - \baselineskip}
    \vskip\@tempskipa
   \else
    \DesignerError{\protect\UseBBskip\space outside~ vmode}
   \fi
  }


\newcommand*\DeclareParagraphLayout[9]{%
    \@namedef{#1Para}{
  \fontsize{#2}{#3}\selectfont
          #9
  \setlength\parindent  {#4}
  \setlength\leftskip   {#5}
  \setlength\rightskip  {#6}
  \@rightskip\rightskip
  \setlength\parfillskip{#7}
  \setlength\parskip    {#8}
}
}


%    \end{macrocode}
%    
%    \begin{macrocode}


% #1 target-area
% #2 text-type (keyword)
% #3 marker-name
% #4 format-right
% #5 text

\def \dothanks #1#2#3#4#5#6 {
  \stepcounter{#3}
  \protected@edef
    \xfm@resultiv@tlp { \csname the#3 \endcsname }

  \xfm@add@element@sep@nn {#1} {marker:#3}
  \tlp@gput@right@co
     { xfm@#1@list@tlp }
     { \csname xfm@format@target@marker@ #3 @n \expandafter
       \endcsname  \expandafter { \xfm@resultiv@tlp }  }

  \xfm@add@element@sep@nn {#1} {key:#2}

  \tlp@gput@right@co
     { xfm@#1@list@tlp }
     { \csname xfm@format@key@#2@n  \endcsname
       { #6}  }

  #4
  \csname xfm@format@source@marker@ #3 @n \endcsname
     {\xfm@resultiv@tlp}
  #5
}

\def\thanks{\dothanks{thanks}{thanks}{thanks}
                     {\textsuperscript\,}{\textsuperscript)}}


\def \xfm@insert@element@sep@nn #1#2 {
  \edef \@tempa
     { \noexpand \xfm@area@sep@nnn 
                 { #1 }
                 { \csname xfm@ #1 @last@tlp \endcsname }
                 { #2 }
     }
  \tlp@gset@cn{xfm@ #1 @last@tlp}{#2}
  \expandafter
  \tlp@gput@right@No
     \csname xfm@ #1 @list@tlp \endcsname
     \@tempa
}
%    \end{macrocode}

%
% \endinput
\endinput
%
% $Log$
% Revision 1.14  2001/04/12 07:39:24  latex3
% fixed author counting when doing sort by address
%
% Revision 1.13  2001/04/08 21:19:25  latex3
% first attempt to get sorting by address to work in real life
%
% Revision 1.12  2001/04/07 16:58:10  latex3
% some code cleanup, some more documentation
% added the possibility to have \thanks and the like within other
% keyword values
%
% Revision 1.11  2001/04/06 20:24:40  latex3
% more documentation, being burned by having lost the afternoons work
% we save more often :-(
%
% Revision 1.10  2001/04/06 19:11:53  latex3
% let's save some documentation
%
% Revision 1.9  2001/04/06 15:45:36  latex3
% *** empty log message ***
%
% Revision 1.8  2001/04/05 14:23:40  latex3
% first attempt to solve the author-and issue
% some code cleanup
%
% Revision 1.7  2001/04/05 11:00:52  latex3
% started to add area element separator code
%
% Revision 1.6  2001/04/05 09:20:19  latex3
% support combining key values in areas
%
% Revision 1.5  2001/04/03 20:28:43  latex3
% more templates, more generalisation ('orrible results :-)
%
% Revision 1.4  2001/04/02 06:46:45  latex3
% first template approach for author keys
%
% Revision 1.3  2001/04/01 13:33:34  latex3
% sort by address works first time
%
% Revision 1.2  2001/04/01 09:24:20  latex3
% now we can do at least author block followed by address block with all
% other data distributed appropriately to whatever area is desired (eg
% thanks area etc.)
%

% \endinput



%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{}
%    \begin{macrocode}


%
%
% \begin{macro}{}
%    \begin{macrocode}

%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
% \begin{macro}{}
%    \begin{macrocode}

%    \end{macrocode}
% \end{macro}
%
%
%
%
