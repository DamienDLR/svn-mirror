% \iffalse
%%
%% (C) Copyright 2001 Frank Mittelbach
%% All rights reserved.
%%
%% Not for general distribution. In its present form it is not allowed
%% to put this package onto CD or an archive without consulting the
%% the authors.
%% 
%    \begin{macrocode}
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{
%<*dtx>
  \ProvidesFile{#2.dtx}
%</dtx>
%<package>\ProvidesPackage{#2}
%<driver>\ProvidesFile{#2.drv}
  [#4 #3 #8 (#6)]}
\next$Id$
       {front matter}
%\iffalse
%    \end{macrocode}
%
%<*driver>
 \documentclass{ltxdoc}
%
 \begin{document}
 \DocInput{xfm.dtx}
 \end{document}
%\fi
%</driver>
%
% \fi
%
%
% \GetFileInfo{xfm.dtx}
%
% \title{The \textsf{xfm} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi}
% \date{\filedate}
%
%  \maketitle
%
% \tableofcontents
%
%
% \begin{abstract}
%    This document describes a front matter model and implementation
%    for \LaTeX.
%
%    As of today a large portion of the documentation is incorrect,
%    sorry folks, for example the original \verb=\author= command was
%    generalised to allow any kind of front matter structures of this
%    type, but the documentation still talks about \verb=\author= and
%    |address| keyword instead of ``some keyword'' of ``a front matter
%    structure'' \ldots\ one day
% \end{abstract}
%
% \section{Introduction}
%
%
% \subsection{Layout Areas}
%
% Conceptually the front matter consists of so called ``layout areas''
% or ``layout block'' which receive textual data from the syntax
% elements such as the |\title| command or the author declarations
% (i.e., the |\author| command).
%
% A ``layout area'' is vertically oriented, which means that it starts
% out in vertical mode and finishes of in vertical mode by pre- and
% appending a |\par| command. Textual data which is put into it will
% not contain direct formatting information at that point but instead
% will be surrounded by functions with one argument responsible for the
% formatting. For example, an address will appear as
%\begin{verbatim}
%    \xfm@format@key@address@n {Zedernweg 62, 55128 Mainz, Germany}
%\end{verbatim}
% in such a ``layout area''. 
%
% 
% \subsubsection{Area Declaration}
%
%\DescribeMacro\DeclareTextArea
% Areas are declared by |\DeclareTextArea| as follows:
%\begin{verbatim}
%    \DeclareTextArea{<name>}
%     {
%       area-required-boolean    = <true or false>,
%       area-measure-setup       = <horizontal galley parameters>,
%       area-bb-skip             = <vertical separation to prev block>,
%
%       head-text                = <fixed heading text>,
%       head-font                = <font for heading>,
%       head-format              = <format of heading>,
%       head-justification-setup = <how to justify heading>,
%
%       head-text-bb-skip        = <vertical separation between head/text>,
%       head-text-h-skip         = <horizontal separation between head/text>,
%
%       text-font                = <font for text>,
%       text-pshape-setup        = <special parshape if necessary>,
%       text-justification-setup = <how to justify text>,
%       text-firstindent-boolean = <indent first paragraph?>,
% }
%\end{verbatim}
% The |basebase-skip| key defines the distance between the first baseline in
% the area and the last baseline of an earlier area (if there is
% one).\footnote{For very complex layouts where the areas are not
% essentially following each other that key seems slightly odd, but
% for most type of layouts the placement within the area setup is
% appropriate (and it is easier to implement this way).} By default it
% is the value of |fontbaseline| so that areas follow each other
% without any special space.
%
% The |fontsize| and the |fontbaseline| keys define some important
% properties of the body font. There need to be others and all those
% should probably be combined somehow and offered as |font-setup|.
%
% The |justification-setup| defines the paragraph justification used
% for area. If we go with the galley2 type of templates (without
% actually using them) then we probably also need something like
% |pshape-setup|.
%
% Finally |required-boolean| defines whether or not that area needs
% filling. An unfilled area is ignored including the whitespace
% preceding it, but if the area is required we will get an error
% message.
% 
% 
% 
% \subsubsection{Element Separation}\label{sec:eltsep}
%
% The ``textual elements'' in the areas will be internally separated
% from each other by functions taking three arguments:
%\begin{verbatim}
%    \xfm@area@sep@nnn {addresses}{key:address}{marker:addresses}
%\end{verbatim}
% The first argument is the name of the area itself, the second
% describes the nature of the previous element (an address in the
% example), and the third describes the nature of the following
% element (a marker with the name |addresses| in the example).
% If there is no previous element the second argument contains the
% string |START| and if there is no further element the third argument
% contains the string |END|.
%
% Having these separator functions it is possible to describe in
% detail the formatting that should happen between two elements in an
% area as well as allowing special actions to be taken before the
% first element and after the last element.
%
% \DescribeMacro\DeclareElementSep
% The actions of the separator functions are declared using a number
% of |\DeclareElementSep| each taking four arguments: the area to
% which they apply, the ``descriptive name'' of the previous element,
% the ``descriptive name'' of the following element, and the action to
% take if we are between two such elements (i.e., if the three
% arguments of |\xfm@area@sep@nnn| match the first three arguments in
% the |\DeclareElementSep| declaration. Instead of a ``descriptive
% name'' one can use a |*| which means any element.
%
% As a simple example consider the author names appearing in such a
% list being denoted by |key:name|\footnote{How to determine which
% elements have what name we cover later.} then separating them by
% comma could be done as follows:
%\begin{verbatim} 
%  \DeclareElementSep{authors}{START}{key:name}   {}
%  \DeclareElementSep{authors}{*}    {key:name}   {, }
%  \DeclareElementSep{authors}{*}    {END}        {}
%\end{verbatim} 
% This is admittedly a simple example; especially in this case we
% typically have the need to handle the situation of two elements
% specially, e.g., adding \verb*= and = in that case but
% \verb*=, and =  between the last two authors if there are more 
% than two.\footnote{It remains to be seen if this kind of extra
% complication asks for a  even more generic solution or if it can be
% suitably handled with the current concepts.}
%
% As a second example consider markers being added after author names
% to refer to email address, thanks, and the like. The following
% specification will put a small space before the first marker,
% separate the markers by a raised comma (the marker itself is better
% be raised as well in that case :-) and finishes the set of markers
% for one author by a raised close parenthesis.
%\begin{verbatim}
%  \DeclareElementSep{authors}
%                    {*}            {marker:thanks}{\,}
%  \DeclareElementSep{authors}
%                    {marker:thanks}{marker:thanks}{\textsuperscript{,}}
%  \DeclareElementSep{authors}
%                    {marker:thanks}{*}            {\textsuperscript{)}}
%\end{verbatim} 
%
% The use of the |*| in the |\DeclareElementSep| declaration needs
% some further explanation. Consider the following three declarations:
%\begin{verbatim}
%  \DeclareElementSep{authors}{A}{*}{do-A}
%  \DeclareElementSep{authors}{*}{B}{do-B}
%  \DeclareElementSep{authors}{A}{C}{do-C}
%  \DeclareElementSep{authors}{*}{*}{do-D}
%\end{verbatim}
% If we are between two elements then it is first checked if there is
% a declaration for this exact combination (thus not involving stars).
% If this is the case then the corresponding action is executed and
% nothing else. Therefore if we are between |A| and |C| the algorithm
% executes |do-C| and ignores that the first andthe last of the above
% rules would match the situation as well.
%
% However, if the exact match is not found, the algorithm first tries
% to finds a rule with the second element replaced by a star (and if
% found executes its action) and then regardless of the result for
% that search also looks for a rule with the first element being
% replaced by a star. 
%
% If there was at least one match involving one star processing stops
% otherwise the algorithm makes a final attempt and looks for a rule
% with both elements replaced by stars.
%
% Thus for |A| followed by |B| we execute |do-A| and then |do-B|,
% while for |A| followed by |D| we execute only |do-A|, for |C|
% followed by |B| we would execute |do-B|, and for |C| followed by |C|
% we would execute |do-D| (assuming that the above are the only rules
% involving |A|, |B|, and |C|).
%
%
% \subsubsection{Processing and Formatting}
%
% \DescribeMacro\xfm@add@element@nnn
% \DescribeMacro\xfm@add@element@nno
% To add an element to some area the command |\xfm@add@element@nnn|
% can be used as follows:
%\begin{verbatim} 
%  \xfm@add@element@nnn {authors} {key:name}{Frank Mittelbach}
%\end{verbatim} 
% where the first argument specifies the target area, the second the
% ``descriptive name'' for the element, and the third the actual
% data. This command and its companion (which is the same except that
% last argument is expanded once) are intended for internal use, so
% the argument would usually contain |#1| and the like rather than
% fixed data. 
%
% The target area should have been declared; the ``descriptive name''
% can in be any string, though to be useful there should be a sensible
% convention (the one used by this setup is explained below).
%
% The commands append at the right by first adding an element
% separation command (as explained in the previous section) followed
% by contents of the third argument. Thus formatting commands such as
% |\xfm@format@key@address@n| need to be part of that third argument
% if necessary.
%
%
% The areas are formatted by executing an instance of type |textarea|
% and the name of that area, e.g.,
%\begin{verbatim} 
%  \UseInstance{textarea}{thanks}
%\end{verbatim}
% would typeset the contents of an area named |thanks| at the current
% point.
%
% \DescribeMacro\xfm@typeset@area@list@n
%
% \DescribeMacro\xfm@typeset@insertion@area@list@nn
%
%
% \DescribeMacro\xfm@typeset@area@n
% [GONE]
% As a shortcut |\xfm@typeset@area@n| first checks if an instance of
% with the area name exists and if so calls the instance, otherwise it
% does nothing. This allows to build very generic templates for
% |\maketitle| which can be customised by declaring or not declaring
% certain areas.\footnote{Not sure that is something that should
% survive in the end, but for now it is helpful.}
%
% As mentioned above the elements are formatted using commands with
% one argument. The definition for these commands are part of the
% declarations that set up the data sources from which the text comes,
% e.g., keys of the |\author| commands gets distributed to areas and
% the formatting for the key value is described with the key declaration.
%
%
%
%
%
%
% \subsection{Markers}
%
% Some of the information distributed to different areas need to be
% linked to other areas, e.g., you might want to link an author name
% appearing in the |authors| area with its address (appearing, for
% example, in the |addresses| area) as well as with its email address
% and homepage information (both appearing, say, as footnotes on the
% bottom of the page).
%
% \DescribeMacro\DeclareFMMarker
% This is done by linking this data via ``markers'' which are declared
% using the |\DeclareFMMarker| declaration as follows:
%\begin{verbatim}
%  \DeclareFMMarker{<name>}
%   {
%     marker-type   = <display-type-of-marker>,
%     source-format = <presentation-in-sourcearea>,
%     target-format = <presentation-in-target-area>,
%   }
%\end{verbatim}
% Markers are internally represented as counters, with the
% |marker-type| we define the general display properties of the
% marker, e.g., as arabic numbers or as footnote symbols , etc.
% The |source-format| describes for formatting in the source area
% (link start) while the |target-format| describes the formatting in
% the target area (if different from the formatting in the source
% area.
%
% For example, we might have |\textsuperscript{\normalfont#1}| as
% formatting  in the source area, but perhaps |#1)| in the target
% area. Both |-format| keys apply to a single reference to a marker,
% if several such marker reference appear in succession in an area,
% they are separated by element separator functions and thus the
% formatting between them can be specified via this concept.
%
%
%
%
% \subsection{Author Data}
%
% Author data is perhaps the most complicated information in the front
% matter because it contains several items that need special treatment
% in most layout styles. This package provides a single input syntax
% while supporting the various layout conventions required by
% different journals.
%
% 
% \subsubsection{Author Data Input Specification}
% 
% \DescribeMacro\author 
% Author data is entered in the source document using the |\author|
% command:
% \begin{verbatim}
% \author{<name>}{
%   address    = <author address> ,
%   altaddress = <alternate author address> ,
%   homepage   = <author home page> ,
%   email      = <author email address> ,
%   thanks     = <thanks and attributions> ,
%   ...
% }
% \end{verbatim}
% 
% The keywords in the second argument to the |\author| command are an
% extensible set; they are declared by document class (or in the
% preamble). For the sake of portability, a suitable default set
% should be provided.
% 
% Keywords used but not declared result in an error. Declaring
% keywords on the other hand does not necessarily mean that the value
% is going to be used by the class.
% 
% 
% \subsubsection{Declaring keywords for the author command}
% 
% \DescribeMacro\DeclareAuthorKeyword
% Keywords available within the second argument of the |\author|
% command are declared using |\DeclareAuthorKeyword| as follows:
% \begin{verbatim}
% \DeclareAuthorKeyword{<keyword>}
%   {
%    value-required-boolean = <true-or-false>,
%    value-targetarea-id    = <area-name>,
%    value-combine-boolean  = <true-or-false>,
%    marker-id                = <marker-name>,
%    marker-sourcearea-id    = <area-name>,
%   }
% \end{verbatim}
% Not every keyword within the |\author| command represents a required
% value. We might require that every author has an address but
% probably not every author has an email address. By specifying that
% |value-required-boolean| is |false| for a keyword we instruct the front
% matter algorithm that it is permissable when this particular keyword
% is missing in an author declaration. If this is set to |true| the
% algorithm checks if that keyword is present for every author and if
% not will issue an error message. (The default is |true|.)
% 
% To get a keyword formatted at some point it needs a target area in
% which it gets typeset; this area is specified by
% |value-targetarea-id |. If this contains no value the declared keyword
% will be accepted but ignored.
% 
% If the value of the author keyword has to be linked with some other
% data we need a marker which can be specified by the |marker-id|. If
% a |marker-id| is given the corresponding marker will be used in two
% places:
% \begin{itemize}
% \item in the |value-targetarea-id | before the author keyword value is
%   inserted there
% \item in the |marker-sourcearea-id| at the current point in that area.
% \end{itemize}
% The formatting used for the marker depends on the declarations for
% this marker. The |marker-id| has no effect if the whole author
% keyword is ignored (i.e., if the |value-targetarea-id | is empty).
% 
% The default for the |marker-sourcearea-id| is the area named |authors|
% which by convention holds the author names.
% 
% In some cases identical data in certain areas (for certain keys)
% should be combined. This can be requested on the author keyword
% level by setting the flag |value-combine-boolean| to |true|. In this case
% all data flagged with the same marker is searched to find an already
% existing entry with the same value. If this value is found then the
% corresponding marker label is used instead of generating a new
% one. Note that if a marker is used for linking data in different
% target areas (which is probably a bad idea in the first place) then
% the identical string might be found in any of these target areas!
% 
% There is the interesting question where to put a flag like
% |value-combine-boolean|. Putting it onto an area sounds interesting but
% consider the following scenario: both thanks and address go to the
% footnote area at the bottom of the page and two authors thank their
% wives named Lisa. To conserve space we want to combine identical
% addresses, do we also want to have the line ``With thanks to Lisa''
% be combined into a single line?
% 
% 
% \subsubsection{Processing data for one author}
% 
% General processing of individual author data is identical for all
% styles. Its purpose is to collect referencing information that link
% the author name author data not formatted and ``close by'', e.g.,
% url information later formatted as a footnote, and prepare for this
% data to be processable in a later stage.
% 
% \begin{itemize}
% \item Clear the temporary marker reference list.
% \item Process the author data in a specified keyword order (this order
%   is stored in the template value \texttt{keyword-order}).
% \item For each keyword determine if it has a value and if so
%   \begin{itemize}
%   \item append an appropriate marker reference to the marker reference
%     list
%   \item postprocess the keyword value by appending it together with
%     its marker reference to an area list for later formatting (if
%     necessary---the data might already be present).
%   \end{itemize}
% \end{itemize}
% 
% After this process the temporary marker reference list can (and
% should) be used to format marker information that should be attached
% to the author name. The area lists are global to this processing,
% ie., their contents will not be cleared.
% 
%
%
%
% \section{Question, Issues, and Ideas}
%
% This is a set of comments on the concepts and the implementation in
% random order.
%
% \begin{itemize}
%
% \item The more I work with templates the more I (mis)use the
%    template interface to provide key/value parsing, e.g., define a
%    declaration command such as |\DeclareFMMarker| which does
%    nothing else than declaring a template instance and immediately
%    executing it. After that this instance is never going to be
%    used again. This really calls for providing an interface for such
%    action which internally generates some anonymous instance which
%    is removed from storage immediately afterwards.
%
% \item Just realised that the fake templates would get much simpler
%    if I pass the name as a template argument rather than as a
%    key. Should probably update them all but not tonight.
%
% \item Perhaps it is a good idea to provide the interface to markers
%   in a more general way as a generic interface to counters since
%   there as well something like |source-format| and |target-format|
%   would make sense for many of them as well.
%
% \item The current use of markers needs one more layer of
%    abstraction, i.e., rather than passing around the display value
%    of the marker it would be better to pass around a reference to it
%    and determine the real value at the very last moment. This would
%    allow to get independent usages of the same marker, e.g., via
%    direct |\thanks| commands in sync with those produced when author
%    key values are distributed to areas.
% \end{itemize}
%
%
%
%
% \section{Implementation}
%
%    To implement the front matter code we need the |template| code as
%    well as some general purpose stuff implementing property lists
%    and the like which is coming from |xtools|.
%
%    \begin{macrocode}
%<*package>
\NeedsTeXFormat{LaTeX2e}[1998/12/01]
\RequirePackage{ldcsetup}
\RequirePackage{xtools}
\RequirePackage{template}
\RequirePackage{xfmgalley}
\IgnoreWhiteSpace
%    \end{macrocode}
%    
%
%
% \subsection{Layout Areas}
%
%
% \subsubsection{Area declaration}
%
% \DescribeMacro\g@xfm@FOO@list@tlp
%    For an area named |FOO| the tlp |\g@xfm@FOO@list@tlp| holds all
%    formatting instructions to be used when the corresponding area
%    instance is executed. (After execution this list is cleared so an
%    area can be used un a loop, if in the loop filling and using is
%    alternated.)
%
% \DescribeMacro\g@xfm@FOO@last@tlp
%    For an area |FOO| the tlp |\g@xfm@FOO@last@tlp| holds the
%    descriptive name of the last element that was added. This is used
%    when computing the separator function that is placed between two
%    such elements.
%
% \DescribeMacro\XFMShowAreas
%    The |\XFMShowAreas| is indented as a debugging aid and shows the
%    current contents of each area.
%
%
% \begin{macro}{textarea (template/type)}
%    Areas are internally implemented as instances of templates so we
%    start by declaring a template type for this. As a typical
%    ``setup'' type this type has no arguments.
%    \begin{macrocode}
\DeclareTemplateType{textarea}{0}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\DeclareTextArea}
%    The |\DeclareTextArea| is the designer interface to area
%    declaration, the first argument is the area name and the second
%    is a list of key/values. This hides the fact that we use template
%    instances for areas but it is also here because we do want to do
%    some code execution when the area is declared and some when it is
%    used.
%
%    \begin{macrocode}
\def\DeclareTextArea #1#2{
%    \end{macrocode}
%    Each area has a tlp which holds the contents of the area. It is
%    initially empty.
%    \begin{macrocode}
  \tlp@gclear@c{g@xfm@ #1 @list@tlp}
%    \end{macrocode}
%    As a primitive form of debugging during development we provide a
%    |\show| of the area tlp contents so we add the new area to the
%    |\XFMShowAreas| macro (this is clearly code which will vanish one
%    day).
%    \begin{macrocode}
  \tlp@gput@right@No
     \XFMShowAreas
     {\expandafter \show \csname g@xfm@ #1 @list@tlp \endcsname }
%    \end{macrocode}
%    To be able to add proper element separator commands into the area
%    we need to initialise the tlp that keeps track of the last
%    element seen:
%    \begin{macrocode}
  \tlp@gset@cn{g@xfm@ #1 @last@tlp}{START}
%    \end{macrocode}
%    And finally we declare a template instance, passing area name
%    under the key |area-id| and the second argument as the remaining
%    key/values.
%    \begin{macrocode}
  \DeclareInstance{textarea}{#1}{std}{ area-id = #1,  #2 }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \begin{macro}{\XFMShowAreas}
%    The debugging command |\XFMShowAreas| shows the current contents
%    of all areas, the output is rather unreadable---need something
%    better in the end. We have to initialise this or else the
%    |\tlp@gput@right@No| in |\DeclareTextArea| will fail.
%    \begin{macrocode}
\tlp@new@Nn\XFMShowAreas{}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{textarea/std (template)}
%    The purpose of this instance is to format the contents of an area
%    and prepare for its reuse (if necessary).
%
%    Keys and their names for this template need further thought, they
%    are neither complete nor good.
%    \begin{macrocode}
\DeclareTemplate{textarea}{std}{0}{
   area-id               =n \l@textarea@id@tlp,
   area-required-boolean =s {}
                            {\let\textarea@missing@value@\relax},
   area-measure-setup    =i {measure} \textarea@measure@n,

   area-bb-skip            =L  \textarea@BBskip,
   head-text               =f0 \textarea@head@text,
   head-font               =f0 \textarea@head@font,
   head-format             =f1 \textarea@head@format@n,
   head-justification-setup=i {justification} [center]
                                  \textarea@head@justification@,
   head-text-h-skip         =L  \textarea@text@vskip,
   head-text-bb-skip        =L  \textarea@text@BBskip,

   text-font                =f0 \textarea@text@font,
   text-justification-setup =i {justification} [centerfirst-adjust]
                                        \textarea@text@justification@,
   text-pshape-setup        =i {pshape} \textarea@text@pshape,
   text-firstindent-boolean =s {}{\let\textarea@text@handle@indent@
                                  \gal@remove@next@parindent@ },

 }
 {
%    \end{macrocode}
%    
%    \begin{macrocode}
  \let\textarea@measure@n \@gobble
  \let\textarea@BBskip    \baselineskip
%    \end{macrocode}
%    The default for |\textarea@missing@value@| is to call an error
%    routine which tells the user that contents for this area is
%    required but not provided by the document.
%    \begin{macrocode}
  \def\textarea@missing@value@{\xfm@error@decl@nn{area}\l@textarea@id@tlp}

  \let\textarea@text@pshape\relax
  \let\textarea@text@BBskip\baselineskip
  \let\textarea@text@vskip\NoValue
  \let\textarea@text@font\@empty

  \let\textarea@head@text\NoValue
  \let\textarea@head@font\@empty
  \let\textarea@head@format@n\@firstofone
  \let\textarea@text@handle@indent@\relax
%    \end{macrocode}
%    
%    \begin{macrocode}
  \DoParameterAssignments
%    \end{macrocode}
%    
%    If the area contents is empty we execute
%    |\textarea@missing@value@| which, by default, will generate an
%    error message, but if the declaration set |required-boolean| to
%    |false| it will do nothing.
%    \begin{macrocode}
  \expandafter
  \ifx\csname g@xfm@ \l@textarea@id@tlp @list@tlp
      \endcsname \@empty
    \textarea@missing@value@
%    \end{macrocode}
%    If it is non-empty we have to typeset it:
%    \begin{macrocode}
  \else
%    \end{macrocode}
%    First thing to do is to append the final separator command since
%    this is still missing.
%    \begin{macrocode}
    \xfm@add@element@sep@nn \l@textarea@id@tlp {END}
%    \end{macrocode}
%    The actual typesetting is done in a group so that font changes
%    etc are kept local to the area.
%    \begin{macrocode}
    \begingroup
      \par
      \textarea@measure@n \NoValue

      \ifx \textarea@head@text \NoValue
         \let\textarea@text@BBskip\textarea@BBskip
         \textarea@text@handle@indent@
      \else
         \begingroup
	   \textarea@head@font
	   \UseBBskip\textarea@BBskip
	   \ifx \textarea@text@vskip \NoValue
	   \else
             \textarea@text@handle@indent@
           \fi
	   \textarea@head@format@n
	      \textarea@head@text
         \endgroup
         \textarea@head@justification@
      \fi
%    \end{macrocode}
%    We need to set up the body font for the area \emph{before} we
%    call |\UseBBskip| since the latter needs to know the upcoming
%    baselineskip value to make the right calculations.
%    \begin{macrocode}
      \ifx \textarea@text@vskip \NoValue
      \else
         \hskip\textarea@text@vskip
      \fi
      \textarea@text@font
      \ifx \textarea@text@vskip \NoValue
         \par
         \UseBBskip\textarea@text@BBskip
      \fi
%    \end{macrocode}
%    Then we set up justification and finally typeset the area
%    contents followed by a |\par| to ensure that we return to
%    vertical mode.
%    \begin{macrocode}
      \textarea@text@pshape
      \textarea@text@justification@
\expandafter\show \csname g@xfm@ \l@textarea@id@tlp @list@tlp \endcsname
      \csname g@xfm@ \l@textarea@id@tlp @list@tlp \endcsname
      \par
    \endgroup
%    \end{macrocode}
%
%    After that we have to reinitialise the area to allow reuse (as
%    well as to save space). We can do this within the |\else| part
%    since we can assume that an empty contents means that we are
%    still having an initialised version (if not something will break :-).
%    \begin{macrocode}
    \tlp@gclear@c{g@xfm@ \l@textarea@id@tlp @list@tlp}
    \tlp@gset@cn {g@xfm@ \l@textarea@id@tlp @last@tlp}{START} % provide restart
  \fi
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xfm@error@decl@nn}
%    The current error handling is BAD and the texts are wrong, so
%    there\ldots
%    \begin{macrocode}
\def \xfm@error@decl@nn #1#2
    {\PackageError{xfm}{No~ contents~ in~ #1~ `#2'~ missing}
                       \@eha % needs real help message
    }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsubsection{Element Separation}
%
% \DescribeMacro{\xfm@AREA-A-B}
%    The action to be taken between two elements |A| and |B| in an
%    area named |AREA| is stored in |\xfm@AREA-A-B|. |A| and |B| are
%    either descriptive element names or |*|s denoting ``any name''.
%
% \begin{macro}{\DeclareElementSep}
%    The |\DeclareElementSep| stores away the information in the
%    appropriate tlp.
%    \begin{macrocode}
\def \DeclareElementSep #1#2#3#4 { \tlp@gset@cn{xfm@#1-#2-#3}{#4} }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xfm@add@element@nnn}
% \begin{macro}{\xfm@add@element@nno}
%    |\xfm@add@element@nnn| takes an area name as first argument, an
%    (descriptive) element name as second argument, and the element
%    value as third and updates the area tlp with this information by
%    adding an appropriate element separator function followed by the
%    third argument with its formatter function.
%    \begin{macrocode}
\def \xfm@add@element@nnn #1#2#3 {
%    \end{macrocode}
%    Add the separator function first\ldots
%    \begin{macrocode}
  \xfm@add@element@sep@nn {#1}{#2}
%    \end{macrocode}
%    \ldots then add the third argument to the area tlp.
%    \begin{macrocode}
  \tlp@gput@right@cn
     { g@xfm@#1@list@tlp }
     { \xfm@area@value@nnn{#1}{#2}{#3} }
}
%    \end{macrocode}
%    |\xfm@add@element@nno| is the more common variant which expands
%    the third argument once before adding it.
%    \begin{macrocode}
\def \xfm@add@element@nno #1#2#3 {
  \xfm@add@element@sep@nn {#1}{#2}
%    \end{macrocode}
%    Because we don't know the length of the first two arguments to
%    |\xfm@area@value@nnn| we add the expanded third argument in a
%    separate step.
%    \begin{macrocode}
  \tlp@gput@right@cn
     { g@xfm@#1@list@tlp }
     { \xfm@area@value@nnn {#1}{#2} }
  \tlp@gput@right@co
     { g@xfm@#1@list@tlp }
     { \expandafter { #3 } }
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
% \begin{macro}{\xfm@add@element@sep@nn}
%    |\xfm@add@element@sep@nn| takes an area name as first argument
%    and an element name as second argument and appends the line
%\begin{verbatim}
%   \xfm@area@sep@nnn {<area>} {<last-element>} {<upcoming-element>}
%\end{verbatim}
%    to the area tlp.
%    \begin{macrocode}
\def \xfm@add@element@sep@nn #1#2 {
%    \end{macrocode}
%    We have to get the contents of |\g@xfm@|\meta{area}|@last@tlp|
%    into the area tlp and the easiest way to do this is via full
%    expansion.
%    \begin{macrocode}
  \edef \@tempa
     { \noexpand \xfm@area@sep@nnn 
                 { #1 }
                 { \csname g@xfm@ #1 @last@tlp \endcsname }
                 { #2 }
     }
%    \end{macrocode}
%    After that we can update |\g@xfm@|\meta{area}|@last@tlp| to point
%    to the new name.
%    \begin{macrocode}
  \tlp@gset@cn{g@xfm@ #1 @last@tlp}{#2}
%    \end{macrocode}
%    Finally we add the contents of |\@tempa| to the area tlp.
%    \begin{macrocode}
  \tlp@gput@right@co
     {g@xfm@ #1 @list@tlp}
     \@tempa
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xfm@area@value@nnn}
%    |\xfm@area@value@nnn| picks up an area name and a descriptive
%    element name and finds the formatting for it. Then it applies
%    that to the third argument which is the element's value.
%    \begin{macrocode}
\def \xfm@area@value@nnn #1#2 {
  \@ifundefined{xfm@#1-#2}
    {
     \@ifundefined{xfm@*-#2}
	\@firstofone
	{ \csname xfm@*-#2 \endcsname }
    }
    { \csname xfm@#1-#2 \endcsname }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareElementFormat}
%    |\DeclareElementFormat| desclares the formatting for element |#2|
%    in area |#1|. The formatting code has one argument and we pick it
%    up implicitly so that we can use `|#1|' in the third argument.
%    \begin{macrocode}
\def \DeclareElementFormat #1#2 { \@namedef{xfm@#1-#2}##1 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xfm@area@sep@nnn}
%    The |\xfm@area@sep@nnn| is the area separator function apearing
%    between elements in the area. It is a huge bunch of tests to find
%    out which combinations of element names and stars is defined and
%    which of them needs execution. See section \ref{sec:eltsep} for
%    an explanation of the logic.
%    \begin{macrocode}
\def\xfm@area@sep@nnn #1#2#3 {
  \@ifundefined{xfm@#1-#2-#3}
    {
      \@ifundefined{xfm@#1-#2-*}
        {
          \@ifundefined{xfm@#1-*-#3}
            {
              \@ifundefined{xfm@#1-*-*}
                {}
                { \csname xfm@#1-*-* \endcsname }
            }
            { \csname xfm@#1-*-#3 \endcsname }
        }
        { \csname xfm@#1-#2-* \endcsname
          \@ifundefined{xfm@#1-*-#3}
            {}
            { \csname xfm@#1-*-#3 \endcsname }
        }
    }
    { \csname xfm@#1-#2-#3 \endcsname }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \subsection{Markers}
%
% As mentioned above markers are essentially \LaTeX{} counters with a
% few additions. Here is a list of internals structures set up when a
% marker named |FOO| is declared.
%
% \DescribeMacro\c@FOO
%    The current value of the marker is stored in the count register
%    |\c@FOO|.
%
% \DescribeMacro\theFOO
%    The basic display representation of the marker is given by
%    |\theFOO|.
%
% \DescribeMacro\g@xfm@FOO@prop
%    For each marker |FOO| we maintain a property list
%    |\g@xfm@FOO@prop| in which we put under the key
%    |\mark-|\meta{marker-num} the following data
%\begin{verbatim}
%  { <display-value> }{ <target-text> }
%\end{verbatim}
%    which is needed if we want combine reference to identical text.
%
%    This property list will change with a different implementation,
%    see ``Questions, Issues'' section!
%
% \DescribeMacro\xfm@format@source@marker@FOO@n
%    A command with one argument which describes the formatting to be
%    applied to the marker value if used in the source area.
%
% \DescribeMacro\xfm@format@target@marker@FOO@n
%    A command with one argument which describes the formatting to be
%    applied to the marker value if used in a target area.
%
%
% \begin{macro}{\DeclareFMMarker}
%    The |\DeclareFMMarker| simply hides the fact that the
%    key/value parsing is done via a template. It declares an instance
%    and immediately executes it.
%    \begin{macrocode}
\def\DeclareFMMarker #1#2{
  \UseTemplate{FMmarkersetup}{std}{#2}{#1}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{FMmarkersetup (template type)}
%    Here is the template type declaration.
%    \begin{macrocode}
\DeclareTemplateType{FMmarkersetup}{1}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{FMmarkersetup/std (template)}
%    The purpose of this template is to set up the marker data
%    structures.
%    \begin{macrocode}
\DeclareTemplate{FMmarkersetup}{std}{1}{
   marker-type   =f0 \FMmarker@type,
   source-format =f1 \FMmarker@source@format,
   target-format =f1 \FMmarker@target@format,
 }
 {
%    \end{macrocode}
%    As defaults we use |\arabic| for the |marker-type|, |#1| for the
%    |source-format| and the value of |source-format| (default or
%    modified) for the |target-format|. To be able to determine if a
%    value for |target-format| was given we default it to some
%    impossible value and later on test for that.
%    \begin{macrocode}
   \def\FMmarker@type{\arabic}
   \let\FMmarker@source@format\@firstofone
   \let\FMmarker@target@format\NoValue
%    \end{macrocode}
%    
%    \begin{macrocode}
   \DoParameterAssignments
%    \end{macrocode}
%    Make a new \LaTeX{}  counter with the name of the marker; due to
%    this the declaration is currently not modifiable once it is
%    given!
%    \begin{macrocode}
   \newcounter {#1}
   \expandafter\xdef\csname the#1 \endcsname
      {\expandafter\noexpand\FMmarker@type {#1} }
%    \end{macrocode}
%    Provide the special property list that we need for combining
%    references.
%    \begin{macrocode}
   \prop@new@c {g@xfm@ #1 @prop}
%    \end{macrocode}
%    We store the source format in the appropriate command:
%    \begin{macrocode}
   \global\expandafter\let 
      \csname xfm@format@source@marker@ #1 @n \endcsname
      \FMmarker@source@format
%    \end{macrocode}
%    If |\FMmarker@target@format| still equals |\NoValue| we
%    haven't got any user value, so we |\let| it to the current value
%    of |source-format|.
%    \begin{macrocode}
   \ifx\FMmarker@target@format\NoValue
      \let\FMmarker@target@format\FMmarker@source@format
   \fi
%    \end{macrocode}
%    Then we store whatever we have in the command that has the marker
%    name in its name.
%    \begin{macrocode}
   \global\expandafter\let 
      \csname xfm@format@target@marker@ #1 @n \endcsname
      \FMmarker@target@format
 }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \subsection{Front Matter Structure Data}
%
% 
% \subsubsection{Strcuture Input Specification}
% 
%
% \begin{macro}{\author}
%    The |\author| command stores the key/values as properties in a
%    property list which is named |\g@xfm@structure@|\meta{num}|@prop| where
%    \meta{num} is a sequence number which we get from incrementing
%    the counter |\g@xfm@structure@cnt|. Thus that counter will tell us the
%    number of authors seen in total.

%    In addition we store the current value of that counter in the
%    queue |\g@xfm@authors@queue| so that this queue will initially hold
%    the value $1,\ldots,n$ if we have $n$ authors in total.
%
%    Thus we can loop through this queue if we want to process the
%    authors. Also, if authors need to be sorted by address, we can
%    remove values from this queue once they are processed and thus
%    keep track of the authors still unprocessed.
%
%    The key names are of the form |\xfm@key@|\meta{name-of-key}.
%    \begin{macrocode}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\g@xfm@structure@cnt}
%    We count the |\author| commands seen in the counter
%    |\g@xfm@structure@cnt|. At a later stage the counter is used to denote
%    the number of authors during processing, e.g., when sorting by
%    address it denotes the number of authors found for the current
%    address.
%    \begin{macrocode}
\newcount\g@xfm@structure@cnt
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xfm@structure@parse@keyword@code@n}
%    |\xfm@structure@parse@keyword@code@n| is the code used to evaluate a key
%    using |\setkeys{xfm}|, i.e., for each keyword \meta{key} we want
%    to allow in the second argument of |\authors| we need to |\let|
%    the macro name |\KV@xfm-|\meta{structure}|@|\meta{key} to this
%    macro (this is done in the declaration of keys for the |\author|
%    command below).
%
%    We could have used |\define@key| in that declaration but since
%    the code is the same for all keys using a direct |\let| saves a
%    lot of space.
%
%    The purpose of the code is to store the key value as a property
%    in the property list for the current author using the property
%    key |\xfm@key@|\meta{key}.
%
%    The macro has an argument but we can make it implicit and have
%    |\prop@gput@ccn| to pick it up as its third argument.
%
%    If anybody wonders what the |\@tempa| is doing\marginpar{DANGER:
%    bad dependency to keyval package} in the second argument to
%    |\prop@gput@ccn| \ldots: it holds the value of the parsed key (so
%    this is totally dependent on the implementation of |\setkeys|,
%    urg, which should offer a proper interface to the currently
%    parsed key name but doesn't).
%
%    \begin{macrocode}
\def \xfm@structure@parse@keyword@code@n {
  \prop@gput@ccn  
     {g@xfm@structure@ \the\g@xfm@structure@cnt @prop}
     {xfm@key@\@tempa}
}
%    \end{macrocode}
% \end{macro}
%
%
% 
% 
% \subsubsection{Declaring keywords for a structure command}
% 
% To declare a keyword |FOO| for the front matter structure BAR we have to set
%    up a number of internal data structures.
%
% \DescribeMacro{\KV@xfm-BAR@FOO}
%    The |\KV@xfm-BAR@FOO| command is the parsing routine for
%    \texttt{keyval} to capture the keyword |FOO| within the structure |BAR|.
%
%
% \DescribeMacro\xfm@format@key@FOO@n
%    The macro |\xfm@format@key@FOO@n| holds the formatting
%    instructions for the key value when it is passed into the target
%    area.
%
% \DescribeMacro\xfm@find@marker@FOO@Nn
%    The macro |\xfm@find@marker@FOO@Nn| executed if we try to find an
%    already existing value to combine marker information. It will be
%    either |\let| to |\xfm@find@marker@Nn| (in which case we try to
%    combine) or to |\@gobble| (in which case we  loop but only through
%    data away --- not very efficient)
%
% \DescribeMacro{\xfm@process@key@author-FOO@N}
%    The macro |\xfm@process@key@author-FOO@N| stores the code that is
%    executed when we try to distribute this particular key value to
%    some target area. It is either a call to
%    |\xfm@append@keyval@nnN| or to
%    |\xfm@linkappend@keyval@nnnnN| with all but the last
%    arguments fixed. Which of the two is used depends on the
%    value for the |marker-id|: if we don't have markers we
%
%
%
% \begin{macro}{\DeclareFMKeyword}
%    |\DeclareFMKeyword| takes the name of a structure (without
%    backslash) as first argument, the name of a keyword for this
%    structure as second argument and the specification what to do for
%    this keyword as a third argument.
%    \begin{macrocode}
\def\DeclareFMKeyword #1#2#3{
 \UseTemplate{keywordsetup}{std}{#3}{#1}{#2}
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{keywordsetup (template type)}
%    Arguments are structure and keyword names.
%    \begin{macrocode}
\DeclareTemplateType{keywordsetup}{2}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{keywordsetup/std (template)}
%    The purpose of this template is to register a keyword for a front
%    matter structure command and set up the necessary data
%    structures.
%    \begin{macrocode}
\DeclareTemplate{keywordsetup}{std}{2}{
   value-targetarea-id    =n  \keysetup@target@area@id,
   value-required-boolean =s  {}
                             {\let\keysetup@missing@key\relax},
   value-combine-boolean  =s  {\let\keysetup@combine@boolean
                              \xfm@find@marker@Nn}
                             {},
   value-format           =f1 \keysetup@keyword@format,
   marker-id              =n  \keysetup@marker@id,
   marker-sourcearea-id   =n  \keysetup@source@area@id,

   value-targetarea-id2   =n  \keysetupii@target@area@id,
   value-format2          =f1 \keysetupii@keyword@format,
   marker-sourcearea-id2  =n  \keysetupii@source@area@id,
   marker-id2             =n  \keysetupii@marker@id,

   value-targetarea-id3   =n  \keysetupiii@target@area@id,
   value-format3          =f1 \keysetupiii@keyword@format,
   marker-sourcearea-id3  =n  \keysetupiii@source@area@id,
   marker-id3             =n  \keysetupiii@marker@id,

 }
 {
%    \end{macrocode}
%    Start by setting up (sensible?) defaults: by default we don't
%    have a marker and we format the key value by simply passing it on
%    unchanged --- easy.
%    \begin{macrocode}
   \let\keysetup@marker@id\@empty
   \let\keysetupii@marker@id\@empty
   \let\keysetupiii@marker@id\@empty
   \let\keysetup@keyword@format\@firstofone
   \let\keysetupii@keyword@format\@firstofone
   \let\keysetupiii@keyword@format\@firstofone
%    \end{macrocode}
%    If no |marker-sourcearea-id| for the marker is given we assume that the
%    author name will go to the area |authors| and that the marker
%    reference therefore should be there too --- less clear.
%    \begin{macrocode}
   \def\keysetup@source@area@id{authors}
   \let\keysetupii@source@area@id\@empty
   \let\keysetupii@target@area@id\@empty
   \let\keysetupiii@source@area@id\@empty
   \let\keysetupiii@target@area@id\@empty
%    \end{macrocode}
%    By default declared front matter structure keys are required,
%    which may be the wrong way round.
%    \begin{macrocode}
   \def\keysetup@missing@key{\xfm@error@key@nn{#1}{#2}}
%    \end{macrocode}
%    By default we do not combine entries.
%    \begin{macrocode}
   \let\keysetup@combine@boolean\@gobbletwo
%    \end{macrocode}
%    
%    \begin{macrocode}
   \DoParameterAssignments
%    \end{macrocode}
%    Registering the keyword means linking the \texttt{keyval} parsing
%    routine to the default parsing routine for front matter structure
%    keywords.
%    \begin{macrocode}
   \global\expandafter\let 
      \csname KV@xfm-#1@ #2 \endcsname
      \xfm@structure@parse@keyword@code@n
%    \end{macrocode}
%    
%    \begin{macrocode}
   \global\expandafter\let 
      \csname xfm@ \keysetup@target@area@id -key: #2 \endcsname
      \keysetup@keyword@format
%    \end{macrocode}
%    
%    \begin{macrocode}
   \ifx\keysetupii@target@area@id\@empty
   \else
     \global\expandafter\let 
	\csname xfm@ \keysetupii@target@area@id -key: #2 \endcsname
	\keysetupii@keyword@format
   \fi

   \ifx\keysetupiii@target@area@id\@empty
   \else
     \global\expandafter\let 
	\csname xfm@ \keysetupiii@target@area@id -key: #2 \endcsname
	\keysetupiii@keyword@format
   \fi
%    \end{macrocode}
%    
%    \begin{macrocode}
   \global\expandafter\let 
      \csname xfm@find@marker@ #2 @Nn \endcsname
      \keysetup@combine@boolean
%    \end{macrocode}
%    
%    \begin{macrocode}
   \global\expandafter\edef
      \csname xfm@process@key@ #1-#2 @N \endcsname
      ##1
      {
       \ifx\keysetup@marker@id\@empty
          \noexpand\xfm@append@keyval@nnN
          {#2}
       \else
          \noexpand\xfm@linkappend@keyval@nnnnN
          {#2}
          {\keysetup@marker@id}
          {\keysetup@source@area@id}
       \fi
       {\keysetup@target@area@id}
       ##1

       \ifx\keysetupii@target@area@id\@empty
       \else
         \ifx\keysetupii@marker@id\@empty
            \noexpand\xfm@append@keyval@nnN
            {#2}
         \else
            \noexpand\xfm@linkappend@keyval@nnnnN
            {#2}
            {\keysetupii@marker@id}
            {\keysetupii@source@area@idi}
         \fi
         {\keysetupii@target@area@id}
         ##1
       \fi

       \ifx\keysetupiii@target@area@id\@empty
       \else
         \ifx\keysetupiii@marker@id\@empty
            \noexpand\xfm@append@keyval@nnN
            {#2}
         \else
            \noexpand\xfm@linkappend@keyval@nnnnN
            {#2}
            {\keysetupiii@marker@id}
            {\keysetupiii@source@area@idi}
         \fi
         {\keysetupiii@target@area@id}
         ##1
       \fi
   }
 }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xfm@error@key@nn}
%    Raise an error when a required keyword (|#2|) in the front matter
%    structure |#1| is missing. Could and should give better help one
%    day.
%    \begin{macrocode}
\def\xfm@error@key@nn #1#2 {
  \PackageError{xfm}{Required~ keyword~`#2'~missing~ in~
     front~ matter~ structure~ `#1'}\@eha}
%    \end{macrocode}
% \end{macro}
%
%
% 
% 
% \subsubsection{Processing data of one author}
%
%
% \begin{macro}{\xfm@distribute@structure@data@nn}
%    This macro takes the reference to one author as an argument and
%    processes for this author all keywords specified in
%    |\g@xfm@author@keyword@order@tlp|, i.e., distributes their values
%    to appropriate title areas as specified by the keyword instance
%    (including references if requested).
%    \begin{macrocode}
\def\xfm@distribute@structure@data@nn #1#2 {
%    \end{macrocode}
%    Loop over the keyword names in |#1|
%    and\ldots
%    \begin{macrocode}
  \expandafter
  \@for \expandafter \@tempa \expandafter : \expandafter = 
     \csname g@xfm@ #1 @keyword@order@tlp \endcsname
     \do {
%    \end{macrocode}
%    \ldots call for each keyword the command that holds the code to
%    distribute and manipulate the keyword value is present. This
%    command requires the authors property list so we construct it as
%    well.
%    \begin{macrocode}
     \expandafter
     \ifx \csname xfm@process@key@ #1-\@tempa @N \endcsname \relax
%    \end{macrocode}
%    Runtime checking like this bad, should be checked in the template
%    code!\footnote{FIX!}
%    \begin{macrocode}
         \PackageError{xfm}{Undeclared~ keyword:~ \@tempa}\@eha
     \else
       \csname xfm@process@key@ #1-\@tempa @N \expandafter \endcsname
       \csname g@xfm@structure@ #2 @prop \endcsname
     \fi
  }
}
%    \end{macrocode}
% \end{macro}
%
% The macro
% |\xfm@process@key@|\meta{structure-name}|-|\meta{key-name}|@N| in
% the above loop is supposed to distribute the key value to a target
% area according to the specification given in the declaration for
% this key. This is done in one of two ways: the simple form simply
% adds the value as an element to an area and makes sure that it is
% properly separated by a separator function (as explained in the
% section on areas) --- this is done by calling
% |\xfm@append@keyval@nnN| with appropriate arguments.
%
% The more complicated form also
% handles linking the information with some other area by putting
% marker elements into both --- this is done by calling
% |\xfm@linkappend@keyval@nnnnN| with appropriate arguments.
%
% Some attempt was made to make these two macros independent of the
% particular |\author| key data structure. However, this isn't fully
% done so more work is needed if the macros should be usable on
% non-author property lists.
%
%
% \begin{macro}{\xfm@append@keyval@nnN}
%    The |\xfm@append@keyval@nnN| command takes three arguments: a key
%    name, a target area name, and a property list in which we look up
%    the key.
%    \begin{macrocode}
\def \xfm@append@keyval@nnN #1#2#3 {
%    \end{macrocode}
%    As a first step look up the key in the property list assuming
%    that the property list key is constructed from the key name by
%    prepending |\xfm@key@|. The result is stored in
%    |\g@xfm@result@tlp|.
%    \begin{macrocode}
  \prop@gget@NcN
     #3
     {xfm@key@#1}
     \g@xfm@result@tlp
%    \end{macrocode}
%    Check if we have found this key at all (otherwise we now have the
%    quark |\q@no@value| in |\g@xfm@result@tlp|):
%    \begin{macrocode}
  \quark@if@no@value@NTF \g@xfm@result@tlp
%    \end{macrocode}
%    If the key was not found we execute the code that was set up when
%    the key was registered. It will either be |\relax| or generate an
%    error if the key is required.
%    \begin{macrocode}
     { \csname xfm@missing@key@#1@ \endcsname }
%    \end{macrocode}
%    If the key was found we add its value to the target area.
%    \begin{macrocode}
     { \xfm@add@element@nno {#2} {key:#1} \g@xfm@result@tlp }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\xfm@linkappend@keyval@nnnnN}
%    \begin{macrocode}
% key-name, marker-name, sourcearea-name, target-area-name, author-prop 
% #1      , #2         , #3                #4                #5


\def\xfm@linkappend@keyval@nnnnN #1#2#3#4#5 {
  \prop@gget@NcN
     #5
     {xfm@key@#1}
     \g@xfm@result@tlp

%    \end{macrocode}
%    If the key was specified we have a value in |\g@xfm@result@tlp|,
%    otherwise the key is missing and we may or may not have to do
%    something about that.
%    \begin{macrocode}
  \quark@if@no@value@NTF \g@xfm@result@tlp
%    \end{macrocode}
%    Do whatever is required if the key is missing token at this point
%    (the code is in the macro being constructed):
%    \begin{macrocode}
     { \csname xfm@missing@key@#1@ \endcsname }
%    \end{macrocode}
%    
%    \begin{macrocode}
     {
      \let\l@xfm@result@tlp\q@no@value

      \prop@map@cc 
          {g@xfm@ #2 @prop}
          {xfm@find@marker@#1@Nn}

      \quark@if@no@value@NT \l@xfm@result@tlp
%    \end{macrocode}
%    
%    Value does not exist, so make new mark:
%    \begin{macrocode}
        {
          \stepcounter{#2}
          \protected@xdef
             \g@xfm@resultiii@tlp { \csname the#2 \endcsname }

%    \end{macrocode}
%    Next bit of code adds an entry to the property list
%    |#2|, this could be done manually which would be faster but less
%    understandable.
%
%    First start the value of the marker number and the text as two
%    brace groups in |\g@xfm@resultii@tlp|
%    \begin{macrocode}
          \tlp@gset@No 
             \g@xfm@resultii@tlp 
             { \expandafter { \g@xfm@resultiii@tlp } }
          \tlp@gput@right@No
             \g@xfm@resultii@tlp 
             { \expandafter { \g@xfm@result@tlp } }
%    \end{macrocode}
%    Then put all of that into the property list:
%    \begin{macrocode}
          \prop@gput@cco
             {g@xfm@ #2 @prop}
             {mark-\the\value{#2}}
             \g@xfm@resultii@tlp

%    \end{macrocode}
%    
%    \begin{macrocode}
          \xfm@add@element@nno {#4} {marker:#2} \g@xfm@resultiii@tlp

          \xfm@add@element@nno {#4} {key:#1} \g@xfm@result@tlp

        }
%    \end{macrocode}
%    At this point the mark reference is definitely in
%    |\l@xfm@result@tlp| so we can append it to the
%    to the source area.
%    \begin{macrocode}

      \xfm@add@element@nno {#3} {marker:#2} \g@xfm@resultiii@tlp

     }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\g@xfm@result@tlp}
% \begin{macro}{\g@xfm@resultii@tlp}
% \begin{macro}{\g@xfm@resultiii@tlp}
% \begin{macro}{\l@xfm@result@tlp}
%    Some temporary storage bins three globally used one locally (but
%    this is mainly a historical fact.
%    \begin{macrocode}
\tlp@new@Nn\g@xfm@result@tlp{}
\tlp@new@Nn\g@xfm@resultii@tlp{}
\tlp@new@Nn\g@xfm@resultiii@tlp{}
\tlp@new@Nn\l@xfm@result@tlp{}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\xfm@find@marker@Nn}
%    \begin{macrocode}
%    This bit of code finds an already existing marker with a value
%    equal to the text stored in |\g@xfm@result@tlp|.
%    \begin{macrocode}
\def \xfm@find@marker@Nn #1 #2 {
  \tlp@gset@No \g@xfm@resultii@tlp  { \@secondoftwo #2 }
  \tlp@gset@No \g@xfm@resultiii@tlp { \@firstoftwo  #2 }
  \ifx \g@xfm@result@tlp\g@xfm@resultii@tlp
    \tlp@set@Nn \l@xfm@result@tlp {#1}
    \let \prop@map@funct@Nn \@gobbletwo
  \fi
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \subsection{Remaining Document Commands}
%
%
%
% \begin{macro}{\xfm@structure@loop@n}
% \begin{macro}{\xfm@structure@loop@nN}
%    |\xfm@structure@loop@n| loops through an structure queue (i.e.,
%    |\g@xfm@#1@queue|) and applies
%    |\xfm@distribute@structure@data@nn{#1}| to each structure element
%    in the queue.
%
%    |\xfm@structure@loop@nN| is the variant that needs to be used if
%    the queue name is not standard (i.e., not the one corresponding
%    to the structure), for example, during sorting.
%    \begin{macrocode}
\def \xfm@structure@loop@n #1 {
  \expandafter
  \xfm@structure@loop@Nn
     \csname g@xfm@ #1 @queue \endcsname
     {#1}
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \xfm@structure@loop@Nn #1#2 {
  \queue@map@Nn
    #1
    { \xfm@distribute@structure@data@nn{#2}{##1} }
%    \end{macrocode}
%    A bit of debugging (at the moment):
%    \begin{macrocode}
  \XFMShowAreas
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
% \subsection{Algorithm for sorting by address}
% 
% The author numbers are stored in a queue which at the start simply
% contains the numbers $1$ to $n$ if we have $n$ authors in the preamble
% specified.
% 
% The algorithm works on this queue in the following way:
% \begin{itemize}
% \item Check if the |authors| queue is empty; if so processing stops.
% \item Otherwise remove the first element from the |authors| queue and
%   retrieve its address and store its value in |curr-address|.
% \item Store the element as the first element of the queue
%   |curr-queue|.
% \item Clear the queue |remaining-authors|.
% \item Set the counter |author-cnt| to 1.
% \item Now loop through the remainder of the queue |authors| and do the
%   following:
%   \begin{itemize}
%   \item If for the current element the address is the same as
%     |cur-address| append the current element to |curr-queue| and
%     advance |author-cnt| by one.
%   \item Otherwise append the current element to the queue
%     |remaining-authors|.
%   \end{itemize}
% \item Replace the contents of the |authors| queue by the contents of
%   the |remaining-authors| queue.
% \end{itemize}
% At this point in time we have the following situation:
% \begin{itemize}
% \item Queue |curr-address| contains the current address.
% \item Tlp |curr-queue| contains the authors having this address.
% \item |author-cnt| contains the number of authors in this queue
% \item Queue |authors| contains the remaining authors having addresses
%   not yet processed.
% \end{itemize}
% This means that we can now format the authors in |curr-queue| and then
% restart the algorithm processing any remaining authors started in the
% |authors| queue.
% 
% \subsubsection{Processing the \texttt{curr-queue}}
% 
% The authors in |curr-queue| will be processed in the normal way, i.e.,
% by looping through all keywords of interest (with the exception of
% |address| since that is the same for all authors in the queue) and
% appending their values to appropriate areas.
% 
% As a result we will get:
% \begin{itemize}
% \item The authors names followed by any labels in
%   |\g@xfm@authors@list@tlp|.
% \item The address still in |curr-address|.
% \item Any other keyword values the desired area lists, e.g., if
%   |thanks| is moved to the |footnote-area| its value will be appended
%   there in the form
% \begin{verbatim}
%   \xfm@format@key@thanks@nn{<label-number>}{<text>}
% \end{verbatim}
%   allowing further formatting at this point as desired.
% \end{itemize}
% 
% By default we only append data to the areas. This means that if an
% area is to be intended to belong solemnly to the group of authors
% currently processed (i.e., those in |curr-queue|) then it is the
% responsibility the processing code to clear those areas.
% 
% For example, if the layout is to be something like this:
% \begin{verbatim}
%    <Author1>, <Author2>, and <Author3>
% 
%    <Main address for all authors above>
%    <data special to individual authors referenced via labels>
% 
%    <Author4>, ...
% \end{verbatim}
% then the area receiving the ``special data'' needs to be cleared after
% processing to avoid that its contents shows up again below
% |<Author4>|. On the other hand, data going into the footnote area does
% not need this treatments since the latter area is processed only once
% at the very end.
% 
% 
%
%
% \begin{macro}{\g@xfm@curr@sort@queue}
% \begin{macro}{\g@xfm@remaining@sort@queue}
%    Two queues are used when sorting some queue by a key:
%    |\g@xfm@curr@sort@queue| receives elements matching the current
%    key value while |\g@xfm@remaining@sort@queue| receives those
%    which do not match and need further processing at a later
%    stage.
%    \begin{macrocode}
\queue@new@N\g@xfm@curr@sort@queue
\queue@new@N\g@xfm@remaining@sort@queue
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\g@xfm@curr@sort@value@tlp}
%    In |\g@xfm@curr@sort@value@tlp| we store the value of a key when
%    doing sorting by this key.
%    \begin{macrocode}
\tlp@new@Nn \g@xfm@curr@sort@value@tlp{}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\xfm@structure@sorted@by@nnn}
%    \begin{macrocode}
\def \xfm@stucture@sorted@by@nnn #1#2 {
   \expandafter
   \xfm@structure@sorted@by@NNnnn
     \csname g@xfm@ #1 @queue \expandafter\endcsname
     \csname xfm@key@ #2 \endcsname
     {#1}
     {#2}
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xfm@structure@sorted@by@NNnnn}
%    The |\xfm@structure@sorted@by@NNnnn| macro takes formatting
%    instructions as its argument: those which should be processed
%    when all authors with a certain address have been found.
%    \begin{macrocode}
\def \xfm@structure@sorted@by@NNnnn #1#2#3#4#5 {
%    \end{macrocode}
%    We start by looking if the queue |#1| is empty,
%    if so we have done all that is needed and return immediately
%    (this ends the recursive call below).
%    \begin{macrocode}
  \queue@empty@NTF #1
    {}
%    \end{macrocode}
%    Otherwise we prepare for finding the next batch of authors with
%    the same address. For this we clear the queue
%    |\g@xfm@curr@sort@queue| which will receive all authors found.
%    The queue |\g@xfm@remaining@sort@queue| doesn't need clearing
%    since it is empty at this point (see below).
%    \begin{macrocode}
    {
     \queue@gclear@N\g@xfm@curr@sort@queue
%    \end{macrocode}
%    Then we pop the top element from |#1| and store
%    the result in |\g@xfm@result@tlp| and also put it into the queue
%    |\g@xfm@curr@sort@queue|.
%    \begin{macrocode}
     \queue@gpop@NN
       #1
       \g@xfm@result@tlp
     \queue@gadd@No
       \g@xfm@curr@sort@queue
       \g@xfm@result@tlp
%    \end{macrocode}
%    Next step is to retrieve the keyword value for this structure and
%    store it in |\g@xfm@curr@sort@value@tlp|.
%    \begin{macrocode}
     \prop@gget@cNN
       {g@xfm@structure@ \g@xfm@result@tlp @prop}
       #2
       \g@xfm@curr@sort@value@tlp

%    \end{macrocode}
%    If the key was not in we have a problem (perhaps the solution is
%    to make this key required if you want to sort by it :-) --- have
%    to think it through, for the moment we just balk.
%    \begin{macrocode}
     \quark@if@no@value@NT
        \g@xfm@curr@sort@value@tlp
        {
         \PackageError{xfm}{Keyword~ `#4'~ for~ sorting~ missing~ in~
           structure~ `#3'}\@eha
         \tlp@gset@Nn\g@xfm@curr@sort@value@tlp{<MISSING~KEY>}
        }
%    \end{macrocode}
%    Since we have found the first author for this address we set the
%    |\g@xfm@structure@cnt| to 1.
%    \begin{macrocode}
     \global\g@xfm@structure@cnt\@ne
%    \end{macrocode}
%    Now we loop through the remaining elements in the queue
%    |#1| each time determining whether or not the
%    element under inspection has the same address as stored in
%    |\g@xfm@curr@sort@value@tlp| and if so add it to
%    |\g@xfm@curr@sort@queue|. Otherwise we add it to the queue
%    |\g@xfm@remaining@sort@queue|. This is done by mapping
%    |\xfm@find@key@value@Nn#2| over the queue |#1|.
%    \begin{macrocode}
     \queue@map@Nn
       #1
       { \xfm@find@key@value@Nn #2 {##1} }
%    \end{macrocode}
%    Once we are finished with this we can move the authors from the
%    |\g@xfm@remaining@sort@queue| back to |#1|
%    for the next iteration. After that this temporary queue can be
%    cleared.
%    \begin{macrocode}
     \global\let#1\g@xfm@remaining@sort@queue
     \queue@gclear@N\g@xfm@remaining@sort@queue
%    \end{macrocode}
%    A bit debugging stuff atthis point:
%    \begin{macrocode}
     \show\g@xfm@curr@sort@queue
     \show #1
%    \end{macrocode}
%    Now we loop through all the elements in |\g@xfm@curr@sort@queue|
%    and distribute their key values into the appropriate areas.
%    \begin{macrocode}
     \xfm@structure@loop@Nn
       \g@xfm@curr@sort@queue
       {#3}
%    \end{macrocode}
%
%    The\marginpar{WRONG: this is still done correctly only for
%    addresses area and address keyword!!! FIXME} 
%    next bit of code isn't really as it should be (I guess) but
%    we have a problem here: if |value-combine-boolean| was set to |false|
%    for the |address| key we end up with the current address several
%    times in the |\g@xfm@addresses@list@tlp| which makes the |address|
%    area basically unusable.
%
%    But why use this area in the first place and not
%    |\g@xfm@curr@sort@value@tlp| which contains the current address?
%    Well, for one we can have the situation that alternate addresses
%    should also go into that area, perhaps mixed with emails etc. But
%    this only makes sense if the |address| key is set up in a way
%    that it appears only once, i.e., if |value-combine-boolean| for it is
%    set to |true|.
%
%    So the current logic is as follows:
%    \begin{itemize}
%    \item
%      If |value-combine-boolean| is |false| for the address key then the
%      current address will be the only text appearing in the
%      |address| area; if any other keys contribute to that area ---
%      tough, their values get overwritten.
%    \item
%      Otherwise keys are distributed into any area in the normal
%      fashion.
%    \end{itemize}
%
%    The\marginpar{RUBBISH: rewrite!}
%    status of the |value-combine-boolean| key for |address| can be
%    found by looking at |\xfm@find@marker@address@Nn|. If we are not
%    interested in finding address markers, then we haven't been asked to
%    combine addresses.
%    \begin{macrocode}
    \ifx\xfm@find@marker@address@Nn\@gobbletwo
%    \end{macrocode}
%    So this is the case when we overwrite whatever was added to
%    |\g@xfm@addresses@list@tlp| and replace it by a single element:
%    \begin{macrocode}
%????
      \tlp@gset@Nn\g@xfm@addresses@list@tlp
         {
           \xfm@area@sep@nnn {addresses}{START}{key:address}
           \xfm@area@value@nnn {addresses}{key:address}
         }
      \tlp@gput@right@No\g@xfm@addresses@list@tlp 
         { \expandafter { \g@xfm@curr@sort@value@tlp } }

    \fi
%    \end{macrocode}
%
%    So finally we are ready to do some formatting:
%    \begin{macrocode}
     #5
%    \end{macrocode}
%    And then recourse if necessary:
%    \begin{macrocode}
     \xfm@structure@sorted@by@NNnnn #1 #2 {#3} {#4} {#5}
    }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\xfm@find@key@value@Nn}
%    The |\xfm@find@key@value@Nn| is the code that tries to find elements
%    with the same key value as the one given in
%    |\g@xfm@curr@sort@value@tlp|. The first argument is the internal
%    key and the second is a pointer to a
%    structure property list name as we store it in the structure queues.
%    \begin{macrocode}
\def \xfm@find@key@value@Nn #1#2 {
%    \end{macrocode}
%    First we retrieve the key value for the current element and
%    store it in |\g@xfm@result@tlp|.
%    \begin{macrocode}
  \prop@gget@cNN
    {g@xfm@structure@ #2 @prop}
    #1
    \g@xfm@result@tlp
%    \end{macrocode}
%    If this value corresponds to what is stored in
%    |\g@xfm@curr@sort@value@tlp| we add the current element to the
%    |\g@xfm@curr@sort@queue| queue and increment the counter
%    counting the number of elements found.
%    \begin{macrocode}
  \ifx \g@xfm@result@tlp\g@xfm@curr@sort@value@tlp
    \global\advance\g@xfm@structure@cnt\@ne
    \queue@gadd@Nn \g@xfm@curr@sort@queue {#2}
%    \end{macrocode}
%    Otherwise we add the current element to the the queue of remaining
%    elements, i.e., |\g@xfm@remaining@sort@queue|.
%    \begin{macrocode}
  \else
    \queue@gadd@Nn \g@xfm@remaining@sort@queue {#2}
  \fi
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \section{Stuff}
%
%
%
%
%    
%    \begin{macrocode}
\def\NoValue{-NoValue-}
%    \end{macrocode}
%
%
%    \begin{macrocode}
\DeclareTemplateType{titlesetup}{0}

\DeclareTemplate{titlesetup}{authorbyaddress}{0}{
   author-keyword-list =f0 \g@xfm@authorinfo@keyword@order@tlp,
   articleinfo-keyword-list =f0 \g@xfm@articleinfo@keyword@order@tlp,
   top-areas-list      =f0 \g@xfm@top@areas@tlp,
   author-areas-list   =f0 \g@xfm@authors@areas@tlp,
   bottom-areas-list   =f0 \g@xfm@bottom@areas@tlp,
   footins-areas-list  =f0 \g@xfm@footins@areas@tlp,
 }
 {

   \def\g@xfm@authorinfo@keyword@order@tlp{name,address,thanks}
   \def\g@xfm@articleinfo@keyword@order@tlp{title,subtitle,thanks}

   \DoParameterAssignments

   \xfm@structure@loop@n {articleinfo}

   \xfm@typeset@area@list@n \g@xfm@top@areas@tlp

   \xfm@stucture@sorted@by@nnn
     {authorinfo}
     {address}
     { \xfm@typeset@area@list@n \g@xfm@authors@areas@tlp  }

   \xfm@typeset@area@list@n \g@xfm@bottom@areas@tlp

   \xfm@typeset@insertion@area@list@nn 
     \g@xfm@footins@areas@tlp
     \footins
 }




\DeclareTemplate{titlesetup}{tub}{0}{
   author-keyword-list =f0 \g@xfm@authorinfo@keyword@order@tlp,
   articleinfo-keyword-list =f0 \g@xfm@articleinfo@keyword@order@tlp,
   top-areas-list      =f0 \g@xfm@top@areas@tlp,
   author-areas-list   =f0 \g@xfm@authors@areas@tlp,
   bottom-areas-list   =f0 \g@xfm@bottom@areas@tlp,
   footins-areas-list  =f0 \g@xfm@footins@areas@tlp,
 }
 {

   \def\g@xfm@authorinfo@keyword@order@tlp{name,address,thanks}
   \def\g@xfm@articleinfo@keyword@order@tlp{title,subtitle,thanks}

   \DoParameterAssignments

   \xfm@structure@loop@n {articleinfo}

   \xfm@typeset@area@list@n \g@xfm@top@areas@tlp

   \xfm@stucture@sorted@by@nnn
     {authorinfo}
     {address}
     { \xfm@typeset@area@list@n \g@xfm@authors@areas@tlp  }

   \xfm@typeset@area@list@n \g@xfm@bottom@areas@tlp

   \xfm@typeset@insertion@area@list@nn 
     \g@xfm@footins@areas@tlp
     \footins

   \AtEndDocument{ \xfm@typeset@area@list@n{authordetails} }
 }






\DeclareTemplate{titlesetup}{plain}{0}{
   author-keyword-list      =f0 \g@xfm@authorinfo@keyword@order@tlp,
   articleinfo-keyword-list =f0 \g@xfm@articleinfo@keyword@order@tlp,
   top-areas-list           =f0 \g@xfm@top@areas@tlp,
   footins-areas-list       =f0 \g@xfm@footins@areas@tlp,
 }
 {

   \def\g@xfm@authorinfo@keyword@order@tlp{name,address,thanks}
   \def\g@xfm@articleinfo@keyword@order@tlp{title,subtitle,thanks}

   \DoParameterAssignments

   \xfm@structure@loop@n {articleinfo}
   \xfm@structure@loop@n {authorinfo}

   \xfm@typeset@area@list@n \g@xfm@top@areas@tlp

   \xfm@typeset@insertion@area@list@nn 
     \g@xfm@footins@areas@tlp
     \footins

   \AtEndDocument{ \xfm@typeset@area@list@n{authordetails} }
 }





\def\maketitle{
  \UseInstance{titlesetup}{maketitle}
}


\def\xfm@typeset@area@list@n #1 {
  \@for \@tempb:= #1 \do {
    \IfExistsInstanceTF{textarea}\@tempb
      { \UseInstance{textarea}\@tempb }
      \relax
  }
}

\def\xfm@typeset@insertion@area@list@nn #1#2 {
  \@for \@tempb:= #1 \do {
    \IfExistsInstanceTF{textarea}\@tempb
      {
       \expandafter
       \ifx\csname g@xfm@ \@tempb @list@tlp
           \endcsname \@empty
% actually here we would need to test for required area perhaps???
       \else
         \insert #2 { \UseInstance{textarea}\@tempb }
       \fi
      }
      \relax
  }
}


%    \end{macrocode}
%    
%    
%    \begin{macrocode}

\def \XFMSplitOnComma #1#2#3 {
  \global\let\xfm@split@code\@empty
  \@for\@tempa:=#1\do {
     \expandafter\xfm@split@code
     \expandafter#3\expandafter{\expandafter\ignorespaces\@tempa}
     \gdef\xfm@split@code{#2}
  }
}

%    \end{macrocode}
%    
%    \begin{macrocode}

\newcount\xfm@typeset@authors
\xfm@typeset@authors=1

\def\XFMAuthorSeparation {
  \advance\xfm@typeset@authors\@ne
  \ifnum\g@xfm@structure@cnt = \tw@
     \space and~
  \else
     \ifnum\xfm@typeset@authors = \g@xfm@structure@cnt
       ,~ and~
     \else
       ,~
     \fi
  \fi
}
%    \end{macrocode}
%    
%    \begin{macrocode}

\newcommand*\UseBBskip[1]
  {%
%   \edef\@tempa{#1}
%   \ifx\@tempa\NoValue
%   \else
     \ifhmode
       \par
     \fi
     \setlength\@tempskipa{#1 - \parskip - \baselineskip}
     \vskip\@tempskipa
%   \fi
  }


%    \end{macrocode}
%    
%    \begin{macrocode}


% #1 value-target-area
% #2 text-type (keyword)
% #3 marker-name
% #4 value picked up

\def \dothanks #1#2#3#4 {
  \stepcounter{#3}
  \protected@xdef
    \g@xfm@resultiii@tlp { \csname the#3 \endcsname }

  \xfm@add@element@nno {#1} {marker:#3} \g@xfm@resultiii@tlp

  \xfm@add@element@nnn {#1} {key:#2} {#4}

  \xfm@area@sep@nnn   \l@textarea@id@tlp {SUB} {marker:#3}
  \xfm@area@value@nnn \l@textarea@id@tlp {marker:#3} \g@xfm@resultiii@tlp 
  \xfm@area@sep@nnn   \l@textarea@id@tlp {marker:#3} {SUB}
}

%    \end{macrocode}
%    
% \begin{macro}{\DeclareFMStructure}
%    \begin{macrocode}
\def\DeclareFMStructure #1#2{
 \UseTemplate{structuresetup}{std}
   {#2}{#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{structuresetup (template type)}
%    \begin{macrocode}
\DeclareTemplateType{structuresetup}{1}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{structuresetup/std (template)}
%    \begin{macrocode}
\DeclareTemplate{structuresetup}{std}{1}{
  accepted-keyword-list =f0 \structuresetup@accepted@list,
 }
 {
  \let\structuresetup@accepted@list\@empty

  \DoParameterAssignments

  \@namedef{#1}##1{
    \global\advance\g@xfm@structure@cnt\@ne
    \prop@new@c
       {g@xfm@structure@ \the\g@xfm@structure@cnt @prop}
    \queue@gadd@co
       {g@xfm@ #1 @queue}
       {\the\g@xfm@structure@cnt}
    \setkeys{xfm-#1}{##1}
  }
  \queue@new@c {g@xfm@ #1 @queue}

%    \end{macrocode}
%    The way it is now the contents of |\structuresetup@accepted@list|
%    needs to be a comma separated list \emph{without} blanks. In
%    practise this probably needs to be allowed since normally blanks
%    are ignored in templates.
%    \begin{macrocode}
  \@for\@tempa:= \structuresetup@accepted@list \do {
    \global\expandafter\let 
       \csname KV@xfm-#1@ \@tempa \endcsname
       \xfm@structure@parse@keyword@code@n
%    \end{macrocode}
%    The above ensures that the keyword will get parsed properly and
%    the one below ensures that by default we do nothing with it
%    during processing.
%    \begin{macrocode}
    \global\expandafter\let 
       \csname xfm@process@key@ #1-\@tempa @N \endcsname
       \@gobble
  }
 }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \endinput
\endinput
%
% $Log$
% Revision 1.29  2001/05/06 18:01:49  latex3
% extended keyword setup to distribute to three areas
% some cleanup
% added draft for "plain" title template
%
% Revision 1.28  2001/05/06 12:28:18  latex3
% now support formatting of values via \DeclareElementFormat
%
% Revision 1.27  2001/05/05 19:31:10  latex3
% use \UseTemplate instead of ANONYMOUS instances
%
% Revision 1.26  2001/05/05 14:46:40  latex3
% lot of keyword renamings
%
% Revision 1.25  2001/04/29 21:07:13  latex3
% added further logic to text areas allowing runin headings and other
% frills
%
% Revision 1.24  2001/04/27 16:43:09  latex3
% after before attempting to distribute key values to several areas
%
% Revision 1.23  2001/04/27 10:13:39  latex3
% before attempting to distribute key values to several areas
%
% Revision 1.22  2001/04/27 07:52:06  latex3
% end of days work, one hour after midnight
%
% Revision 1.21  2001/04/26 21:07:58  latex3
% \DeclareFMStructure added
% sorting generalised
%
% Revision 1.20  2001/04/26 14:58:12  latex3
% started with a maketitle template
%
% Revision 1.19  2001/04/15 08:27:18  latex3
% more author data documentation
%
% Revision 1.18  2001/04/14 12:38:59  latex3
% documentation for title markers
%
% Revision 1.17  2001/04/14 09:54:15  latex3
% area documentation
%
% Revision 1.16  2001/04/13 15:23:16  latex3
% further code cleanup and document
% version before introducing \xfm@add@element@nno in the code
%
% Revision 1.15  2001/04/12 08:15:48  latex3
% used separate key (on maketitle) to denote keyword order when
% processing authors
%
% Revision 1.14  2001/04/12 07:39:24  latex3
% fixed author counting when doing sort by address
%
% Revision 1.13  2001/04/08 21:19:25  latex3
% first attempt to get sorting by address to work in real life
%
% Revision 1.12  2001/04/07 16:58:10  latex3
% some code cleanup, some more documentation
% added the possibility to have \thanks and the like within other
% keyword values
%
% Revision 1.11  2001/04/06 20:24:40  latex3
% more documentation, being burned by having lost the afternoons work
% we save more often :-(
%
% Revision 1.10  2001/04/06 19:11:53  latex3
% let's save some documentation
%
% Revision 1.9  2001/04/06 15:45:36  latex3
% *** empty log message ***
%
% Revision 1.8  2001/04/05 14:23:40  latex3
% first attempt to solve the author-and issue
% some code cleanup
%
% Revision 1.7  2001/04/05 11:00:52  latex3
% started to add area element separator code
%
% Revision 1.6  2001/04/05 09:20:19  latex3
% support combining key values in areas
%
% Revision 1.5  2001/04/03 20:28:43  latex3
% more templates, more generalisation ('orrible results :-)
%
% Revision 1.4  2001/04/02 06:46:45  latex3
% first template approach for author keys
%
% Revision 1.3  2001/04/01 13:33:34  latex3
% sort by address works first time
%
% Revision 1.2  2001/04/01 09:24:20  latex3
% now we can do at least author block followed by address block with all
% other data distributed appropriately to whatever area is desired (eg
% thanks area etc.)
%

% \endinput



%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{}
%    \begin{macrocode}


%
%
% \begin{macro}{}
%    \begin{macrocode}

%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
% \begin{macro}{example}
%    this kind of horrible example shows how to extend a macro with
%    one argument with further code containing macro arguments, since
%    it took me a long time to get it working i'll keep it for the
%    moment.
%    \begin{macrocode}
   \edef\@tempa{
     \noexpand\xfm@handle@keys@N{####1}
     \ifx\authorkeysetup@marker@id\@empty
       \noexpand\xfm@append@keyval@nnN ####1
       {\authorkeysetup@id}
     \else
       \noexpand\xfm@linkappend@keyval@nnnnN ####1
       {\authorkeysetup@id}
       {\authorkeysetup@marker@id}
     \fi
       {\authorkeysetup@target@area@id}
   }
   \def\@tempb{\gdef\xfm@handle@keys@N####1}
   \expandafter\expandafter\expandafter\@tempb
   \expandafter\expandafter\expandafter
      {\@tempa}

%    \end{macrocode}
% \end{macro}
%
%
%
%
