% \iffalse
%%
%% (C) Copyright 2001 Frank Mittelbach
%% All rights reserved.
%%
%% Not for general distribution. In its present form it is not allowed
%% to put this package onto CD or an archive without consulting the
%% the authors.
%% 
%    \begin{macrocode}
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{
%<*dtx>
  \ProvidesFile{#2.dtx}
%</dtx>
%<package>\ProvidesPackage{#2}
%<driver>\ProvidesFile{#2.drv}
  [#4 #3 #8 (#6)]}
\next$Id$
       {multiple marks}
\iffalse
%    \end{macrocode}
%
%<*driver>
 \documentclass{ltxdoc}
%
 \begin{document}
 \DocInput{xfm.dtx}
 \end{document}
\fi
%</driver>
%
% \fi
%
%
% \GetFileInfo{xfm.dtx}
%
% \title{The \textsf{xfm} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi}
% \date{\filedate}
%
%  \maketitle
%
% \tableofcontents
%
%
%
% \section{Intro}
%
%
%    \begin{macrocode}
\RequirePackage{ldcsetup}
\RequirePackage{xtools}
\RequirePackage{template}
\IgnoreWhiteSpace
%    \end{macrocode}
%    
%    \begin{macrocode}


%    \end{macrocode}
%
%
%
%
%
%
%    \begin{macrocode}
\newcount\xfm@authors
\newcount\xfm@typeset@authors

\def\author#1#2{
  \advance\xfm@authors\@ne
  \prop@new@c 
     {xfm@author@\the\xfm@authors}
  \prop@gput@cNn  
     {xfm@author@\the\xfm@authors}
     \xfm@key@name
     {#1}
  \queue@gadd@No
     \xfm@authors@queue
     {\the\xfm@authors}
  \setkeys{xfm}{#2}
}

\queue@new@N\xfm@authors@queue

% this is what we could have done via \define@key ...
% one argument implicit (picked up by |\prop@gput@ccn|)
%
%\def \xfm@author@keyword@code@n #1 {
\def \xfm@author@keyword@code@n {
  \prop@gput@ccn  
     {xfm@author@\the\xfm@authors}
     {xfm@key@\@tempa}
%     {#1}
}

\xfm@typeset@authors=1

\def\AuthorSeparation {
  \advance\xfm@typeset@authors\@ne
  \ifnum\xfm@authors = \tw@
     and~
  \else
     \ifnum\xfm@typeset@authors = \xfm@authors
       ,~ and~
     \else
       ,~
     \fi
  \fi
}

%    \end{macrocode}
%    
%    \begin{macrocode}

\tlp@new@Nn\xfm@result@tlp{}
\tlp@new@Nn\xfm@resultii@tlp{}
\tlp@new@Nn\xfm@resultiii@tlp{}
\tlp@new@Nn\xfm@resultiv@tlp{}



% author-prop, key, key-format, missing-key-action,
% #1           #2   #3          #4              
%
% target-tlp,              marker-counter
% #5           #6          #7         
%
%
\def\distribute@author@key@NNnnn #1#2#3#4#5 {
  \prop@get@NcN
     #1
     {xfm@key@#4}
     \xfm@result@tlp

%    \end{macrocode}
%    If the key was specified we have a value in |\xfm@result@tlp|,
%    otherwise the key is missing and we may or may not have to do
%    something about that.
%    \begin{macrocode}
  \quark@if@no@value@NTF \xfm@result@tlp
%    \end{macrocode}
%    Do whatever is required if the key is missing 
%    token at this point!)
%    \begin{macrocode}
     { \csname xfm@missing@key@#4@ \endcsname }
%    \end{macrocode}
%    
%    \begin{macrocode}
     {
      \let\xfm@resultii@tlp\q@no@value

      \prop@map@cc 
          {xfm@ #5 @prop}
          {xfm@find@marker@#4@Nn}

      \quark@if@no@value@NT \xfm@resultii@tlp
%    \end{macrocode}
%    
%    Value does not exist, so make new mark:
%    \begin{macrocode}
        {
          \stepcounter{#5}
          \protected@edef
             \xfm@resultiv@tlp { \csname the#5 \endcsname }

%    \end{macrocode}
%    Next bit of code adds an entry to the property list
%    |#5|, this could be done manually which would be faster but less
%    understandable.
%
%    First start the value of the marker number and the text as two
%    brace groups in |\xfm@resultiii@tlp|
%    \begin{macrocode}
          \tlp@gset@No 
             \xfm@resultiii@tlp 
             { \expandafter { \xfm@resultiv@tlp } }
          \tlp@gput@right@No
             \xfm@resultiii@tlp 
             { \expandafter { \xfm@result@tlp } }
%    \end{macrocode}
%    Then put all of that into the property list:
%    \begin{macrocode}
          \prop@gput@cco
             {xfm@ #5 @prop}
             {mark-\the\value{#5}}
             \xfm@resultiii@tlp

%    \end{macrocode}
%    
%    \begin{macrocode}
          \xfm@add@element@sep@nn {#3} {marker:#5}
%    \end{macrocode}
%    
%    \begin{macrocode}
          \tlp@gput@right@No
             #2
             { \csname xfm@format@target@marker@ #5 @n \expandafter
               \endcsname  \expandafter {\xfm@resultiv@tlp}  }

          \xfm@add@element@sep@nn {#3} {key:#4}

          \tlp@gput@right@No
             #2
             { \csname xfm@format@key@#4@n \expandafter \endcsname
               \expandafter {\xfm@result@tlp}  }

        }
%    \end{macrocode}
%    At this point the mark reference is definitely in
%    |\xfm@resultii@tlp| so we can append it to the
%    |\xfm@authors@list@tlp|.
%    \begin{macrocode}

      
      \xfm@add@element@sep@nn {authors} {marker:#5}

      \tlp@gput@right@No
         \xfm@authors@list@tlp
         { \csname xfm@format@source@marker@ #5 @n \expandafter
           \endcsname \expandafter {\xfm@resultiv@tlp}  }

     }
}

%    \end{macrocode}
%    This bit of code finds an already existing marker with a value
%    equal to the text stored in |\xfm@result@tlp|.
%    \begin{macrocode}
\def \xfm@find@marker@Nn #1 #2 {
  \tlp@gset@No\xfm@resultiii@tlp{ \@secondoftwo #2 }
  \tlp@gset@No\xfm@resultiv@tlp { \@firstoftwo  #2 }
  \ifx \xfm@result@tlp\xfm@resultiii@tlp
    \tlp@set@Nn\xfm@resultii@tlp{#1}
    \let \prop@map@funct@Nn \@gobbletwo
  \fi
}


% author-prop, key-name, marker-name, target-area
% #1         , #2      , #3         , #4

\def \distribute@author@key@Nnnn #1#2#3#4  {
  \expandafter
  \distribute@author@key@NNnnn
    \expandafter
      #1
      \csname xfm@#4@list@tlp \endcsname 
      {#4}
      {#2}
      {#3}
}

% author-prop, key-name, target-area
% #1         , #2      , #3

\def \append@author@key@Nnn #1#2#3 {
  \expandafter
  \append@author@key@NNNN
    \expandafter
      #1
      \csname xfm@key@#2             \expandafter \endcsname
      \csname xfm@format@key@#2@n    \expandafter \endcsname
      \csname xfm@missing@key@#2@    \expandafter \endcsname
      \csname xfm@#3@list@tlp \endcsname 
      {#3}{#2}
} 


% author-prop, key, key-format, missing-key-action, target-tlp
% #1           #2   #3          #4                  #5
%
\def \append@author@key@NNNN #1#2#3#4#5#6#7 {
  \prop@get@NNN
     #1
     #2
     \xfm@result@tlp

  \quark@if@no@value@NTF \xfm@result@tlp
% if the key is required we have to do something here
     #4
     {
      \xfm@add@element@sep@nn {#6} {key:#7}
      \tlp@gput@right@No
	 #5
	 { \expandafter #3 \expandafter { \xfm@result@tlp } }
     }
}



\def\distribute@author@data@n #1 {
  \expandafter 
  \xfm@handle@keys@N
     \csname xfm@author@ #1 \endcsname
}


\def \DoAuthorLoop {
  \xfm@authors@loop@N
    \xfm@authors@queue
}

\def \xfm@authors@loop@N #1 {
  \queue@map@NN
    #1
    \distribute@author@data@n

  \xfm@add@element@sep@nn {authors} {END}

\xfm@show@areas@
}

\queue@new@N\xfm@currauthors@queue
\queue@new@N\xfm@remainingauthors@queue
\tlp@new@Nn \xfm@curraddresses@tlp{}

\def \DoSortByAddress {
  \queue@empty@NTF
    \xfm@authors@queue
    {}
    {
     \queue@gclear@N\xfm@currauthors@queue

     \queue@gpop@NN
       \xfm@authors@queue
       \xfm@result@tlp

     \prop@get@cNN
       {xfm@author@\xfm@result@tlp}
       \xfm@key@address
       \xfm@curraddresses@tlp

     \queue@gadd@No
       \xfm@currauthors@queue
       \xfm@result@tlp
     
     \queue@map@NN
       \xfm@authors@queue
       \xfm@find@address@n

     \global\let\xfm@authors@queue\xfm@remainingauthors@queue
     \queue@gclear@N\xfm@remainingauthors@queue

\show\xfm@currauthors@queue
\show\xfm@authors@queue

     \tlp@gset@Nn\xfm@addresses@list@tlp{}
     \tlp@gset@Nn\xfm@authors@list@tlp{}

     \xfm@authors@loop@N
       \xfm@currauthors@queue

%do formatting here:

     \DoSortByAddress
    }
}


\def \xfm@find@address@n #1 {
  \prop@get@cNN
    {xfm@author@#1}
    \xfm@key@address
    \xfm@result@tlp
  \ifx \xfm@result@tlp\xfm@curraddresses@tlp
    \queue@gadd@Nn\xfm@currauthors@queue{#1}
  \else
    \queue@gadd@Nn\xfm@remainingauthors@queue{#1}
  \fi
}

%    \end{macrocode}
%
%
% \section{Template interface}
%
%    \begin{macrocode}

\def\DeclareTitleMarker #1#2{
 \DeclareInstance{titlemarkersetup}{#1}{std}
   { marker-id = #1,  #2 }
 \UseInstance{titlemarkersetup}{#1}
}
\DeclareTemplateType{titlemarkersetup}{0}

\DeclareTemplate{titlemarkersetup}{std}{0}{
   marker-id     =n  \titlemarker@id,
   marker-type   =f0 \titlemarker@type,
   source-format =f1 \titlemarker@source@format,
   target-format =f1 \titlemarker@target@format,
 }
 {
   \def\titlemarker@type{\arabic}

   \DoParameterAssignments

   \newcounter \titlemarker@id
   \expandafter\xdef\csname the\titlemarker@id\endcsname
      {\expandafter\noexpand\titlemarker@type{\titlemarker@id}}

   \prop@new@c {xfm@ \titlemarker@id @prop}

   \global\expandafter\let 
      \csname xfm@format@source@marker@ \titlemarker@id @n \endcsname
      \titlemarker@source@format

   \global\expandafter\let 
      \csname xfm@format@target@marker@ \titlemarker@id @n \endcsname
      \titlemarker@target@format

 }




\def\DeclareAuthorKeyword #1#2{
 \DeclareInstance{authorkeywordsetup}{#1}{std}
   { keyword-id = #1,  #2 }
 \UseInstance{authorkeywordsetup}{#1}
}
\DeclareTemplateType{authorkeywordsetup}{0}

\DeclareTemplate{authorkeywordsetup}{std}{0}{
   keyword-id            =n  \authorkeysetup@id,
   target-area-id        =n  \authorkeysetup@target@area@id,
   marker-id             =n  \authorkeysetup@marker@id,
   required-boolean      =s  {}
                             {\let\authorkeysetup@missing@key\relax},
   combine-boolean       =s  {\let\authorkeysetup@combine@boolean
                              \xfm@find@marker@Nn}
                            {},
   keyword-format        =f1 \authorkeysetup@keyword@format,
 }
 {

   \let\authorkeysetup@marker@id\@empty
   \def\authorkeysetup@format##1{##1~ }
   \def\authorkeysetup@missing@key{\ERRORkeyMissing\authorkeysetup@id}

   \let\authorkeysetup@combine@boolean\@gobbletwo


   \DoParameterAssignments

   \global\expandafter\let 
      \csname KV@xfm@ \authorkeysetup@id\endcsname
      \xfm@author@keyword@code@n

   \global\expandafter\let 
      \csname xfm@format@key@ \authorkeysetup@id @n \endcsname
      \authorkeysetup@keyword@format

   \global\expandafter\let 
      \csname xfm@find@marker@ \authorkeysetup@id @Nn \endcsname
      \authorkeysetup@combine@boolean


   \edef\@tempa{
     \noexpand\xfm@handle@keys@N{####1}
     \ifx\authorkeysetup@marker@id\@empty
       \noexpand\append@author@key@Nnn ####1
       {\authorkeysetup@id}
     \else
       \noexpand\distribute@author@key@Nnnn ####1
       {\authorkeysetup@id}
       {\authorkeysetup@marker@id}
     \fi
       {\authorkeysetup@target@area@id}
   }
   \def\@tempb{\gdef\xfm@handle@keys@N####1}
   \expandafter\expandafter\expandafter\@tempb
   \expandafter\expandafter\expandafter
      {\@tempa}

%\show\xfm@handle@keys@N
 }


\let\xfm@handle@keys@N\@gobble

\def\ERRORkeyMissing#1 {\PackageError{xfm}{Keyword~`#1'~missing~ in~
                      \noexpand\author command}\@eha}
%    \end{macrocode}
%
%
%
%
%
%
%    \begin{macrocode}

\tlp@new@Nn\xfm@show@areas@{}


\def\DeclareTitleArea #1#2{
  \tlp@gclear@c{xfm@ #1 @list@tlp}
  \tlp@gput@right@No
     \xfm@show@areas@
     {\expandafter \show \csname xfm@ #1 @list@tlp \endcsname }

  \tlp@gset@cn{xfm@ #1 @last@tlp}{START}

 \DeclareInstance{titlearea}{#1}{std}
   { area-id = #1,  #2 }
 \UseInstance{titlearea}{#1}
}
\DeclareTemplateType{titlearea}{0}

\DeclareTemplate{titlearea}{std}{0}{
   area-id             =n  \areasetup@id,
   BBskip              =L  \areasetup@BBskip,
   fontsize            =L  \areasetup@fontsize,
   fontbaseline        =L  \areasetup@fontbaseline,
   justification-setup =i {justification}  \areasetup@justification,
   required-boolean    =s  {}
                           {\let\areasetup@missing@value\relax},
 }
 {

  \def\areasetup@BBskip{\baselineskip}
  \def\areasetup@fontsize{\f@size}
  \def\areasetup@fontbaseline{\f@baselineskip}

   \def\areasetup@missing@value{\ERRORkeyMissing\areasetup@id}

  \DoParameterAssignments
  
  \expandafter
      \ifx\csname xfm@ \areasetup@id @list@tlp
          \endcsname \@empty
  \else
    \begingroup
      \fontsize\areasetup@fontsize\areasetup@fontbaseline\selectfont
      \UseBBskip\areasetup@BBskip
      \areasetup@justification
      \csname xfm@ \areasetup@id @list@tlp \endcsname
      \par
    \endgroup
  \fi
 }

%    \end{macrocode}
%    
%    \begin{macrocode}
\def \DeclareElementSep #1#2#3#4{
 \global\@namedef{xfm@#1-#2-#3}{#4}
}

\def \xfm@add@element@sep@nn #1#2 {
  \edef \@tempa
     { \noexpand \xfm@area@sep@nnn 
                 { #1 }
                 { \csname xfm@ #1 @last@tlp \endcsname }
                 { #2 }
     }
  \tlp@gset@cn{xfm@ #1 @last@tlp}{#2}
  \expandafter
  \tlp@gput@right@No
     \csname xfm@ #1 @list@tlp \endcsname
     \@tempa
}

\def\xfm@area@sep@nnn #1#2#3 {
  \@ifundefined{xfm@#1-#2-#3}
    {
      \@ifundefined{xfm@#1-#2-*}
	{
	  \@ifundefined{xfm@#1-*-#3}
	    {
	      \@ifundefined{xfm@#1-*-*}
		{}
		{ \csname xfm@#1-*-* \endcsname }
	    }
	    { \csname xfm@#1-*-#3 \endcsname }
	}
	{ \csname xfm@#1-#2-* \endcsname
	  \@ifundefined{xfm@#1-*-#3}
	    {}
	    { \csname xfm@#1-*-#3 \endcsname }
        }
    }
    { \csname xfm@#1-#2-#3 \endcsname }
}
%    \end{macrocode}
%
%
%
%
%
%
%
%
%    \begin{macrocode}
\DeclareTemplateType{maketitlesetup}{0}

\DeclareTemplate{maketitlesetup}{plain}{0}{
 }
 {
   \DoParameterAssignments
 }




\def \maketitle {
   \XFMtitleblock
}

\def \XFMtitleblock {
  \XFMTypesetArea{title}
  \XFMTypesetArea{authors}
}

\long\def \maketitle {

  \UseInstance{titlearea}{title}
  \UseInstance{titlearea}{subtitle}

  \DoAuthorLoop
%  \DoSortByAddress

  \UseInstance{titlearea}{authors}

  \insert\footins{
    \UseInstance{titlearea}{thanks}
  }
 
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\renewcommand*\title{\@dblarg\@xtitle}
\def\@xtitle[#1]#2{
  \def\@shorttitle{#1}
  \def\xfm@title@list@tlp{#2}
}
\newcommand*\subtitle[1]{
  \def\xfm@subtitle@list@tlp{#1}
}
%    \end{macrocode}
%    
%    \begin{macrocode}

\def \XFMSplitOnComma #1#2#3 {
  \global\let\xfm@split@code\@empty
  \@for\@tempa:=#1\do {
     \expandafter\xfm@split@code
     \expandafter#3\expandafter{\expandafter\ignorespaces\@tempa}
     \gdef\xfm@split@code{#2}
  }
}

%    \end{macrocode}
%    
%    \begin{macrocode}


\DeclareTemplateType{justification}{0}

\DeclareTemplate{justification}{std}{0}{
  startskip      =L  \startskip ,
  leftskip       =l  \leftskip ,
  rightskip      =l  \rightskip ,
  parfillskip    =l  \parfillskip ,
  spaceskip      =l  \spaceskip ,
  xspaceskip     =l  \xspaceskip ,
  linefillskip   =L  \linefillskip ,
  parindent      =l  \parindent ,
 }{
  \DoParameterAssignments
  \@rightskip\rightskip
 }

\DeclareInstance{justification}{center}{std}
   {parindent  =0pt,
    rightskip  =\fill,
    leftskip   =\fill,
    startskip  =0pt,
    parfillskip=0pt
}


\DeclareInstance{justification}{flushleft}{std}
   {parindent  =0pt,
    rightskip  =\fill,
    leftskip   =0pt,
    startskip  =0pt,
    parfillskip=0pt
}

\newcommand*\UseBBskip[1]
  {\ifvmode
    \setlength\@tempskipa{#1 - \parskip - \baselineskip}
    \vskip\@tempskipa
   \else
    \DesignerError{\protect\UseBBskip\space outside~ vmode}
   \fi
  }


\newcommand*\DeclareParagraphLayout[9]{%
    \@namedef{#1Para}{
  \fontsize{#2}{#3}\selectfont
          #9
  \setlength\parindent  {#4}
  \setlength\leftskip   {#5}
  \setlength\rightskip  {#6}
  \@rightskip\rightskip
  \setlength\parfillskip{#7}
  \setlength\parskip    {#8}
}
}

%    \end{macrocode}

%
% \endinput
\endinput
%
% $Log$
% Revision 1.9  2001/04/06 15:45:36  latex3
% *** empty log message ***
%
% Revision 1.8  2001/04/05 14:23:40  latex3
% first attempt to solve the author-and issue
% some code cleanup
%
% Revision 1.7  2001/04/05 11:00:52  latex3
% started to add area element separator code
%
% Revision 1.6  2001/04/05 09:20:19  latex3
% support combining key values in areas
%
% Revision 1.5  2001/04/03 20:28:43  latex3
% more templates, more generalisation ('orrible results :-)
%
% Revision 1.4  2001/04/02 06:46:45  latex3
% first template approach for author keys
%
% Revision 1.3  2001/04/01 13:33:34  latex3
% sort by address works first time
%
% Revision 1.2  2001/04/01 09:24:20  latex3
% now we can do at least author block followed by address block with all
% other data distributed appropriately to whatever area is desired (eg
% thanks area etc.)
%
