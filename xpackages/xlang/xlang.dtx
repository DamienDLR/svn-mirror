
% \iffalse
%%
%% (C) Copyright 1999, 2004 Frank Mittelbach
%% All rights reserved.
%%
%% Not for general distribution. In its present form it is not allowed
%% to put this package onto CD or an archive without consulting the
%% the authors.
%% 
%    \begin{macrocode}
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{
%<*dtx>
  \ProvidesFile{#2.dtx}
%</dtx>
%<package>\ProvidesPackage{#2}
%<driver>\ProvidesFile{#2.drv}
  [#4 #3 #8 (#6)]}
\next$Id$
       {multiple marks}
%    \end{macrocode}
%
%<*driver>
 \documentclass{ltxguide}
%
 \catcode`\|=12
 \usepackage{doc}
%
 \CodelineIndex
 \setcounter{IndexColumns}{2}
%
 \catcode`\|=\active
 \catcode`\<=\active
 \catcode`\>=\active
%
%
 \begin{document}
 \DocInput{xlang.dtx}
 \end{document}
%</driver>
%
% \fi
%
%
% \GetFileInfo{xlang.dtx}
%
% \title{Language Information in 
%         Structured Documents: 
%         The \textsf{xlang} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi}
% \date{\filedate}
%
%  \maketitle
%
% \tableofcontents
%
% \DoNotIndex{\@@,\@auxout,\@currenvir,\@eha,\@empty,\@endpefalse,\@gobble}
% \DoNotIndex{\@ignorefalse,\@latex@error,\@nil,\@writefile}
% \DoNotIndex{\csname}
% \DoNotIndex{\def}
% \DoNotIndex{\edef,\else,\endcsname\endgroup,\endinput,\errmessage,\expandafter}
% \DoNotIndex{\fi}
% \DoNotIndex{\glossary}
% \DoNotIndex{\ifx,IgnoreWhiteSpace}
% \DoNotIndex{\index}
% \DoNotIndex{\label,\let,\long}
% \DoNotIndex{\meaning}
% \DoNotIndex{\newcommand,\noexpand}
% \DoNotIndex{\on@line}
% \DoNotIndex{\par}
% \DoNotIndex{\protect,\protected@write}
% \DoNotIndex{\relax,\reserved@a,\RequirePackage}
% \DoNotIndex{\string}
% \DoNotIndex{\thepage}
%
%
% \section{Introduction}
%
%    This package implements the concepts described in ``Language
%    Information in Structured Documents: A Model for Mark-Up and
%    Rendering'' \cite{?}. There are a few changes compared to the
%    model described in the above paper. These are documented below.
%
% \subsection{The Preamble Interface}
%
%    \begin{decl}
%    |\DeclareDocumentLanguages| \arg{language-list}
%    \end{decl}
%
%    Lists all languages that are used in the document (any other
%    language will then generate an error message if it appears in a
%    language change command or environment).\footnote{Instead of
%    enforcing the use of such a command one could determine the used
%    languages when parsing the document for the first time but this
%    will result in some time and space penalty which is probably
%    better avoided.} On a higher level this could be specified via
%    the option names to the language package.
%
%    -- produces, or adds to, the |\usedlanguages| list.
%
%
%
%    \begin{decl}
%    |\SetDocumentLanguage| \arg{language}
%    \end{decl}
%
%    Declares <language> to be the document language (i.e. the overall
%    language of the document). It will also set the base language to
%    use at the start of the body of the document.  Again this can
%    also be set by making the last option to the language package
%    become the base language. If no such declaration is given the
%    ``document language'' defaults to ``english''.
%
%
%
% \subsection{The Document Interface}
%
%    In a document, language information is encoded (tagged) using
%    the constructs with the following characteristics:
%    \begin{itemize}
%    \item 
%      A base-language change command with the language-label as
%      argument.  This command is declarative to highlight the flat
%      structure of base languages.
%    
%    \item 
%      A language-environment with the language-label as argument and text
%      as body.  The environment starts a new paragraph to enforce the block
%      level nature.
%    
%    \item 
%      A language-command with the language-label and text both as
%      arguments. In contrast to the environment, this command applies
%      language related actions to its second argument, which cannot
%      directly contain full paragraphs.
%    \end{itemize}
%
%    
%
%    \begin{decl}
%    |\baselanguage| \arg{language}
%    \end{decl}
%
%    This declaration changes the current ``base language'' to
%    <language>. It can only be used in the document body between
%    paragraphs and is not allowed to appear inside of other language
%    constructs such as the |langblock| environment or the |\langfrag|
%    command.
%
%    \begin{decl}
%    |\begin{langblock}| \arg{language}  ... |\end{langblock}| \\
%    |\langblock| \arg{language} \arg{text}
%    \end{decl}
%
%    The environment |langblock| takes one argument to denote the
%    language of its body. The body is allowed to contain multiple
%    paragraphs, i.e., a |langblock| is intended for longer text
%    blocks in one language being embedded in another language. (When
%    to use such blocks rather than changing the ``base language''
%    might be defined by the house style or might be obvious given the
%    nature of the text but can't be specified formally for all
%    documents.) ``Language blocks'' can be nested.
%    There is an alternate command form which takes two arguments the
%    second being the text of the block.
%
%
%    \begin{decl}
%    |\begin{langfrag}| \arg{language}  ... |\end{langfrag}| \\
%    |\langfrag| \arg{language} \arg{text}
%    \end{decl}
%
%    The environment |langfrag| takes one argument to denote the
%    language of its body. The body is not allowed  to contain
%    complete paragraphs, i.e., a |langfrag| is intended for short text
%    fragments, such as individual words or sentences, in one language
%    being embedded in another language.
%    There is an alternate command form which takes two arguments the
%    second being the text of the fragment.
%
%
% \subsection{Class and Package Interfaces}
%
%    The following commands are intended to be used in class and/or
%    package files or, in some cases, in the preamble of the document
%    to overwrite decisions made in class or package files.
%
%    \begin{decl}
%    |\DeclareLanguageProperty| \arg{cmd}
%    \end{decl}
%
%    Declares <cmd> to be a language command used by the current
%    package or class. The purpose of this declaration is to announce
%    to the \LaTeX{} system that this class or package uses the <cmd>
%    (or even commands, it could be a comma separated list if we wish)
%    as a language command and that therefore any declarations made
%    via |\SetLanguagePropertyValue| or
%    |\SetLanguagePropertyValueMapping| for this command are to be
%    kept in the body of the document.
%
%
%    \begin{decl}
%    |\SetLanguagePropertyValue| \arg{language} \arg{cmd} \arg{action}
%    \end{decl}
%
%    Sets the action to <action> for <cmd> in <language>. To set the
%    default action to be anything other than a fixed error message, use
%    \texttt{default} as <language>. Any such declaration is kept only up
%    to the begin of the actual document unless <cmd> was declared within a
%    package or class with |\DeclareLanguageProperty|.
%    
%    -- check that <language> is in the list |\g@lang@known@languages@queue|, if not, add
%    it to |\g@lang@known@languages@queue| and initiate |\g@lang@<language>@plist|.
%    
%    -- add or modify <cmd>/<action> pair in |\g@lang@<language>@plist|.
%
%
%
%    \begin{decl}
%    |\SetLanguagePropertyValueMapping| \arg{cmd} \arg{type-or-level}
%    \end{decl}
%
%    Maps <cmd> to <type-or-level>. Any such declaration is kept only
%    up to the beginning of the actual document unless <cmd> was
%    declared within a package or class with
%    |\DeclareLanguageProperty|.  If no such mapping value is declared
%    for <cmd>, a global default is used.
%
%    -- add or modify an entry in |\g@lang@known@mappings@plist|.


% \subsection{The system Interface}
%
%    One of the main aspects of the model is the notion of ``language
%    structures'' (called parameter groups in the paper) which can be
%    given different values for different languages. In this
%    implementation they are modelled as commands each taking a single
%    value.\footnote{This might need changing/extension.}
%
%
% \DescribeMacro\DeclareLanguageProperty\meta{cmd}
%    Declares the command name \meta{cmd} as a language command which
%    means it can take different values in different languages.
%
%    It is permissible to declare a \meta{cmd} several times 
%    
% \DescribeMacro\DeclareLanguagePropertyValue\meta{lang}\meta{cmd}\meta{action}
%    Defines the action carried out by \meta{cmd} if typesetting is
%    done in language \meta{lang} to be \meta{action}
%
% \DescribeMacro\g@lang@known@cmds@queue
%
%
% \subsection{Setting defaults}
%
%    Due to the relationship between |\DeclareLanguageProperty|,
%    |\DeclareLanguagePropertyValue|, and
%    |\DeclareLanguagePropertyValueMapping| it is possible to set
%    default at different levels.
%
%    Predeclared actions for a language will be kept until
%    |\begin{document}|; if the corresponding <language> is not among
%    the list of document languages they will be removed at that
%    point. This means that such declarations can even be put into the
%    \LaTeX{} format without noticeable side effects.
%
%    Similarly the default sets of actions for a language can contain
%    settings for language related commands declared (via
%    |\DeclareLanguageProperty|) in various packages. If the
%    corresponding package is not used in the document those
%    declarations are then ignored. This allows, for example, to have
%    customized user settings all stored in a single place (file) and
%    loaded into each document without worrying which packages are
%    actually being used.
%
%
%    If a language specific command has no action associated with a
%    certain language, its use inside this language will result in an
%    error message unless a default action was specified for this command.
%    Which of the two methods (error or default action) is appropriate
%    really depends on the command itself. For example, for a command
%    storing a language string (e.g., |\captername|) it is of limited
%    use to provide a default value (other than ensuring that a
%    document compiles), but for a selection of hyphenation patterns a
%    sensible default could be ``do not hyphenate''.
%
%
% \section{Implementation}
%
%
%    We need a couple of support packages from the experimental
%    \texttt{x...} series of package, in particular \texttt{ldcsetup}
%    and \texttt{xtools} for the coding; \texttt{xo-trace} is only
%    used because we don't have a general code tracing package yet (so
%    reuse the one from the OR stuff).
%    \begin{macrocode}
\RequirePackage{ldcsetup}
\RequirePackage{xtools}
\RequirePackage{xo-trace}
%    \end{macrocode}
%    
%    \begin{macrocode}
\IgnoreWhiteSpace
%    \end{macrocode}
%
%
% \subsection{General support macros}
%
%    Code in this section does not really belong here and will be
%    distributed to other files in the future.
%
% \begin{macro}{\IfNotOmega}
%    \begin{macrocode}
\def\IfNotOmega{\ifx\textdir\@undefined}  % not really the way to go :-)
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\begin}
%    To support environments with the same name as corresponding
%    commands the |\begin| macro of \LaTeX{} is slightly modified. The
%    code below checks at the begin level for the existance of of a
%    command with the name |\begin@@|\meta{env-name}; if this exists
%    it will be used as the begin code for the environment
%    \meta{env-name}, if not |\|\meta{env-name} will be used. This
%    allows to define a command variant for the environment in the
%    following way:
%\begin{verbatim}
%\newcommand\begin@@foo[n]{begin code for foo}
%\def\endfoo{end code for foo}
%\newcommand\foo[n+1]{\begingroup
%   \begin@@foo {#1}...{#n}
%     #n+1
%   \endfoo
%  \endgroup}
%\end{verbatim}
%   There are a few restrictions when using the above concept:
%   \begin{itemize}
%   \item Due to the way \LaTeX{} guards definitions of new commands
%    and envrionments you have to use |\def| to define the |\endfoo|.
%   \item Clearly the command version |\foo| needs one more argument
%    than the environment version so the total number of arguments for
%    the environment can be 8 not 9.
%   \item For every environment used in a document there will be a
%    test which might generate a second (otherwise unused)
%    csname. This should be harmless as the total number of different
%    environments in documents is not that large.
%   \item
%    The actual implementation might change and instead of the
%    low-level setup above there might be a proper interface for
%    declaring such environment/command combinations one day.
%   \end{itemize}
%   So here is the code:
%    \begin{macrocode}
\def\begin#1{
  \@ifundefined{#1}
    {\def\reserved@a{\@latex@error{Environment~ #1~ undefined}\@eha}}
    {\def\reserved@a{\def\@currenvir{#1}
     \edef\@currenvline{\on@line}
%    \end{macrocode}
%    The difference to the standard \LaTeX{} version is in the next
%    four lines where the original simply calls on |\csname #1\endcsname|.
%    \begin{macrocode}
     \csname \expandafter
       \ifx \csname begin@@#1\endcsname\relax
       \else begin@@
       \fi
       #1\endcsname}}
  \@ignorefalse
  \begingroup\@endpefalse\reserved@a}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Data structures for the language support}
%
%    In this section we initialize the internal structures.
%
% \begin{macro}{\g@lang@known@cmds@queue}
%    Global queue in which we store every command name that was
%    declared via |\DeclareLanguageProperty|. This information is used
%    at |\begin{document}| to decide which language related actions
%    need to be preserved for the current document.
%    \begin{macrocode}
\queue@new@N \g@lang@known@cmds@queue
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\g@lang@known@languages@queue}
%    Global queue in which we store all language names for which we
%    have seen at least one |\SetLanguagePropertyValue|. We need this
%    information for housekeeping since we want to get rid of all
%    information for languages which are not used in a particular
%    document (and for this we better keep track of all language for
%    which we stored something).
%    \begin{macrocode}
\queue@new@N \g@lang@known@languages@queue
%    \end{macrocode}
% \end{macro}
%
%    There is one pseudo language which we need in any case (the
%    ``default'' language which is the ``language'' in which we stored
%    default actions. So let's initialise that one directly.
%    \begin{macrocode}
\queue@gadd@Nn \g@lang@known@languages@queue {default}
%    \end{macrocode}
%
%
%
% \begin{macro}{\g@lang@default@plist}
%    For each language there will be a property list with the name
%    |\g@lang@<language>@plist| which holds all the actions declared
%    via |\SetLanguagePropertyValue|. Here is the one for the
%    ``default'' language. All others will get implicitly generated
%    the first time a language enters the scene.
%    \begin{macrocode}
\prop@new@N \g@lang@default@plist
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \subsection{Declaring language structures}
%
% \begin{macro}{\DeclareLanguageProperty}
%    |\DeclareLanguageProperty| takes a command name as its argument
%    and adds it to |\g@lang@known@cmds@queue| if not already present.
%    \begin{macrocode}
\def\DeclareLanguageProperty #1  % <cmd>
  {
    \queue@if@in@NnF
       \g@lang@known@cmds@queue {#1}
       {
         \queue@gadd@Nn \g@lang@known@cmds@queue {#1}
       }
  }
\@onlypreamble\DeclareLanguageProperty
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SetLanguagePropertyValue}
%    Sets the action to <action> for <cmd> in <language>. To set the
%    default action to be anything other than error message use
%    "default" as <language>.
% 
% - check that <language> is on |\g@lang@known@languages@queue|, if not add it to
%   |\g@lang@known@languages@queue| and initiate |\g@lang@<language>@plist|.
% 
% - add or modify <cmd>/<action> pair in |\g@lang@<language>@plist|.
% 
%    \begin{macrocode}
\newcommand*\SetLanguagePropertyValue[3]              % <language> <cmd> <action>
  {
    \queue@if@in@NnF
      \g@lang@known@languages@queue {#1}
       { 
         \queue@gadd@Nn\g@lang@known@languages@queue{#1}
         \prop@new@c {g@lang@#1@plist}
       }
    \prop@gput@cNn {g@lang@#1@plist} #2 { \lang@set@action@Nn#2 {#3} }
  }

\@onlypreamble\SetLanguagePropertyValue
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\lang@set@action@Nn}
%    \begin{macrocode}
\def\lang@set@action@Nn #1#2
  {
    \tlp@set@Nn#1{#2}
    \tr@ce{LANG:~ setting~ \string#1~ \meaning#1}      
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\SetLanguagePropertyValueMapping}
%    Sets the PAM value to <value> for <cmd>.
% 
%    - add or modify entry in |\g@lang@known@mappings@plist|.
% 
%    \begin{macrocode}

\newcommand*\SetLanguagePropertyValueMapping              
  {
    \prop@gput@NNn \g@lang@known@mappings@plist
  }

\@onlypreamble\SetLanguagePropertyValueMapping
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\PreambleToBodyAlgorithm}
%   for each <cmd> in |\g@lang@known@cmds@queue|, do:
% 
%   "find PAM-value" and store in <PAMvalue>;
% 
%   for each <lang> in |\usedlanguages|, do:
%     
%     "find action for <cmd> in language <lang>";
% 
%     add `explicit' form of this action to |\actions|<lang><PAMvalue>
%
%    \begin{macrocode}
\newcommand\PreambleToBodyAlgorithm
  {
%<*trace>
   \@tracepush{PreambleToBodyAlgorithm}
%</trace>
    \queue@map@inline@Nn
       \g@lang@known@cmds@queue
       {
         {
           \queue@map@inline@Nn
             \usedlanguages
             {
%    \end{macrocode}
% "find action for <cmd> in language <lang>"
% 
% if <cmd> has entry in |\g@lang@<language>@plist|,
%   then
%     retrieve action
%   else
%     if <cmd> has entry in |\g@lang@default@plist|,
%       then
%         retrieve action
%       else
%         define action to be ERROR: <cmd> has no declaration for
%                                      language <lang>
%                             HELP: declare action using 
%                                      |\SetLanguagePropertyValue| ...
% 
% 
%    
%    \begin{macrocode}
              \prop@get@cNN {g@lang@ ####1 @plist} ##1 \action
              \quark@if@no@value@NTF \action
                 {
                   \prop@gget@NNN \g@lang@default@plist ##1 \action
                   \quark@if@no@value@NTF \action
                     {
                      \tlp@gset@Nn \action 
                         { 
                           \lang@set@action@Nn##1
                             {\errmessage{ERROR:~ \noexpand##1 has~ no~
                               definition~ in~ \l@curr@lang}}
                         }
                     }
                     {}
                 }
                 {}
%    \end{macrocode}
% 
% "find PAM-value" 
% 
% if PAM-value for <cmd> is in |\g@lang@known@mappings@plist|, 
%   then
%     retrieve it
%   else
%     use fixed default value
% 
%    
%    \begin{macrocode}
              \prop@gget@NNN \g@lang@known@mappings@plist ##1 \PAMvalue
              \quark@if@no@value@NTF \PAMvalue
                 {
                   \tlp@gset@Nn \PAMvalue { all }
                 }
                 {}
%    \end{macrocode}
%    
%%%% next 3lines are a temp fix for the tlp module not having a proper init
%    \begin{macrocode}
               \expandafter\ifx\csname actions ####1 \PAMvalue\endcsname \relax
                  \tlp@gclear@c {actions ####1 \PAMvalue}
               \fi
               \exp@args@Nco \tlp@gput@right@Nn {actions ####1 \PAMvalue} \action
             }
         }
       }
%    \end{macrocode}
% 
% for each <lang> in |\g@lang@known@languages@queue|, do:
% 
%   empty |\g@lang@<language>@plist|
% 
% empty all other preamble structures.
%
%    
%    \begin{macrocode}
    \queue@map@inline@Nn
       \usedlanguages
       {
        \tlp@gclear@c {g@lang@ ##1 @plist }       % using fact that prop-lists are also tlps
       }
%    \end{macrocode}
%    keep for |\Show...| cmds for the moment
%    \begin{macrocode}
%    \queue@gclear@N  \g@lang@known@cmds@queue
    \queue@gclear@N  \g@lang@known@languages@queue
    \prop@gclear@N \g@lang@known@mappings@plist
% others?
%<*trace>
   \@tracepop{PreambleToBodyAlgorithm}
%</trace>
  }

\@onlypreamble\PreambleToBodyAlgorithm

\AtBeginDocument{\PreambleToBodyAlgorithm}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
% \begin{macro}{\DeclareDocumentLanguages}
%    \begin{macrocode}
%
% \DeclareDocumentLanguages <language-list>
% 
% Lists all languages that are used in the document (any other language
% will then generate an error message if it appears in a language change
% command or environment)
% 
% - produces \usedlanguages list
% 
\newcommand\DeclareDocumentLanguages   %  arg <language-list> (implicit)
  {
   \queue@from@comma@Nn \usedlanguages
  }

\@onlypreamble\DeclareDocumentLanguages
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\SetDocumentLanguage}
%    \begin{macrocode}
%
% \SetDocumentLanguage <language>
% 
% Declares <language> to be the document language.
% 

\newcommand\SetDocumentLanguage        %  <language> (implicit)
  { \tlp@gset@Nn \g@document@lang }

\@onlypreamble\SetDocumentLanguage 
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Body tags}
%
%
% \begin{macro}{\baselanguage}
% \begin{macro}{\@baselanguage}
%     A base-language change command with the language-label as
%     argument.  This command is declarative to highlight the flat
%     structure of base languages.
%
%    We expand the argument once to allow the language name being
%    hidden inside a macro.
%    \begin{macrocode}
\newcommand*\baselanguage[1]  % <language>
  {\expandafter\@baselanguage\expandafter{#1}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\newcommand*\@baselanguage[1] 
  {
   \par
%    \end{macrocode}
%    The command should not be called inside language blocks or frags
%    so we first check if the |\l@curr@thd@type| is ``base''.
%    \begin{macrocode}
   \ifx\l@curr@thd@type\c@lang@thd@base@name@tlp
     \lang@check@nT {#1}
        {
	 \tlp@gset@Nn \g@base@lang {#1}
	 \tlp@set@Nn \l@curr@lang {#1}
%    \end{macrocode}
%    Since we know the |\l@next@thd@level| being |base| we don't need
%    to call |\lang@update@level@n| but instead do the
%    updates directly. First the update of the language data structures.
%    \begin{macrocode}
	 \lang@actions@base@n {#1}
%    \end{macrocode}
%    Then we update the font encoding
%    \begin{macrocode}
         \lang@update@encodings@
%    \end{macrocode}
%    \ldots and if necessary the text direction:
%    \begin{macrocode}
         \lang@update@direction@
        }
%    \end{macrocode}
%    If we are not at ``base'' signal an error (not yet implemented
%    really):
%    \begin{macrocode}
   \else
     \ERRORbaselanguagenotatbaselevel
     \show\l@curr@thd@type
     \show\c@lang@thd@base@name@tlp
   \fi
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%    
% \begin{macro}{\c@lang@thd@base@name@tlp}
%    A constant holding the name of the ``base''.
%    \begin{macrocode}
\def\c@lang@thd@base@name@tlp{base}
%    \end{macrocode}
% \end{macro}
%
%   
%    At start of the document body we initiate all actions tied to the
%    document level and then make make the document language the
%    first base language.
%    \begin{macrocode}
\AtBeginDocument
  {
   \lang@actions@nn\g@document@lang{document}
   \baselanguage\g@document@lang
  }
%    \end{macrocode}
%
%
%    The next three macros define the \texttt{langblock} environment
%    and its command form |\langblock| using the extended |\begin|
%    mechanism.
%
% \begin{macro}{\begin@@langblock}
%    A language-environment with the language-label as argument and
%    text as body.  The environment starts a new paragraph to enforce
%    the block level nature.
%    \begin{macrocode}
\newcommand*\begin@@langblock[1]
  {
%<*trace>
   \@tracepush{langblock:~ #1}
%</trace>
   \par
   \lang@check@nT {#1}
     {
      \tlp@set@Nn \l@curr@lang {#1}
      \lang@update@level@n {#1}
      \lang@update@block@n {#1}
      \lang@update@encodings@
      \lang@update@direction@
     }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\endlangblock}
%    At the end of the block we issue a par to enforce the block-level
%    nature. Nothing else to do since restoring happens implicitly at
%    the |\endgroup| of the |\end| tag.
%    \begin{macrocode}
\def\endlangblock
  {\par
%<*trace>
   \@tracepop{langblock}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\langblock}
%
%    This command accepts full paragraphs in its second argument so we
%    have to use |\newcommand| to define it.
%    \begin{macrocode}
\newcommand\langblock[2]      % <language> <text>
  {
   \begingroup
     \begin@@langblock{#1}
     #2
     \endlangblock
   \endgroup
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%    The next three macros define the \texttt{langfrag} environment
%    and its command form |\langfrag| using the extended |\begin|
%    mechanism. They are more or less conceptually identical to the
%    ones defining the environment \texttt{langblock} except that they
%    don't accept |\par|s in their argument\footnote{Actually, the
%    environment for does allow them, we would need to trap the
%    command explicitly to prevent that; not yet done.} and do not
%    start and end a paragraph.
%
%
% \begin{macro}{\begin@@langfrag}
%    A language-command with the language-label and text both as
%    arguments. In contrast to the environment, this command applies
%    language related actions to its second argument, which cannot
%    directly contain full paragraphs.
%    \begin{macrocode}
\newcommand*\begin@@langfrag[1]
  {
%<*trace>
   \@tracepush{langfrag:~ #1}
%</trace>
   \lang@check@nT {#1}
    {
       \tlp@set@Nn \l@curr@lang {#1}
       \lang@update@level@n {#1}
       \lang@update@frag@n {#1}
       \lang@update@encodings@
       \lang@update@direction@
    }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\endlangfrag}
%    At the end of the language change there is nothing to do (except
%    for tracing what is happening.
%    \begin{macrocode}
\def\endlangfrag
  {
%<*trace>
   \@tracepop{langfrag}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\langfrag}
%    This command should not accept multiple paragraphs in its
%    argument so we use |\newcommand*| to define it.
%    \begin{macrocode}
\newcommand*\langfrag[2]      % <language> <text>
  {
   \begingroup
     \begin@@langfrag{#1}
     #2
     \endlangfrag
   \endgroup
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\lang@check@nT}
%    Check that language is one of the declared and if so execute second
%    argument (true case) otherwise generate error.
%    \begin{macrocode}
\def\lang@check@nT #1#2
  {
   \queue@if@in@NnTF \usedlanguages {#1} 
       {#2} 
       {\errmessage{ERROR:~ language~ #1~ not~ known}}
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\lang@update@level@n}
%    Go down the level in the thd (nesting) and execute all
%    corresponding actions:
%    \begin{macrocode}
\def\lang@update@level@n
%    \end{macrocode}
%    Tracing considered harmful :-(
%    \begin{macrocode}
%<*trace> 
   #1
%</trace>
  {
%<*trace>
   \@tracepush{lang@update@level@n:~ \l@next@thd@level}
%</trace>
    \csname lang@actions@ \l@next@thd@level @n 
    \endcsname
%<*trace>
       {#1}
%</trace>
%<*trace>
   \@tracepop{lang@update@level@n}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
%
%
% \begin{macro}{\lang@update@block@n}
%    \begin{macrocode}
\def\lang@update@block@n #1
  {
%<*trace>
   \@tracepush{lang@update@block@n}
%</trace>
   \csname lang@actions@\l@curr@thd@type @block@n
   \endcsname
%<*trace>
       {#1}
%</trace>
%<*trace>
   \@tracepop{lang@update@block@n}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
%
% \begin{macro}{\lang@update@frag@n}
%    \begin{macrocode}
\def\lang@update@frag@n #1
  {
%<*trace>
   \@tracepush{lang@update@frag@n}
%</trace>
   \csname lang@actions@\l@curr@thd@type @frag@n
   \endcsname
%<*trace>
       {#1}
%</trace>
%<*trace>
   \@tracepop{lang@update@frag@n}
%</trace>
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\lang@update@encodings@}
%    \begin{macrocode}
\def\lang@update@encodings@{
    \fontencoding\fontencodingname\selectfont
%    \end{macrocode}
%    Next set of lines require the \texttt{inputenc} package, so need
%    different handling eventually.
%    \begin{macrocode}
    \ifx\inputencodingname\@empty
    \else
      \inputencoding\inputencodingname
    \fi
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\lang@update@direction@}
%    \begin{macrocode}
\IfNotOmega
  \def\lang@update@direction@{
\typeout{Not~ Omega!}
%    \end{macrocode}
%    \begin{macrocode}
  }
\else
  \def\lang@update@direction@{}
\fi
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\lang@actions@nn}
%
%    For each language in |\usedlanguages| and each node-type in the
%    THD,
% 
%    |\actions<language><node-type>|
% 
%     `explicit' list of what happens, for that node-type, when changing to
%     language <language> at a node of type <node-type>.

%    to reduce the number of csname one can make this functions with
%    <language> as their argument this will be slower in processing
%    but simpler in setup ...

%    \begin{macrocode}
\def \lang@actions@nn #1#2
  { \csname actions #1 #2 \endcsname }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lang@actions@all@n}
%    \begin{macrocode}

\def \lang@actions@all@n #1
   { \lang@actions@nn{#1}{all} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lang@actions@second@n}
%    \begin{macrocode}

\def \lang@actions@second@n #1
   { \lang@actions@nn{#1}{second} 
     \lang@actions@all@n{#1}
     \tlp@set@Nn \l@next@thd@level {all}
   }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lang@actions@first@n}
%    \begin{macrocode}

\def \lang@actions@first@n #1
   { \lang@actions@nn{#1}{first} 
     \lang@actions@second@n{#1}
     \tlp@set@Nn \l@next@thd@level {second}
   }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lang@actions@base@n}
%    \begin{macrocode}

\def \lang@actions@base@n #1
   { \lang@actions@nn{#1}{base} 
     \lang@actions@first@n{#1}
     \lang@actions@base@block@n{#1}
     \tlp@set@Nn \l@next@thd@level {first}
     \tlp@set@Nn \l@curr@thd@type  {base}
   }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lang@actions@base@block@n}
%    \begin{macrocode}

\def \lang@actions@base@block@n #1
   { \lang@actions@nn{#1}{block} 
     \lang@actions@nn{#1}{subblock} 
     \lang@actions@nn{#1}{frag} 
     \tlp@set@Nn \l@curr@thd@type {block}
   }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lang@actions@block@block@n}
%    \begin{macrocode}
\def \lang@actions@block@block@n #1
   { \lang@actions@nn{#1}{subblock} 
     \lang@actions@nn{#1}{frag} 
     \tlp@set@Nn \l@curr@thd@type {subblock}
   }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lang@actions@subblock@block@n}
%    \begin{macrocode}
\let \lang@actions@subblock@block@n \lang@actions@block@block@n
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lang@actions@base@frag@n}
%    \begin{macrocode}

\def \lang@actions@base@frag@n #1
   { \lang@actions@nn{#1}{frag} 
     \tlp@set@Nn \l@curr@thd@type {frag}
   }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lang@actions@block@frag@n}
%    \begin{macrocode}

\let \lang@actions@block@frag@n \lang@actions@base@frag@n
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lang@actions@subblock@frag@n}
%    \begin{macrocode}
\let \lang@actions@subblock@frag@n \lang@actions@base@frag@n
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lang@actions@frag@frag@n}
%    \begin{macrocode}
\let \lang@actions@frag@frag@n  \lang@actions@base@frag@n
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\lang@actions@frag@block@n}
%    \begin{macrocode}
\let \lang@actions@frag@block@n \lang@actions@base@frag@n
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
%
%
% \begin{macro}{\usedlanguages}
%    \begin{macrocode}
\queue@new@N \usedlanguages              
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g@lang@known@mappings@plist}
%    \begin{macrocode}

% list of <cmd>/<PAM-value> pairs

\prop@new@N \g@lang@known@mappings@plist
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l@curr@lang}
%    \begin{macrocode}


\tlp@new@Nn\l@curr@lang   {?}        % current language
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l@base@lang}
%    \begin{macrocode}
\tlp@new@Nn\l@base@lang   {}         % current base language
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g@document@lang}
%    \begin{macrocode}
\tlp@new@Nn\g@document@lang{english} % document language     (more or less a constant)
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l@curr@thd@type}
%    \begin{macrocode}
\tlp@new@Nn\l@curr@thd@type{base}     % current type of the thd node (this is the block or frag rail)
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l@next@thd@level}
%    \begin{macrocode}
\tlp@new@Nn\l@next@thd@level{first}   % upcoming level in nesting hierarchy (we start at base)
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\comma@loop@Nnn}
%    \begin{macrocode}
%
% bunch of missing functions or bug fixes ...


%    this is like good old \@for with a different starting syntax. would
%    need a separate module implementing
%    such functions (and better names)

\def \comma@loop@Nnn #1#2#3
  {
  \expandafter\def\expandafter\@fortmp\expandafter{#2}
  \ifx\@fortmp\@empty \else
    \expandafter\@forloop#2,\@nil,\@nil\@@#1{#3}\fi}
% make a queue out of a comma-list:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\queue@from@comma@Nn}
%    \begin{macrocode}
\def \queue@from@comma@Nn #1#2
  {
   \comma@loop@Nnn \l@tmpa@tlp {#2} { \queue@gadd@No #1 \l@tmpa@tlp  }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\queue@map@inline@Nn}
%    \begin{macrocode}



% bug fix? def of \queue@elt was global

\def \queue@map@inline@Nn #1#2{
    \def \queue@elt ##1\queue@eelt {#2}#1
    \let \queue@elt \ERROR
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ShowLanguagePropertyStatus}
%    \begin{macrocode}
\def \ShowLanguagePropertyStatus {
%<*trace>
   \@tracepush{ShowLanguagePropertyStatus~(language=\l@curr@lang)}
%</trace>
   \queue@map@inline@Nn \g@lang@known@cmds@queue 
      { \tr@ce{ \string##1:~\meaning ##1 } }
%<*trace>
   \@tracepop{ShowLanguagePropertyStatus}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%    
%
% \begin{macro}{\fontencodingname}
% \begin{macro}{\inputencodingname}
%    \begin{macrocode}
\DeclareLanguageProperty\fontencodingname
\DeclareLanguageProperty\inputencodingname
\SetLanguagePropertyValue{default}\fontencodingname {\encodingdefault}
\SetLanguagePropertyValue{default}\inputencodingname{}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%    
%    \begin{macrocode}
\DeclareLanguageProperty\prefacename
\DeclareLanguageProperty\refname
\DeclareLanguageProperty\abstractname
\DeclareLanguageProperty\bibname
\DeclareLanguageProperty\chaptername
\DeclareLanguageProperty\appendixname
\DeclareLanguageProperty\contentsname
\DeclareLanguageProperty\listfigurename
\DeclareLanguageProperty\listtablename
\DeclareLanguageProperty\indexname
\DeclareLanguageProperty\figurename
\DeclareLanguageProperty\tablename
\DeclareLanguageProperty\partname
\DeclareLanguageProperty\enclname
\DeclareLanguageProperty\ccname
\DeclareLanguageProperty\headtoname
\DeclareLanguageProperty\pagename
\DeclareLanguageProperty\seename
\DeclareLanguageProperty\alsoname
\DeclareLanguageProperty\proofname
\DeclareLanguageProperty\glossaryname
%    \end{macrocode}
%    
%    \begin{macrocode}

\def\addcontentsline#1#2#3{%
  \addtocontents{#1}{\protect\contentsline{#2}
    {\string\langfrag{\l@curr@lang}{#3}}{\thepage}}}

% unchanged so far
\long\def\addtocontents#1#2{%
  \protected@write\@auxout
      {\let\label\@gobble \let\index\@gobble \let\glossary\@gobble}%
      {\string\@writefile{#1}{#2}}}

%    \end{macrocode}
%
%    \begin{macrocode}
\endinput
%    \end{macrocode}
%    
%    
% \PrintIndex
%
%
