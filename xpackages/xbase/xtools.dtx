% \iffalse
%%
%% (C) Copyright 2000,2001 Frank Mittelbach
%% All rights reserved.
%%
%% Not for general distribution. In its present form it is not allowed
%% to put this package onto CD or an archive without consulting the
%% the authors.
%% 
%    \begin{macrocode}
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{
%<*dtx>
  \ProvidesFile{#2.dtx}
%</dtx>
%<package>\ProvidesPackage{#2}
%<driver>\ProvidesFile{#2.drv}
  [#4 #3 #8 (#6)]}
\next$Id$
       {xtools}
%    \end{macrocode}
%
%<*driver>
 \documentclass{ltxdoc}
%
 \begin{document}
 \catcode`\_=11
 \catcode`\:=11
 \DocInput{xtools-uc.dtx}
 \end{document}
%</driver>
%
% \fi
%
%
% \GetFileInfo{xtools.dtx}
%
% \title{The \textsf{xtools} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi}
% \date{\filedate}
%
%  \maketitle
%
% \tableofcontents
%
%
%
% \section{Intro}
%
%
% The implementation below is more or less a straight adaption of code
% from l3expl, so it still needs a rewrite one day. It is based on
% modules implementing ``queues'', ``property lists'', and ``quarks''
% most of which have been published as experimental code with a
% slightly different surface syntax, i.e., as \texttt{l3seq.sty},
% \texttt{l3prop.sty}, and \texttt{l3quark.sty}.
%
%    \begin{macrocode}
\RequirePackage{ldcsetup}
\IgnoreWhiteSpace
%    \end{macrocode}
%
%    \begin{macrocode}
\long\def\@firstofthree#1#2#3{#1}
\long\def\@secondofthree#1#2#3{#2}
\long\def\@thirdofthree#1#2#3{#3}
%    \end{macrocode}
%
%    \begin{macrocode}
\let \tlp_new:Nn \gdef
\def \tlp_clear:c #1{\@namedef{#1}{}}
\def \tlp_gclear:c  {\global\tlp_clear:c}
%    \end{macrocode}
%    
%    \begin{macrocode}
\let \tlp_set:Nn \def
\def \tlp_set:No #1#2 {\expandafter \tlp_set:Nn
                       \expandafter #1 \expandafter {#2}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \tlp_gset:Nn {\global\tlp_set:Nn} 
\def \tlp_gset:No #1#2 {\expandafter \tlp_gset:Nn
                        \expandafter #1 \expandafter {#2}}
\def \tlp_gset:cn #1{\global\@namedef{#1}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\long \def \tlp_gput_right:Nn #1#2{\tlp_gset:No #1{#1#2}}
\long \def \tlp_gput_right:No #1#2 {
  \expandafter \tlp_gput_right:Nn \expandafter #1 \expandafter { #2 }}
\def \tlp_gput_right:cn #1 {
  \expandafter \tlp_gput_right:Nn \csname #1 \endcsname }
\def \tlp_gput_right:co #1 {
  \expandafter \tlp_gput_right:No \csname #1 \endcsname }
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \tlp_to_str:N {\expandafter \tlp_to_str:aux \meaning}
\def \tlp_to_str:aux #1>{}
\def \tlp_to_str:c #1 {\expandafter \tlp_to_str:N \csname#1\endcsname}
%    \end{macrocode}
%
%
%
% \subsection{General commands for expansion}
%
% \begin{macro}{\exp_args:Nco}
%    \begin{macrocode}
\def \exp_args:Nco  #1#2#3 {\expandafter#1
                            \csname#2\expandafter\endcsname
                            \expandafter {#3}
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Commands for manipulating queues}
%
% \begin{macro}{\trace@queue}
% \begin{macro}{\trace@queue@internal}
% \begin{macro}{\tracingqueues}
%    \begin{macrocode}
%<*trace>
\def\trace@queue#1{\ifnum \tracingqueues > \z@
      \typeout{Queues:~ #1~ \on@line}\fi}
\def\trace@queue@internal#1{\ifnum\tracingqueues>\@ne
      \typeout{Queues:~ #1~ \on@line}\fi}
\newcount\tracingqueues
%</trace>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\queue_new:N}
% \begin{macro}{\queue_new:c}
%    \begin{macrocode}
\def\queue_new:N#1{\let#1\@empty}
\def\queue_new:c#1{\@namedef{#1}{}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
\let \queue_clear:N \queue_new:N
\def \queue_gclear:N {\global\queue_clear:N}
%    \end{macrocode}
%
% \begin{macro}{\queue_gadd:Nn}
%    \begin{macrocode}
\def\queue_gadd:Nn#1#2{\expandafter\gdef\expandafter#1\expandafter
    {#1\queue_elt#2\queue_eelt}
%<*trace>
  \trace@queue@internal{add~ `#2'~ to~ queue~ \string#1}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\queue_gadd:cn}
% \begin{macro}{\queue_gadd:No}
% \begin{macro}{\queue_gadd:co}
%    \begin{macrocode}
\def\queue_gadd:cn#1{\expandafter\queue_gadd:Nn\csname#1\endcsname}
\def\queue_gadd:No#1#2{\expandafter\queue_gadd:Nn
                       \expandafter#1\expandafter{#2}}
\def\queue_gadd:co#1{\expandafter\queue_gadd:No\csname#1\endcsname}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\queue_top:NN}
%    \begin{macrocode}
\def\queue_top:NN#1#2{
  \queue_empty_err:N#1
  \expandafter\queue_top_split:w#1\q_stop{\def#2}
%<*trace>
  \trace@queue@internal{top~ of~ queue~\string#1:~`\tlp_to_str:N#2'}
%</trace>
}
% \end{macro}
%
% \begin{macro}{\queue_top_split:w}
\def\queue_top_split:w\queue_elt#1\queue_eelt#2\q_stop#3{#3{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\queue_top:cN}
%    \begin{macrocode}
\def\queue_top:cN#1{\expandafter\queue_top:NN\csname#1\endcsname}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\queue_pop_aux:nnNN}
% \begin{macro}{\queue_pop_aux:w}
%    \begin{macrocode}
\def \queue_pop_aux:nnNN #1#2#3{
  \queue_empty_err:N #3
  \expandafter\queue_pop_aux:w #3\q_stop #1#2#3}
\def \queue_pop_aux:w \queue_elt#1\queue_eelt
                #2\q_stop #3#4#5#6{#3#5{#2}#4#6{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\queue_gpop:NN}
%    \begin{macrocode}
\def \queue_gpop:NN #1#2{\queue_pop_aux:nnNN \gdef \gdef #1 #2
%<*trace>
  \trace@queue@internal{pop~ of~ queue~\string#1:~`\tlp_to_str:N #2'}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\queue_gpop:cN}
%    \begin{macrocode}
\def \queue_gpop:cN #1{\expandafter\queue_gpop:NN\csname#1\endcsname}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\queue_empty_err:N}
%    \begin{macrocode}
\def\queue_empty_err:N #1{\ifx#1\@empty \ERROR \fi}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\queue_if_in:NnTF}
% \begin{macro}{\queue_if_in:NnF}
%    |\queue_if_in:NnTF| \meta{queue}\meta{item} \meta{true~case}
%    \meta{false~case} will check whether \meta{item} is in
%    \meta{queue} and then either execute the \meta{true~case} or the
%    \meta{false~case}.
%    \begin{macrocode}
\def \queue_if_in:NnTF #1#2{
  \def \tmp_w
      ##1\queue_elt #2\queue_eelt ##2##3\q_stop{
%    \end{macrocode}
%    Note that |##2| contains exactly one token which we can compare
%    with |\q_no_value|.
%    \begin{macrocode}
        \ifx\q_no_value##2
          \expandafter\@secondoftwo
        \else
          \expandafter\@firstoftwo
        \fi
      }
  \expandafter
  \tmp_w #1\queue_elt #2\queue_eelt \q_no_value \q_stop}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \queue_if_in:NnF #1#2{
  \def \tmp_w
      ##1\queue_elt #2\queue_eelt ##2##3\q_stop{
        \ifx\q_no_value##2
          \expandafter\@firstofone
        \else
          \expandafter\@gobble
        \fi
      }
  \expandafter
  \tmp_w #1\queue_elt #2\queue_eelt \q_no_value \q_stop}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%    \begin{macrocode}
\def \queue_if_in:NoTF #1#2{\expandafter \queue_if_in:NnTF
                            \expandafter #1 \expandafter {#2}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \queue_map:NN #1#2{
  \let \queue_map_funct:n #2
  \expandafter\queue_map_aux:w #1\queue_elt\q_stop\queue_eelt}
\def \queue_map_aux:w \queue_elt#1\queue_eelt{
%    \end{macrocode}
%    |#1| can compare arbitrary tokens so for testing against
%    |\q_stop| we need to wrap it into a macro.
%    \begin{macrocode}
  \def\tmp_w{#1}
  \ifx \tmp_w\q_stop \else
    \queue_map_funct:n {#1}
    \expandafter\queue_map_aux:w
  \fi}
%    \end{macrocode}
%    Inline version where the code is specified as second argument
%    with |##1| marking the mapping argument within the code.
%    \begin{macrocode}
\def \queue_map:Nn #1#2{
  \def \queue_map_funct:n ##1{#2}
  \expandafter\queue_map_aux:w #1\queue_elt\q_stop\queue_eelt}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \queue_empty:NTF #1 {
  \ifx#1\@empty
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
}
%    \end{macrocode}
%
%
%
%
%
% \subsection {Quarks}
%
% A quark is a control sequence that expands into itself |\def|
% |\foo{\foo}|.  Quarks provide a cheap way of generating distinct
% constants.  Also, they permit the following ingenious trick: when
% you pick up a token in a temporary, and you want to know whether you
% have picked up a particular quark, all you have to do is compare the
% temporary to the quark using |\ifx|.
%
% \begin{macro}{\quark_new:N}
%    Allocate a new quark.
%    \begin{macrocode}
\def \quark_new:N #1{\def #1{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\q_stop}
% \begin{macro}{\q_no_value}
% \begin{macro}{\q_nil}
%    |\q_stop| is often used as a marker in parameter text,
%    |\q_no_value| is the canonical missing value, and |\q_nil|
%    represents a nil pointer in some data structures.
%    \begin{macrocode}
\quark_new:N \q_stop
\quark_new:N \q_no_value
\quark_new:N \q_nil
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\q_error}
% \begin{macro}{\q_mark}
%    We need two additional quarks.  |\q_error| delimits the end of
%    the computation for purposes of error recovery.  |\q_mark| is
%    used in parameter text when we need a scanning boundary that is
%    distinct from |\q_stop|.
%    \begin{macrocode}
\quark_new:N\q_error
\quark_new:N\q_mark
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\quark_if_no_value:NTF}
% \begin{macro}{\quark_if_no_value:NF}
% \begin{macro}{\quark_if_no_value:nTF}
% \begin{macro}{\quark_if_no_value:nT}
% \begin{macro}{\quark_if_no_value:nF}
%    Here we test if we found a special quark as the first argument.
%    The argument might contain an arbitrary list of tokens, therefore
%    we have to wrap it up in a token list pointer.
%    \begin{macrocode}
\def \quark_if_no_value:NTF #1{
%    \end{macrocode}
%    We better start with |\q_no_value| as the first argument since
%    the whole thing may otherwise loop if |#1| is wrongly given
%    a string like |aabc| instead of a single token.\footnote{It may
%    still loop in special circumstances however!}
%    \begin{macrocode}
     \ifx\q_no_value#1
          \expandafter\@firstoftwo
     \else \expandafter\@secondoftwo \fi}
%    \end{macrocode}
%    It would be possible to speed up the following commands by
%    providing individual implementations similar to the one above.
%    Should perhaps be done if they are used often!
%    \begin{macrocode}
\def \quark_if_no_value:NF #1{\quark_if_no_value:NTF #1\@empty}
\def \quark_if_no_value:NT #1#2{\quark_if_no_value:NTF #1{#2}\@empty}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \quark_if_no_value:nTF #1{\gdef \@gtempa {#1}
    \quark_if_no_value:NTF\@gtempa}
\def \quark_if_no_value:nF #1{\quark_if_no_value:nTF {#1}\@empty}
\def \quark_if_no_value:nT #1#2{\quark_if_no_value:nTF {#1}
        {#2}\@empty}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\quark_if_nil:NTF}
%    A function to check for the presence of |\q_nil|.
%    \begin{macrocode}
\def\quark_if_nil:NTF#1{
  \ifx#1\q_nil
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo\fi}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{Commands for manipulating property lists}
%
%
% \begin{macro}{\prop_new:N}    
% \begin{macro}{\prop_new:c}    
%    \begin{macrocode}
\let \prop_new:N \queue_new:N
\let \prop_new:c \queue_new:c
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
\let \prop_clear:N \queue_clear:N
\let \prop_gclear:N \queue_gclear:N
%    \end{macrocode}
%
% \begin{macro}{\prop_put:NNn}    
% \begin{macro}{\prop_gput:NNn}    
% \begin{macro}{\prop_gput:NNo}    
% \begin{macro}{\prop_gput:Nco}    
% \begin{macro}{\prop_gput:cNn}    
% \begin{macro}{\prop_gput:cNo}    
% \begin{macro}{\prop_gput:cco}    
% \begin{macro}{\prop_gput:ccn}    
%    \begin{macrocode}
\long\def \prop_put:NNn #1#2{\prop_split_aux:NNn
                             #1#2{\prop_put_aux:w {\def #1}#2}}
\long\def \prop_gput:NNn #1#2{\prop_split_aux:NNn
                                #1#2{\prop_put_aux:w {\gdef #1}#2}}
%  missing commands for galley stuff...
\def \prop_gput:NNo #1#2#3{
  \expandafter\prop_gput:NNn \expandafter #1 \expandafter 
                          #2 \expandafter { #3 } }
\def \prop_gput:Nco #1#2#3{
  \expandafter\prop_gput:NNn \expandafter #1 
                          \csname #2 \expandafter \endcsname
                          \expandafter { #3 } }
\def \prop_gput:cNn #1{
  \expandafter\prop_gput:NNn \csname #1\endcsname
}
\def \prop_gput:cNo #1{
  \expandafter\prop_gput:NNo \csname #1\endcsname
}
\def \prop_gput:cco #1#2#3{
  \expandafter\prop_gput:NNn \csname #1\expandafter\endcsname
                             \csname #2\expandafter\endcsname
                             \expandafter { #3 } }
\def \prop_gput:ccn #1#2{
  \expandafter\prop_gput:NNn \csname #1\expandafter\endcsname
                             \csname #2\endcsname
                              }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\prop_put_aux:w}    
%    \begin{macrocode}
\long\def \prop_put_aux:w #1#2#3#4#5#6{
  \quark_if_no_value:nTF {#4}
    {#1{#2{#6}#3}}
    {\def\tmp_w ##1#2\q_no_value {#1{#3#2{#6}##1}}
     \tmp_w #5}}
%    \end{macrocode}
% \end{macro}
%    
% \begin{macro}{\prop_split_aux:NNn}    
%    \begin{macrocode}
\long\def \prop_split_aux:NNn #1#2#3{
  \def\tmp_w ##1#2##2##3\q_stop {#3{##1}{##2}{##3}}
%                                       ^   ^ needed!
  \expandafter\tmp_w #1#2\q_no_value \q_stop}
%    \end{macrocode}
% \end{macro}
%    
%
% \begin{macro}{\prop_get:NNN}    
% \begin{macro}{\prop_get:NcN}    
% \begin{macro}{\prop_get:cNN}    
% \begin{macro}{\prop_gget:NNN}    
% \begin{macro}{\prop_gget:NcN}    
% \begin{macro}{\prop_gget:cNN}    
%    \begin{macrocode}
\def \prop_get:NNN #1#2{\prop_split_aux:NNn
                                    #1#2\prop_get_aux:w}
\def \prop_get:NcN #1#2 {
 \expandafter \prop_get:NNN \expandafter #1
 \csname #2 \endcsname 
}
\def \prop_get:cNN #1{
  \expandafter\prop_get:NNN \csname #1\endcsname
}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \prop_gget:NNN #1#2{\prop_split_aux:NNn
                                    #1#2\prop_gget_aux:w}
\def \prop_gget:NcN #1#2 {
 \expandafter \prop_gget:NNN \expandafter #1
 \csname #2 \endcsname 
}
\def \prop_gget:cNN #1{
  \expandafter\prop_gget:NNN \csname #1\endcsname
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%    
%
% \begin{macro}{\prop_get_aux:w}    
%    \begin{macrocode}
\long\def \prop_get_aux:w #1#2#3#4{\def#4{#2}}
\long\def \prop_gget_aux:w #1#2#3#4{\gdef#4{#2}}
%    \end{macrocode}
% \end{macro}
%    
%
% \begin{macro}{\prop_map_funct:Nn}    
%    \begin{macrocode}
\let \prop_map_funct:Nn \@gobbletwo
%    \end{macrocode}
% \end{macro}
%    
%
% \begin{macro}{\prop_map:NN}    
%    \begin{macrocode}
\def \prop_map:NN #1#2{
  \let \prop_map_funct:Nn #2
  \expandafter\prop_map_aux:w #1\q_stop \q_stop}
%    \end{macrocode}
% \end{macro}
%    
%
% \begin{macro}{\prop_map_aux:w}    
%    \begin{macrocode}
\def \prop_map_aux:w #1#2{
  \ifx #1\q_stop \else
    \prop_map_funct:Nn #1{#2}
    \expandafter\prop_map_aux:w
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\prop_map:cN}    
% \begin{macro}{\prop_map:cc}    
%    \begin{macrocode}
\def \prop_map:cN #1{
  \expandafter \prop_map:NN \csname #1\endcsname }
\def \prop_map:cc #1#2{
  \expandafter \prop_map:NN \csname #1 \expandafter\endcsname 
   \csname #2\endcsname }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
