% \iffalse
%%
%% (C) Copyright 2000,2001 Frank Mittelbach
%% All rights reserved.
%%
%% Not for general distribution. In its present form it is not allowed
%% to put this package onto CD or an archive without consulting the
%% the authors.
%% 
%    \begin{macrocode}
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{
%<*dtx>
  \ProvidesFile{#2.dtx}
%</dtx>
%<package>\ProvidesPackage{#2}
%<driver>\ProvidesFile{#2.drv}
  [#4 #3 #8 (#6)]}
\next$Id$
       {multiple marks}
%    \end{macrocode}
%
%<*driver>
 \documentclass{ltxdoc}
%
 \begin{document}
 \DocInput{xtools.dtx}
 \end{document}
%</driver>
%
% \fi
%
%
% \GetFileInfo{xtools.dtx}
%
% \title{The \textsf{xtools} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi}
% \date{\filedate}
%
%  \maketitle
%
% \tableofcontents
%
%
%
% \section{Intro}
%
%
% The implementation below is more or less a straight adaption
% of that code, so it still needs a rewrite one day. It is based on
% modules implementing ``queues'', ``property lists'', and ``quarks''
% most of which have been published as experimental code with a
% slightly different surface syntax, i.e., as \texttt{l3seq.sty},
% \texttt{l3prop.sty}, and \texttt{l3quark.sty}.
%
%    \begin{macrocode}
\RequirePackage{ldcsetup}
\IgnoreWhiteSpace
%    \end{macrocode}
%
%    \begin{macrocode}
\long\def\@firstofthree#1#2#3{#1}
\long\def\@secondofthree#1#2#3{#2}
\long\def\@thirdofthree#1#2#3{#3}
%    \end{macrocode}
%
%    \begin{macrocode}
\let \tlp@new@Nn \gdef
\def \tlp@clear@c #1{\@namedef{#1}{}}
\def \tlp@gclear@c  {\global\tlp@clear@c}
\let \tlp@set@Nn \def
\def \tlp@gset@Nn {\global\tlp@set@Nn} 
\def \tlp@gset@No #1#2 {\expandafter \tlp@gset@Nn
                        \expandafter #1 \expandafter {#2}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\long \def \tlp@gput@right@Nn #1#2{\tlp@gset@No #1{#1#2}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \tlp@to@str@N {\expandafter \tlp@to@str@aux \meaning}
\def \tlp@to@str@aux #1>{}
\def \tlp@to@str@c #1 {\expandafter \tlp@to@str@N \csname#1\endcsname}
%    \end{macrocode}
%
%
%
% \subsection{General commands for expansion}
%
% \begin{macro}{\exp@args@Nco}
%    \begin{macrocode}
\def \exp@args@Nco  #1#2#3 {\expandafter#1
                            \csname#2\expandafter\endcsname
                            \expandafter {#3}
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Commands for manipulating queues}
%
% \begin{macro}{\trace@queue}
% \begin{macro}{\trace@queue@internal}
% \begin{macro}{\tracingqueues}
%    \begin{macrocode}
%<*trace>
\def\trace@queue#1{\ifnum \tracingqueues > \z@
      \typeout{Queues:~ #1~ \on@line}\fi}
\def\trace@queue@internal#1{\ifnum\tracingqueues>\@ne
      \typeout{Queues:~ #1~ \on@line}\fi}
\newcount\tracingqueues
%</trace>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\queue@new@N}
% \begin{macro}{\queue@new@c}
%    \begin{macrocode}
\def\queue@new@N#1{\let#1\@empty}
\def\queue@new@c#1{\@namedef{#1}{}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
\let \queue@clear@N \queue@new@N
\def \queue@gclear@N {\global\queue@clear@N}
%    \end{macrocode}
%
% \begin{macro}{\queue@gadd@Nn}
%    \begin{macrocode}
\def\queue@gadd@Nn#1#2{\expandafter\gdef\expandafter#1\expandafter
    {#1\queue@elt#2\queue@eelt}
%<*trace>
  \trace@queue@internal{add~ `#2'~ to~ queue~ \string#1}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\queue@gadd@cn}
% \begin{macro}{\queue@gadd@No}
%    \begin{macrocode}
\def\queue@gadd@cn#1{\expandafter\queue@gadd@Nn\csname#1\endcsname}
\def\queue@gadd@No#1#2{\expandafter\queue@gadd@Nn
                       \expandafter#1\expandafter{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\queue@top@NN}
%    \begin{macrocode}
\def\queue@top@NN#1#2{
  \queue@empty@err@N#1
  \expandafter\queue@top@split@w#1\q@stop{\def#2}
%<*trace>
  \trace@queue@internal{top~ of~ queue~\string#1:~`\tlp@to@str@N#2'}
%</trace>
}
% \end{macro}
%
% \begin{macro}{\queue@top@split@w}
\def\queue@top@split@w\queue@elt#1\queue@eelt#2\q@stop#3{#3{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\queue@top@cN}
%    \begin{macrocode}
\def\queue@top@cN#1{\expandafter\queue@top@NN\csname#1\endcsname}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\queue@pop@aux@nnNN}
% \begin{macro}{\queue@pop@aux@w}
%    \begin{macrocode}
\def \queue@pop@aux@nnNN #1#2#3{
  \queue@empty@err@N #3
  \expandafter\queue@pop@aux@w #3\q@stop #1#2#3}
\def \queue@pop@aux@w \queue@elt#1\queue@eelt
                #2\q@stop #3#4#5#6{#3#5{#2}#4#6{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\queue@gpop@NN}
%    \begin{macrocode}
\def \queue@gpop@NN #1#2{\queue@pop@aux@nnNN \gdef \def #1 #2
%<*trace>
  \trace@queue@internal{pop~ of~ queue~\string#1:~`\tlp@to@str@N #2'}
%</trace>
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\queue@gpop@cN}
%    \begin{macrocode}
\def \queue@gpop@cN #1{\expandafter\queue@gpop@NN\csname#1\endcsname}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\queue@empty@err@N}
%    \begin{macrocode}
\def\queue@empty@err@N #1{\ifx#1\@empty \ERROR \fi}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\queue@if@in@NnTF}
% \begin{macro}{\queue@if@in@NnF}
%    |\queue@if@in@NnTF| \m{queue}\m{item} \m{true~case} \m{false~case}
%    will check whether \m{item} is in \m{queue} and then either execute
%    the \m{true~case} or the \m{false~case}.
%    \begin{macrocode}
\def \queue@if@in@NnTF #1#2{
  \def \tmp@w
      ##1\queue@elt #2\queue@eelt ##2##3\q@stop{
%    \end{macrocode}
%    Note that |##2| contains exactly one token which we can compare
%    with |\q@no@value|.
%    \begin{macrocode}
        \ifx\q@no@value##2
          \expandafter\@secondoftwo
        \else
          \expandafter\@firstoftwo
        \fi
      }
  \expandafter
  \tmp@w #1\queue@elt #2\queue@eelt \q@no@value \q@stop}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def \queue@if@in@NnF #1#2{
  \def \tmp@w
      ##1\queue@elt #2\queue@eelt ##2##3\q@stop{
        \ifx\q@no@value##2
          \expandafter\@firstofone
        \else
          \expandafter\@gobble
        \fi
      }
  \expandafter
  \tmp@w #1\queue@elt #2\queue@eelt \q@no@value \q@stop}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
%
%
%
%
% \subsection {Quarks}
%
% A quark is a control sequence that expands into itself@ |\def|
% |\foo{\foo}|.  Quarks provide a cheap way of generating distinct
% constants.  Also, they permit the following ingenious trick: when
% you pick up a token in a temporary, and you want to know whether you
% have picked up a particular quark, all you have to do is compare the
% temporary to the quark using |\ifx|.
%
% \begin{macro}{\quark@new@N}
%    Allocate a new quark.
%    \begin{macrocode}
\def \quark@new@N #1{\def #1{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\q@stop}
% \begin{macro}{\q@no@value}
% \begin{macro}{\q@nil}
%    |\q@stop| is often used as a marker in parameter text,
%    |\q@no@value| is the canonical missing value, and |\q@nil|
%    represents a nil pointer in some data structures.
%    \begin{macrocode}
\quark@new@N \q@stop
\quark@new@N \q@no@value
\quark@new@N \q@nil
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\q@error}
% \begin{macro}{\q@mark}
%    We need two additional quarks.  |\q@error| delimits the end of
%    the computation for purposes of error recovery.  |\q@mark| is
%    used in parameter text when we need a scanning boundary that is
%    distinct from |\q@stop|.
%    \begin{macrocode}
\quark@new@N\q@error
\quark@new@N\q@mark
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\quark@if@no@value@NTF}
% \begin{macro}{\quark@if@no@value@NF}
% \begin{macro}{\quark@if@no@value@nTF}
% \begin{macro}{\quark@if@no@value@nT}
% \begin{macro}{\quark@if@no@value@nF}
%    Here we test if we found a special quark as the first argument.
%    The argument might contain an arbitrary list of tokens, therefore
%    we have to wrap it up in a token list pointer.
%    \begin{macrocode}
\def \quark@if@no@value@NTF #1{
%    \end{macrocode}
%    We better start with |\q@no@value| as the first argument since
%    the whole thing may otherwise loop if |#1| is wrongly given
%    a string like |aabc| instead of a single token.\footnote{It may
%    still loop in special circumstances however!}
%    \begin{macrocode}
     \ifx\q@no@value#1
          \expandafter\@firstoftwo
     \else \expandafter\@secondoftwo \fi}
%    \end{macrocode}
%    It would be possible to speed up the following commands by
%    providing individual implementations similar to the one above.
%    Should perhaps be done if they are used often!
%    \begin{macrocode}
\def \quark@if@no@value@NF #1{\quark@if@no@value@NTF {#1}\@empty}
\def \quark@if@no@value@nTF #1{\gdef \@gtempa {#1}
    \quark@if@no@value@NTF\@gtempa}
\def \quark@if@no@value@nF #1{\quark@if@no@value@nTF {#1}\@empty}
\def \quark@if@no@value@nT #1#2{\quark@if@no@value@nTF {#1}
        {#2}\@empty}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\quark@if@nil@NTF}
%    A function to check for the presence of |\q@nil|.
%    \begin{macrocode}
\def\quark@if@nil@NTF#1{
  \ifx#1\q@nil
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo\fi}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection{Commands for manipulating property lists}
%
%
% \begin{macro}{\prop@new@N}    
% \begin{macro}{\prop@new@c}    
%    \begin{macrocode}
\let \prop@new@N \queue@new@N
\let \prop@new@c \queue@new@c
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
\let \prop@clear@N \queue@clear@N
\let \prop@gclear@N \queue@gclear@N
%    \end{macrocode}
%
% \begin{macro}{\prop@put@NNn}    
% \begin{macro}{\prop@gput@NNn}    
% \begin{macro}{\prop@gput@NNo}    
% \begin{macro}{\prop@gput@cNn}    
% \begin{macro}{\prop@gput@cco}    
% \begin{macro}{\prop@gput@ccn}    
%    \begin{macrocode}
\long\def \prop@put@NNn #1#2{\prop@split@aux@NNn
                             #1#2{\prop@put@aux@w {\def #1}#2}}
\long\def \prop@gput@NNn #1#2{\prop@split@aux@NNn
                                #1#2{\prop@put@aux@w {\gdef #1}#2}}
%  missing commands for galley stuff...
\def \prop@gput@NNo #1#2#3{
  \expandafter\prop@gput@NNn \expandafter #1 \expandafter 
                          #2 \expandafter { #3 } }
\def \prop@gput@cNn #1{
  \expandafter\prop@gput@NNn \csname #1\endcsname
}
\def \prop@gput@cco #1#2#3{
  \expandafter\prop@gput@NNn \csname #1\expandafter\endcsname
                             \csname #2\expandafter\endcsname
                             \expandafter { #3 } }
\def \prop@gput@ccn #1#2{
  \expandafter\prop@gput@NNn \csname #1\expandafter\endcsname
                             \csname #2\endcsname
                              }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\prop@put@aux@w}    
%    \begin{macrocode}
\long\def \prop@put@aux@w #1#2#3#4#5#6{
  \quark@if@no@value@nTF {#4}
    {#1{#2{#6}#3}}
    {\def\tmp@w ##1#2\q@no@value {#1{#3#2{#6}##1}}
     \tmp@w #5}}
%    \end{macrocode}
% \end{macro}
%    
% \begin{macro}{\prop@split@aux@NNn}    
%    \begin{macrocode}
\long\def \prop@split@aux@NNn #1#2#3{
  \def\tmp@w ##1#2##2##3\q@stop {#3{##1}{##2}{##3}}
%                                       ^   ^ needed!
  \expandafter\tmp@w #1#2\q@no@value \q@stop}
%    \end{macrocode}
% \end{macro}
%    
%
% \begin{macro}{\prop@get@NNN}    
% \begin{macro}{\prop@get@cNN}    
% \begin{macro}{\prop@gget@NNN}    
%    \begin{macrocode}
\long\def \prop@get@NNN #1#2{\prop@split@aux@NNn
                                    #1#2\prop@get@aux@w}
\def \prop@get@cNN #1{
  \expandafter\prop@get@NNN \csname #1\endcsname
}
\def \prop@gget@NNN {\global\prop@get@NNN}
%    \end{macrocode}
% \end{macro}
%    
%
% \begin{macro}{\prop@get@aux@w}    
%    \begin{macrocode}
\long\def \prop@get@aux@w #1#2#3#4{\def#4{#2}}
%    \end{macrocode}
% \end{macro}
%    
%
% \begin{macro}{\prop@map@funct@Nn}    
%    \begin{macrocode}
\let \prop@map@funct@Nn \@gobbletwo
%    \end{macrocode}
% \end{macro}
%    
%
% \begin{macro}{\prop@map@NN}    
%    \begin{macrocode}
\def \prop@map@NN #1#2{
  \let \prop@map@funct@Nn #2
  \expandafter\prop@map@aux@w #1\q@stop \q@stop}
%    \end{macrocode}
% \end{macro}
%    
%
% \begin{macro}{\prop@map@aux@w}    
%    \begin{macrocode}
\def \prop@map@aux@w #1#2{
  \ifx #1\q@stop \else
    \prop@map@funct@Nn #1{#2}
    \expandafter\prop@map@aux@w
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\prop@map@cN}    
%    \begin{macrocode}
\def \prop@map@cN #1{
  \expandafter \prop@map@NN \csname #1\endcsname }
%    \end{macrocode}
% \end{macro}
%
%
%
%
