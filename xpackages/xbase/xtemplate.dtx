 % \iffalse
%% File: xtemplate.dtx (C) Copyright 1999-2001 David Carlisle, Frank Mittelbach
%%                     (C) Copyright 2004-2009 Frank Mittelbach, LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%1	
%% This file is part of the ``xbase bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%% 
%
%<*driver|package>
\RequirePackage{l3names}
%</driver|package>
%\fi
\GetIdInfo$Id$
  {Prototype document functions}
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass[full]{l3doc}
\ExplSyntaxOn
% SYNTAX environments getting ugly. This helps:
\cs_if_exist:NT \g_doc_syntax_dim {
  \dim_set:Nn \g_doc_syntax_dim {\textwidth}
}
\ExplSyntaxOff
\usepackage{booktabs}
\begin{document}
  \DocInput{xtemplate.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{xtemplate} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{\Team}
% \date{\filedate}
% \maketitle
%
% \begin{documentation}
%
% \section{Introduction}
%
% There are three broad `layers' between putting down ideas into a source file
% and ending up with a typeset document. These layers of document writing are:
% \begin{enumerate}
% \item Authoring of the text, with mark-up
% \item Document layout design
% \item Implementation (with \TeX\ programming) of the design
% \end{enumerate}
% We write the text as an author, and we see the visual output of the design
% after the document is generated; the \TeX\ implementation in the middle is
% the glue between the two.
%
% \LaTeX's greatest success has been to standardise a system of mark-up that
% balances the trade-off between ease of reading and ease of writing to suit
% almost all forms of technical writing. It's
% other original strength was a good background in typographical design; while
% the standard \LaTeXe\ classes look somewhat dated now in terms of their
% visual design, their typography is generally sound. (Barring the occasional
% minor faults.)
%
% However, \LaTeXe\ has always lacked a standard approach to customising
% the visual design of a document. Changing the looks of the standard classes
% involved either:
% \begin{itemize}
% \item Creating a new version of the implementation code of the class and
%       editing it.
% \item Loading one of the many packages to customise certain elements of
%       the standard classes.
% \item Loading a completely different document class, such as 
%       \textsf{KOMA-Script} or \textsf{memoir}, that allows easy 
%       customisation.
% \end{itemize}
% All three of these approaches have their drawbacks and learning curves.
%
% The idea behind \pkg{xtemplate} is to cleanly separate the three layers
% introduced at the beginning of this section, so that document authors who
% are not programmers can easily change the design of their documents.
% \pkg{xtemplate} also makes it easier for \LaTeX\ programmers to provide
% their own customisations on top of a pre-existing class.
%
% \section{What is a document?}
%
% Besides the textual content of the words themselves, the source file of a
% document contains mark-up elements that add structure to the document.
% These elements include sectional divisions, figure/table captions,
% lists of various sorts, theorems/proofs, and so on.
% The list will be different for every document that can be written.
%
% Each element can be represented logically without worrying about the
% formatting, with mark-up such as \cmd\section, \cmd\caption,
% \cmd\begin"{enumerate}" and so on.
% The output of each one of these document
% elements will be a typeset representation of the information marked up, and
% the visual arrangement and design of these elements can vary widely in
% producing a variety of desired outcomes.
%
% For each type of document element, there may be design variations that
% contain the same sort of information but present it in slightly different
% ways.
% For example, the difference between a numbered and an unnumbered
% section, \cmd\section\ and \cmd\section"*", or the difference between an
% itemised list or an enumerated list.
%
% There are three distinct layers in the definition of `a document' at this
% level:
% \begin{enumerate}
% \item Semantic elements such as the ideas of sections and lists.
% \item A set of design solutions for representing these elements visually.
% \item Specific variations for these designs that represent the elements in the document.
% \end{enumerate}
% In the parlance of the \pkg{xtemplate} package, we call these types, 
% templates, and instance, respectively, and they are discussed below in
% sections \ref{sec:types}, \ref{sec:templates}, and~\ref{sec:instances},
% respectively.
%
% \section {Types, templates, and instances}
%
% By formally declaring our document to be composed of mark-up elements
% grouped into types, which are interpreted and typeset with a set of
% templates, each of which has one more instance with which to compose each
% and every semantic unit of the text, we have achieved in cleanly separating
% the components of document construction.
% The \pkg{xtemplate} package provides the tools to do this.
%
% \subsection{Types}\label{sec:types}
%
% An object type is an abstract idea of a document element that takes a
% fixed number of arguments corresponding to the information from the
% document author that it is representing.
% A sectioning type, for example, might take three inputs: `title',
% `short title', and `label'.
%
% Any given document class will define which types are to be used in the
% document, and any template of a given type can be used to generate an
% instance for the type.
% (Of course, different templates will produce different typeset
% representations, but the underlying content will be the same.)
%
% \begin{function}{\DeclareObjectType}
% \begin{syntax}
%  "\DeclareObjectType" \Arg{name} \Arg{Nargs}
% \end{syntax}
% This function defines a \emph{object type},
% where \meta{name} is the name of the type and \meta{Nargs} is the number of
% arguments an instance of this type should take. For example,
% \begin{quote}
% \begin{verbatim}
% \DeclareObjectType{sectioning}{3}
% \end{verbatim}
% \end{quote}
% \end{function}
%
% \subsection{Templates}\label{sec:templates}
%
% A \emph{template} is a generalised design solution for representing the
% information of a specified \emph{object type}.
% Templates that do the same thing~--- e.g., two completely different ways of
% printing a chapter heading~--- are grouped together by their type and given
% separate names.
% There are two important parts to a template:
% \begin{itemize}
% \item The parameters it takes to vary the design it is producing.
% \item The implementation of the design.
% \end{itemize}
% As a document author or designer does not care about the implementation
% but rather only the interface to the template, these two aspects of the template
% definition are split into two independent declarations, \cmd\DeclareTemplateInterface\
% and \cmd\DeclareTemplateCode.
%
% \begin{function}{\DeclareTemplateInterface}
% \par
% \begin{syntax}
% "\DeclareTemplateInterface" \Arg{type} \Arg{template} \Arg{Nargs}
% "{"
% "   "<name of key 1> ":" <key type 1> ","
% "   "<name of key 2> ":" <key type 2> "=" <optional default> ","
% "    ..."
% "}"
% \end{syntax}
% The \meta{name of keys} can be any string of \textsc{ascii} characters;
% we recommend only using lower case letters and dashes, however.
% Note that spaces in key names are ignored, so that key names can be 
% spaced out for ease of reading without affecting the recognition of 
% keys inside and outside of code blocks.
%
% The <key types> define what sort of input the key accepts, such as `boolean',
% `integer', and so on. The complete list of possible <key types> is shown in
% \autoref{tab:keytypes}.
% \end{function}
%
% \begin{table}[p]
% \begin{tabular}{@{}ll@{}}
% \toprule
% Key Type & Description of input \\
% \midrule
% "boolean" & "true" or "false" \\
% "choice "\Arg{choices} & A list of pre-defined choices \\
% "code" & Generalised key type; use "#1" as the input to the key \\
% "commalist" & A comma-separated list of arbitrary items \\
% "function "$N$ & A function definition with $N$ arguments
%   ($N$ from $0$ to $9$) \\
% "instance "\Arg{name} & An instance of type \meta{name} \\
% "integer" & An integer expression (e.g., {\small "(1 + 5)/2"}) \\
% "length" & A dimension expression (e.g., {\small "3pt + 2cm"}) \\
% "skip" & A dimension expression with glue 
%   (e.g., {\small "3pt plus 2pt minus 1pt"}) \\
% "tokenlist" & A `token list' input; any text or commands \\
% \bottomrule
% \end{tabular}
% \caption{`Key types' for defining template interfaces with \cs{DeclareTemplateInterface}.}
% \label{tab:keytypes}
% \end{table}
%
% \begin{table}[p]
% \begin{tabular}{@{}lcl@{}}
% \toprule
% Key Type && Description of binding \\
% \midrule
% "boolean" &$\star$& Boolean variable; e.g., "\l_tmpa_bool" \\
% "choice" && "{" \meta{choice\,$_1$} "=" \meta{code\,$_1$} "," \meta{choice\,$_2$} "=" \meta{code\,$_2$} "," \dots "}" \\
% "code" && \meta{code} ; use "#1" as the input to the key \\
% "commalist" &$\star$& Comma-list variable; e.g., "\l_tmpa_clist" \\
% "function" &$\star$& Function w/ $N$ arguments; e.g., "\use_i:nn" \\
% "instance" &$\star$& An instance variable; e.g., "\g_foo_instance"  \\
% "integer" &$\star$& Integer variable; e.g., "\l_tmpa_int" \\
% "length" &$\star$& Dimension variable; e.g., "\l_tmpa_dim" \\
% "skip" &$\star$& Skip variable; e.g., "\l_tmpa_skip" \\
% "tokenlist" &$\star$& Token list variable; e.g., "\l_tmpa_tl" \\
% \bottomrule
% \end{tabular}
% \caption{Bindings required for different key types when defining template implementations with \cs{DeclareTemplateCode}. Starred entries may be prefixed with the keyword \texttt{global} to make a global assignment.}
% \label{tab:keyvariables}
% \end{table}
%
% \begin{function}{\DeclareTemplateCode}
% \par
% \begin{syntax}
% "\DeclareTemplateCode" \Arg{type} \Arg{template} \Arg{Nargs}
% "{"
% "   "<name of key 1> "=" <internal variable or code 1> ","
% "   "<name of key 2> "=" <internal variable or code 2> ","
% "    ..."
% "}{"
% "   "\meta{implementation code}
% "   \DoParameterAssignments"
% "   "\meta{more implementation code}
% "}"
% \end{syntax}
% After the keys have been declared with "\DeclareTemplateInterface", the
% implementation binds each <name of key> with an <internal variable>
% (for key types such as `integer', `length', `tokenlist', etc.)
% or with a certain <code> fragment to execute, which will be described below.
%
% Assignments to variables which should be made globally are indicated by adding the
% word \texttt{global} before the variable name:
%
% \begin{syntax}
% "   "<name of key 1> "="        <internal variable 1> ","
% "   "<name of key 2> "=" global <internal variable 2> ","
% \end{syntax}
%
% The key types "choices" and "code" do not take variable bindings; instead,
% fragments of code are defined which are executed instead. The complete list
% of bindings taken by different key types is shown in \autoref{tab:keyvariables}.
% The "choices" key type is explained fully in \autoref{sec:choices-key} below.
%
% \begin{function}{\DoParameterAssignments}
% \par
% The final argument of \cs{DeclareTemplateCode} contains the <implementation code>
% for the template design, taking arguments |#1|, |#2|, etc.\ according to the number of
% arguments allowed, <Nargs>. \cs{DoParameterAssignments} must be
% executed in order to assign variables and perform code executions according
% to the keys set.
% \end{function}
% \end{function}
%
% \subsection{Multiple choices}
% \label{sec:choices-key}
% 
% The \texttt{choice} keytype implements multiple choice input. At the 
% interface level, only the list of valid choices is needed:
% \begin{verbatim}
% \DeclareTemplateInterface { foo } { bar } 0 {
%   key-name : choice { A,B,C }
% }
% \end{verbatim}
% where the choices are given as a comma-list (which must therefore
% be wrapped in braces). A default value can also be given:
% \begin{verbatim}
% \DeclareTemplateInterface { foo } { bar } 0 {
%   key-name : choice { A,B,C } = A
% }
% \end{verbatim}
% 
% At the implementation level, each choice is associated with code, 
% using a nested key--value list.
% \begin{verbatim}
% \DeclareTemplateCode { foo } { bar } 0 {
%   key-name = {
%     A = Code-A ,
%     B = Code-B ,
%     C = Code-C ,
%   }
% } { ... }
% \end{verbatim}
% The two choice lists should match, but in the implementation a
% special \texttt{unknown} choice is also available. This can be used 
% to ignore values and implement an `else' branch:
% \begin{verbatim}
% \DeclareTemplateCode { foo } { bar } 0 {
%   key-name = {
%     A       = Code-A ,
%     B       = Code-B ,
%     C       = Code-C ,
%     unknown = Else-code
%   }
% } { ... }
% \end{verbatim}
% The \texttt{unknown} entry must be the last one given, and should
% \emph{not} be listed in the interface part of of the template.
%
% \subsection{Instances}\label{sec:instances}
%
% After a template is defined it still needs to be put to use.
% The parameters that it expects need to be defined before it can be used in
% a document.
% Every time a template has parameters given to it, an \emph{instance} is
% created, and this is the code that ends up in the document to perform the
% typesetting of whatever pieces of information are input into it.
%
% For example, a template might say `here is a section with or without a
% number that might be centred or left aligned and print its contents in a
% certain font of a certain size, with a bit of a gap before and after it'
% whereas an instance declares `the section has a number, is centred, is set
% in 12pt italic with a 10pt skip before and a 12pt skip after it'.
%
% Therefore, an instance is just a frozen version of a template with specific
% settings as chosen by the designer.
%
% \begin{function}{\DeclareInstance}
% \par
% \begin{syntax}
% "\DeclareInstance" \Arg{type} \Arg{template} \Arg{instance} \Arg{parameters}
% \end{syntax}
% The name of the instance being declared is <instance>, with <parameters>
% the keyval input to set some or all of the <template> keys to specific values.
%
% Here is a hypothetical example:
% \begin{quote}
% \begin{verbatim}
% \DeclareInstance{sectioning}{section-num}{basic} {
%        numbered = true ,
%   justification = center ,
%            font = \normalsize\itshape ,
%     before-skip = 10pt ,
%      after-skip = 12pt ,
% }
% \end{verbatim}
% \end{quote}
% \end{function}
%
%
% \subsection{Document interface}
%
% After the instances have been chosen, document commands must be declared to
% use those instances in the document. \cmd\UseInstance\ calls instances directly,
% and this command should be used internally in document-level mark-up.
%
% \begin{function}{\UseInstance}
% \par
% \begin{syntax}
% "\UseInstance" \Arg{type} \Arg{instance} <arguments>
% \end{syntax}
% \end{function}
%
% It will take as many arguments as were defined for the object type.
%
% Use \textsf{xparse} to declare the document commands in terms of instances.
% Another hypothetical example:
% \begin{quote}
% \begin{verbatim}
% \DeclareDocumentCommand\section{ som }{
%   \IfBooleanTF #1
%   {
%     \UseInstance{sectioning}{section-nonum}{#2}{#3}
%   }
%   {
%     \UseInstance{sectioning}{section-num}{#2}{#3}
%   }
% }
% \end{verbatim}
% \end{quote}
% 
% \begin{function}{\UseTemplate}
% \par
% \begin{syntax}
% "\UseTemplate" \Arg{type} \Arg{template} \Arg{settings} <arguments>
% \end{syntax}
% There are occasions where creating an instance of a template does not
% make sense, as it will only be used once. In this case, templates can
% be used directly, with the key settings given as an argument to the
% \cs{UseTemplate} function. This will also work when giving an argument
% to a key which needs an instance. For example, if we have an key
% \texttt{instance-key} which expects an instance of \texttt{object2},
% then we can either declare an instance:
% \begin{quote}
% \begin{verbatim}
% \DeclareInstance {object2} {template2} {temp-instance} {
%   <settings>
% }
% \DeclareInstance {object} {template} {instance} {
%   instance-key = temp-instance
% }
% \end{verbatim}
% \end{quote} 
% or use the template directly:
% \begin{quote}
% \begin{verbatim}
% \DeclareInstance {object} {template} {instance} {
%   instance-key = \UseTemplate {object2} {template2} {<settings>}
% }
% \end{verbatim}
% \end{quote} 
% Which is the best approach will depend on the exact nature of the
% situation.
% \end{function}
%
% \subsection{Summaries}
%
% For the document designer:
% \begin{itemize}
% \item The class will define which types are used in a document.
% \item The class will define user commands that contain the required
% instances that the document must use.
% \item Having knowledge of a variety of suitable templates, for each
% required instance a template can be selected and instantiated based on the
% parameters defined by \cmd\DeclareTemplateInterface.
% \end{itemize}
%
% For the class programmer:
% \begin{itemize}
% \item Define the different types of document elements: what the semantics
% are and what information is required.
% \item Create document commands to call instances that fulfil the needs of
% the types.
% \item Implement the required templates to produce typeset implementations
% of the document elements and instantiate them with the appropriate names.
% \end{itemize}
%
% \section{Instances in different contexts}
%
% We may wish the behaviour of an instance to change as it is used in varying contexts.
% For example, in the frontmatter of a document, section numbering is
% different. Semantics are the same, but the typesetting changes. But we want
% to use the same user commands, and hence the same instance names.
%
% \emph{Collections} allow us to define multiple instances that we can switch
% between. Collections are activated with \cmd\UseCollection.
%
% \begin{function}{\DeclareCollectionInstance}
%
% \begin{syntax}
% "\DeclareCollectionInstance" \Arg{collection} \Arg{type} \Arg{instance} \Arg{template}\\\hfill \Arg{parameters}
% \end{syntax}
% \end{function}
%
% \begin{function}{\UseCollection}
% \begin{syntax}
% "\UseCollection" \Arg{type} \Arg{collection}
% \end{syntax}
% \end{function}
%
% The instance declared will override another instance of the same name when
% the collection is active. Note that a collection instance can only be declared if
% the \emph{original} instance already exists.
%
% An example might be:
% \begin{verbatim}
% \UseCollection{sectioning}{frontmatter}
% \section{Nomenclature}
% ...
% \UseCollection{sectioning}{default}
% \section{Introduction}
% \end{verbatim}
% In both cases, the same instance (perhaps `"section-num"') is being used inside
% the \cs{section}. But \cs{DeclareCollectionInstance} will have been used for
% the `"frontmatter"' and override the instance that is used in the default case.
%
% \section{Bits 'n' pieces}
%
% \subsection{Does an instance exist?}
%
% \begin{function}{\IfInstanceExist / (TF)}
%
% \begin{syntax}
% "\IfInstanceExistTF" \Arg{type} \Arg{instance} \Arg{true code} \Arg{false code}
% "\IfInstanceExistT" \Arg{type} \Arg{instance} \Arg{true code}
% "\IfInstanceExistF" \Arg{type} \Arg{instance} \Arg{false code}
% \end{syntax}
% Test if <instance> has been declared. This is useful when the use of an instance
% depends on some global variable, such as the current font selection. Designers
% or users can then implement specific designs for exact situations rather than
% relying on blanket parameter redefinitions. See \pkg{xfrac} for a good example of this.
% \end{function}
%
% \subsection{Template defaults}
%
% Template parameters may be assigned specific defaults for instances to use
% if the instance declaration doesn't explicit set those parameters.
% In some cases, the document designer will wish to edit these defaults to
% allow them to "cascade" to the instances.
% The alternative would be to set each parameter identically for each
% instance declaration, a tedious and error-prone process.
% \begin{function}{\EditTemplateDefaults}
%
% \begin{syntax}
% "\EditTemplateDefaults" \Arg{type} \Arg{template} \Arg{new defaults}
% \end{syntax}
% \end{function}
%
% This command only takes effect for instances that have not yet been declared.
% Use "\EditInstance" if you wish to change an instance that already exists.
%
% \subsection{Small changes to an instance}
%
% When a designer creates an instance but the user wishes to slightly tweak
% it, it is convenient to not have to reset all of the (possibly many)
% parameters defining that instance and only override the specific parameter
% that should be changed.
% \begin{function}{\EditInstance}
%
% \begin{syntax}
% "\EditInstance" \Arg{type} \Arg{instance }\Arg{template} \Arg{new parameters}
% \end{syntax}
% \end{function}
%
% Collection instances may also be edited.
% \begin{function}{\EditCollectionInstance}
%
% \begin{syntax}
% "\EditCollectionInstance" \Arg{type} \Arg{collection} \Arg{instance}\\\hfill \Arg{template} \Arg{new parameters}
% \end{syntax}
% \end{function}
%
% \subsection{Parameters evaluated now}
% 
% \begin{function}{\EvaluateNow}
% \begin{syntax}
% "\EvaluteNow" \Arg{expression}
% \end{syntax}
% The standard method when creating an instance from a template is to
% evaluate the <expression> when the instance is used. However, it may
% be desirable to calculate the value when declared, which can be
% forced using \cs{EvaluateNow}. Currently, this functionality is
% regarded as experimental: the team have not found an example where it
% is actually needed, and so it may be dropped \emph{if} no good 
% examples are suggested! 
% \end{function}
%
%
% \subsection{Setting one key to the value of another}
%
% It is often useful to use the value of one key as the default for another.
% \begin{function}{\KeyValue}
% \begin{syntax}
% "\KeyValue" \Arg{key name}
% \end{syntax}
% This command is used as the argument to an instance key; it will set that
% key to the value of <key name> each time the instance is executed at run-time.
% Using \cs{KeyValue} means that the designer does not need to know
% how a particular key has been implemented.
% \end{function}
%
% \subsection{When template parameters should be frozen}
%
% A class designer may be inheriting templates declared by someone else,
% either third-party code or the \LaTeX\ kernel itself. Sometimes these
% templates will be overly general for the purposes of the document. The user
% should be able to customise parts of the template instances, but otherwise
% be restricted to only those parameters allowed by the designer.
%
% "\DeclareRestrictedTemplate" creates a derived version of a template for
% which certain parameters are frozen as specified but the remaining parameters are
% available to be set as usual in an instance declaration.
%
% \begin{function}{\DeclareRestrictedTemplate}
% \par
% \begin{syntax}
% |\DeclareRestrictedTemplate| \Arg{type} \Arg{parent} \Arg{new template} \Arg{frozen parameters}
% \end{syntax}
% Defines <new template> based on template <parent> (of certain <type>)
% with certain keys set and frozen as defined in <keyvals>.
% \end{function}
%
% \section{Getting information about templates and instances}
%
% \begin{function}{
%   \ShowTemplateCode      |
%   \ShowTemplateDefaults  |
%   \ShowTemplateKeytypes  |
%   \ShowTemplateVariables }
%
% \begin{syntax}
% "\ShowTemplateCode" \Arg{type} \Arg{template}
% \end{syntax}
% These functions pause the typesetting and display
% in the console the various pieces of information for a template.
% \end{function}
%
% \begin{function}{ \ShowInstanceValues | \ShowCollectionInstanceValues }
%
% \begin{syntax}
% "\ShowInstanceValues" \Arg{type} \Arg{instance}
% "\ShowCollectionInstanceValues" \Arg{type} \Arg{collection} \Arg{instance}
% \end{syntax}
% These functions pause the typesetting and display in the console
% information about an instance or a collection instance.
% \end{function}
%
% \section{Examples}
%
% (Nothing here yet.)
% 
%\section{Code documentation}
%
%\subsection{Variables and constants}
%
%\begin{variable}{
%  \c_xtemplate_code_root_tl      |
%  \c_xtemplate_defaults_root_tl  |
%  \c_xtemplate_instances_root_tl |
%  \c_xtemplate_keytypes_root_tl  |
%  \c_xtemplate_restrict_root_tl  |
%  \c_xtemplate_values_root_tl    |
%  \c_xtemplate_vars_root_tl      |
%}
% A number of pieces of code and lists of properties have to be stored
% for templates and instances. The various csname roots are set up as
% token lists to avoid use of the literal text in the code.
%\end{variable}
%
%\begin{variable}{\c_xtemplate_key_order_tl}
% The order keys are declared in must be stored (as property lists 
% have no `order'). The special property used is named here.
%\end{variable}
%
%\begin{variable}{\c_xtemplate_keytypes_arg_clist}
% Some keytypes (such as \texttt{instance}) need additional 
% information, given as an argument. The list of keytypes that need this
% extra data is set up here, for later use when splitting things.
%\end{variable}
%
%\begin{variable}{\l_xtemplate_assignments_toks}
% This token register is used in two places. First, it is where the
% list of assignments for an instance is constructed during 
% \cs{DeclareInstance}. Second, it is where these are copied to to
% allow \cs{DoParameterAssignments} to work correctly.
%\end{variable}
%
%\begin{variable}{\l_xtemplate_collection_tl}
% The name of the current instance collection active. If no collection
% is in use, this will simply be empty.
%\end{variable}
%
%\begin{variable}{\l_xtemplate_collections_prop}
% Records the collection in force for each object type.
%\end{variable}
%
%\begin{variable}{
%  \l_xtemplate_default_tl     |
%  \l_xtemplate_key_name_tl    |
%  \l_xtemplate_keytype_tl     |
%  \l_xtemplate_keytype_arg_tl |
%  \l_xtemplate_value_tl       |
%  \l_xtemplate_var_tl         |
%}
% When processing keys, various properties for the current key need to
% be available. These are copied from the property list to appropriately
% named token lists, and back again, as needed.
%\end{variable}
%
%\begin{variable}{\l_xtemplate_error_bool}
% Used to indicate an error when parsing a key list, so that further
% processing can be abandoned.
%\end{variable}
%
%\begin{variable}{\l_xtemplate_global_bool}
% When actually assigning data to variables, a check is made to see
% if this should be global. The flag here is used to indicate this.
%\end{variable}
%
%\begin{variable}{\l_xtemplate_key_seq}
% The order in which keys are defined is stored here for later
% recovery and use. It is transferred into the property list for the
% template when the template is saved.
%\end{variable}
%
%\begin{variable}{\l_xtemplate_restrict_bool}
% Flag used when editing templates, so that simple editing and
% restricting can share the same underlying editing method.
%\end{variable}
%
%\begin{variable}{
%  \l_xtemplate_restricted_clist |
%  \l_xtemplate_keytypes_prop    |
%  \l_xtemplate_values_prop      |
%  \l_xtemplate_vars_prop        |
%}
% To avoid needing to refer to the data about a template or instance
% by csname in a large number of locations, the data is copied to these
% scratch variables and back again for processing. This makes the code
% easier to follow.
%\end{variable}
%
%\begin{variable}{
%  \l_xtemplate_tmp_clist |
%  \l_xtemplate_tmp_dim   |
%  \l_xtemplate_tmp_int   |
%  \l_xtemplate_tmp_skip  |
%  \l_xtemplate_tmp_tl    |
%}
% Used when carrying out assignments, as the pre-processing can take
% place here before passing data through to the storage area defined
% by the implementation part of a template. The token list is also used
% for general scratch purposes by \pkg{xtemplate}.
%\end{variable}
%
%\begin{variable}{\l_xtemplate_object_type_prop}
% For tracking which object types have been declared, and the number
% of arguments each requires.
%\end{variable}
%
%\begin{variable}{\l_xtemplate_restrict_bool}
% Flag used when editing templates, so that simple editing and
% restricting can share the same underlying editing method.
%\end{variable}
%
%\subsection{Utility functions}
%
%\begin{function}{
%  \xtemplate_if_key_value:nT /  (EXP) |
%  \xtemplate_if_key_value:VT /  (EXP)
%}
%  \begin{syntax}
%    "\xtemplate_if_key_value:nT"  \marg{tokens} \marg{true code}
%  \end{syntax}
%  Tests if the first token in <tokens> is \cs{KeyValue}.
%\end{function}
%
%\begin{function}{
%  \xtemplate_if_arg_agreement:nNTF |
%  \xtemplate_if_arg_agreement:nVTF
%}  
%  \begin{syntax}
%    "\xtemplate_if_arg_agreement:nNTF" \marg{type} <num> 
%    ~~~~\marg{true code} \marg{false code}
%  \end{syntax}
%  Tests if the number of arguments required by <type> is equal
%  to <num>, then executes either <true code> or <false code> as
%  appropriate.
%\end{function}
%
%\begin{function}{\xtemplate_if_eval_now:nTF /  (EXP)}
%  \begin{syntax}
%    "\xtemplate_if_eval_now:nTF"  \marg{tokens} 
%    ~~~~\marg{true code} \marg{false code}
%  \end{syntax}
%  Tests if the first token in <tokens> is a marker for evaluating
%  now (\cs{EvaluateNow}).
%\end{function}
%
%\begin{function}{\xtemplate_if_instance_exist:nnn / (TF) (EXP)}
%  \begin{syntax}
%    "\xtemplate_if_instance_exist:nnnTF"  \marg{type}
%    ~~~~\marg{collection} \marg{instance} \marg{true code} 
%        \marg{false code}
%  \end{syntax}
%  Tests if <instance> of <type> exists for the <collection> given.
%\end{function}
%
%\begin{function}{\xtemplate_if_keys_exist:nnTF / (EXP)}
%  \begin{syntax}
%    "\xtemplate_if_keys_exist:nnTF"  \marg{type} \marg{template}
%    ~~~~\marg{true code} \marg{false code}
%  \end{syntax}
%  Tests if keys for <template> of <type> have been declared (but
%  not necessarily given an implementation).
%\end{function}
%
%\begin{function}{
%  \xtemplate_if_keytype_exist:nTF / (EXP) |
%  \xtemplate_if_keytype_exist:VTF / (EXP) |
%}
%  \begin{syntax}
%    "\xtemplate_if_keytype_exist:nTF"  \marg{keytype}
%    ~~~~\marg{true code} \marg{false code}
%  \end{syntax}
%  Tests if <keytype> is a known keytype.
%\end{function}
%
%\begin{function}{\xtemplate_if_template_exist:nnTF / (EXP)}
%  \begin{syntax}
%    "\xtemplate_if_template_exist:nnTF"  \marg{type} \marg{template}
%    ~~~~\marg{true code} \marg{false code}
%  \end{syntax}
%  Tests if <template> of <type> has been defined (i.e., the code has 
%  been created for an implementation).
%\end{function}
%
%\begin{function}{\xtemplate_if_type_exist:nTF / (EXP)}
%  \begin{syntax}
%    "\xtemplate_if_type_exist:nTF"  \marg{type}
%    ~~~~\marg{true code} \marg{false code}
%  \end{syntax}
%  Tests if template <type> has been created.
%\end{function}
%
%\begin{function}{\xtemplate_if_use_template:nTF / (EXP)}
%  \begin{syntax}
%    "\xtemplate_if_use_template:nTF"  \marg{assignment}
%    ~~~~\marg{true code} \marg{false code}
%  \end{syntax}
%  Tests if {assignment} begins with \cs{UseTemplate}.
%\end{function}
%
%\begin{function}{
%  \xtemplate_store_defaults:n     |
%  \xtemplate_store_keytypes:n     |
%  \xtemplate_store_restrictions:n |
%  \xtemplate_store_values:n       |
%  \xtemplate_store_vars:n         |
%}
%  \begin{syntax}
%    "\xtemplate_store_defaults:n" \marg{full name}
%  \end{syntax}
%  These functions copy information about the current template or
%  instance from the scratch variables to those for storing the 
%  information. The <full name> of the instance or template is needed:
%  this includes the <type> and <collection> (if applicable).
%\end{function}
%
%\begin{function}{
%  \xtemplate_recover_defaults:n     |
%  \xtemplate_recover_keytypes:n     |
%  \xtemplate_recover_restrictions:n |
%  \xtemplate_recover_values:n       |
%  \xtemplate_recover_vars:n         |
%}
%  \begin{syntax}
%    "\xtemplate_recover_defaults:n" \marg{full name}
%  \end{syntax}
%  The reverse of the \texttt{store} functions, these functions copy
%  data from the storage areas to the scratch variables for use in the
%  module. Again, the <full name> is needed, including the <type>.
%\end{function}
%
%\subsection{Creating object types}
%
%\begin{function}{\xtemplate_declare_object_type:nn}
%  \begin{syntax}
%    "\xtemplate_declare_object_type:nn" \marg{type} \marg{num}
%  \end{syntax}
%  Declares <type> of object, to accept <num> arguments.
%\end{function}
%
%\subsection{Declaring template keys}
%
%\begin{function}{\xtemplate_declare_template_keys:nnnn}
%  \begin{syntax}
%    "\xtemplate_declare_template_keys:nnnn" \marg{type}
%    ~~~~\marg{template} \marg{num} \marg{keyvals}
%  \end{syntax}
%  Declares <template> of <type>, and accepting <num> arguments, with
%  key types and default values defined by <keyvals>.
%\end{function}
%
%\begin{function}{
%  \xtemplate_parse_keys_elt:n  |
%  \xtemplate_parse_keys_elt:nn
%}
%  \begin{syntax}
%    "\xtemplate_parse_keys_elt:nn" \marg{key} \marg{value}
%  \end{syntax}
%  Functions used to process each key--value pair when declaring
%  keys from <keyvals>.
%\end{function}
%
%\begin{function}{\xtemplate_split_keytype:n}
%  \begin{syntax}
%    "\xtemplate_split_keytype:n" \marg{key}
%  \end{syntax}
%  Splits a <key> into a key name (stored as \cs{l_xtemplate_key_tl})
%  and a keytype (stored as \cs{l_xtemplate_keytype_tl}).
%\end{function}
%
%\begin{function}{
%  \xtemplate_split_keytype_arg:n |
%  \xtemplate_split_keytype_arg:V
%}
%  \begin{syntax}
%    "\xtemplate_split_keytype_arg:n" \marg{keytype}
%  \end{syntax}
%  Splits a <keytype> into the type itself and any optional qualifying
%  text. The results are stored in \cs{l_xtemplate_keytype_tl} and
%  \cs{l_xtemplate_keytype_arg_tl}.
%\end{function}
%
%\subsection{Storing defaults and values}
%
%\begin{function}{
%  \xtemplate_store_value_boolean:n   |
%  \xtemplate_store_value_choice:n    |
%  \xtemplate_store_value_choice:V    |
%  \xtemplate_store_value_code:n      |
%  \xtemplate_store_value_commalist:n |
%  \xtemplate_store_value_function:n  |
%  \xtemplate_store_value_function:n  |
%  \xtemplate_store_value_instance:n  |
%  \xtemplate_store_value_tokenlist:n |
%  \xtemplate_store_value_integer:n   |
%  \xtemplate_store_value_length:n    |
%  \xtemplate_store_value_skip:n      |
%}
%  \begin{syntax}
%    "\xtemplate_store_value_boolean:n" \marg{value}
%  \end{syntax}
%  Store values of the given keytype for later assignment to variables.
%  For the numeric and Boolean data types, the value is evaluated 
%  at this stage unless \cs{DelayEvaluation} or \cs{KeyValue} are
%  used in the <value>.
%\end{function}
%
%\begin{function}{\xtemplate_store_value_choice_name:n}
%  \begin{syntax}
%    "\xtemplate_store_value_choice_name:n" \marg{value}
%  \end{syntax}
%  Stores the name of a choice for a multiple choice key, which will
%  be turned into an implementation when code is available.
%\end{function}
%
%\subsection{Implementing templates}
%
%\begin{function}{\xtemplate_declare_template_code:nnnnn}
%  \begin{syntax}
%    "\xtemplate_declare_template_code:nnNnn" \marg{type}
%    ~~~~\marg{template} \marg{num} \marg{keyvals} \marg{code}
%  \end{syntax}
%  Declares implementation of <template> of <type>, and accepting <num>
%  arguments, with keys implemented as listed in <keyvals> and with
%  <code> to be executed when the <template> is used.
%\end{function}
%
%\begin{function}{\xtemplate_store_key_implementation:nnn}
%  \begin{syntax}
%    "\xtemplate_store_key_implementation:nnn" \marg{type}
%    ~~~~\marg{template} \marg{keyvals}
%  \end{syntax}
%  Stores the implementation for keys as specified in <keyvals> for
%  a <template> of <type>.
%\end{function}
%
%\begin{function}{
%  \xtemplate_parse_vars_elt:n  |
%  \xtemplate_parse_vars_elt:nn
%}
%  \begin{syntax}
%    "\xtemplate_parse_vars_elt:nn" \marg{key} \marg{variable}
%  \end{syntax}
%  Used by the key--value parser to assign a <variable> for each
%  <key> listed.
%\end{function}
%
%
%\begin{function}{\xtemplate_store_key_implementation:nnn}
%  \begin{syntax}
%    "\xtemplate_store_key_implementation:nnn" \marg{type}
%    ~~~~\marg{template} \marg{keyvals}
%  \end{syntax}
%  Stores the implementation for keys as specified in <keyvals> for
%  a <template> of <type>.
%\end{function}
%
%\begin{function}{\xtemplate_implement_choices:n}
%  \begin{syntax}
%    "\xtemplate_implement_choices:n" {key--value list}
%  \end{syntax}
%  Master function for turning <key-value lsit> into a set of choices.
%\end{function}

%
%\begin{function}{
%  \xtemplate_implement_choice_elt:n  |
%  \xtemplate_implement_choice_elt:nn
%}
%  \begin{syntax}
%    "\xtemplate_implement_choice_elt:nn" \marg{choice} \marg{code}
%  \end{syntax}
%  Used by the key--value parser to convert a key--value list of 
%  choices and code into working multiple choice values.
%\end{function}
%
%\subsection{Modifying templates}
%
%\begin{function}{\xtemplate_declare_restricted:nnnn}
%  \begin{syntax}
%    "\xtemplate_declare_restricted:nnnn" \marg{type} \marg{parent}
%    ~~~~\marg{restricted} \marg{keyvals}
%  \end{syntax}
%  Creates <restricted> template of <type> based on <parent> by fixing
%  values as listed in <keyvals>.
%\end{function}
%
%\begin{function}{\xtemplate_edit_defaults:nnn}
%  \begin{syntax}
%    "\xtemplate_edit_defaults:nnn" \marg{type} \marg{template}
%    ~~~~\marg{keyvals}
%  \end{syntax}
%  Modifies the default values for <template> of <type> as instructed
%  in <keyvals>.
%\end{function}
%
%\begin{function}{\xtemplate_parse_values:nn}
%  \begin{syntax}
%    "\xtemplate_parse_values:nn" \marg{name} \marg{keyvals}
%  \end{syntax}
%  Parses <keyvals> for full <name>, finding the value for each key
%  and storing it for later assignment.
%\end{function}
%
%\begin{function}{
%  \xtemplate_parse_values_elt:n  |
%  \xtemplate_parse_values_elt:nn
%}
%  \begin{syntax}
%    "\xtemplate_parse_values_elt:nn" \marg{key} \marg{variable}
%  \end{syntax}
%  Used by the key--value parser to find <value> to assing to 
%  implementation of <key>.
%\end{function}
%
%\begin{function}{\xtemplate_set_template_eq:nn}
%  \begin{syntax}
%    "\xtemplate_set_template_eq:nn" \marg{copy} \marg{parent}
%  \end{syntax}
%  Copies all of <parent> template to the <copy>, where both are full
%  names (i.e., a template plus type).
%\end{function}
%
%\subsection{Creating instances}
%
%\begin{function}{\xtemplate_declare_instance:nnnnn}
%  \begin{syntax}
%    "\xtemplate_declare_instance:nnnnn" \marg{type} \marg{template}
%    ~~~~\marg{collection} \marg{instance} \marg{keyvals}
%  \end{syntax}
%  Declares an <instance> (within <collection>) of <template> of <type>,
%  using <keyvals> to define the instance.
%\end{function}
%
%\begin{function}{\xtemplate_edit_instance:nnnnn}
%  \begin{syntax}
%    "\xtemplate_declare_instance:nnnnn" \marg{type} \marg{template}
%    ~~~~\marg{collection} \marg{instance} \marg{keyvals}
%  \end{syntax}
%  Modifies an <instance> (within <collection>) of <template> of <type>,
%  using <keyvals> to modify the instance.
%\end{function}
%
%\begin{function}{\xtemplate_convert_to_assignments:}
%  \begin{syntax}
%    "\xtemplate_convert_to_assignments:"
%  \end{syntax}
%  Converts the contents of the various scratch property lists into
%  a list of variable assignments in \cs{l_xtemplate_assignments_toks}.
%\end{function}
%
%\begin{function}{\xtemplate_find_global:}
%  \begin{syntax}
%    "\xtemplate_find_global:"
%  \end{syntax}
%  Checks in \cs{l_xtemplate_var_tl} for the special text 
%  \texttt{global}, which is removed from the variable is found. The
%  flag \cs{l_xtemplate_global_bool} is then set as appropriate.
%\end{function}
%
%\subsection{Converting values to assignments}
%
%\begin{function}{
%  \xtemplate_assign_boolean:    |
%  \xtemplate_assign_choice:     |
%  \xtemplate_assign_code:       |
%  \xtemplate_assign_code:n      |
%  \xtemplate_assign_commalist:  |
%  \xtemplate_assign_function:   |
%  \xtemplate_assign_instance:   |
%  \xtemplate_assign_integer:    |
%  \xtemplate_assign_length:     |
%  \xtemplate_assign_skip:       |
%  \xtemplate_assign_tokenlist:  
%}
%  \begin{syntax}
%    "\xtemplate_assign_boolean:" 
%  \end{syntax}
%  Convert the given <keytype> of <key> into an assignment to a 
%  <variable>.
%\end{function}
%
%\begin{function}{\xtemplate_assign_variable:N}
%  \begin{syntax}
%    "\xtemplate_assign_variable:N" <function>
%  \end{syntax}
%  Convert the current contents of \cs{l_xtemplate_value_tl} into an
%  assignment using <function> to the variable named in 
%  \cs{l_xtemplate_var_tl}.
%\end{function}
%
%\begin{function}{\xtemplate_key_to_value:}
%  \begin{syntax}
%    "\xtemplate_key_to_value:"
%  \end{syntax}
%  Converts an attribute named uing \cs{KeyValue} into the
%  value of the underlying implementation variable.
%\end{function}
%
%\subsection{Using instances}
%
%\begin{function}{\xtemplate_use_instance:nn}
%  \begin{syntax}
%    "\xtemplate_use_instance:nn" \marg{type} \marg{instance}
%  \end{syntax}
%  Executes code stored for <instance> of <type>, taking account of
%  any active collection.
%\end{function}
%
%\begin{function}{\xtemplate_use_template:nnn}
%  \begin{syntax}
%    "\xtemplate_use_template:nnn" \marg{type} \marg{template}
%    ~~~~\marg{settings}
%  \end{syntax}
%  Executes code stored for <template> of <type> using <settings>.
%\end{function}
%
%\begin{function}{\xtemplate_use_collection:nn}
%  \begin{syntax}
%    "\xtemplate_use_collection:nn" \marg{type} \marg{collection}
%  \end{syntax}
%  Activates <collection> for instances of \marg{type}.
%\end{function}
%
%\begin{function}{\xtemplate_get_collection:n}
%  \begin{syntax}
%    "\xtemplate_get_collection:n" \marg{type}
%  \end{syntax}
%  Sets \cs{l_xtemplate_collection_tl} to the name of the collection 
%  in force for templates of <type>.
%\end{function}
%
%\begin{function}{\xtemplate_assignments_pop:}
%  \begin{syntax}
%    "\xtemplate_assignments_pop:"
%  \end{syntax}
%  Pops \cs{l_xtemplate_assignment_toks}, and therefore executes
%  the assignements stored there.
%\end{function}
%
%\begin{function}{\xtemplate_assignments_push:n}
%  \begin{syntax}
%    "\xtemplate_assignments_push:n" \marg{assignments}
%  \end{syntax}
%  Pushes <assignments> to \cs{l_xtemplate_assignment_toks} for later
%  execution.
%\end{function}
%
%\subsection{Showing details}
%
%\begin{function}{\xtemplate_show_code:nn}
%  \begin{syntax}
%    "\xtemplate_show_code:nn" \marg{type} \marg{template}
%  \end{syntax}
%  Shows code associated with <template> of <type>.
%\end{function}
%
%\begin{function}{\xtemplate_show_code:nn}
%  \begin{syntax}
%    "\xtemplate_show_code:nn" \marg{type} \marg{template}
%  \end{syntax}
%  Shows code associated with <template> of <type>.
%\end{function}
%
%\begin{function}{\xtemplate_show_defaults:nn}
%  \begin{syntax}
%    "\xtemplate_show_default:nn" \marg{type} \marg{template}
%  \end{syntax}
%  Shows default values associated with <template> of <type>.
%\end{function}
%
%\begin{function}{\xtemplate_show_keytypes:nn}
%  \begin{syntax}
%    "\xtemplate_show_keytypes:nn" \marg{type} \marg{template}
%  \end{syntax}
%  Shows key types associated with <template> of <type>.
%\end{function}
%
%\begin{function}{\xtemplate_show_values:nnn}
%  \begin{syntax}
%    "\xtemplate_show_code:nnn" \marg{type} \marg{collection}
%    ~~~~\marg{instance}
%  \end{syntax}
%  Shows values associated with <instance> of <type> within
%  <collection>.
%\end{function}
%

%\begin{function}{\xtemplate_show_vars:nn}
%  \begin{syntax}
%    "\xtemplate_show_vars:nn" \marg{type} \marg{template}
%  \end{syntax}
%  Shows variables associated with <template> of <type>.
%\end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
%\section{Implementation}
%
% \pkg{xtemplate} builds on \pkg{xparse}, which will then load 
% \pkg{expl3}. So for a \LaTeXe\ package only \pkg{xparse} has to be
% required directly. In format mode, this can be skipped as the 
% \pkg{xtemplate} should follow after the \pkg{xparse} stuff.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
\RequirePackage{xparse}
%</package>
%<*initex|package>
%    \end{macrocode}
%    
%\subsubsection{Variables and constants}
%
%\begin{macro}{\c_xtemplate_code_root_tl}
%\begin{macro}{\c_xtemplate_defaults_root_tl}
%\begin{macro}{\c_xtemplate_instances_root_tl}
%\begin{macro}{\c_xtemplate_keytypes_root_tl}
%\begin{macro}{\c_xtemplate_restrict_root_tl}
%\begin{macro}{\c_xtemplate_values_root_tl}
%\begin{macro}{\c_xtemplate_vars_root_tl}
% So that literal values are kept to a minimum.
%    \begin{macrocode}
\tl_new:Nn \c_xtemplate_code_root_tl      { xtemplate_code >  }
\tl_new:Nn \c_xtemplate_defaults_root_tl  { xtemplate_defaults >  }
\tl_new:Nn \c_xtemplate_instances_root_tl { xtemplate_instances >  }
\tl_new:Nn \c_xtemplate_keytypes_root_tl  { xtemplate_keytypes >  }
\tl_new:Nn \c_xtemplate_restrict_root_tl  { xtemplate_restrict >  }
\tl_new:Nn \c_xtemplate_values_root_tl    { xtemplate_values >  }
\tl_new:Nn \c_xtemplate_vars_root_tl      { xtemplate_vars >  }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\c_xtemplate_key_order_tl}
% A special property name, used to store the order keys are defined 
% in.
%    \begin{macrocode}
\tl_new:Nn \c_xtemplate_key_order_tl { key~order }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\c_xtemplate_keytypes_arg_clist}
% A list of keytypes which also need additional data (an argument), used
% to parse the keytype correctly.
%    \begin{macrocode}
\clist_new:N \c_xtemplate_keytypes_arg_clist
\clist_put_right:Nn  \c_xtemplate_keytypes_arg_clist { choice }
\clist_put_right:Nn  \c_xtemplate_keytypes_arg_clist { function }
\clist_put_right:Nn  \c_xtemplate_keytypes_arg_clist { instance }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xtemplate_assignments_toks}
% When creating an instance, the assigned values are collected here. A
% toks is needed as there can be |#| tokens.
%    \begin{macrocode}
\toks_new:N \l_xtemplate_assignments_toks
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xtemplate_collection_tl}
% The current instance collection name is stored here.
%    \begin{macrocode}
\tl_new:N \l_xtemplate_collection_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xtemplate_collections_prop}
% Lists current collection in force, indexed by object type.
%    \begin{macrocode}
\prop_new:N \l_xtemplate_collections_prop
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xtemplate_default_tl}
% The default value for a key is recovered here from the property list
% in which it is stored. The internal implementation of property lists
% means that this is safe even with un-escaped |#| tokens.
%    \begin{macrocode}
\tl_new:N \l_xtemplate_default_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xtemplate_error_bool}
% A flag for errors to be carried forward.
%    \begin{macrocode}
\bool_new:N \l_xtemplate_error_bool
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xtemplate_global_bool}
% Used to indicate that assignments should be global.
%    \begin{macrocode}
\bool_new:N \l_xtemplate_global_bool
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xtemplate_restrict_bool}
% A flag to indicate that a template is being restricted.
%    \begin{macrocode}
\bool_new:N \l_xtemplate_restrict_bool
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xtemplate_restricted_clist}
% A scratch list for restricting templates.
%    \begin{macrocode}
\clist_new:N \l_xtemplate_restricted_clist
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xtemplate_key_name_tl}
%\begin{macro}{\l_xtemplate_keytype_tl}
%\begin{macro}{\l_xtemplate_keytype_arg_tl}
%\begin{macro}{\l_xtemplate_value_tl}
%\begin{macro}{\l_xtemplate_var_tl}
% When defining each key in a template, the name and type of the key
% need to be separated and stored. Any argument needed by the
% keytype is also stored separately.
%    \begin{macrocode}
\tl_new:N \l_xtemplate_key_name_tl
\tl_new:N \l_xtemplate_keytype_tl
\tl_new:N \l_xtemplate_keytype_arg_tl
\tl_new:N \l_xtemplate_value_tl
\tl_new:N \l_xtemplate_var_tl
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_xtemplate_key_seq}
% The order that keys are declared needs to be know, so that they can
% be set in the same way. As property lists are not ordered data types,
% a separate list needs to be kept which \emph{is} ordered. This will
% then be stored in the property list.
%    \begin{macrocode}
\seq_new:N \l_xtemplate_key_seq
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xtemplate_keytypes_prop}
%\begin{macro}{\l_xtemplate_values_prop}
%\begin{macro}{\l_xtemplate_vars_prop}
% To avoid needing too many difficult-to-follow csname assignments,
% various scratch token registers are used to build up data, which is
% then transferred
%    \begin{macrocode}
\prop_new:N \l_xtemplate_keytypes_prop
\prop_new:N \l_xtemplate_values_prop
\prop_new:N \l_xtemplate_vars_prop
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_xtemplate_tmp_clist}
%\begin{macro}{\l_xtemplate_tmp_dim}
%\begin{macro}{\l_xtemplate_tmp_int}
%\begin{macro}{\l_xtemplate_tmp_skip}
% For pre-processing the data stored by \pkg{xtemplate}, a number of 
% scratch variables are needed. The assignments are made to these in the
% first instance, unless evaluation is delayed.
%    \begin{macrocode}
\clist_new:N \l_xtemplate_tmp_clist
\dim_new:N \l_xtemplate_tmp_dim
\int_new:N \l_xtemplate_tmp_int
\skip_new:N \l_xtemplate_tmp_skip
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_xtemplate_tmp_tl}
% A scratch variable for comparisons and so on.
%    \begin{macrocode}
\tl_new:N \l_xtemplate_tmp_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xtemplate_object_type_prop}
% For storing types and the associated number of arguments.
%    \begin{macrocode}
\prop_new:N \l_xtemplate_object_type_prop 
%    \end{macrocode}
%\end{macro}
%
%\subsection{Testing existence and validity}
%
% There are a number of checks needed for either the existence of
% a object type, template or instance. There are also some for the
% validity of a particular call. All of these are collected up here.
% 
%\begin{macro}{\xtemplate_if_arg_agreement:nNTF}
%\begin{macro}{\xtemplate_if_arg_agreement:nVTF}
% A test agreement between the number of arguments for the template
% type and that specified when creating a template.
%    \begin{macrocode}
\prg_new_conditional:Nnn \xtemplate_if_arg_agreement:nN { TF } {
  \prop_get:NnN \l_xtemplate_object_type_prop {#1} \l_xtemplate_tmp_tl
  \tl_if_eq:nVTF {#2} \l_xtemplate_tmp_tl {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
\cs_generate_variant:Nn \xtemplate_if_arg_agreement:nNTF { nV } 
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_if_key_value:nT}
%\begin{macro}{\xtemplate_if_key_value:VT}
% Tests for the first token in a string being \cs{KeyValue}, where
% \cs{DelayEvaluation} is not important.
%    \begin{macrocode}
\prg_set_conditional:Nnn \xtemplate_if_key_value:n { T } {
  \tl_if_eq:noTF { \KeyValue } { \tl_head:w #1 \q_nil } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
\cs_generate_variant:Nn \xtemplate_if_key_value:nT { V }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_if_eval_now:nTF}
% Tests for the first token in a string being \cs{EvaluateNow}.
%    \begin{macrocode}
\prg_new_conditional:Nnn \xtemplate_if_eval_now:n { TF } {
  \tl_if_eq:noTF { \EvaluateNow } { \tl_head:w #1 \q_nil } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[TF]{\xtemplate_if_instance_exist:nnn}
% Testing for an instance is collection dependent.
%    \begin{macrocode}
\prg_new_conditional:Nnn \xtemplate_if_instance_exist:nnn { T, F, TF } {
  \cs_if_exist:cTF { \c_xtemplate_instances_root_tl #1 / #2 / #3 :w } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_if_keys_exist:nnTF}
% To check that the keys for a template have been set up before trying
% to create any code, a simple check for the correctly-named keytype
% property list.
%    \begin{macrocode}
\prg_new_conditional:Nnn \xtemplate_if_keys_exist:nn { TF } {
  \cs_if_exist:cTF { l_ \c_xtemplate_keytypes_root_tl #1 / #2 _prop } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_if_keytype_exist:nTF}
%\begin{macro}{\xtemplate_if_keytype_exist:VTF}
% The test for valid keytypes looks for a function to set up the key,
% which is part of the `code' side of the template definition. This 
% avoids having different lists for the two parts of the process. 
%    \begin{macrocode}
\prg_new_conditional:Nnn \xtemplate_if_keytype_exist:n { TF } {
  \cs_if_exist:cTF { xtemplate_store_value_ \l_xtemplate_keytype_tl :n } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
\cs_generate_variant:Nn \xtemplate_if_keytype_exist:nTF { V }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%
%\begin{macro}{\xtemplate_if_template_exist:nnTF}
% A template is only fully declared if the code has been set up, 
% which can be checked by looking for the template function itself.
%    \begin{macrocode}
\prg_new_conditional:Nnn \xtemplate_if_template_exist:nn { TF } {
  \cs_if_exist:cTF { \c_xtemplate_code_root_tl #1 / #2 :w } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_if_type_exist:nTF}
% To check that a particular object type is valid.
%    \begin{macrocode}
\prg_new_conditional:Nnn \xtemplate_if_type_exist:n { TF } {
  \prop_if_in:NnTF \l_xtemplate_object_type_prop {#1} {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_if_use_template:nTF}
% Tests for the first token in a string being \cs{UseTemplate}.
%    \begin{macrocode}
\prg_new_conditional:Nnn \xtemplate_if_use_template:n { TF } {
  \tl_if_eq:noTF { \UseTemplate } { \tl_head:w #1 \q_nil } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Saving and recovering property lists}
%
% The various property lists for templates have to be shuffled in
% and out of storage.
%
%\begin{macro}{\xtemplate_store_defaults:n}
%\begin{macro}{\xtemplate_store_keytypes:n}
%\begin{macro}{\xtemplate_store_restrictions:n}
%\begin{macro}{\xtemplate_store_values:n}
%\begin{macro}{\xtemplate_store_vars:n}
% The defaults and keytypes are transferred from the scratch property
% lists to the `proper' lists for the template being created.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_store_defaults:n {
  \cs_if_free:cT { l_ \c_xtemplate_defaults_root_tl #1 _prop } {
    \prop_new:c { l_ \c_xtemplate_defaults_root_tl #1 _prop }
  }
  \prop_set_eq:cN { l_ \c_xtemplate_defaults_root_tl #1 _prop }
    \l_xtemplate_values_prop
}
\cs_new:Nn \xtemplate_store_keytypes:n {
  \cs_if_free:cT { l_ \c_xtemplate_keytypes_root_tl #1 _prop } {
    \prop_new:c { l_ \c_xtemplate_keytypes_root_tl #1 _prop }
  }
  \prop_set_eq:cN { l_ \c_xtemplate_keytypes_root_tl #1 _prop }
    \l_xtemplate_keytypes_prop
}
\cs_new:Nn \xtemplate_store_values:n {
  \cs_if_free:cT { l_ \c_xtemplate_values_root_tl #1 _prop } {
    \prop_new:c { l_ \c_xtemplate_values_root_tl #1 _prop }
  }
  \prop_set_eq:cN { l_ \c_xtemplate_values_root_tl #1 _prop }
    \l_xtemplate_values_prop
}
\cs_new:Nn \xtemplate_store_restrictions:n {
  \clist_set_eq:cN { l_ \c_xtemplate_restrict_root_tl #1 _clist }
    \l_xtemplate_restrict_clist
}
\cs_new:Nn \xtemplate_store_vars:n {
  \cs_if_free:cT { l_ \c_xtemplate_vars_root_tl #1 _prop } {
    \prop_new:c { l_ \c_xtemplate_vars_root_tl #1 _prop }
  }
  \prop_set_eq:cN { l_ \c_xtemplate_vars_root_tl #1 _prop }
    \l_xtemplate_vars_prop
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_recover_defaults:n}
%\begin{macro}{\xtemplate_recover_keytypes:n}
%\begin{macro}{\xtemplate_recover_restrictions:n}
%\begin{macro}{\xtemplate_recover_values:n}
%\begin{macro}{\xtemplate_recover_vars:n}
% Recovering the stored data for a template is rather less complex 
% than storing it. All that happens is the data is  transferred from 
% the permanent to the scratch storage.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_recover_defaults:n {
  \prop_set_eq:Nc \l_xtemplate_values_prop
    { l_ \c_xtemplate_defaults_root_tl #1 _prop }
}
\cs_new:Nn \xtemplate_recover_keytypes:n {
  \prop_set_eq:Nc \l_xtemplate_keytypes_prop
    { l_ \c_xtemplate_keytypes_root_tl #1 _prop }
}
\cs_new:Nn \xtemplate_recover_restrictions:n {
  \clist_set_eq:Nc \l_xtemplate_restrict_clist
    { l_ \c_xtemplate_restrict_root_tl #1 _clist }
}
\cs_new:Nn \xtemplate_recover_values:n {
  \prop_set_eq:Nc \l_xtemplate_values_prop
    { l_ \c_xtemplate_values_root_tl #1 _prop }
}
\cs_new:Nn \xtemplate_recover_vars:n {
  \prop_set_eq:Nc \l_xtemplate_vars_prop
    { l_ \c_xtemplate_vars_root_tl #1 _prop }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%    
%\subsubsection{Creating new object types}
%
%\begin{macro}{\xtemplate_declare_object_type:nn}
% Although the object type is the `top level' of the template system,
% it is actually very easy to implement. All that happens is that the
% number of arguments required is recorded, indexed by the name of the 
% object type.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_declare_object_type:nn {
  \int_set:Nn \l_xtemplate_tmp_int {#2}
  \intexpr_compare:nTF { #2 > \c_nine } {
    \msg_error:nnxx { xtemplate } { too-many-arguments } {#1} 
      { \exp_not:V \l_xtemplate_tmp_int }
  }{
    \prop_put:NnV \l_xtemplate_object_type_prop {#1} 
      \l_xtemplate_tmp_int
  }
}
%    \end{macrocode}
%\end{macro}
%
%\subsection{Design part of template declaration}
%
% The `design' part of a template declaration defines the general
% behaviour of each key, and possibly a default value. However, it does
% not include the implementation. This means that what happens here is
% the two properties are saved to appropriate lists, which can then
% be used later to recover the information when implementing the keys.
% 
%\begin{macro}{\xtemplate_declare_template_keys:nnnn}
% The main function for the `design' part of creating a template starts
% by checking that the object type exists and that the number of 
% arguments required agree. If that is all fine, then the two storage
% areas for defaults and keytypes are initialised. The mechanism is then
% set up for the \pkg{l3keyval} module to actually parse the keys. 
% Finally, the code hands of to the storage routine to save the parsed
% information properly.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_declare_template_keys:nnnn {
  \xtemplate_if_type_exist:nTF {#1} {
    \int_set:Nn \l_xtemplate_tmp_int {#3}
    \xtemplate_if_arg_agreement:nVTF {#1} \l_xtemplate_tmp_int {
      \prop_clear:N \l_xtemplate_values_prop
      \prop_clear:N \l_xtemplate_keytypes_prop
      \seq_clear:N \l_xtemplate_key_seq
      \cs_set_eq:NN \KV_key_no_value_elt:n \xtemplate_parse_keys_elt:n
      \cs_set_eq:NN \KV_key_value_elt:nn \xtemplate_parse_keys_elt:nn
      \KV_parse_space_removal_sanitize:n {#4}
      \prop_put:NVV \l_xtemplate_keytypes_prop \c_xtemplate_key_order_tl
        \l_xtemplate_key_seq
      \xtemplate_store_defaults:n { #1 / #2 }
      \xtemplate_store_keytypes:n { #1 / #2 }
    }{
      \msg_error:nnxx { xtemplate } { bad-arg-count } {#1} 
        { \exp_not:V \l_xtemplate_tmp_int }
    }
  }{
    \msg_error:nnx { xtemplate } { unknown-object-type } {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_parse_keys_elt:n}
% Processing the key part of the key--value pair is always carried out
% using this function, even if a value was found. First, the key name
% is separated from the keytype, and if necessary the keytype is 
% separated into two parts. This information is then used to check that
% the keytype is valid, before storing the keytype (plus argument if
% necessary) as a property of the key name. The key name is also stored
% (in braces) in the token list to record the order the keys are defined
% in.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_parse_keys_elt:n {
  \xtemplate_split_keytype:n {#1}
  \bool_if:NF \l_xtemplate_error_bool {
    \xtemplate_if_keytype_exist:VTF \l_xtemplate_keytype_tl {
      \tl_set:Nx \l_xtemplate_tmp_tl {
        \l_xtemplate_keytype_tl
        \l_xtemplate_keytype_arg_tl
      }
      \prop_put:NVV \l_xtemplate_keytypes_prop \l_xtemplate_key_name_tl
        \l_xtemplate_tmp_tl
      \seq_put_right:NV \l_xtemplate_key_seq \l_xtemplate_key_name_tl 
      \tl_if_eq:VnT \l_xtemplate_keytype_tl { choice } {
        \clist_if_in:NnT \l_xtemplate_keytype_arg_tl { unknown } {
          \msg_error:nn { xtemplate } { choice-unknown-reserved }
        }
      }
    }{
      \msg_error:nnx { xtemplate } { invalid-keytype } 
        { \l_xtemplate_keytype_tl }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_parse_keys_elt:nn}
% For keys which have a default, the keytype and key name are first
% separated out by the \cs{xtemplate_parse_keys_elt:n}
% routine, before storing the default value in the scratch property list.
% Choices have special handling as the code is not yet available to 
% actually do the storing!
%    \begin{macrocode}
\cs_new:Nn \xtemplate_parse_keys_elt:nn {
  \xtemplate_parse_keys_elt:n {#1}
  \tl_if_eq:VnTF \l_xtemplate_keytype_tl { choice } {
    \xtemplate_store_value_choice_name:n {#2}
  }{
    \use:c { xtemplate_store_value_ \l_xtemplate_keytype_tl :n } {#2}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_split_keytype:n}
%\begin{macro}[aux]{\xtemplate_split_keytype_aux:w}
% The keytype and key name should be separated by `\texttt{:}'. As the
% definition might be given inside or outside of a code block, spaces
% are removed and the category code of colons is standardised. After
% that, the standard delimited argument method is used to separate the
% two parts.
%    \begin{macrocode}
\group_begin:
\char_set_lccode:nn { `\@ } { `\: }
\char_make_other:N \@
\tl_to_lowercase:n {
  \group_end:
  \cs_new:Nn \xtemplate_split_keytype:n {
    \bool_set_false:N \l_xtemplate_error_bool
    \tl_set:Nn \l_xtemplate_tmpa_tl {#1}
    \tl_replace_all_in:Nnn \l_xtemplate_tmpa_tl { ~ } { }
    \tl_replace_all_in:Nnn \l_xtemplate_tmpa_tl { : } { @ }
    \tl_if_in:VnTF \l_xtemplate_tmpa_tl { @ } {
      \exp_after:wN \xtemplate_split_keytype_aux:w \l_xtemplate_tmpa_tl
        \q_stop
    }{
      \bool_set_true:N \l_xtemplate_error_bool
      \msg_error:nnx { xtemplate } { no-keytype } {#1}
    }
  }
  \cs_new:Npn \xtemplate_split_keytype_aux:w #1 @ #2 \q_stop {
    \tl_set:Nx \l_xtemplate_key_name_tl { \tl_to_str:n {#1} }
    \xtemplate_split_keytype_arg:n {#2}
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_split_keytype_arg:n}
%\begin{macro}{\xtemplate_split_keytype_arg:V}
%\begin{macro}[aux]{\xtemplate_split_keytype_arg_aux:n}
%\begin{macro}[aux]{\xtemplate_split_keytype_arg_aux:w}
% The second stage of sorting out the keytype is to check for an
% argument. As there is no convenient delimiting token to look for,
% a check is made instead for each possible text value for the keytype.
% To keep things faster, this only involves the keytypes that need an
% argument. If a match is made, then a check is also needed to see that
% it is at the start of the keytype information. All being well, the 
% split can then be applied. Any non-matching keytypes are assumed to
% be `correct' as given, and are left alone (this is checked by other
% code).
%    \begin{macrocode}
\cs_new:Nn \xtemplate_split_keytype_arg:n {
  \tl_set:Nn \l_xtemplate_keytype_tl {#1}
  \tl_clear:N \l_xtemplate_keytype_arg_tl
  \cs_set_nopar:Nn \xtemplate_split_keytype_arg_aux:n {
    \tl_if_in:nnT {#1} {##1} {
      \cs_set:Npn \xtemplate_split_keytype_arg_aux:w 
        ####1 ##1 ####2 \q_stop {
          \tl_if_empty:nT {####1} {
            \tl_set:Nn \l_xtemplate_keytype_tl {##1}
            \tl_set:Nn \l_xtemplate_keytype_arg_tl {####2}
            \clist_map_break:
        }
      }
      \xtemplate_split_keytype_arg_aux:w #1 \q_stop
    }
  }
  \clist_map_function:NN \c_xtemplate_keytypes_arg_clist
    \xtemplate_split_keytype_arg_aux:n
}
\cs_generate_variant:Nn \xtemplate_split_keytype_arg:n { V }
\cs_new_nopar:Nn \xtemplate_split_keytype_arg_aux:n { }
\cs_new_nopar:Npn \xtemplate_split_keytype_arg_aux:w #1 \q_stop { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\subsubsection{Storing values}
%
% As \pkg{xtemplate} pre-processes key values for efficiency reasons,
% there is a need to convert the values given as defaults into
% `ready to use' data. The same general idea is true when an instance
% is declared. However, assignments are not made until an instance is
% used, and so there has to be some intermediate storage. Furthermore,
% the ability to delay evaluation of results is needed. To achieve these
% aims, a series of `process and store' functions are defined here.
% 
% All of the information about the key (the key name and the keytype)
% is already stored as variables. The same property list is always used
% to store the data, meaning that the only argument required is the
% value to be processed and potentially stored.
%
%\begin{macro}{\xtemplate_store_value_boolean:n}
% Storing Boolean values requires a test for delayed evaluation, but
% is different to the various numerical variable types as there are
% only two possible values to store. So the code here tests the default
% switch and then records the meaning (either \texttt{true} or 
% \texttt{false}).
%    \begin{macrocode}
\cs_new:Nn \xtemplate_store_value_boolean:n {
  \xtemplate_if_eval_now:nTF {#1} {
    \bool_if:cTF { c_ #1 _bool } {
      \prop_put:NVn \l_xtemplate_values_prop \l_xtemplate_key_name_tl
        { true }
    }{
      \prop_put:NVn \l_xtemplate_values_prop \l_xtemplate_key_name_tl
        { false }
    }
  }{
    \prop_put:NVn \l_xtemplate_values_prop \l_xtemplate_key_name_tl {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_store_value_choice:n}
%\begin{macro}{\xtemplate_store_value_choice:V}
%\begin{macro}[aux]{\xtemplate_store_value_choice_aux:n}
%\begin{macro}[aux]{\xtemplate_store_value_choice_aux:V}
%\begin{macro}{\xtemplate_store_value_choice_name:n}
%    \begin{macrocode}
\cs_new:Nn \xtemplate_store_value_choice:n {
  \tl_set:Nx \l_xtemplate_tmp_tl {
    \l_xtemplate_key_name_tl ~ #1
  }
  \prop_if_in:NVTF \l_xtemplate_vars_prop \l_xtemplate_tmp_tl {
    \xtemplate_store_value_choice_aux:V \l_xtemplate_tmp_tl
  }{
    \tl_set:Nx \l_xtemplate_tmp_tl {
      \l_xtemplate_key_name_tl ~ unknown
    }
    \prop_if_in:NVTF \l_xtemplate_vars_prop \l_xtemplate_tmp_tl {
      \xtemplate_store_value_choice_aux:V \l_xtemplate_tmp_tl
    }{
      \msg_error:nnxx { xtemplate } { unknown-choice } {#1}
        { \l_xtemplate_key_name_tl }
    }
  }
}
\cs_generate_variant:Nn \xtemplate_store_value_choice:n { V }
\cs_new:Nn \xtemplate_store_value_choice_aux:n {
  \prop_get:NnN \l_xtemplate_vars_prop {#1} \l_xtemplate_tmp_tl
  \prop_put:NVV \l_xtemplate_values_prop \l_xtemplate_key_name_tl 
    \l_xtemplate_tmp_tl
}
\cs_generate_variant:Nn \xtemplate_store_value_choice_aux:n { V }
\cs_new:Nn \xtemplate_store_value_choice_name:n {
  \prop_put:NVn \l_xtemplate_values_prop \l_xtemplate_key_name_tl {#1}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_store_value_code:n}
%\begin{macro}{\xtemplate_store_value_commalist:n}
%\begin{macro}{\xtemplate_store_value_function:n}
%\begin{macro}{\xtemplate_store_value_instance:n}
%\begin{macro}{\xtemplate_store_value_tokenlist:n}
% With no need to worry about delayed evaluation, these keytypes all
% just store the input directly.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_store_value_code:n {
  \prop_put:NVn \l_xtemplate_values_prop \l_xtemplate_key_name_tl {#1}
}
\cs_new:Nn \xtemplate_store_value_commalist:n {
  \prop_put:NVn \l_xtemplate_values_prop \l_xtemplate_key_name_tl {#1}
}
\cs_new:Nn \xtemplate_store_value_function:n {
  \prop_put:NVn \l_xtemplate_values_prop \l_xtemplate_key_name_tl {#1}
}
\cs_new:Nn \xtemplate_store_value_instance:n {
  \prop_put:NVn \l_xtemplate_values_prop \l_xtemplate_key_name_tl {#1}
}
\cs_new:Nn \xtemplate_store_value_tokenlist:n {
  \prop_put:NVn \l_xtemplate_values_prop \l_xtemplate_key_name_tl {#1}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_store_value_integer:n}
%\begin{macro}{\xtemplate_store_value_length:n}
%\begin{macro}{\xtemplate_store_value_skip:n}
% Storing the value of a number is in all cases more or less the same.
% If evaluation is taking place now, assignment is made to a scratch
% variable, and this result is then stored. On the other hand, if
% evaluation is delayed the current data is simply stored `as is'.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_store_value_integer:n {
  \xtemplate_if_eval_now:nTF {#1} {
    \int_set:Nn \l_xtemplate_tmp_int {#1}
    \prop_put:NVV \l_xtemplate_values_prop \l_xtemplate_key_name_tl
      \l_xtemplate_tmp_int
  }{
    \prop_put:NVn \l_xtemplate_values_prop \l_xtemplate_key_name_tl {#1}
  }
}
\cs_new:Nn \xtemplate_store_value_length:n {
  \xtemplate_if_eval_now:nTF {#1} {
    \dim_set:Nn \l_xtemplate_tmp_dim {#1}
    \prop_put:NVV \l_xtemplate_values_prop \l_xtemplate_key_name_tl
      \l_xtemplate_tmp_dim
  }{
    \prop_put:NVn \l_xtemplate_values_prop \l_xtemplate_key_name_tl {#1}
  }
}
\cs_new:Nn \xtemplate_store_value_skip:n {
  \xtemplate_if_eval_now:nTF {#1} {
    \skip_set:Nn \l_xtemplate_tmp_skip {#1}
    \prop_put:NVV \l_xtemplate_values_prop \l_xtemplate_key_name_tl
      \l_xtemplate_tmp_skip
  }{
    \prop_put:NVn \l_xtemplate_values_prop \l_xtemplate_key_name_tl {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
% 
%\subsubsection{Implementation part of template declaration}
%
%\begin{macro}{\xtemplate_declare_template_code:nnnnn}
% The main function for implementing a template starts with a couple of
% simple checks to make sure that there are no obvious mistakes: the
% number of arguments must agree and the template keys must have been
% declared. 
%    \begin{macrocode}
\cs_new:Nn \xtemplate_declare_template_code:nnnnn {
  \xtemplate_if_type_exist:nTF {#1} {
    \int_set:Nn \l_xtemplate_tmp_int {#3}
    \xtemplate_if_arg_agreement:nVTF {#1} \l_xtemplate_tmp_int {
      \xtemplate_if_keys_exist:nnTF {#1} {#2} {
        \xtemplate_store_key_implementation:nnn {#1} {#2} {#4}
        \cs_generate_from_arg_count:cNnn 
          { \c_xtemplate_code_root_tl #1 / #2 :w } \cs_set:Npn 
          { \int_use:N \l_xtemplate_tmp_int } {#5}
      }{
        \msg_error:nnxx { xtemplate } { code-no-keys } {#1} {#2}
      }
    }{
      \msg_error:nnxx { xtemplate } { bad-arg-count } {#1} 
        { \exp_not:V \l_xtemplate_tmp_int }
    }
  }{
    \msg_error:nnx { xtemplate } { unknown-object-type } {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_store_key_implementation:nnn}
% Actually storing the implementation part of a template is quite easy
% as it only requires the list of keys given to be turned into a 
% property list. There is also some error-checking to do, hence the need
% to have the list of defined keytypes available.
%    \begin{macrocode}
\cs_set:Nn \xtemplate_store_key_implementation:nnn {
  \xtemplate_recover_defaults:n { #1 / #2 }
  \xtemplate_recover_keytypes:n { #1 / #2 }
  \prop_clear:N \l_xtemplate_vars_prop
  \cs_set_eq:NN \KV_key_no_value_elt:n \xtemplate_parse_vars_elt:n
  \cs_set_eq:NN \KV_key_value_elt:nn \xtemplate_parse_vars_elt:nn
  \KV_parse_no_space_removal_no_sanitize:n {#3}
  \xtemplate_store_defaults:n { #1 / #2 }
  \xtemplate_store_vars:n { #1 / #2 }
  \clist_clear:N \l_xtemplate_restrict_clist
  \xtemplate_store_restrictions:n { #1 / #2 }
  \prop_del:NV \l_xtemplate_keytypes_prop \c_xtemplate_key_order_tl
  \prop_if_empty:NF \l_xtemplate_keytypes_prop {
    \prop_map_inline:Nn \l_xtemplate_keytypes_prop {
      \msg_error:nnxx { xtemplate } { key-not-implemented }
        { #1~(of~type~#2) } {##1}
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_parse_vars_elt:n}
% At the implementation stage, every key must have a value given. So
% this is an error function.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_parse_vars_elt:n {
  \msg_error:nnx { xtemplate } { key-no-variable } {#1}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_parse_vars_elt:nn}
% The actual storage part here is very simple: the storage bin name
% is placed into the property list. At the same time, a comparison is
% made with the keytypes defined earlier: if there is a mismatch then
% an error is raised.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_parse_vars_elt:nn {
  \tl_set:Nx \l_xtemplate_key_name_tl { \tl_to_str:n {#1} }
  \tl_replace_all_in:Nnn \l_xtemplate_key_name_tl { ~ } { }
  \prop_if_in:NVTF \l_xtemplate_keytypes_prop \l_xtemplate_key_name_tl {
    \prop_get:NVN \l_xtemplate_keytypes_prop \l_xtemplate_key_name_tl
      \l_xtemplate_keytype_tl
     \xtemplate_split_keytype_arg:V \l_xtemplate_keytype_tl
    \prop_del:NV \l_xtemplate_keytypes_prop \l_xtemplate_key_name_tl
    \xtemplate_parse_vars_elt_aux:n {#2}
  }{
    \msg_error:nnx { xtemplate } { key-not-declared } {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}[aux]{\xtemplate_parse_vars_elt_aux:n}
%\begin{macro}[aux]{\xtemplate_parse_vars_elt_aux:w}
% There now needs to be some sanity checking on the variable name
% given. This does not apply for \texttt{choice} or 
% \texttt{code} `variables', but in all other cases the variable needs
% to exist. Also, the only prefix acceptable is \texttt{global}. So 
% there are a few related checks to make.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_parse_vars_elt_aux:n {
  \tl_if_eq:VnTF \l_xtemplate_keytype_tl { choice } {
    \xtemplate_implement_choices:n {#1}
  }{
    \prop_put:NVn \l_xtemplate_vars_prop \l_xtemplate_key_name_tl {#1}
    \tl_if_eq:VnF \l_xtemplate_keytype_tl { code } {
      \tl_if_eq:noF {#1} { \tl_head:w #1 \q_nil } {
        \tl_if_in:nnTF {#1} { global } {
          \xtemplate_parse_vars_elt_aux:w #1 \q_nil
        }{
          \msg_error:nnx { xtemplate } { bad-variable } 
            { \exp_not:n {#1} }
        }
      }
    }
  }
}
\cs_new:Npn \xtemplate_parse_vars_elt_aux:w #1 global #2 \q_nil {
  \tl_if_empty:nTF {#1} {
    \tl_if_eq:noF {#2} { \tl_head:w #2 \q_nil } {
      \msg_error:nnx { xtemplate } { bad-variable } 
        { \exp_not:n { #1 global #2 } }
    }
  }{
    \msg_error:nnx { xtemplate } { bad-variable } 
      { \exp_not:n { #1 global #2 } }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_implement_choices:n}
% Implementing choices requires a second key--value loop. So after a
% little set-up, the standard parser is called. There is then a 
% check for a default choice being set: at this stage the name of
% the choice is replaced by the code to implement it.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_implement_choices:n {
  \clist_set_eq:NN \l_xtemplate_tmp_clist \l_xtemplate_keytype_arg_tl
  \cs_set_eq:NN \KV_key_no_value_elt:n \xtemplate_implement_choice_elt:n
  \cs_set_eq:NN \KV_key_value_elt:nn \xtemplate_implement_choice_elt:nn
  \prop_put:NVn \l_xtemplate_vars_prop \l_xtemplate_key_name_tl { }
  \KV_parse_no_space_removal_no_sanitize:n {#1}
  \cs_set_eq:NN \KV_key_no_value_elt:n \xtemplate_parse_vars_elt:n
  \cs_set_eq:NN \KV_key_value_elt:nn \xtemplate_parse_vars_elt:nn
  \prop_if_in:NVT \l_xtemplate_values_prop \l_xtemplate_key_name_tl {
    \prop_get:NVN \l_xtemplate_values_prop \l_xtemplate_key_name_tl 
      \l_xtemplate_tmp_tl
    \xtemplate_store_value_choice:V \l_xtemplate_tmp_tl
  }
  \clist_if_empty:NF \l_xtemplate_tmp_clist {
    \msg_error:nnx { xtemplate } { non-implemented-choices } 
      {  \l_xtemplate_tmp_clist }
  } 
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_implement_choice_elt:n}
%\begin{macro}{\xtemplate_implement_choice_elt:nn}
% The actual storage of the implementation of a choice is mainly about
% error checking. The code here ensures that all choices have to have
% been declared, apart from the special \texttt{unknown} choice, which 
% must come last. The code for each choice is stored along with the
% key name in the variables property list.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_implement_choice_elt:n {
  \clist_if_empty:NTF \l_xtemplate_tmp_clist {
    \tl_if_eq:nnF {#1} { unknown } {
      \msg_error:nnxx { xtemplate } { bad-choice } {#1} 
        { \l_xtemplate_key_name_tl }
    }
  }{
    \clist_if_in:NnTF \l_xtemplate_tmp_clist {#1} {
      \clist_remove_element:Nn \l_xtemplate_tmp_clist {#1}
    }{
      \msg_error:nnxx { xtemplate } { bad-choice } {#1} 
        { \l_xtemplate_key_name_tl }
    }
  }
}
\cs_new:Nn \xtemplate_implement_choice_elt:nn {
  \xtemplate_implement_choice_elt:n {#1}
  \tl_set:Nx \l_xtemplate_tmp_tl {
    \l_xtemplate_key_name_tl ~ #1
  }
  \prop_put:NVn \l_xtemplate_vars_prop \l_xtemplate_tmp_tl {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsubsection{Editing template defaults}
%
% Template defaults can be edited either with no other changes or
% to prevent further editing, forming a ``restricted template''.
% In the later case, a new template results, whereas simple editing 
% does not produce a new template name.
% 
%\begin{macro}{\xtemplate_declare_restricted:nnnn}
% Creating a restricted template means copying the old template to the
% new one first.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_declare_restricted:nnnn {
  \xtemplate_if_keys_exist:nnTF {#1} {#2} {
    \xtemplate_set_template_eq:nn { #1 / #3 } { #1 / #2 }
    \bool_set_true:N \l_xtemplate_restrict_bool
    \xtemplate_edit_defaults_aux:nnn {#1} {#3} {#4}
  }{
   \msg_error:nnxx { xtemplate } { unknown-template } {#1} {#2}
 }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_edit_defaults:nnn}
%\begin{macro}[aux]{\xtemplate_edit_defaults_aux:nnn}
% Editing the template defaults means getting the values back out
% of the store, then parsing the list of new values before putting
% the updated list back into storage. The auxiliary function is used
% to allow code-sharing with the template-restriction system.
%    \begin{macrocode}
\cs_new:Npn \xtemplate_edit_defaults:nnn {
  \bool_set_false:N \l_xtemplate_restrict_bool
  \xtemplate_edit_defaults_aux:nnn
}
\cs_new:Nn \xtemplate_edit_defaults_aux:nnn {
  \xtemplate_if_keys_exist:nnTF {#1} {#2} {
    \xtemplate_recover_defaults:n { #1 / #2 }
    \xtemplate_recover_restrictions:n { #1 / #2 }
    \xtemplate_parse_values:nn { #1 / #2 } {#3}
    \xtemplate_store_defaults:n { #1 / #2 }
    \xtemplate_store_restrictions:n { #1 / #2 }
  }{
   \msg_error:nnxx { xtemplate } { unknown-template } {#1} {#2}
 }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_parse_values:nn}
% The routine to parse values is the same for both editing a 
% template and setting up an instance. So the code here does only the
% minimum necessary for reading the values.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_parse_values:nn {
  \xtemplate_recover_keytypes:n {#1}
  \clist_clear:N \l_xtemplate_restricted_clist
  \cs_set_eq:NN \KV_key_no_value_elt:n \xtemplate_parse_values_elt:n
  \cs_set_eq:NN \KV_key_value_elt:nn \xtemplate_parse_values_elt:nn
  \KV_parse_space_removal_sanitize:n {#2}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_parse_values_elt:n}
% Every key needs a value, so this is just an error routine.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_parse_values_elt:n {
  \bool_set_true:N \l_xtemplate_error_bool
  \msg_error:nnx { xtemplate } { key-no-value } {#1}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_parse_values_elt:nn}
%\begin{macro}[aux]{\xtemplate_parse_values_elt_aux:nn}
%\begin{macro}[aux]{\xtemplate_parse_values_elt_aux:Vn}
% To store the value, find the keytype then call the saving function.
% These need the current key name saved as \cs{l_xtemplate_key_name_tl}.
% When a template is being restricted, the setting code will be 
% skipped for restricted keys.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_parse_values_elt:nn {
  \tl_set:Nx \l_xtemplate_key_name_tl { \tl_to_str:n {#1} }
  \tl_replace_all_in:Nnn \l_xtemplate_key_name_tl { ~ } { }
  \prop_if_in:NVTF \l_xtemplate_keytypes_prop \l_xtemplate_key_name_tl {
    \bool_if:NTF \l_xtemplate_restrict_bool {
      \clist_if_in:NVF \l_xtemplate_restricted_clist 
        \l_xtemplate_key_name_tl {
        \xtemplate_parse_values_elt_aux:Vn \l_xtemplate_key_name_tl {#2}
      }
    }{
      \xtemplate_parse_values_elt_aux:Vn \l_xtemplate_key_name_tl {#2}
    }
  }{
    \msg_error:nnx { xtemplate } { unknown-key } 
      { \l_xtemplate_key_name_tl }
  }
}
\cs_new:Nn \xtemplate_parse_values_elt_aux:nn {
  \clist_put_right:Nn \l_xtemplate_restricted_clist {#1}
  \prop_get:NnN \l_xtemplate_keytypes_prop {#1} \l_xtemplate_tmp_tl
  \xtemplate_split_keytype_arg:V \l_xtemplate_tmp_tl
  \use:c { xtemplate_store_value_ \l_xtemplate_keytype_tl :n } {#2}
}
\cs_generate_variant:Nn \xtemplate_parse_values_elt_aux:nn { Vn }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_set_template_eq:nn}
% To copy a template, each of the lists plus the code has to be copied
% across. To keep this independent of the list storage system, it is
% all done with two-part shuffles.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_set_template_eq:nn {
  \xtemplate_recover_defaults:n {#2}
  \xtemplate_store_defaults:n {#1}
  \xtemplate_recover_keytypes:n {#2}
  \xtemplate_store_keytypes:n {#1}
  \xtemplate_recover_vars:n {#2}
  \xtemplate_store_vars:n {#1} 
  \cs_set_eq:cc { \c_xtemplate_code_root_tl #1 :w }
    { \c_xtemplate_code_root_tl #2 :w } 
}
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Creating instances of templates}
%
%\begin{macro}{\xtemplate_declare_instance:nnnnn}
%\begin{macro}[aux]{\xtemplate_declare_instance_aux:nnnnn}
% Making an instance has two distinct parts. First, the keys given are
% parsed to transfer the values into the structured data format used
% internally. This allows the default and given values to be combined
% with no repetition. In the second step, the structured data is
% converted to pre-defined variable assignments, and these are stored
% in the function for the instance. A final check is also made so that
% there is always an instance `outside' of any collection.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_declare_instance:nnnnn {
  \xtemplate_if_template_exist:nnTF {#1} {#2} {
    \xtemplate_recover_defaults:n { #1 / #2 }
    \xtemplate_recover_vars:n { #1 / #2 }
    \xtemplate_declare_instance_aux:nnnnn {#1} {#2} {#3} {#4} {#5}
  }{
    \msg_error:nnxx { xtemplate } { code-no-keys } {#1} {#2}
  }
}
\cs_new:Nn \xtemplate_declare_instance_aux:nnnnn {
  \bool_set_false:N \l_xtemplate_error_bool
  \xtemplate_parse_values:nn { #1 / #2 } {#5}
  \bool_if:NF \l_xtemplate_error_bool {
    \xtemplate_store_values:n { #1 / #3 / #4 }
    \xtemplate_convert_to_assignments:
    \cs_set:cpx { \c_xtemplate_instances_root_tl #1 / #3 / #4 :w } {
      \exp_not:N \xtemplate_assignments_push:n {
        \exp_not:V \l_xtemplate_assignments_toks
      }
      \exp_not:c { \c_xtemplate_code_root_tl #1 / #2 :w }
    }
    \xtemplate_if_instance_exist:nnnF {#1} { } {#4} {
      \cs_set_eq:cc
        { \c_xtemplate_instances_root_tl #1 /    / #4 :w }
        { \c_xtemplate_instances_root_tl #1 / #3 / #4 :w }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_edit_instance:nnnnn}
% Editing an instance is almost identical to declaring one. The only
% variation is the source of the values to use. When editing, they are
% recovered from the previous instance run.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_edit_instance:nnnnn {
  \xtemplate_if_template_exist:nnTF {#1} {#2} {
    \xtemplate_if_instance_exist:nnnTF {#1} {#3} {#4} {
      \xtemplate_recover_vars:n { #1 / #2 }
      \xtemplate_recover_values:n { #1 / #3 / #4 }
      \xtemplate_declare_instance_aux:nnnnn {#1} {#2} {#3} {#4} {#5}
    }{
      \msg_error:nnxx { xtemplate } { unknown-instance } {#1} {#3}
    }
  }{
    \msg_error:nnxx { xtemplate } { unknown-template } {#1} {#2}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_convert_to_assignments:}
%\begin{macro}[aux]{\xtemplate_convert_to_assignments_aux:n}
%\begin{macro}[aux]{\xtemplate_convert_to_assignments_aux:nn}
%\begin{macro}[aux]{\xtemplate_convert_to_assignments_aux:nV}
% The idea on converting to a set of assignments is to loop over each
% key, so that the loop order follows the declaration order of the keys.
% This is done using a sequence as property lists are not ``ordered''.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_convert_to_assignments: {
  \toks_clear:N \l_xtemplate_assignments_toks
  \prop_get:NVN \l_xtemplate_keytypes_prop \c_xtemplate_key_order_tl
    \l_xtemplate_key_seq
  \seq_map_function:NN \l_xtemplate_key_seq
    \xtemplate_convert_to_assignments_aux:n
}
\cs_new:Nn \xtemplate_convert_to_assignments_aux:n {
  \prop_get:NnN \l_xtemplate_keytypes_prop {#1} \l_xtemplate_tmp_tl
  \xtemplate_convert_to_assignments_aux:nV {#1} \l_xtemplate_tmp_tl
}
%    \end{macrocode}
% The second auxiliary function actually does the work. The
% arguments here are the key name (|#1|) and the keytype (|#2|). 
% From those, the value to assign and the name of the appropriate
% variable are recovered. A bit of work is then needed to sort out
% keytypes with arguments (for example instances), and to look for 
% global assignments. Once that is done, a hand-off can be made to the
% handler for the relevant keytype.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_convert_to_assignments_aux:nn {
  \prop_if_in:NnT \l_xtemplate_values_prop {#1} {
    \prop_if_in:NnTF \l_xtemplate_vars_prop {#1} {
      \prop_get:NnN \l_xtemplate_values_prop {#1} \l_xtemplate_value_tl
      \prop_get:NnN \l_xtemplate_vars_prop {#1} \l_xtemplate_var_tl
      \xtemplate_split_keytype_arg:n {#2}
      \tl_if_eq:VnF \l_xtemplate_keytype_tl { choice } {
        \tl_if_eq:VnF \l_xtemplate_keytype_tl { code } {
          \xtemplate_find_global:
	  \exp_args:NV \cs_if_exist:NF \l_xtemplate_var_tl {
	    \msg_error:nnx { xtemplate } { undeclared-variable }
	      { \exp_not:V \l_xtemplate_var_tl }
	  }
        }
      }
      \use:c { xtemplate_assign_ \l_xtemplate_keytype_tl : }
    }{
      \msg_error:nnx { xtemplate } { unknown-attribute } {#1}
    }
  }
}
\cs_generate_variant:Nn \xtemplate_convert_to_assignments_aux:nn { nV }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_find_global:}
%\begin{macro}[aux]{\xtemplate_find_global_aux:w}
% Global assignments should have the phrase ``global'' at the front. 
% This is pretty easy to find: no other error checking, though.
%    \begin{macrocode}
\cs_new_nopar:Nn \xtemplate_find_global: {
  \bool_set_false:N \l_xtemplate_global_bool
  \tl_if_in:VnT \l_xtemplate_var_tl { global } {
    \exp_after:wN \xtemplate_find_global_aux:w \l_xtemplate_var_tl \q_stop
  }
}
\cs_new:Npn \xtemplate_find_global_aux:w  #1 global #2 \q_stop {
  \tl_set:Nn \l_xtemplate_var_tl {#2}
  \bool_set_true:N \l_xtemplate_global_bool
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsection{Using templates directly}
%
% \begin{macro}{\xtemplate_use_template:nnn}
% Directly use a template with a particular parameter setting.
% This is also picked up if used in a nested fashion inside a parameter
% list. The idea is essentially the same as creating an instance, 
% just with no saving of the result.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_use_template:nnn {
  \xtemplate_recover_defaults:n { #1 / #2 }
  \xtemplate_recover_vars:n { #1 / #2 }
  \xtemplate_parse_values:nn { #1 / #2 } {#3}
  \xtemplate_convert_to_assignments:
  \use:c { \c_xtemplate_code_root_tl #1 / #2 :w  }
}
%    \end{macrocode}
% \end{macro}
%
%\subsubsection{Assigning values to variables}
%
%\begin{macro}{\xtemplate_assign_boolean:}
%\begin{macro}[aux]{\xtemplate_assign_boolean_aux:n}
% Setting a Boolean value is slightly different to everything else 
% as the value can be used to work out which \texttt{set} function to
% call. As long as there is no need to recover things from another 
% variable, everything is pretty easy.
%    \begin{macrocode}
\cs_new_nopar:Nn \xtemplate_assign_boolean: {
  \bool_if:NTF \l_xtemplate_global_bool {
    \xtemplate_assign_boolean_aux:n { bool_gset }
  }{
    \xtemplate_assign_boolean_aux:n { bool_set }
  }
}
\cs_new_nopar:Nn \xtemplate_assign_boolean_aux:n {
  \xtemplate_if_key_value:VT \l_xtemplate_value_tl {
    \xtemplate_key_to_value:
  }
  \toks_put_left:Nx \l_xtemplate_assignments_toks {
    \exp_not:c { #1 _ \l_xtemplate_value_tl :N }
    \exp_not:V \l_xtemplate_var_tl
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_assign_choice:}
% Assigning a choice is actually trivial: the code needed will
% be in \cs{l_xtemplate_value_tl}, and is simply copied to the correct
% place.
%    \begin{macrocode}
\cs_new_nopar:Nn \xtemplate_assign_choice: {
  \toks_put_left:NV \l_xtemplate_assignments_toks \l_xtemplate_value_tl
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_assign_code:}
%\begin{macro}{\xtemplate_assign_code:n}
% Assigning general code to a key needs a scratch function to be created
% and run when \cs{DoParameterAssignment} is called. So the appropriate
% definition then use is created in the toks.
%    \begin{macrocode}
\cs_new_nopar:Nn \xtemplate_assign_code: {
  \toks_put_left:Nx \l_xtemplate_assignments_toks {
    \exp_not:N \cs_set:Nn \exp_not:N \xtemplate_assign_code:n {
      \exp_not:V \l_xtemplate_var_tl
    }
    \exp_not:N \xtemplate_assign_code:n
      { \exp_not:V \l_xtemplate_value_tl }
  }
}
\cs_new:Nn \xtemplate_assign_code:n { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_assign_function:}
%\begin{macro}[aux]{\xtemplate_assign_function_aux:N}
% For functions, the toks needs to have a cs-generation step created.
% This looks a bit messy but is only actually one function.
%    \begin{macrocode}
\cs_new_nopar:Nn \xtemplate_assign_function: {
  \bool_if:NTF \l_xtemplate_global_bool {
    \xtemplate_assign_function_aux:N \cs_gset:Npn
  }{
    \xtemplate_assign_function_aux:N \cs_set:Npn
  }
}
\cs_new_nopar:Nn \xtemplate_assign_function_aux:N {
  \toks_put_left:Nx \l_xtemplate_assignments_toks {
    \exp_not:N \cs_generate_from_arg_count:NNnn
      \exp_not:V \l_xtemplate_var_tl
      \exp_not:N #1
      { \exp_not:V \l_xtemplate_keytype_arg_tl }
      { \exp_not:V \l_xtemplate_value_tl }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_assign_instance:}
%\begin{macro}[aux]{\xtemplate_assign_instance_aux:N}
% Using an instance means adding the appropriate function creation to
% the toks. No checks are made at this stage, so if the instance is 
% not valid then errors will arise later.
%    \begin{macrocode}
\cs_new_nopar:Nn \xtemplate_assign_instance: {
  \bool_if:NTF \l_xtemplate_global_bool {
    \xtemplate_assign_instance_aux:N \cs_gset:Npn
  }{
    \xtemplate_assign_instance_aux:N \cs_set:Npn
  }
}
\cs_new_nopar:Nn \xtemplate_assign_instance_aux:N {
  \toks_put_left:Nx \l_xtemplate_assignments_toks {
    \exp_not:N #1 \exp_not:V \l_xtemplate_var_tl {
      \exp_not:N \xtemplate_use_instance:nn
        { \exp_not:V \l_xtemplate_keytype_arg_tl }
        { \exp_not:V \l_xtemplate_value_tl }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_assign_integer:}
%\begin{macro}{\xtemplate_assign_length:}
%\begin{macro}{\xtemplate_assign_skip:}
% All of the calculated assignments use the same underlying code, with
% only the low-level assignment function changing.
%    \begin{macrocode}
\cs_new_nopar:Nn \xtemplate_assign_integer: {
  \bool_if:NTF \l_xtemplate_global_bool {
    \xtemplate_assign_variable:N \int_gset:Nn
  }{
    \xtemplate_assign_variable:N \int_set:Nn
  }
}
\cs_new_nopar:Nn \xtemplate_assign_length: {
  \bool_if:NTF \l_xtemplate_global_bool {
    \xtemplate_assign_variable:N \dim_gset:Nn
  }{
    \xtemplate_assign_variable:N \dim_set:Nn
  }
}
\cs_new_nopar:Nn \xtemplate_assign_skip: {
  \bool_if:NTF \l_xtemplate_global_bool {
    \xtemplate_assign_variable:N \skip_gset:Nn
  }{
    \xtemplate_assign_variable:N \skip_set:Nn
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_assign_tokenlist:}
%\begin{macro}{\xtemplate_assign_commalist:}
%\begin{macro}[aux]{\xtemplate_assign_tokenlist_aux:N}
% Storing lists of tokens is easy: no complex calculations and no
% need to worry about numbers of arguments. The comma list version
% takes advantage of the low-level implementation of the variable type
% to keep down code duplication.
%    \begin{macrocode}
\cs_new_nopar:Nn \xtemplate_assign_tokenlist: {
  \bool_if:NTF \l_xtemplate_global_bool {
    \xtemplate_assign_tokenlist_aux:N \tl_gset:Nn
  }{
    \xtemplate_assign_tokenlist_aux:N \tl_set:Nn
  }
}
\cs_new_eq:NN \xtemplate_assign_commalist:
  \xtemplate_assign_tokenlist:
\cs_new_nopar:Nn \xtemplate_assign_tokenlist_aux:N {
  \toks_put_left:Nx \l_xtemplate_assignments_toks {
    \exp_not:N #1 \exp_not:V \l_xtemplate_var_tl 
      { \exp_not:V \l_xtemplate_value_tl }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_assign_variable:N}
% A general-purpose function for all of the numerical assignments. 
% As long as the value is not coming from another variable, the stored
% value is simply transferred for output.
%    \begin{macrocode}
\cs_new_nopar:Nn \xtemplate_assign_variable:N {
  \xtemplate_if_key_value:VT \l_xtemplate_value_tl {
    \xtemplate_key_to_value:
  }
  \toks_put_left:Nx \l_xtemplate_assignments_toks {
    \exp_not:N #1 \exp_not:V \l_xtemplate_var_tl 
       { \exp_not:V \l_xtemplate_value_tl }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_key_to_value:}
%\begin{macro}[aux]{\xtemplate_key_to_value_aux:w}
% The idea here is to recover the attribute value of another key. To
% do that, the marker is removed and a look up takes place. If this
% is successful, then the name of the variable of the attribute is 
% returned. This assumes that the value will be used in context where
% it will be converted to a value, for example when setting a number.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_key_to_value: {
  \exp_after:wN \xtemplate_key_to_value_aux:w \l_xtemplate_value_tl
}
\cs_new:Npn \xtemplate_key_to_value_aux:w \KeyValue #1 {
  \tl_set:Nx \l_xtemplate_tmp_tl { \tl_to_str:n {#1} }
  \tl_replace_all_in:Nnn \l_xtemplate_key_name_tl { ~ } { }
  \prop_if_in:NVTF \l_xtemplate_vars_prop \l_xtemplate_tmp_tl {
    \prop_get:NVN \l_xtemplate_vars_prop \l_xtemplate_tmp_tl
       \l_xtemplate_value_tl
  }{
    \msg_error:nnx { xtemplate } { unknown-attribute } 
      { \l_xtemplate_tmp_tl }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsubsection{Using instances}
%
%\begin{macro}{\xtemplate_use_instance:nn}
%\begin{macro}[aux]{\xtemplate_use_instance_aux:nNnnn}
%\begin{macro}[aux]{\xtemplate_use_instance_aux:nn}
% Using an instance is just a question of finding the appropriate
% function. There is the possibility that a collection instance exists,
% so this is checked before trying the general instance. If nothing is
% found, an error is raised. One additional complication is that
% if the first token of argument |#2| is \cs{UseTemplate} then that
% is also valid. There is an error-test to make sure that the
% types agree, and if so the template is used directly.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_use_instance:nn {
  \xtemplate_if_use_template:nTF {#2} {
    \xtemplate_use_instance_aux:nNnnn {#1} #2 
  }{
    \xtemplate_use_instance_aux:nn {#1} {#2}
  }
}
\cs_new:Nn \xtemplate_use_instance_aux:nNnnn {
  \tl_if_eq:nnTF {#1} {#3} {
    \xtemplate_use_template:nnn {#3} {#4} {#5}
  }{
    \msg_error:nnnn { xtemplate } { type-mismatch } {#1} {#3}
  }
}
\cs_new:Nn \xtemplate_use_instance_aux:nn {
  \xtemplate_get_collection:n {#1}
  \xtemplate_if_instance_exist:nnnTF 
    {#1} { \l_xtemplate_collection_tl } {#2} {
    \use:c { 
      \c_xtemplate_instances_root_tl #1 / \l_xtemplate_collection_tl /#2 
      :w
    }
  }{
    \xtemplate_if_instance_exist:nnnTF {#1} { } {#2} {
      \use:c { \c_xtemplate_instances_root_tl #1 / / #2 :w }
    }{
      \msg_error:nnxx { xtemplate } { unknown-instance } {#1} {#2}
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xtemplate_use_collection:nn}
% Switching to an instance collection is just a question of setting the
% appropriate list.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_use_collection:nn {
  \prop_put:Nnn \l_xtemplate_collections_prop {#1} {#2}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_get_collection:n}
% Recovering the collection for a given type is pretty easy: just a read
% from the list.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_get_collection:n {
  \prop_if_in:NnTF \l_xtemplate_collections_prop {#1} {
    \prop_get:NnN \l_xtemplate_collections_prop {#1} 
      \l_xtemplate_collection_tl
  }{
    \tl_clear:N \l_xtemplate_collection_tl
  }
}
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Assignment manipulation}
%
% A few functions to transfer assignments about, as this is needed by
% \cs{DoParameterAssignments}.
% 
%\begin{macro}{\xtemplate_assignments_pop:}
% To actually use the assignments.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_assignments_pop: {
  \toks_use:N \l_xtemplate_assignments_toks 
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_assignments_push:n}
% Here, the assignments are stored for later use.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_assignments_push:n {
  \toks_set:Nn \l_xtemplate_assignments_toks {#1}
}
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Showing templates and instances}
%
%\begin{macro}{\xtemplate_show_code:nn}
% Showing the code for a template is just a translation of 
% \cs{cs_show:c}.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_show_code:nn {
  \cs_show:c { \c_xtemplate_code_root_tl #1 / #2 :w }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xtemplate_show_defaults:nn}
%\begin{macro}{\xtemplate_show_keytypes:nn}
%\begin{macro}{\xtemplate_show_values:nnn}
%\begin{macro}{\xtemplate_show_vars:nn}
% Showing the internal data is a case of getting the appropriate 
% property list back, then displaying the scratch variable.
%    \begin{macrocode}
\cs_new:Nn \xtemplate_show_defaults:nn {
  \xtemplate_recover_defaults:n { #1 / #2 }
  \prop_display:N \l_xtemplate_values_prop
}
\cs_new:Nn \xtemplate_show_keytypes:nn {
  \xtemplate_recover_keytypes:n { #1 / #2 }
  \prop_display:N \l_xtemplate_keytypes_prop
}
\cs_new:Nn \xtemplate_show_values:nnn {
  \xtemplate_recover_values:n { #1 / #2 / #3 }
  \prop_display:N \l_xtemplate_values_prop
}
\cs_new:Nn \xtemplate_show_vars:nn {
  \xtemplate_recover_vars:n { #1 / #2 }
  \prop_display:N \l_xtemplate_vars_prop
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\subsubsection{Messages}
%
%    \begin{macrocode}
\msg_new:nnn { xtemplate } { bad-arg-count } {%
  Template type `#1' does not take #2 arguments.%
}
\msg_new:nnn { xtemplate } { bad-choice } {%
  The choice `#1' was not declared for key `#2'.%
}
\msg_new:nnn { xtemplate } { bad-variable } {%
  The argument `#1'\\%
  is not of the form `<variable>' or `global <variable>'.%
}
\msg_new:nnnn { xtemplate } { choice-unknown-reserved } {%
  The choice `unknown' is reserved, and should not be included in\\%
  the list given for a choice key.
}{%
  The `unknown' choice is automatically checked by template when\\%
  a choice key is given with an unknown value. It should not be\\%
  included in the list of named choices for a key, and is always\\%
  given last in the implementation of choices.%
}
\msg_new:nnnn { xtemplate } { code-no-keys } {%
  No key definitions for template `#2' of type `#1'.%
}{%
  You have probably given \token_to_str:N \DeclareTemplateCode \\%
  before giving \token_to_str:N \DeclareTemplateInterface.%
}
\msg_new:nnn { xtemplate } { invalid-keytype } {%
  The keytype `#1' is not valid.%
}
\msg_new:nnn { xtemplate } { key-no-code } {%
  The key `#1' has no implementation given.%
}
\msg_new:nnn { xtemplate } { key-no-variable } {%
  The key `#1' requires implementation details.%
}
\msg_new:nnn { xtemplate } { key-not-implemented } {%
  The interface declaration for template #1\\%
  includes the key `#2', but no implementation\\%
  has been provided for this key.%
}
\msg_new:nnn { xtemplate } { key-no-value } {%
  The key `#1' has no value.%
}
\msg_new:nnn { xtemplate } { key-not-declared } {%
  An implementation was given for key `#1',\\%
  but it was never declared.%
}
\msg_new:nnn { xtemplate } { no-keytype } {%
  The key description `#1' does not contain a keytype.%
}
\msg_new:nnn { xtemplate } { non-implemented-choices } {%
  The choices `#1' have no implementation.%
}
\msg_new:nnnn { xtemplate } { too-many-arguments } {%
  Too many arguments requested for object type `#1'.%
}{%
  An object may accept between 0 and 9 arguments.\\%
  You asked to use #2 arguments: this is not supported.%
}
\msg_new:nnnn { xtemplate } { type-mismatch } {%
  Object types `#1' and `#2' do not agree.%
}{%
  You are trying to use a template directly with 
  \token_to_str:N \UseInstance \\%
  (or a similar function), but the object types do not match.%
}
\msg_new:nnnn { xtemplate } { undeclared-variable } {%
  The variable #1 has not been declared.%
}{%  
  Before declaring an instance, all of the required variables\\%
  used in template keys must be created.%
}
\msg_new:nnn { xtemplate } { unknown-key } {%
  The key `#1' is unknown.%
}
\msg_new:nnnn { xtemplate } { unknown-attribute } {%
  The attribute `#1' is unknown.%
}{%
  There is a definition in the current template reading\\%
  \token_to_str:N \KeyValue 
  \token_to_str:N { #1 \token_to_str:N }\\%
  but there is no key called `#1'.%
}
\msg_new:nnn { xtemplate } { unknown-choice } {%
  The choice `#1' for key `#2' is unknown.%
}
\msg_new:nnn { xtemplate } { unknown-instance } {%
  The instance `#2' of type `#1' is unknown.%
}
\msg_new:nnn { xtemplate } { unknown-template } {%
  The template `#2' of type `#1' is unknown.%
}
\msg_new:nnn { xtemplate } { unknown-object-type } {%
  The object type `#1' is unknown.%
}
%    \end{macrocode}
%    
%\subsubsection{User functions}
%
% The user functions provided by \pkg{xtemplate} are pretty much direct
% copies of internal ones. However, by sticking to the \pkg{xparse}
% approach only the appropriate arguments are long.
% 
%\begin{macro}{\DeclareObjectType}
%\begin{macro}{\DeclareTemplateInterface}
%\begin{macro}{\DeclareTemplateCode}
%\begin{macro}{\DeclareRestrictedTemplate}
%\begin{macro}{\EditTemplateDefaults}
%\begin{macro}{\DeclareInstance}
%\begin{macro}{\DeclareCollectionInstance}
%\begin{macro}{\EditInstance}
%\begin{macro}{\EditCollectionInstance}
%\begin{macro}{\UseTemplate}
%\begin{macro}{\UseInstance}
%\begin{macro}{\UseCollection}
% All simple translations, with the appropriate long/short argument
% filtering.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \DeclareObjectType #1#2 {
  \xtemplate_declare_object_type:nn {#1} {#2}
}
\cs_new_protected:Npn \DeclareTemplateInterface #1#2#3#4 {
  \xtemplate_declare_template_keys:nnnn {#1} {#2} {#3} {#4}
}
\cs_new_protected:Npn \DeclareTemplateCode #1#2#3#4#5 {
  \xtemplate_declare_template_code:nnnnn {#1} {#2} {#3} {#4} {#5}
}
\cs_new_protected:Npn \DeclareRestrictedTemplate #1#2#3#4 {
  \xtemplate_declare_restricted:nnnn {#1} {#2} {#3} {#4}
}
\cs_new_protected:Npn \DeclareInstance #1#2#3#4 {
  \xtemplate_declare_instance:nnnnn {#1} {#3} { } {#2} {#4} 
}
\cs_new_protected:Npn \DeclareCollectionInstance #1#2#3#4#5 {
  \xtemplate_declare_instance:nnnnn {#2} {#4} {#1} {#3} {#5}
}
\cs_new_protected:Npn \EditTemplateDefaults #1#2#3 {
  \xtemplate_edit_defaults:nnn {#1} {#2} {#3}
}
\cs_new_protected:Npn \EditInstance #1#2#3#4 {
  \xtemplate_edit_instance:nnnnn {#1} {#3} { } {#2} {#4} 
}
\cs_new_protected:Npn \EditCollectionInstance #1#2#3#4#5 {
  \xtemplate_edit_instance:nnnnn {#2} {#4} {#1} {#3} {#5}
}
\cs_new_protected_nopar:Npn \UseTemplate #1#2#3 {
  \xtemplate_use_template:nnn {#1} {#2} {#3}
}
\cs_new_protected_nopar:Npn \UseInstance #1#2 {
  \xtemplate_use_instance:nn {#1} {#2}
}
\cs_new_protected_nopar:Npn \UseCollection #1#2 {
  \xtemplate_use_collection:nn {#1} {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\ShowTemplateCode}
%\begin{macro}{\ShowTemplateDefaults}
%\begin{macro}{\ShowTemplateKeytypes}
%\begin{macro}{\ShowTemplateVariables}
%\begin{macro}{\ShowInstanceValues}
%\begin{macro}{\ShowCollectionInstanceValues}
% The show functions are again just translation.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \ShowTemplateCode #1#2 {
  \xtemplate_show_code:nn {#1} {#2}
}
\cs_new_protected_nopar:Npn \ShowTemplateDefaults #1#2 {
  \xtemplate_show_defaults:nn {#1} {#2}
}
\cs_new_protected_nopar:Npn \ShowTemplateKeytypes #1#2 {
  \xtemplate_show_keytypes:nn {#1} {#2}
}
\cs_new_protected_nopar:Npn \ShowTemplateVariables #1#2 {
  \xtemplate_show_vars:nn {#1} {#2}
}
\cs_new_protected_nopar:Npn \ShowInstanceValues #1#2 {
  \xtemplate_show_values:nnn {#1} { } {#2}
}
\cs_new_protected_nopar:Npn \ShowCollectionInstanceValues #1#2#3 {
  \xtemplate_show_values:nnn {#1} {#2} {#3}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[TF]{\IfInstanceExist}
% More direct translation: only the base instance is checked for.
%    \begin{macrocode}
\cs_new_nopar:Npn \IfInstanceExistTF #1#2 {
  \xtemplate_if_instance_exist:nnnTF {#1} { } {#2} 
}
\cs_new_nopar:Npn \IfInstanceExistT #1#2  {
  \xtemplate_if_instance_exist:nnnT {#1} { } {#2} 
}
\cs_new_nopar:Npn \IfInstanceExistF #1#2  {
  \xtemplate_if_instance_exist:nnnF {#1} { } {#2}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\EvaluateNow}
%\begin{macro}{\KeyValue}
% These are both do nothing functions. Both simply dump their arguments
% when executed: this should not happen with \cs{KeyValue}.
%
% They need to be expandable as they might get called in the context of
% setting some register value.
%    \begin{macrocode}
\cs_new_protected:Npn \EvaluateNow #1 {#1}
\cs_new_protected:Npn \KeyValue #1 {#1}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\DoParameterAssignments}
% A short call to use a token register by proxy.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \DoParameterAssignments {
  \xtemplate_assignments_pop:
}
%    \end{macrocode}
%\end{macro}
%   
%
%
%\subsubsection{Recent additions to the code}
%
%  \begin{macro}{\TP_split_finite_skip_value:nnNN}
%  This macro is for use in error checking template values like
%  "text-float-sep" that can't contain infinite glue and needs the
%  shrink and/or stretch components. First argument is the skip
%  register (which is likely to be user input), second is a template
%  key name, and the last two are the \meta{dimen} registers that
%  stores the stretch and shrink components. Assignments are global.
%    \begin{macrocode}
\cs_new_nopar:Npn \TP_split_finite_skip_value:nnNN #1#2{
  \skip_split_finite_else_action:nnNN {#1} {
    \PackageError{xtemplate}{Value~ for~ key~ #2~ contains~ `fil(ll)'}
    {Only~ finite~ minus~ or~ plus~ parts~ are~ allowed~ for~ this~ key.}
  }
}
%    \end{macrocode}
%  \end{macro}
%    
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
%\PrintIndex
%
%\end{implementation}
