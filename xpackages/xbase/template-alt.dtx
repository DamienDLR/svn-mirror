% \iffalse
%% File: template-alt.dtx (C) Copyright 1999-2001 David Carlisle, Frank Mittelbach
%%                    (C) Copyright 2004-2009 Frank Mittelbach, LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xbase bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%% 
%
%<*driver|package>
\RequirePackage{l3names}
%</driver|package>
%\fi
\GetIdInfo$Id$
  {template}
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{template-alt.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{template-alt} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{\Team}
% \date{\filedate}
% \maketitle
%
%\begin{documentation}
%
%\section{Templates: prototype document functions}
%
% Many parts of the design of a document share common features. For
% example, chapters, sections, subsections and so on are all divisions
% of a document, and have features in common. A \emph{template} is 
% a generalised prototype which expresses these common design features
% as one or more parameters. Each template is then used to derive one
% or more \emph{instances}, where some of these design elements have
% been fixed (for example font size, spacing, etc.). Continuing with
% the example, a document design might provide a template
% \texttt{document-division}, with instances \texttt{chapter}, 
% \texttt{section}, \texttt{subsection} and \texttt{subsubsection}.
% To allow the instances to collect information at point of use, each
% template also can take one or more arguments: in the example, these
% might be the text for the division heading, and a division number.
% Finally, a template also needs to contain code to execute when 
% an instance is used. 
% 
% The parameters of a template are expressed as a key-value list.
% A well-designed template will need to cover a wide range of uses,
% and so may have many parameters. Continuing with the document division
% example, part of the list of parameters might read:
%\begin{verbatim} 
%  font-colour  .set:N     = \l_division_font_colour_tl,
%  font-colour  .initial:n = black,
%  font-size    .set:N     = \l_division_font_size_num,
%  font-size    .initial:N = \l_document_font_size_num,
%\end{verbatim} 
% As illustrated, many of the parameters may well be concerned with
% setting up variable values. In many case, some initial value will
% be needed, which might be a literal (such as \texttt{black} here),
% or taken from another variable such as the hypothetical 
% \cs{l_document_font_size_num}). When creating an instance, one or 
% more of these parameters will receive a value, thus fixing part
% of the design.
% 
% The template process is divided into three parts. First, a template
% must be created. This defines the code for the general class of 
% functions, and also the parameters that will alter behaviour. In the
% second stage, an instance is created. This sets one or more parameters
% of the template to fix appearance at the document level. Finally,
% one or more user functions need to be defined which actually use 
% the instance.
% 
%\subsection{Creating templates}
%
% Templates are created by creating a list of parameters and associated
% code. The parameters are given as a key-value list using key 
% properties (as in \pkg{keys3}. The properties available are detailed
% in the next section.
%
%\begin{function}{\DeclareTemplate}
%  \begin{syntax}
%    "\DeclareTemplate" <template> <num.~args> <parameters> <code>
%  \end{syntax}
%  Declares a function <template> which will accept <num.~args>.
%  The <template> is defined by the key--value list of <parameters>
%  and by the <code> that is executed on expansion. Somewhere in the
%  <code>, the <parameters> are assigned with the function
%  \cs{DoParameterAssignment}.
%\end{function}
%
%\begin{function}{\DeclareDerivedTemplate}
%  \begin{syntax}
%    "\DeclareDerivedTemplate" <template> <parent> <parameters> 
%    ~~~~<presets>
%  \end{syntax}
%  Declares a function <template> which is derived from the existing
%  <parent>. The new <template> will have the same <code> as the
%  parent. New <parameters> can be associated with the <template> that
%  do not apply to the <parent>, and keys from the <parent> can be 
%  fixed as <presets>.
%\end{function}
%
% Templates created using \cs{DeclareTemplate} and 
% \cs{DeclareDerivedTemplate} are equivalent as far as the rest of the
% process is concerned.\footnote{Internally, a template created
% using \cs{DeclareDerivedTemplate} uses the parameter definitions of
% its parent when creating instances. However, this should be
% transparent when the template is used.}
%
%\begin{function}{\DoParameterAssignments}
%  \begin{syntax}
%    "\DoParameterAssignments" 
%  \end{syntax}
%  In <code> for a <template>, marks the point where the <keyval list>
%  is parsed and assignments are made. By requiring an explicit 
%  function to assign parameters, the possibility for the <code> to
%  save or otherwise examine values which are re-assigned by the 
%  <keyval list> is opened.
%\end{function}
%
%\subsection{The parameter properties system}
%
% As in the general key--value module \pkg{keys3}, \pkg{template} uses
% one or more key \emph{properties} to define the behaviour of the 
% parameter keys. Properties with the same name act identically across
% the two modules.  Internally, \pkg{template} uses a pre-expansion 
% system to allow definitions made here to work much more rapidly than
% those defined using \pkg{keys3}.
% 
%\begin{function}{.choice:}
%  \begin{syntax}
%    <parameter> .choice:
%  \end{syntax}
%  Sets <parameter> to act as a multiple choice key. Each choice is a 
%  sub-parameter of the current parameter: this is indicated by a
%  `\texttt{/}':
%  \begin{verbatim}
%    parameter            .choice:,
%    parameter / choice-a .code:n = < code-a >,
%    parameter / choice-b .code:n = < code-b >,
%  \end{verbatim}
%  and so on.
%  \begin{texnote}
%    This is the only property in \pkg{template} which does not
%    require a value.
%  \end{texnote}
%\end{function}
% 
%\begin{function}{
%   .code:n|
%   .code:x
%  }
%  \begin{syntax}
%    <parameter> .code:n = <code>
%  \end{syntax}
%  Stores the <code> for execution when <parameter> is called. The 
%  <code> can include one argument (|#1|), which will be the <value> 
%  given for the <key>.
%\end{function}
% 
%\begin{function}{
%   .code:Nn|
%   .code:Nx
% }
%  \begin{syntax}
%    <parameter> .code:Nn = <number> <code>
%  \end{syntax}
%  Stores the <code> for execution when <parameter> is called. The 
%  <code> can include <number> arguments, which can be in the standard 
%  \TeX\ range 0--9.  For example:
%  \begin{verbatim}
%    my-special-key .code:Nn = 2 { Using~#1~and~#2 },
%  \end{verbatim}
%  If too few parameters are given when the parameter is used, 
%  sufficient empty groups will be supplied to prevent an error
%  occurring.
%\end{function}
%
%\begin{function}{.function:N}
%  \begin{syntax}
%    <parameter> .function:N = <function>
%  \end{syntax}
%  The input for <parameter> is used to define <function>, which 
%  internally uses \cs{cs_set:Nn}. The effect is the same as 
%  \texttt{<key> .code:n = \{ \cs{cs_set:Nn} <function> } |{#1}| 
%  \texttt{ \} }. The <function> should be an internal function, as the 
%  number of arguments is detected from the argument specifier. If the
%  <function> is not defined, it is initialised to empty.
%\end{function}
%
% 
%\begin{function}{
%   .generate_choices:nn|
%   .generate_choices:nx|
% }
%  \begin{syntax}
%    <parameter> .generate_choices:nn = <comma list> <code>
%  \end{syntax}
%  Makes <parameter> a multiple choice key, accepting the choices 
%  specified in <comma list>. Each choice will execute <code> if it 
%  given. Within <code>, the name of the current choice is available as 
%  \cs{l_template_choice_tl},  and its position in the <comma list> as 
%  \cs{l_template_choice_int}.
%\end{function}
%
%\begin{function}{
%  .initial:N|
%  .initial:n|
%  .initial:V
%}
%  \begin{syntax}
%    <parameter> .initial:N = <var>
%  \end{syntax}
%  Initialises <parameter> using <var>, before any assignment of
%  <parameter> from the <keyval list>. This can be used to ensure that
%  the <parameter> has a sane value, and also that it will be set 
%  even if it does not appear in the <keyval list>.
%  
%  There is a subtle but important difference between \texttt{initial:N}
%  and \texttt{initial:V}. The \texttt{V} version will collect the 
%  initial value from the variable when the template is created (in the
%  preamble). This will be appropriate for values which are set early
%  on in a document, then do not change. On the other hand, the 
%  \texttt{N} variant collects the value from the variable when the
%  instance is used. This is intended for using dynamic values for the
%  initialisation. For example
%  \begin{verbatim}
%    key .set:N     = \l_key_tl,
%    key .initial:V = \l_some_tl
%  \end{verbatim}
%  will set \cs{l_key_tl} to whatever \cs{l_some_tl} contains at the
%  time the template is declared. On the other hand, 
%  \begin{verbatim}
%    key .set:N     = \l_key_tl,
%    key .initial:N = \l_some_tl
%  \end{verbatim}
%  will set \cs{l_key_tl} to what \cs{l_some_tl} contains when the 
%  template is used (in the document body).
%\end{function} 
%
%\begin{function}{.instance:nN}
%  \begin{syntax}
%    <parameter> .instance:nN = <template> <function>
%  \end{syntax}
%  <Parameter> will set a <function> which expands to \cs{UseInstance}
%  \texttt{\{<template>\}} |{#1}|, where |#1| is the value passed when
%  setting the parameter.
%\end{function}
%
%\begin{function}{
%   .set:N|
%   .set_x:N
%}
%  \begin{syntax}
%    <parameter> .set:N = <variable>
%  \end{syntax}
%  Defines <parameter> to store the value given in <variable>. The 
%  type and scope (local or global) of <variable> are determined from 
%  the name. The \texttt{x} version performs an expanded assignment. For
%  example
%  \begin{verbatim}
%    key-one .set:N = \l_module_tmpa_tl,  % Locally sets a tl var.
%    key_two .set:N = \g_module_tmpa_toks % Globally sets a toks.
%  \end{verbatim}
%  Assignments are automatically global for global variables. 
%  
%  A  \cs{<variable>_set:Nn} function must exist to allow setting of the
%  <variable>. An error will result if this is not the case. The 
%  \texttt{.set_x:N} version can only be applied to variable types which
%  have a \cs{<variable>_set:Nx} function: other cases will result in an 
%  error.
%\end{function}
%
%\begin{function}{
%   .set_bool:N|
%   .set_bool_inverse:N|
% }
%  \begin{syntax}
%    <parameter> .set_bool:N = <bool>
%    <parameter> .set_bool_inverse:N = <bool>
%  \end{syntax}
%  Defines <parameter> to set <bool> to <value> (which must be either 
%  \texttt{true} or \texttt{false}). The \texttt{inverse} version sets
%  the switch to the opposite logical sense to the argument given.
%\end{function}
%
%\subsection{Creating instances}
%
% Templates can only be used as instances, where one or more parameters
% are fixed. This separation is intended to remind the designer of the
% purpose of the template system!
%
%\begin{function}{\DeclareInstance}
%  \begin{syntax}
%    "\DeclareInstance" <instance> <template> <keyval list> 
%  \end{syntax}
%  Create <instance> of <template>, with settings as described in the
%  <keyval list>. The <keyval list> is parsed at the point that
%  the <instance> is declared, and is stored internally in an optimised
%  format.
%\end{function}
%
%\subsection{Using instances}
%
%
%\begin{function}{\UseInstance}
%  \begin{syntax}
%    "\UseInstance" <instance> <template> 
%  \end{syntax}
%  Use <instance> of <template>. In general, at the user level this
%  will be wrapped up inside a function declared using the \pkg{xparse}
%  interface. For example, for an instance of a template which takes
%  one argument, the code might read:
%  \begin{verbatim}
%    \DeclareDocumentCommand \Example { m } {
%      \UseInstance { instance } { template } {#1}
%    }
%  \end{verbatim}
%\end{function}
%
%\subsection{An example template}
%
% A well-designed template will have to cater for a wide range of
% possible variable items. Deciding on these will require a good deal of
% thought and probably several design cycles. Taking the example
% of document divisions, items such as font, positioning and surrounding
% white space are immediately obvious. As a result, a real template
% is likely to be very long, or designed using a series of
% \cs{DeclareDerivedTemplate} calls. The basics of a rather simplified
% template for document divisions might read as follows:
%\begin{verbatim}
%  \DeclareTemplate { document-division } 3 {
%  
%    alignment     .set:N     = \l_doc_div_alignment_tl,
%    alignment     .initial:n = left,
%  
%    % In a real template, these next settings would 
%    % probably be set separately for different parts of 
%    % a division title, with short-cuts for setting all
%    % in one go to the same value.
%    
%    font-name     .set:N     = \l_doc_div_font_name_tl,
%    font-name     .initial:N = \l_doc_font_name_tl, 
%    font-shape    .choice:,
%    font-shape / italic .code:n = 
%      { \cs_set_eq:NN \doc_div_font_shape: \itshape },
%    font-shape / upright .code:n = 
%      { \cs_set_eq:NN \doc_div_font_shape: \upshape },
%    font-shape    .initial:n = \upshape, 
%    font-size     .set:N     = \l_doc_div_font_size_num,
%    font-size     .initial:N = \l_doc_font_size_num,
%    font-weight   .choice:,
%    font-weight / bold .code:n = 
%      { \cs_set_eq:NN \doc_div_font_weight: \bfseries },
%    font-weight / mid .code:n = 
%      { \cs_set_eq:NN \doc_div_font_weight: \mdseries },
%    font-weight   .initial:n = \bfseries,
%    
%    number-format .choice:,
%    number-format / alpha .code:n = 
%      { \cs_set_eq:NN \doc_div_num_format:n \alpha },
%    number-format / Alpha.code:n = 
%     { \cs_set_eq:NN \doc_div_num_format:n \Alpha },
%    number-format / arabic .code:n = 
%      { \cs_set_eq:NN \doc_div_num_format:n \use_i:n },
%    number-format / roman .code:n = 
%     { \cs_set_eq:NN \doc_div_num_format:n \roman },
%    number-format / Roman .code:n = 
%      { \cs_set_eq:NN \doc_div_num_format:n \Roman }, 
%    number-show   .set_bool:N = \l_doc_div_number_show_bool,
%    
%    space-above   .set:N     = \l_doc_div_space_above_skip,
%    space-above   .initial:n = 0 pt,
%    space-below   .set:N     = \l_doc_div_space_below_skip,
%    space-below   .initial:n = 0 pt,
%    space-left    .set:N     = \l_doc_div_space_left_skip,
%    space-left    .initial:n = 0 pt,
%    space_right   .set:N     = \l_doc_div_space_right_skip,
%    space-right   .initial:n = 0 pt,
%  } {
%    % To be decided, using
%    % #1 = Long text
%    % #2 = Short text 
%    % #3 = Number
%  }
%\end{verbatim}
%
%\subsection{Internal functions}
%
%\begin{function}{\template_arguments_tidy:w}
%  \begin{syntax}
%    "\template_arguments_tidy:w" <args> "\q_template_stop"
%  \end{syntax}
%  Tidies up code used to prevent run-away arguments.
%\end{function}
%
%\begin{function}{\template_assignments_push:n}
%  \begin{syntax}
%    "\template_assignments_push:n" <assignments>
%  \end{syntax}
%  Pushes <assignments> to the tack to be used by
%  \cs{DoParameterAssignments}.
%\end{function}
%
%\begin{function}{
%    \template_bool_set:N |
%    \template_bool_set_inverse:N
%}
%  \begin{syntax}
%    "\template_bool_set:N" <bool>
%  \end{syntax}
%  Creates code to set <bool> when <parameter> is given.
%\end{function}
%
%\begin{function}{
%  \template_choice_find_now:n|
%  \template_choice_find_save:n
%}
%  \begin{syntax}
%    "\template_choice_find_now:n" <choice>
%  \end{syntax}
%  Searches for <choice> as a sub-parameter of <parameter>. The
%  \texttt{now} version is for setting initial values, the 
%  \texttt{save} version for setting items in an instance.
%\end{function}
%
%\begin{function}{\template_choice_make:}
%  \begin{syntax}
%    "\template_choice_make:" 
%  \end{syntax}
%  Makes <parameter> a choice key.
%\end{function}
%
%\begin{function}{
%  \template_choice_unknown:n|
%  \template_choice_unknown_direct:n
%}
%  \begin{syntax}
%    "\template_choice_unknown:n" <choice>
%  \end{syntax}
%  Ready-to-use functions for unknown choices.
%\end{function}
%
%\begin{function}{\template_choices_generate:nx}
%   \begin{syntax}
%     "\template_choices_generate:nx" <comma list> <code>
%   \end{syntax}
%   Makes <comma list> choices for <parameter>, each using <code>.
%\end{function}
%
%\begin{function}{\template_declare:nNnn}
%  \begin{syntax}
%    "\template_declare:nNnn" 
%    ~~~~<template> <num.~args> <parameters> <code>
%  \end{syntax}
%  Declares a function <template> which will accept <num.~args>.
%  The <template> is defined by the key--value list of <parameters>
%  and by the <code> that is executed on expansion.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareTemplate}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\template_declare_derived:nnnn}
%  \begin{syntax}
%    "\template_declare:nNnn" 
%    ~~~~<template> <parent> <parameters> <presets>
%  \end{syntax}
%  Declares a function <template> based on <parent> template. New 
%  <parameters> can be created, and some of the keys of the <parent>
%  can be fixed using the <presets>.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareDerivedTemplate}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\template_instance_declare:nnn}
%  \begin{syntax}
%    "\template_instance_declare:nnn" 
%    ~~~~<instance> <template> <keyval list> 
%  \end{syntax}
%  Create <instance> of <template>, with settings as described in the
%  <keyval list>.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareInstance}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{
%  \template_initial_value:N|
%  \template_initial_value:n|
%  \template_initial_value:V
%}
%  \begin{syntax}
%    "\template_initial_value:N" <var>
%  \end{syntax}
%  Store <var> as the initial value for a parameter.
%\end{function}
%
%\begin{function}{\template_instance_use:nn}
%  \begin{syntax}
%    "\template_instance_use:nn" <instance> <template> 
%  \end{syntax}
%  Use <instance> of <template>.
%  \begin{texnote}
%    This is the internal name for \cs{UseInstance}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{
%  \template_key_cmd_set:nNn|
%  \template_key_cmd_set:nNx
%}
%  \begin{syntax}
%    "\template_key_cmd_set:nNn" <key> <num.~args> <code>
%  \end{syntax}
%  Create a command to execute <key>, taking <num.~args> and 
%  expanding to <code>.
%\end{function}
%
%\begin{function}{\template_key_define:n}
%   \begin{syntax}
%     "\template_key_define:n" <parameter>
%   \end{syntax}
%   Makes a <parameter> based on the current <property>.
%\end{function}
%
%\begin{function}{
%    \template_keys_assign_elt:n |
%    \template_keys_assign_elt:nn
%}
%   \begin{syntax}
%     "\template_keys_assign_elt:n" <key> <value>
%   \end{syntax}
%   Processing functions for key--value pairs when assigning keys.
%\end{function}
%
%\begin{function}{\template_keys_assign:nn}
%  \begin{syntax}
%    "\template_keys_assign:nn" <template> <keyval list>
%  \end{syntax}
%  Parses the <keyval list> and creates assignments using parameters
%  for the <template> chosen.
%\end{function}
%
%\begin{function}{\template_keys_define:nn}
%  \begin{syntax}
%    "\template_keys_define:nn" <template> <parameters>
%  \end{syntax}
%  Parses the <parameters> and defines the keys listed there for
%  <template>.
%\end{function}
%
%\begin{function}{
%    \template_keys_define_elt:n |
%    \template_keys_define_elt:nn
%}
%   \begin{syntax}
%     "\template_keys_define_elt:n" <key> <value>
%   \end{syntax}
%   Processing functions for key--value pairs when defining keys.
%\end{function}
%
%\begin{function}{\template_parameters_assign:}
%  \begin{syntax}
%    "\template_parameters_assign:" 
%  \end{syntax}
%  In <code> for a <template>, marks the point where the <keyval list>
%  is parsed and assignments are made.
%  \begin{texnote}
%    This is the internal name for \cs{DoParameterAssignments}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\template_property_find:n}
%   \begin{syntax}
%     "\template_property_find:n" <key>
%   \end{syntax}
%   Separates <key> from <property>.
%\end{function}
%
%\begin{function}{\template_property_new:nn}
%   \begin{syntax}
%     "\template_property_new:nn" <property> <code>
%   \end{syntax}
%   Makes a new <property> expanding to <code>
%\end{function}
%
%\begin{function}{\template_tmp:w}
%   \begin{syntax}
%     "\template_tmp:w" <args>
%   \end{syntax}
%   Used to store <code> to execute a <property>.
%\end{function}
%
%\begin{function}{\template_variable_set:NN}
%   \begin{syntax}
%     "\template_variable_set:NN" <expansion> <var>
%   \end{syntax}
%   Sets <parameter> to assign <value> to <variable>
%\end{function}
%
%\subsection{Variables and constants}
%
%\begin{variable}{\c_template_extra_properties_clist}
%  List of \pkg{template}-only properties for keys.
%\end{variable}
%
%\begin{variable}{
%  \c_template_root_tl|
%  \c_template_keys_root_tl|
%  \c_template_properties_root_tl|
%}
%  Locations for the various items stored by \pkg{template}.
%\end{variable}
%
%\begin{variable}{
%  \l_template_assignments_toks|
%  \l_template_initial_toks
%}
%  Token registers for recording key settings.
%\end{variable}
%
%\begin{variable}{
%  \l_template_choice_tl|
%  \l_template_choice_int|
%}
%  Available inside an automatically-generated set of choices to 
%  indicate which choice was made.
%\end{variable}
%
%\begin{variable}{\l_template_inheritance_prop}
%  A list of template parents.
%\end{variable}
%
%\begin{variable}{\l_template_initials_tl}
%  Used to build up list for initialisation values.
%\end{variable}
%
%\begin{variable}{\l_template_key_tl}
%  Name of the current key, when needed separated from the path.
%\end{variable}
%
%\begin{variable}{
%  \l_template_name_tl|
%  \l_template_path_tl|
%  \l_template_property_tl
%}
%  Various key paths need to be stored.
%\end{variable}
%
%\begin{variable}{\l_template_parent_tl}
%  Used when checking for derived templates.
%\end{variable}
%
%\begin{variable}{\q_template_stop}
%  A private quark for delimiting key arguments.
%\end{variable}
%
%\end{documentation}
% 
%\begin{implementation}
%
%\subsection{Implementation}
%
% The usual lead-off.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
\RequirePackage{expl3,keys3,xparse-alt}
%</package>
%<*initex|package>
%    \end{macrocode}
%    
%\subsubsection{Variables and constants}
%
%\begin{macro}{\l_template_assignments_toks}
%\begin{macro}{\l_template_initial_toks}
% For creating the list of assignments and initial values.
%    \begin{macrocode}
\toks_new:N \l_template_assignments_toks
\toks_new:N \l_template_initial_toks
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\c_template_extra_properties_clist}
% The extra properties for templates.
%    \begin{macrocode}
\clist_new:N \c_template_extra_properties_clist
\clist_put_left:Nn \c_template_extra_properties_clist {
  initial:N, 
  initial:n, 
  initial:V
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\c_template_root_tl}
%\begin{macro}{\c_template_keys_root_tl}
%\begin{macro}{\c_template_properties_root_tl}
% Various roots for storage.
%    \begin{macrocode}
\tl_new:Nn \c_template_root_tl               { template~>~ }
\tl_new:Nn \c_template_keys_root_tl          { template_keys~>~ }
\tl_new:Nn \c_template_properties_root_tl    { template_properties~>~ }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_template_choice_int}
%\begin{macro}{\l_template_choice_tl}
% Used for the multiple choice system.
%    \begin{macrocode}
\int_new:N \l_template_choice_int
\tl_new:N \l_template_choice_tl
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_template_inheritance_prop}
% To track template inheritance.
%    \begin{macrocode}
\prop_new:N \l_template_inheritance_prop
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_template_initials_tl}
% For building up the list of initial values.
%    \begin{macrocode}
\tl_new:N \l_template_initials_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_template_key_tl}
% The \pkg{template} system needs to separate key and path, and to store
% the result.
%    \begin{macrocode}
\tl_new:N \l_template_key_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_template_name_tl}
% The name of the current template.
%    \begin{macrocode}
\tl_new:N \l_template_name_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_template_parent_tl}
% The parent of a template.
%    \begin{macrocode}
\tl_new:N \l_template_parent_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_template_path_tl}
%\begin{macro}{\l_template_property_tl}
% When setting keys, the property name and path are separated.
%    \begin{macrocode}
\tl_new:N \l_template_path_tl
\tl_new:N \l_template_property_tl
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\q_template_stop}
% A quark for delimiting keys: no one else should use it!
%    \begin{macrocode}
\quark_new:N \q_template_stop
%    \end{macrocode}
%\end{macro}
%    
%\subsubsection{Internal commands}
%
%\begin{macro}{\template_arguments_tidy:w}
% So that nothing runs away, a safety precaution is taken in the code.
%    \begin{macrocode}
\cs_new:Npn \template_arguments_tidy:w #1 \q_template_stop { }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_assignments_push:n}
%    \begin{macrocode}
\cs_new:Nn \template_assignments_push:n {
  \toks_set:Nn \l_template_assignments_toks {#1}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_bool_set:N}
%\begin{macro}{\template_bool_set_inverse:N}
%\begin{macro}[aux]{\template_bool_set_aux:N}
% Boolean keys are really just choices, but all done by hand. In this
% way, things expand nicely.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_bool_set:N {
  \template_key_cmd_set:nNx { \l_template_path_tl / true } 1 {
    \exp_not:c { bool_ \keys_variable_get_scope:N #1 set_true:N } 
      \exp_not:N #1
  }
  \template_key_cmd_set:nNx { \l_template_path_tl / false } 1 {
    \exp_not:N \use:c 
      { bool_ \keys_variable_get_scope:N #1 set_false:N } 
      \exp_not:N #1
  }
  \template_bool_set_aux:N #1
}
\cs_new_nopar:Nn \template_bool_set_inverse:N {
  \template_key_cmd_set:nNx { \l_template_path_tl / true } 1 {
    \exp_not:c { bool_ \keys_variable_get_scope:N #1 set_false:N }
      \exp_not:N #1
  }
  \template_key_cmd_set:nNx { \l_template_path_tl / false } 1 {
    \exp_not:c { bool_ \keys_variable_get_scope:N #1 set_true:N }
      \exp_not:N #1
  }
  \template_bool_set_aux:N #1
}
\cs_new_nopar:Nn \template_bool_set_aux:N {
  \template_choice_make:
  \cs_if_exist:NF #1 {
    \bool_new:N #1
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_choice_find_now:n}
%\begin{macro}{\template_choice_find_save:n}
% Finding a multiple choice is easy: saving it looks a little complex!
%    \begin{macrocode}
\cs_new_nopar:Nn \template_choice_find_now:n {
  \cs_set_eq:Nc \template_tmp:w 
    { \c_template_keys_root_tl \l_template_path_tl / #1 .direct.cmd:w }
  \cs_if_exist:NTF \template_tmp:w {
    \template_tmp:w 
  }{
    \use:c { 
      \c_template_keys_root_tl \l_template_path_tl 
      / unknown.direct.cmd:w 
    } {#1}
  }
}
\cs_new_nopar:Nn \template_choice_find_save:n {
  \cs_set_eq:Nc \template_tmp:w 
    { \c_template_keys_root_tl \l_template_path_tl / #1 .cmd:w }   
  \cs_if_exist:NTF \template_tmp:w {
    \template_tmp:w \q_template_stop
  }{
    \use:c {
      \c_template_keys_root_tl \l_template_path_tl / unknown.cmd:w 
    } {#1} \q_template_stop
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_choice_make:}
% Making a choice key is different from the other types as the 
% expansion has to be done now even if things are to be saved. So the
% functions are created directly.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_choice_make: {
  \num_set:cn { 
    l_ \c_template_keys_root_tl \l_template_path_tl .args_num 
  } {1}
  \cs_set:cpn  { \c_template_keys_root_tl \l_template_path_tl .cmd:w }
     ##1 {
      \template_choice_find_save:n {##1}
      \template_arguments_tidy:w 
    }
  \cs_set:cpn { 
    \c_template_keys_root_tl \l_template_path_tl .direct.cmd:w 
  } ##1 { \template_choice_find_now:n {##1} }
  \cs_set_eq:cN {
    \c_template_keys_root_tl \l_template_path_tl / unknown.cmd:w
  } \template_choice_unknown:n
  \cs_set_eq:cN {
    \c_template_keys_root_tl \l_template_path_tl / unknown.direct.cmd:w
  } \template_choice_unknown_direct:n
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\template_choice_unknown:n}
%\begin{macro}{\template_choice_unknown_direct:n}
% These are pre-defined for easy of use.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_choice_unknown:n {
  \toks_put_right:Nn \l_template_initial_toks {
    \msg_error:nnx { template } { unknown~choice } {#1}
  }
  \template_arguments_tidy:w
}
\cs_new_nopar:Nn \template_choice_unknown_direct:n {
  \msg_error:nnx { template } { unknown~choice } {#1}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_choices_generate:nx}
%\begin{macro}[aux]{\template_choices_generate_aux:n}
% Creating multiple-choices means setting up the ``indicator'' code,
% then applying whatever the user wanted.
%    \begin{macrocode}
\cs_new:Nn \template_choices_generate:nx {
  \template_choice_make:
  \int_zero:N \l_template_choice_int
  \cs_set_nopar:Nn \template_choices_generate_aux:n {
    \int_incr:N \l_template_choice_int
    \template_cmd_set:nNx { \l_template_path_tl / ##1 } 1 {
      \exp_not:n { \tl_set:Nn \l_template_choice_tl } {##1}
      \exp_not:n { \int_set:Nn \l_template_choice_int }
        { \int_use:N \l_template_choice_int }
      #2
    }
  }
  \clist_map_function:nN {#1} \keys_choices_generate_aux:n 
}
\cs_new_nopar:Nn \template_choices_generate_aux:n { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_declare:nNnn}
% Declaring a template has three stages. First, the template function
% itself is generated. The keys for the template are then parsed: this
% will make the key functions and also record any initial values in
% \cs{l_template_initial_toks}. Finally, the initial values are saved,
% and a presets store is set to empty.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_declare:nNnn {
  \cs_generate_from_arg_count:cNnn { \c_template_root_tl #1 :w }
    \cs_set:Npn {#2} {#4}
  \toks_clear:N \l_template_initial_toks
  \template_keys_define:nn {#1} {#3}
  \cs_set_nopar:cpx { l_ \c_template_root_tl #1 _initial_tl }
    { \toks_use:N \l_template_initial_toks }
  \tl_clear:c { l_ \c_template_root_tl #1 _preset_tl }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_declare_derived:nnnn}
% For a derived template, the overall idea is similar to a normal
% template. The appropriate code is copied for the template function,
% before creating any additional keys and saving the initial values:
% both those from the parent and any new ones. Finally, the assignment
% routine is run to save any presets.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_declare_derived:nnnn {
  \cs_if_exist:cTF { \c_template_root_tl #2 :w } {
    \prop_put:Nnn \l_template_inheritance_prop {#1} {#2}
    \cs_set_eq:cc { \c_template_root_tl #1 :w } 
      { \c_template_root_tl #2 :w }
    \toks_set:Nv \l_template_initial_toks 
      { l_ \c_template_root_tl #2 _initial_tl }
    \template_keys_define:nn {#1} {#3}
    \cs_set_nopar:cpx { l_ \c_template_root_tl #1 _initial_tl }
      { \toks_use:N \l_template_initial_toks }
    \toks_clear:N \l_template_assignments_toks
    \template_keys_assign:nn {#2} {#4}
    \cs_set_nopar:cpx { l_ \c_template_root_tl #1 _preset_tl }
      { \toks_use:N \l_template_assignments_toks }
  }{
    \msg_error:nnx { template } { undefined~template } {#2}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_initial_value:N}
%\begin{macro}{\template_initial_value:n}
%\begin{macro}{\template_initial_value:V}
%\begin{macro}[aux]{\template_initial_value_aux:n}
% Setting initial values means expanding the ``set'' function as far
% as possible and adding the result to the initial value token register.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_initial_value:N {
  \template_initial_value_aux:n {
    \toks_put_right:Nx \l_template_initial_toks {
      \exp_not:N \exp_args:NV
      \exp_not:c { 
        \c_template_keys_root_tl \l_template_path_tl .direct.cmd:w 
      }
      \exp_not:N #1
    }
  }  
} 
\cs_new:Nn \template_initial_value:n {
  \template_initial_value_aux:n {
    \cs_set_eq:Nc \template_tmp:w 
      { \c_template_keys_root_tl \l_template_path_tl .direct.cmd:w }
    \toks_put_right:Nx \l_template_initial_toks {
      \exp_not:o { \template_tmp:w {#1} }
    } 
  } 
}
\cs_generate_variant:Nn \template_initial_value:n { V }
\cs_new_nopar:Nn \template_initial_value_aux:n {
  \cs_if_exist:cTF { 
    \c_template_keys_root_tl \l_template_path_tl .cmd:w
  } {
   #1
  }{
    \msg_error:nnx { template } { initial~without~key } 
      { \l_template_path_tl }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_instance_declare:nnn}
% To declare an instance, the parameter list is parsed to 
% construct \cs{l_template_assignment_toks}. That is then used to 
% build the function needed to actually execute the instance.
%    \begin{macrocode}
\cs_new:Nn \template_instance_declare:nnn {
  \cs_if_exist:cTF { \c_template_root_tl #2 :w } {
    	\toks_set:Nv \l_template_assignments_toks
    	  { l_ \c_template_root_tl #2 _initial_tl }
    \template_keys_assign:nn {#2} {#3}
    \exp_args:NNc \toks_put_right:NV \l_template_assignments_toks
       { l_ \c_template_root_tl #2 _preset_tl }
    \cs_set:cpx { \c_template_root_tl #2 / #1 :w } {
      \exp_not:N \template_assignments_push:n {
        \toks_use:N \l_template_assignments_toks
      }
      \exp_not:c { \c_template_root_tl #2 :w }
    } 
  }{
    \msg_error:nnx { template } { undefined~template } {#2}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_instance_use:nn}
% If the instance exists, use it; if not, complain.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_instance_use:nn {
  \cs_if_exist:cTF { \c_template_root_tl #2 / #1 :w } {
    \use:c { \c_template_root_tl #2 / #1 :w } 
  }{
    \msg_error:nnx { template } { undefined~instance } {#1} {#2}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_key_cmd_set:nNn}
%\begin{macro}{\template_key_cmd_set:nNx}
% Creating a new command means setting properties and then creating
% a function with the correct number of arguments. The \texttt{.direct}
% functions are needed for initial values (no saving to the stack).
%    \begin{macrocode}
\cs_new:Nn \template_key_cmd_set:nNn {
  \num_set:cn { l_ \c_template_keys_root_tl #1 .args_num } {#2}
  \cs_generate_from_arg_count:cNnn 
    { \c_template_keys_root_tl #1 .cmd:w } \cs_set:Npn #2 {
      \toks_put_right:Nn \l_template_assignments_toks {#3}
      \template_arguments_tidy:w 
    }
  \cs_generate_from_arg_count:cNnn 
    { \c_template_keys_root_tl #1 .direct.cmd:w } \cs_set:Npn #2 {#3}
}
\cs_new:Nn \template_key_cmd_set:nNx {
  \num_set:cn { l_ \c_template_keys_root_tl #1 .args_num } {#2}
  \cs_generate_from_arg_count:cNnn  
    { \c_template_keys_root_tl #1 .cmd:w } \cs_set:Npx #2 { 
      \exp_not:N \toks_put_right:Nn 
      \exp_not:N \l_template_assignments_toks {#3}
      \exp_not:N \template_arguments_tidy:w
    }
  \cs_generate_from_arg_count:cNnn 
    { \c_template_keys_root_tl #1 .direct.cmd:w } \cs_set:Npx #2 {#3}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_key_define:n}
% Defining a key is just a case of calling the property function,
% taking car to sort out the delimitation of arguments correctly.
%    \begin{macrocode}
\cs_new:Nn \template_key_define:n {
  \intexpr_compare:nTF { 
    \exp_args:Nc \cs_get_arg_count_from_signature:N 
      { \l_template_property_tl } = \c_one
  } {
    \template_tmp:w {#1} \q_template_stop
  }{
    \template_tmp:w #1 
    { } { } { } { } { } { } { } { } { } \q_template_stop
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_keys_assign:nn}
% Assigning keys is the usual `set up and hand off' routine using
% \pkg{l3keyval}.
%    \begin{macrocode}
\cs_new:Nn \template_keys_assign:nn {
  \tl_set:Nn \l_template_name_tl {#1}
  \cs_set_eq:NN \KV_key_no_value_elt:n \template_keys_assign_elt:n
  \cs_set_eq:NN \KV_key_value_elt:nn \template_keys_assign_elt:nn
  \KV_parse_no_space_removal_no_sanitize:n {#2}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_keys_assign_elt:n}
%\begin{macro}{\template_keys_assign_elt:nn}
%\begin{macro}[aux]{\template_keys_assign_elt_aux:Nn}
%\begin{macro}[aux]{\template_keys_assign_elt_aux:n}
% If there is no value, an error is raised. Otherwise, start with the
% current module and look for a key, and look for a key. If that fails,
% look for a parent for the current template and use it if it exists.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_keys_assign_elt:n {
  \msg_error:nnx { template }  { value~required } {#1}
}
\cs_new:Nn \template_keys_assign_elt:nn {
  \tl_set:Nx \l_template_key_tl { \tl_to_str:n {#1} }
  \template_keys_assign_elt_aux:Nn \l_template_name_tl {#2}
}
\cs_new:Nn \template_keys_assign_elt_aux:Nn {
  \tl_set:Nx \l_template_path_tl { #1 / \l_template_key_tl }
  \cs_set_eq:Nc \template_tmp:w { 
    \c_template_keys_root_tl \l_template_path_tl .cmd:w 
  }
  \cs_if_exist:NTF \template_tmp:w {
    \template_keys_assign_elt_aux:n {#2}
  }{
    \prop_if_in:NVTF \l_template_inheritance_prop #1 {
      \exp_args:NNV \prop_get:NnN \l_template_inheritance_prop #1
        \l_template_parent_tl
       \template_keys_assign_elt_aux:Nn \l_template_parent_tl {#2}
    }{
      \msg_error:nnx { template } { key~unknown } 
        { \l_template_path_tl }
    }
  }
}
\cs_new:Nn \template_keys_assign_elt_aux:n {
  \intexpr_compare:nTF {
    \num_use:c { 
      l_ \c_template_keys_root_tl \l_template_path_tl .args_num 
    } = \c_one
  } {
    \template_tmp:w {#1} \q_template_stop
  }{
    \template_tmp:w #1
    { } { } { } { } { } { } { } { } { } \q_template_stop
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_keys_define:nn}
% The main key-defining function mainly sets up things for 
% \pkg{l3keyval} to use.
%    \begin{macrocode}
\cs_new:Nn \template_keys_define:nn {
  \tl_set:Nn \l_template_name_tl {#1}
  \cs_set_eq:NN \KV_key_no_value_elt:n \template_keys_define_elt:n
  \cs_set_eq:NN \KV_key_value_elt:nn \template_keys_define_elt:nn
  \KV_parse_no_space_removal_no_sanitize:n {#2}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_keys_define_elt:n}
%\begin{macro}[aux]{\template_keys_define_elt_aux:w}
%\begin{macro}{\template_keys_define_elt:nn}
% The element processors for defining keys. There is a bit of cleverness
% for the no-value version, as only one property can be given without
% a value.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_keys_define_elt:n {
  \tl_if_in:nnTF {#1} { .choice: } {
    \template_keys_define_elt_aux:w #1 \q_stop
  }{
    \msg_error:nnx { template } { value~required } {#1}
  }
}
\cs_new_nopar:Npn \template_keys_define_elt_aux:w 
  #1 .choice: #2 \q_stop {
  \tl_if_empty:nTF {#2} {
    \template_keys_define_elt:nn { #1 .choice: } { }
  }{
    \msg_error:nnx { template } { value~required } {#1}
  }
}
\cs_new:Nn \template_keys_define_elt:nn {
  \template_property_find:n {#1}
  \cs_set_eq:Nc \template_tmp:w 
    { \c_template_properties_root_tl \l_template_property_tl }
  \cs_if_exist:NTF \template_tmp:w {
    \template_key_define:n {#2}
  }{
    \msg_error:nnx { template } { property~unknown } 
      { \l_template_property_tl }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_parameters_assign:}
% Assignment is easy: just expand the token register.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_parameters_assign: { 
  \toks_use:N \l_template_assignments_toks
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_property_find:n}
%\begin{macro}[aux]{\template_property_find_aux:n}
%\begin{macro}[aux]{\template_property_find_aux:w}
% Searching for a property means finding the last `\texttt{.}' in
% the input, and storing the text before and after it.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_property_find:n {
  \tl_set:Nx \l_template_path_tl { \l_template_name_tl / }
  \tl_if_in:nnTF {#1} {.} {
    \template_property_find_aux:n {#1}
  }{
    \msg_error:nnx { template } { no~property } { #1 }
  }
}
\cs_new_nopar:Nn \template_property_find_aux:n {
  \template_property_find_aux:w #1 \q_stop
}
\cs_new_nopar:Npn \template_property_find_aux:w #1 . #2 \q_stop {
  \tl_if_in:nnTF {#2} {.} {
    \tl_set:Nx \l_template_path_tl { 
      \l_template_path_tl \tl_to_str:n {#1} .
    }
    \template_property_find_aux:w #2 \q_stop
  }{
    \tl_set:Nx \l_template_path_tl { 
      \l_template_path_tl \tl_to_str:n {#1} 
    }
    \tl_set:Nn \l_template_property_tl { . #2 }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_property_new:nn}
% Creating a new property is simply a case of making the correctly-named
% function.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_property_new:nn {
  \cs_new:cn { \c_template_properties_root_tl #1 } {
    #2
    \template_arguments_tidy:w
  }  
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_tmp:w}
% This scratch function is used to actually execute properties.
%    \begin{macrocode}
\cs_new:Npn \template_tmp:w {}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_variable_set:NN}
% To set a variable, there is first a check so that it must exist.
% The setting function is then created by recovering the type and
% scope from the variable name. The ``\texttt{get}'' functions are
% used from \pkg{key3} as the code needed is identical.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_variable_set:NN {
  \cs_if_exist:cF {
    \keys_variable_get_type:N #2 _
    \keys_variable_get_scope:N #2 set:N #1
  } {
    \msg_error:nnxx { template } { no~set~function } {
      \exp_not:c {
        \keys_variable_get_type:N #2 _
        \keys_variable_get_scope:N #2 set:N #1
      }
    } {#2}
  }
  \cs_if_exist:NF #2 {
    \use:c { \keys_variable_get_type:N #2 _new:N } #2
  }
  \template_key_cmd_set:nNx { \l_template_path_tl } 1 {
    \exp_not:c { 
      \keys_variable_get_type:N #2 _
      \keys_variable_get_scope:N #2 set:N #1 
    } \exp_not:N #2 {##1}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Properties}
%
%\begin{macro}{.choice:}
% Making a choice is handled internally, as it is also needed by
% \texttt{.generate_choices:nn}. This is the only property which does
% not take an argument.
%    \begin{macrocode}
\template_property_new:nn { .choice: } {
  \template_choice_make:
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{.code:n}
%\begin{macro}{.code:x}
%\begin{macro}{.code:Nn}
%\begin{macro}{.code:Nx}
% Creating code is simply a case of passing through to the underlying
% \texttt{set} function.
%    \begin{macrocode}
\template_property_new:nn { .code:n } {
  \template_key_cmd_set:nNn { \l_template_path_tl } 1 {#1}
}
\template_property_new:nn { .code:Nn } {
  \template_key_cmd_set:nNn { \l_template_path_tl } #1 {#2}
}
\template_property_new:nn { .code:x } {
  \template_key_cmd_set:nNx { \l_template_path_tl } 1 {#1}
}
\template_property_new:nn { .code:Nx } {
  \template_key_cmd_set:nNx { \l_template_path_tl } #1 {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.function:N}
%    \begin{macrocode}
\template_property_new:nn { .function:N  } {
  \template_key_cmd_set:nNn { \l_template_path_tl } 1 {
    \cs_set:Nn #1 {##1}
  }
  \cs_set:Nn #1 { }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{.generate_choices:nn}
%\begin{macro}{.generate_choices:nx}
% Making choices is expansion-dependent.
%    \begin{macrocode}
\template_property_new:nn { .generate_choices:nn } {
  \template_choices_generate:nx {#1} { \exp_not:n {#2} }
}
\template_property_new:nn { .generate_choices:nx } {
  \template_choices_generate:nx {#1} {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.initial:N}
%\begin{macro}{.initial:n}
%\begin{macro}{.initial:V}
%    \begin{macrocode}
\template_property_new:nn { .initial:N } {
  \template_initial_value:N #1
}
\template_property_new:nn { .initial:n } {
  \template_initial_value:n {#1}
}
\template_property_new:nn { .initial:V } {
  \template_initial_value:V #1
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.instance:nN}
% This is very simple, so no extra function is needed.
%    \begin{macrocode}
\template_property_new:nn { .instance:nN } {
  \template_key_cmd_set:nNn { \l_template_path_tl } 2 {
    \cs_set:Nn ##2 { \UseInstance {#1} {##1} }
  }
  \cs_if_exist:NF #1 {
    \cs_set:Nn #1 { }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{.set:N}
%\begin{macro}{.set_x:N}
% Setting a variable is very easy: just pass the data along.
%    \begin{macrocode}
\template_property_new:nn { .set:N } {
  \template_variable_set:NN n #1
}
\template_property_new:nn { .set_x:N } {
  \template_variable_set:NN x #1
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.set_bool:N}
%\begin{macro}{.set_bool_inverse:N}
% One function for each of these, but this keeps the key functions
% themselves  short.
%    \begin{macrocode}
\template_property_new:nn { .set_bool:N } {
  \template_bool_set:N #1
}
\template_property_new:nn { .set_bool_inverse:N } {
  \template_bool_set_inverse:N #1
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsubsection{Messages}
%
% A few error messages: if moved to the kernel, \pkg{keys3} and 
% \pkg{template} could share quite a number of these.
%    \begin{macrocode}
\msg_new:nnn { template } { choice~unknown } {%
  Choice `#2' unknown for key `#1':\\%
  the key is being ignored.%
}
\msg_new:nnn { template } { initial~without~key } {%
  An initial value cannot be set for key `#1':
  the key has not yet been created.%
}
\msg_new:nnn { template } { key~unknown } {%
  The key `#1' is unknown and is being ignored.%
}
\msg_new:nnn { template } { no~property } {%
  No property given in definition of key `#1'.%
}
\msg_new:nnnn { template } { no~set~function } {%
  There is no function #1\\%
  for setting variable \exp_not:N #2.%
}{%
  template can only `set' variables which have a function\\%
  \exp_not:N \<var>_(g)set:Nn, or in some cases 
  \exp_not:N \<var>_(g)set:Nx.\\%
  You have asked to `set' some other kind of variable.%
}
\msg_new:nnn { template } { property~unknown } {%
  The key property `#1' is unknown.%
}
\msg_new:nnn { template } { undefined~instance } {%
  The instance `#1' of template `#2'has not yet been defined.%
}
\msg_new:nnn { template } { undefined~template } {%
  The template `#1' has not yet been defined.\\%
  Use \token_to_str:N \DeclareTemplate \msg_space: 
  to create the template.%
}
\msg_new:nnn { template } { value~required } {%
  The key `#1' requires a value\\%
  and is being ignored.%
}
%    \end{macrocode}
%    
%\subsubsection{User functions}
%
%\begin{macro}{\DeclareInstance}
%\begin{macro}{\DeclareDerivedTemplate}
%\begin{macro}{\DeclareTemplate}
%\begin{macro}{\DoParameterAssignments}
%\begin{macro}{\UseInstance}
% Pretty much all direct translation to internal functions.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareDerivedTemplate { mmMM } { 
  \template_declare_derived:nnnn {#1} {#2} {#3} {#4}
}
\DeclareDocumentCommand \DeclareInstance { mmM } { 
  \template_instance_declare:nnn {#1} {#2} {#3} 
}
\DeclareDocumentCommand \DeclareTemplate { mmMM } { 
  \template_declare:nNnn {#1} #2 {#3} {#4}
}
\DeclareDocumentCommand \DoParameterAssignments { } {
  \template_parameters_assign:
}
\DeclareDocumentCommand \UseInstance { mm } { 
  \template_instance_use:nn {#1} {#2} 
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%    
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
% 
% \PrintIndex
