% \iffalse
%%
%% (C) Copyright 1999 David Carlisle, Frank Mittelbach
%% All rights reserved.
%%
%% Not for distribution
%% 
%<*dtx>
          \ProvidesFile{template.dtx}
%</dtx>
%<package>\NeedsTeXFormat{LaTeX2e}
%<package>\ProvidesPackage{template}
%<driver>\ProvidesFile{template.drv}
% \fi
%         \ProvidesFile{template.dtx}
          [1999/08/27 v0.11 template parsing (DPC,FMi)]
%
% \iffalse
%<*driver>
 \documentclass{ltxdoc}
 \begin{document}
 \DocInput{template.dtx}
 \end{document}
%</driver>
% \fi
%
% \GetFileInfo{template.dtx}
%
% \title{The \textsf{template} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{DPC, FMi}
% \date{\filedate}
%  \maketitle
% 
% \changes{0.06}{1998/12/17}{generic functions reborn as templates}
%
% \section{Introduction}
% A \emph{Template} is a named `function' that has a fixed number
% of \emph{mandatory arguments} and an additional set of \emph{keys}
% or `named attributes' that are set in a `key value list'. That is,
% a comma separated  set of assignments of the form:\\
% \meta{key$_1$} |=| \meta{value$_1$} |,|
% \meta{key$_2$} |=| \meta{value$_2$} \ldots
%
% More specific instances of the template may be declared by
% specifying settings of the parameters. The key value list is parsed
% at the time the instance is declared, and an `internal' set of
% parameter assignments is passed to the template code. It is normally
% not parsed at run-time, though it is possible to enforce this
% behaviour.
%
% Templates have a \emph{type} and a \emph{name}. Templates
% of the same type have the same argument and parameter
% structure. That is, templates of the same type are expected to be
% exchangeable semantically. (However, except for checking that
% templates of the same type always have the same number of arguments
% this is not enforced by the code.)
%
% A template type is declared via the |\DeclareTemplateType|
% declaration which takes two arguments: the name for the type and the
% number of arguments a template of this type requires.
%
% Templates are declared via the |\DeclareTemplate|
% command which takes five arguments
% \begin{itemize}
% \item The \emph{type} of the template (no |\|).
% \item The \emph{name} of the template (no |\|).
% \item The number of arguments for the template (same as on type
% declaration).
% \item A list declaring the keys accepted by the template,
% with information about the action to take when the key is specified
% with a value.
% \item The code for the template. This may be arbitrary \TeX\
% code. At some point it should execute |\DoParameterAssignments|
% to run the parameter assigments.
%
% The mandatory arguments are accessed via |#1|, |#2|, \ldots
% \end{itemize}
%
%
% Each element of the key specification list is of the form:
% \begin{flushleft}
% \meta{key name} |=|
%       \meta{key type} \meta{optional default} \meta{internal code}
% \end{flushleft}
%
% The \meta{key types} are essentially specified by giving a symbolic
% representation of the assignment function to be used by \TeX.
%
% Currently the possibilities are
%
% \begin{center}\catcode`|=12
% \begin{tabular}{l|ll|l}
% key type& letter& internal code& argument form\\\hline
% Command & f\emph{n}&command name & command definition\\
% name    & n &       command name & command definition\\
% length  & l &       length register& calc length syntax\\
% fake length & L &  command name  & calc length syntax\\
% count   & c &       count register& calc count syntax\\
% fake count  & C &  command name  & calc count syntax\\
% boolean & b &       name of \verb|\newif| switch& true or false\\
% switch  & s &       \marg{true code}\marg{false code}& true or false\\
% instance& i\marg{type}& command name& instance of this \emph{type}\\ 
% direct  & x &       Internal code& any\\
% general & g &       general code & any
% \end{tabular}
% \end{center}
%
% In addition, any of these types may me prefixed by |+| to
% denote a global assignment (described below).
% |f| takes a digit from 0--9 to denote the number of arguments.
% |n| is in fact the same as |f0|. When an instance is declared
% The value assigned to the key should be the definition of
% the command, using |#1|\ldots|#9| to denote the specified arguments.
%
% |c| takes an internal form a count register,
%  not a \LaTeX\ counter name.
%
% For |f|, |n|, |l|, and |c|, the assignment is done twice, once
% at the time an instance is \emph{declared}. (This may involve
% using \textsf{calc} expresions. Then the `primitive assignment'
% of the value (not using calc) is copied to the internal parameter
% list, to be executed when an instance is run. Sometimes you need the
% expression to be evaluated at the time an instance is run rather
% than the time it is declared. For example it may be an expression
% involving some values that are not fixed throughout a document.
% In this case the instance declaration may give a value in the
% form |\DelayedEvaluation|\marg{calc expression}. In this case
% the value is not evaluated when the instance is declared, and
% instead the entire expression is copied to the `internal parameter
% list' and is evaluated whenever the instance is used.
%
% |L| and |C| take the same value types as |l| and |c| but the internal
% assignments are to macros not registers.
%
% Keys declared with |b| and |s| each take values either \emph{true} or
% \emph{false}. if the key zzz is declared with |b| then specifying
% |zzz=true| will essentially pass |\zzztrue| to the internal parameter
% list (although in fact |\zzztrue| need not be defined) . If instead
% zzz had been declared via |s|,  then |zzz=true| would pass the tokens
% of the \marg{true code} to the internal parameter list.
% 
% If a key is specified as |x|, then when used the \emph{internal code}
% will be copied to the internal parameter lists. This code may use |#1|
% to denote the value supplied to the key in the instance declaration.
% Note that this code is \emph{only} copied at the time the instance is
% declared. It is not executed at this time. It is executed when the
% instance is executed.\footnote{Despite the question of whether or
% not x and g are still necessary these days, they have the wrong
% `names' since x is the one that is not executed during delcaration
% while g is.}
%
% If a key is declared with |g| then the code is run at the time the
% instance is declared. By default \emph{nothing} is passed to the
% internal parameter list. This code may use |#1| to denote the
% value that will be supplied when an instance is declared.
% Any code that should be run when an instance is executed should
% be explicitly passed to the internal parameter list using
% |\addto@hook\TP@toks{|\ldots|}|
%
% A key declared with |i|\marg{type} takes as value the name of a
% declared instance of that type. The command token associated with
% the key will store a command essentially equivalent to a call
% to |\UseInstance|\marg{type}\marg{name}, but in a slightly optimised
% internal form.
% As an exception to this rule the replacement code may be of the form
% |\UseTemplate| followed by the key settings for the template
% but without the mandatory arguments. In this case the `inner'
% instance declaration is `pre compiled' and the token assigned to
% the store the value assigned to this key will execute an instance
% of the template directly, it will not re-parse the keyword settings
% each time the instance is used.
%
% \section{Commands}
% \DescribeMacro{\DeclareTemplateType}
%                \marg{type}\marg{num} \\
% Declare a template type.
%
% \DescribeMacro{\DeclareTemplate}
% \marg{type}\marg{tname}\marg{num}\marg{keyspec}\marg{code} \\
% Declare a template \meta{tname} of type \meta{type} with the set of
% keys as defined by \meta{keyspec}. At runtime it will run
% \meta{code} and expects \meta{num} mandatory arguments (same number
% for all templates of one type).\footnote{The \meta{num} argument is
% redundent as it can be deduced from the type. However, for practical
% reasons it seems better to keep that information with each
% individual template declaration.}
%
% \DescribeMacro{\DoParameterAssignments}
% The list of key value assignments made (and saved) during template
% declaration is evaluated at this point in the template code.
%
% \DescribeMacro{\DeclareRestrictedTemplate}
% \marg{type}\marg{new-tname}\marg{old-tname}\marg{keyvals} \\
% Declare as new template \meta{new-tname} for type \meta{type} by
% taking template \meta{old-tname} as the basis and setting one or
% more of its keys to specific values.
%
% \DescribeMacro{\UseTemplate}
%                \marg{type}\marg{tname}\marg{keyval} \\
% Execute a template \meta{tname} of type  \meta{type} at run-time
% using \meta{keyvals} as the value assignments for its keys. In this
% case the keys are evaluated at run-time thus this method is far
% slower than using a predeclared instance of this template (see
% below). This command can also appear as the value for a key of type
% `i' in which case the evaluation happens at declaration time of the
% template that contains this key!
%
% \DescribeMacro{\DeclareInstance}
%                \marg{type}\marg{iname}\marg{tname}\marg{keyvals} \\
% Declare an instance of type \meta{type} named \meta{iname} build
% from using template \meta{tname} with key settings as given by
% \meta{keyvals}. 
%
% \DescribeMacro{\DeclareCollectionInstance}
% \marg{collection}\marg{type}\marg{iname}\marg{tname}\marg{keyvals}
% \\
% Same as |\DeclareInstance| except that this instance is only active
% when for the type \meta{type} the collection \meta{collection} was
% selected via |\UseCollection|. E.g., within the frontmatter one
% could make all headings behave differently by defining collection
% instances for template type `head'.
%
% \DescribeMacro{\DelayEvaluation}
%                \marg{code} \\
% Used in the value spec for an instance to declare that the value
% \meta{code} should not be evaluated at declaration time but at run-time.
%
% \DescribeMacro{\UseCollection}
%                \marg{type}\marg{collection}
% Declare that from now on (normal scoping rules) the collection
% \meta{collection} for template type \meta{type} is in force. This
% means that a call to |\UseInstance| will first check if there is a
% collection instance defined, and if so use that instance, otherwise
% use the normal instance.
%
% The order of arguments is illogical in my eyes! a collection
% modifies the behavior of several types and thus should be first (as
% it is in the |\DeclareCollectionInstance| case). or not or what?
%
% \DescribeMacro{\UseInstance}
%                \marg{type}\marg{iname}\\
% Run the instance \meta{iname} of template type \meta{type}. If a
% collection is in force see if there is a collection instance of name
% \meta{iname} and if so run that ine instead.
%
% \DescribeMacro{\IfExistsInstanceTF}
%                \marg{type}\marg{iname}\marg{true}\marg{false}\\
%
% How should this behave for Collection instances? Do we need a
% special check for  those or a default action?
%
%
%
% \subsection{Multi-valued parameters}
%
% [docu taken from trial implementation in xlists.dtx, FMi]
%
%  The following code implements for registers (ie L,l,C,c keys) and
%  for names (ie n key) a multi-selection mechanism of the following
%  form:
% \begin{verbatim}
%    key    = \MultiSelection \@listdepth {
%                   \DelayEvaluation {2.5em},
%                   20pt + 34pt } 
%                  { \DelayEvaluation {1em} },
% \end{verbatim}
%
% where the first argument to |\MultiSelection| is a counter, the
% second argument is a comma separated list of values denoting the
% values for the cases 1, 2,\ldots, and the third argument contains
% the value for all other cases.
%
% The values are evaluated at declaration time in case of registers
% and therefore can contain calc expressions as well as
% |\DelayEvaluation|.
%
% Due to the implementation the case list is not allowed to have a
% trailing comma! And of course no checks are made whatsoever :-(
%
% A probably much nicer syntax would be something like this:
% \begin{verbatim}
%    key    = \MultiSelection {
%                selector = \@listdepth,
%                1        = \DelayEvaluation {2.5em},
%                2        = 20pt + 34pt,
%                else     = \DelayEvaluation {1em} 
%              },
% \end{verbatim}
%
% but i found that too difficult to implement right now.
%
% I think it should also be considered if this kind of thing should be
% a generally available feature on all key types especially on the
% f\meta{number} ones.
%
% Anyway it is what i need for lists right now and as such it is
% sufficient.
%
%
%
%
%
%
%
%
%
%
% \section{Example}
%
% FIX ME!!
%
% The example below may make this more clear.
%
% The following example shows a sketch of a template for
% setting captions. One might expect that a general float handling
% procedure arranges to call an instance of the 
%  |captionsetting| type with name |top|. with three
% arguments. The float name , eg `Table' or `Fig.' etc., The float
% number eg `10' or `3--c' etc.\ and third and final argument with the
% caption text. It is the responsibility of the class designer to
% define |captionsetting| |top| by instantiating the template
% \emph{setcaption} with suitable parameters.
%
% The following is a complete working example, except that it does
% not typeset anything, it just gives tracing information on the
% terminal.
%
% First a length and a boolean switch used internally by the
% template
%\begin{verbatim}
% \newlength\cap@width
% \newif\if@topcaption
%\end{verbatim}
%
% Now we declare the new \emph{setcaption} template
%
%
%\begin{verbatim}
% \DeclareTemplate{setcaption}{3}
%\end{verbatim}
%
% The third argument gives the declaration of the keys accepted
% by the \emph{setcaption} template.
%
% \emph{captionwidth} is a length parameter. Its value will be 
% fully evaluated bythe calc package, and this value passed
% to the template in the internal |\cap@width| register.
%
% \emph{paragraph-shape} is passed a name of a shape (eg `center')
% and this is internally stored in |\para@shape|, a macro with no
% arguments.
%
% \emph{number-format} takes as its value a function definition with
% two arguments. This may be either a pre-defined function, or
% an `inline' function, using |#1| and |#2|, as shown here.
%
% Finally the \emph{position} key takes as argument either true or
% false.
%
%\begin{verbatim}
%  {captionwidth    =l       \cap@width,
%   paragraph-shape =n       \para@shape,
%   number-format   =f2      \num@format,
%   position        =b       @topcaption}
%\end{verbatim}
%
% The final argument to |\DeclareTemplate| is essentially
% arbitrary \TeX\ code. It should normally run |\DoParameterAssignments|
% in order to access the parameters. This example doesn't
% actually do anything useful except make some typeouts.
%
% Note that |\DoParameterAssignments|
% which is evaluated first contains the parameter
% assignments, an internal version of the key value list
% also note that as we are using a convention in packages
% where white space is ignored, we use |~| for the space in typeouts.
%\begin{verbatim}
%  {
%   \begingroup
%    \DoParameterAssignments
% \typeout{width=\the\cap@width}
% \typeout{parashape=\para@shape}
% \typeout{position~(if~top)=\meaning\if@topcaption}
% \typeout{arg1=#1}
% \typeout{arg2=#2}
% \typeout{arg3=#3}
% % .............
%   \endgroup}
%\end{verbatim}
%
% If we assume the current line width is 30 pica.
%\begin{verbatim}
%\linewidth=30pc
%\end{verbatim}
%
% First we run an instance of the template with these
% parameter settings, and the three mandatory arguments supplied.
%\begin{verbatim}
% \UseInstance{setcaption}{
%   captionwidth    = \linewidth - 24pt,
%   paragraph-shape = raggedright,
%   number-format   = \textbf{#1\unbreakablespace #2:},
%   position        =  top}
%   {table}{10}{The Caption Text}
%\end{verbatim}
%
% The parameter setting are parsed, and internally the following list
% of assignments are stored and then executed by
% |\DoParameterAssignments|.
%\begin{verbatim}
%  \cap@width =336.0pt\relax
%  \functiondefine 0\para@shape {raggedright}
%  \functiondefine 2\num@format {\textbf {##1\unbreakablespace ##2:}}
%  \@topcaptiontrue .
%\end{verbatim}
% Note that |\cap@width| is passed a fully evaluated length. Its
% setting does not explicitly depend on |\linewidth|.
% Also note that the testing for `top' has all been done by the parser,
% and the function itself is just passed the simpler
% |\@topcaptiontrue| switch.
%
% This instance thus produces the following terminal output:
%\begin{verbatim}
%  width=336.0pt
%  parashape=raggedright
%  position (if top)=\iftrue
%  arg1=table
%  arg2=10
%  arg3=TheCaptionText
%\end{verbatim}
%
% Normally one would not run such an instance directly, but would
% declare an instance of the template with fixed parameter settings.
%\begin{verbatim}
%\DeclareInstance\captionsetting{setcaption}{
%   captionwidth    = \linewidth,
%   paragraph-shape = centerlast,
%   number-format   = \textsf{#1\unbreakablespace #2.},
%   position        = bottom}
%\end{verbatim}
%
% This could then be called by the float handling routines with the
% necessary arguments supplied. Our example
%\begin{verbatim}
%\captionsetting{table}{10}{The Caption Text}
%\end{verbatim}
% produces
%\begin{verbatim}
%  width=360.0pt
%  parashape=centerlast
%  position (if top)=\iffalse
%  arg1=table
%  arg2=10
%  arg3=TheCaptionText
%\end{verbatim}
%
% \StopEventually{}
% \CheckSum{0}
%
% \section{Implementation}
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
\RequirePackage{ldcsetup}
%    \end{macrocode}
%
% Ignore white space in this package.
%    \begin{macrocode}
\IgnoreWhiteSpace
%    \end{macrocode}
%
% Declare a private token register for building parameter lists.
% Having the number saves a few expandafters
% (probably not needed in the end).
%    \begin{macrocode}
\newtoks\TP@toks
\newtoks\TP@toksb % may not need this one
%    \end{macrocode}
%
%
% \begin{macro}{\functiondefine}
% |\def| setup with a latex style `number of arguments' argument.
% definition setup left in toksb for possible future use.
%    \begin{macrocode}
\def\functiondefine#1#2#3{%
  \def\@tempa##1#1##2##{%
    \TP@toksb\expandafter{\expandafter\def\expandafter#2\@gobble##1#1}
    \the\TP@toksb}%
  \@tempa0##1##2##3##4##5##6##7##8##9{#3}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@DCI}
% Declare a command name to be an instance of a template
% ie with a particular setting of the parameters.\\
% |#1| internal command name for instance to be (globally) declared\\
% |#2| template type/template name\\
% |#3| key value assignments for parameters of |#2|
%    \begin{macrocode}
\def\TP@DCI#1#2#3{
  \begingroup
    \TP@get@restrictions {#2}                  % puts stuff in \TP@toks
    \toks@\expandafter\expandafter\expandafter
          {\csname TPD>/#2\endcsname\relax\relax}
    \setkeys{\the\TP@temptoks}             % temp OK?
            {#3}                           % adds stuff to \TP@toks
    \expandafter\TP@add@default \the\toks@ % prepends stuff to \TP@toks
    \xdef#1{
      \expandafter\ifx\csname TP>/#2\endcsname\TP@dpa
        \the\TP@toks
      \else
        \noexpand\TP@assignments{\the\TP@toks}
        \expandafter\noexpand\csname TP>/#2\endcsname
      \fi}
  \endgroup}
%    \end{macrocode}
%
%    \begin{macrocode}
\long\def\TP@dpa{\DoParameterAssignments}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@add@default#1#2{
  \ifx#1\relax
   \else
     \@temptokena{#2}
     \edef\@tempa{{\the\@temptokena\the\TP@toks}}
     \TP@toks\@tempa
    \expandafter\TP@add@default
  \fi}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\UseTemplate}
% |{type}{templatename}{keyval}|
% Directly use a template with a particular parameter setting.
% This is also picked up if used in a nested fashion inside a parameter
% list.\\
% |#1| type of a template.\\
% |#2| name of a template.\\
% |#3| key value assignments for parameters of |#1|.
%    \begin{macrocode}
\def\UseTemplate#1#2#3{
  \TP@get@restrictions {#1/#2}                % from here ...
  \toks@\expandafter\expandafter\expandafter
        {\csname TPD>/#1/#2\endcsname\relax\relax}
  \setkeys{\the\TP@temptoks}{#3}
  \expandafter \TP@add@default \the\toks@  % to here is :  
                % Shared with \def\DeclareCommandInstance
  \TP@push
  \csname TP>/#1/#2\endcsname}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DoParameterAssignments}
% Acces the list stored in |\TP@toks|.
%    \begin{macrocode}
\def\DoParameterAssignments{
  \expandafter\TP@pop\the\TP@stack\@@}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@pop#1#2\@@{
  \global\TP@stack{#2}
  #1}
%    \end{macrocode}
%
%    \begin{macrocode}
\newtoks\TP@stack
%    \end{macrocode}
%
%    \begin{macrocode}
\global\TP@stack{\relax}% avoid brace loss
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@assignments}
% Access the list stored in |\TP@toks|.
%    \begin{macrocode}
\def\TP@assignments{
  \afterassignment\TP@push\TP@toks}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@push{
  \global\TP@stack\expandafter
    {\expandafter{\the\expandafter\TP@toks\expandafter}
    \the\TP@stack}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareTemplateType}
% |{type}{nofarg}|
%    \begin{macrocode}
\def\DeclareTemplateType#1#2{
  \expandafter\def\csname TP@<#1>\endcsname{{}#2}}
%    \end{macrocode}
% \end{macro}
%
% |{type}| returns prefix for csnames for type, based on current collection.
%    \begin{macrocode}
\def\TP@prefix#1{
  <\expandafter\expandafter\expandafter
    \@firstoftwo\csname TP@<#1>\endcsname>#1/}
%    \end{macrocode}
%
% |{type}| returns arg count for type,
%    \begin{macrocode}
\def\TP@args#1{
  \expandafter\expandafter\expandafter
    \@secondoftwo\csname TP@<#1>\endcsname}
%    \end{macrocode}
%
% \begin{macro}{\DeclareTemplate}
% |{type}{templatename}{nofarg}{keywordspec}{code}|
%    \begin{macrocode}
\long\def\DeclareTemplate#1#2#3#4#5{
  \@ifundefined{TP@<#1>}
    {\undefinedtype\DeclareTemplateType{#1}#3}
    {\ifnum#3=\TP@args{#1}\relax\else
      \BadArgCount\fi}
%    \end{macrocode}
% Parse the key declaration, and execute the list with a suitable
% definition of |\KV@elt|.
%    \begin{macrocode}
  \let\KV@elt\TP@elt
  \def\KV@default@elt##1{
    \PackageError{template}{Missing = after ##1}\@ehd}
  \def\TP@name{#1/#2}
  \toks@{}
  \KV@parse{#4}
%    \end{macrocode}
%
% Define the defaults 
%    \begin{macrocode}
  \expandafter\edef\csname TPD>/\TP@name\endcsname{\the\toks@}
%    \end{macrocode}
%
% Define the template
%    \begin{macrocode}
  \expandafter\newcommand\csname TP>/\TP@name\endcsname[#3]{#5}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@elt}
% The list of undefined keys and values is put in the list of the form\\
% |\KV@elt|\marg{key}\marg{val}%^^A
% |\KV@elt|\marg{key}\marg{val}\ldots\\
% So just need to give this macro a suitable definition. We just need
% to look at the first token of the value, to see what sort of key
% it is, so call a helper function to split that off.
%    \begin{macrocode}
\def\TP@elt#1#2{%
  \let\TP@global\@empty
  \TP@do{#1}#2\TP@do}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@f@shift}
%    Helper for |\TP@do|.
%    \begin{macrocode}
\def\TP@f@shift#1#2{%
  \TP@testopt{#1}{\TPkeycommand{#1}{#2}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@i@shift}
%    Helper for |\TP@do|.
%    \begin{macrocode}
\def\TP@i@shift#1#2{%
  \TP@testopt{#1}{\TP@instance{#1}{#2}}}
%    \end{macrocode}
%
%      declaration |hd =i{head} \fooo| \\
%      use         |hd = mine|\\
%      makes |\fooo| shorthand for |\UseInstance{head}{mine}|
%
%      also allowed: |hd = \UseTemplate{head}{...}{...}|\\
% in case you want to use an unnamed instance of type |head|
% in this place. 
% \begin{macro}{\TP@instance}
%    \begin{macrocode}
\def\TP@instance#1#2#3{
  \TP@define@key{#1}{
    \TPinstance#3{#2}{##1}}}
%    \end{macrocode}
%
% \begin{macro}{\TPinstance}
%    \begin{macrocode}
\def\TPinstance#1#2#3{
  \expandafter\ifx\@car#3.\@nil\UseTemplate
    \typeout{\string\UseTemplate\space seen}
%    \end{macrocode}
%
% code below from |\TPkeycommand| (should be combined and cleaned up)
% at this point one should also check if first arg of |\UseTemplate|
% corresponds to |#2| and if not complain (not done)
%
%    \begin{macrocode}
       {\TP@fudge#3}
        \expandafter\addto@hook\expandafter\TP@toks\expandafter{
                             \expandafter\KV@toks\expandafter{\TP@gtemp}
                             \edef#1{\the\KV@toks}}
  \else
    \@letinstance#1{#2}{#3}
    \expandafter\expandafter\expandafter\addto@hook
    \expandafter\expandafter\expandafter\TP@toks
    \expandafter\expandafter\expandafter{
           \@letinstance#1{#2}{#3}}
  \fi}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\TP@do}
%    Case switch on the possible key types.
%    \begin{macrocode}
\def\TP@do#1#2#3\TP@do{
  \ifx#2f
     \TP@f@shift{#1}#3\@@
  \else\ifx#2n
     \TP@testopt{#1}{\TPnamecommand{#1}}#3\@@
  \else\ifx#2l
     \TP@testopt{#1}{\TP@register\setlength{#1}}#3\@@
  \else\ifx#2L
     \TP@testopt{#1}{\TP@fakeregister\setlength\fake@length
                                      {#1}}#3\@@
  \else\ifx#2c
     \TP@testopt{#1}{\TP@register\SetInternalCounter{#1}}#3\@@
  \else\ifx#2C
     \TP@testopt{#1}{\TP@fakeregister\SetInternalCounter\@tempcnta
                                       {#1}}#3\@@
  \else\ifx#2b
     \TP@testopt{#1}{\TP@setboolean{#1}}#3\@@
  \else\ifx#2s
     \TP@testopt{#1}{\TP@booltest{#1}}#3\@@
  \else\ifx#2g
     \TP@testopt{#1}{\TP@setgeneral{#1}}#3\@@
  \else\ifx#2x
     \TP@testopt{#1}{\TP@setx{#1}}#3\@@
  \else\ifx#2i
     \TP@i@shift{#1}#3\@@
  \else\ifx#2+
     \def\TP@global{\addto@hook\TP@toks{\global}}
     \TP@do{#1}#3\TP@do
  \else
      \PackageError{template}{Unknown~key~type~ (#2)~for~#1}\@eha
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@testopt}
%    \begin{macrocode}
\def\TP@testopt#1#2{
  \@ifnextchar[%]
    {\TP@test@pt{#1}{#2}}
    {\TP@zap@@{#2}}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@zap@@#1#2\@@{
  #1{#2}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@test@pt#1#2[#3]#4\@@{
  #2
  {#4}
  \begingroup
    \TP@toks{}
    \let\TP@remove\@gobble
    \csname KV@\TP@name @#1\endcsname{#3}
  \expandafter
  \endgroup
  \expandafter
  \toks@\expandafter{
     \csname KV@\TP@name @#1\expandafter\endcsname\expandafter
         {\the\expandafter\TP@toks\expandafter}\the\toks@}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@setgenral}
%    \begin{macrocode}
\def\TP@setx#1#2{
  \TP@define@key{#1}{\addto@hook\TP@toks{#2}}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@setgeneral#1#2{
  \TP@define@key{#1}{#2}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@setboolean#1#2{
  \expandafter\let\csname if#2\endcsname\iftrue
  \TP@define@key{#1}{
    \TPsetboolean{#2}{##1}}
}
%    \end{macrocode}
%
% Modify so the boolean does not need to have been
%  declared with |\newif|
%    \begin{macrocode}
\def\TPsetboolean#1#2{
  \expandafter\ifx\csname if#2\endcsname\relax
    \PackageError{template}{Bad~boolean~setting~#1=#2}\@eha
  \else
    \expandafter\let\csname if#1\expandafter\endcsname
                      \csname if#2\endcsname
    \expandafter\addto@hook\expandafter\TP@toks\expandafter{
             \expandafter\let
             \csname if#1\expandafter\endcsname\csname if#2\endcsname}
   \fi}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@booltest#1#2{
  \TP@define@key{#1}{
    \TPbooltest{##1}#2}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@true{true}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TPbooltest#1#2#3{
% no error check on this yet.
  \def\@tempa{#1}
  \ifx\@tempa\TP@true
     \addto@hook\TP@toks{#2}
  \else
     \addto@hook\TP@toks{#3}
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\generalcode}
% The first token of the key type declaration is never executed, it
% Just is used to control the switch in |\TP@do|. So this could have
% an arbitrary definition, but define it like this so it does
% something sensible if it is accidently used in a different context.
%
% Not used in current version.
%    \begin{macrocode}
\let\generalcode\@firstofone
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@register}
% This is normally called automatically by |\DeclareTemplate|.
%
% Command for setting a template attribute whose name
% corresponds directly to a tex count or length register\\
% |#1| the fuction to set the value eg \setlength.\\
% |#2| key name.\\
% |#3| the register to set.
%
% This command \emph{fully evaluates} the argument at declare time,
% and assigns the value to the register. It also passes an assignment
% of the register to the final value into the parameter list for the
% template.
%
% If the value is a call to |\DelayEvaluation|, don't evaluate it now,
% just pass the whole assignment to the template.
%
% [Note that the code below contains some : being used in csnames in other files
%  this is currently being allowed by default but in this one it is right now
%  manually added --- need fixing either way]
%    \begin{macrocode}
\catcode`\:=11\relax
\def\TP@register#1#2#3{
  \TP@define@key{#2}{
      \expandafter\ifx\@car##1\@nil\DelayEvaluation
        \addto@hook\TP@toks{#1#3{##1}}
       \else
%    \end{macrocode}
%
%
% check for |\MultiSelection| creeping up and if so add something like
%
% \begin{verbatim}
%  \setlength\register{\ifcase\selector \or value1 \or value2
%                       ... \else valueotherwise \fi}
% \end{verbatim}
% to |\TP@toks|.
%
%    \begin{macrocode}
  \expandafter\ifx\@car##1..\@nil\MultiSelection
       \begingroup
        \TP@multi#1#3##1
       \endgroup
%    \end{macrocode}
%
%
% there are probably better ways to do this :-)
%
%    \begin{macrocode}
       \expandafter\in@\expandafter\DelayEvaluation
                       \expandafter{\the\TP@multi@toks}
       \ifin@
         \addto@hook:No\TP@toks
              {\expandafter#1\expandafter#3\expandafter{\the\TP@multi@toks}}
       \else
         \addto@hook:No\TP@toks
           {\expandafter  #3
            \expandafter= \the\TP@multi@toks\relax}
       \fi
%    \end{macrocode}
%
%
% otherwise do as before
%
%    \begin{macrocode}
  \else
      \addto@hook:No\TP@toks
         {\expandafter  #3
          \expandafter= \the#3\relax}
       \fi\fi}}
%    \end{macrocode}
%
%
%
%    \begin{macrocode}
\def\addto@hook:No#1#2 {
      \expandafter\addto@hook\expandafter#1\expandafter{#2}}
\catcode`\:=12\relax
%    \end{macrocode}
%
%
%
%    \begin{macrocode}
\let\DelayEvaluation\@firstofone
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TPkeycommand}
% Same for macro names. Again usually called automatically when
%  declaring a new template.\\
% |#1|  the key.\\
% |#2|   Determines how many arguments the function should have.\\
% |#3| The macro to be defined.
%
% If the `|##1|`, the value passed as the argument of the key |#1|
% to the macro |#3| is invoked starts with |\FunctionInstance|, then a
%  special procedure is taken. Instead of defining a macro with the
%  specified number of arguments, the paramater list of the nested
%  function instance is parsed, and |#3| is defined to be a macro
% expanding to that instance. In this case the specified template
%   is responsible for picking up the requested number of
%  arguments. (This is \emph{not} checked.)
%    \begin{macrocode}
\def\TP@define@key#1#2{%
  \expandafter\def
    \csname KV@\TP@name @#1\expandafter\endcsname
      \expandafter##\expandafter1
      \expandafter{
         \expandafter\TP@remove
           \csname KV@\TP@name @#1\expandafter\endcsname
           \TP@global
          #2}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@remove#1{
  \def\@tempa##1#1##2##3#1##4\@@{
    \toks@{##1##3}}
  \expandafter\@tempa\the\toks@#1\relax#1\@@}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TPkeycommand#1#2#3{
  \TP@define@key{#1}{
%    \end{macrocode}
%
% |##1| can either be arbitrary inline code, in which case it will be
% defined with |\newcommand[val]| so it needs to use |#1| -- |#val|.
%
% define it locally here
%    \begin{macrocode}
  \functiondefine#2#3{##1}
%    \end{macrocode}
%
%    \begin{macrocode}
        \expandafter\addto@hook\expandafter\TP@toks\expandafter{
                        \the\TP@toksb{##1}}
      }
    }
%    \end{macrocode}
% \end{macro}
%
%
% Here is the extended version that tries to deal with
% |\MultiSelection|.
%
% In case of `n' keys there is no evaluation at declaration time so it
% is not sensible to look for |\DelayEvaluation|. For this reason as
% well as for the fact that |\TP@multi| above assumes that it deals
% with registers that can be accessed via |\the| we have to use a
% different command to handle the |\MultiSelection| args but
% it is essentially doing the same.
%
%    \begin{macrocode}
\catcode`\:=11\relax
\def\TPnamecommand#1#2{
  \TP@define@key{#1}{
  \expandafter\ifx\@car##1..\@nil\MultiSelection
       \begingroup
        \TP@multi@name##1
       \endgroup
       \addto@hook:No\TP@toks
            {\expandafter\def\expandafter#2\expandafter{\the\TP@multi@toks}}
  \else
        \def#2{##1}                      % setting it?
        \addto@hook\TP@toks{\def#2{##1}}
  \fi
      }
    }
\catcode`\:=12\relax
%    \end{macrocode}
%
%    \begin{macrocode}
%\catcode`\:=12\relax
\def\TP@multi@name #1#2#3#4{
   \global\TP@multi@toks{\ifcase #2}
   \@for\next:=\@empty #3\do{
   \TP@do@multi\next
}
   \global\addto@hook\TP@multi@toks{\else #4\fi}
  }
%\catcode`\:=11\relax
%    \end{macrocode}
%
%
%
%
%
%
%
%
%
%
% \begin{macro}{\DeclareInstance}
% |{type}{instname}{templatename}{keyval}|
%    \begin{macrocode}
\def\DeclareInstance{\DeclareCollectionInstance{}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareCollectionInstance}
% |{collection}{type}{instname}{templatename}{keyval}|
%    \begin{macrocode}
\long\def\DeclareCollectionInstance#1#2#3#4{
  \expandafter\TP@DCI\csname<#1>#2/#3\endcsname{#2/#4}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\UseCollection}
% |{type}{collection}|
%    \begin{macrocode}
\def\UseCollection#1#2{
  \expandafter\edef\csname TP@<#1>\endcsname{
   {#2}
   \TP@args{#1}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@letinstance}
% |\internalcommand{type}{instname}|
%    \begin{macrocode}
\def\@letinstance#1#2#3{
  \expandafter\let\expandafter#1\csname
  \@ifundefined{\TP@prefix{#2}#3}
   {<>#2/}
   {\TP@prefix{#2}}
   #3
   \endcsname}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\UseInstance}
% |{type}{instname}|
%    \begin{macrocode}
\def\UseInstance#1#2{
  \@letinstance\@tempa{#1}{#2}
  \ifx\@tempa\relax
     \INSTANCEundefined
   \else
    \expandafter\@tempa
   \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@fudge}
%    \begin{macrocode}
\long\def\TP@fudge#1#2#3{%
  \TP@DCI\TP@gtemp{#2/#3}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ShowTemplate}
% Some extension to |\ShowTemplate| so that we also get to see the
% restrictions if any
%    \begin{macrocode}
\def\ShowTemplate#1#2{
   \typeout{*******~ Template:~ #1/#2~ *******}
   \typeout{*}
   \typeout{*~ Defaults:}
   \typeout{*}
   \typeout{\string\TPD>/#1/#2=
      \expandafter\meaning\csname TPD>/#1/#2\endcsname}
   \typeout{*}
   \typeout{*~ Restrictions:}
   \typeout{*}
   \typeout{\string\TPR>/#1/#2=
      \expandafter\meaning\csname TPR>/#1/#2\endcsname}
   \typeout{*}
   \typeout{*~ Body:}
   \typeout{*}
   \expandafter\show\csname TP>/#1/#2\endcsname}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\def\ShowCollectionInstance#1#2#3{
   \typeout{*******~ Instance:~ <#1>#2/#3~ *******}
   \typeout{*}
   \expandafter\show\csname <#1>#2/#3\endcsname}
\def\ShowInstance{\ShowCollectionInstance{}}
%    \end{macrocode}
%
% |{setcomand}{privateregister}{key}{internalcode}|
%    \begin{macrocode}
\catcode`\:=11\relax
\def\TP@fakeregister#1#2#3#4{
  \TP@define@key{#3}{
      \expandafter\ifx\@car##1..\@nil\DelayEvaluation
%    \end{macrocode}
%    In thew v0.08 version of \texttt{template.dtx} a
%    |\DelayEvaluation| for a faked register would simply be equiv to
%    a |\def| (code is below commented out). The negative side effect
%    of this is that something like |=L| used with |\DelayEvaluation|
%    would not allow for calc syntax since it would end up as
%    |\def|\allowbreak|\foo|\allowbreak|{a+b}|. The code below changes
%    this to first assign to a scratch register (at runtime) and then
%    do an |\edef|. Could be coded differently to save space (at cost
%    of time)
%    \begin{macrocode}
%        \addto@hook\TP@toks{\def#4{##1}}
        \addto@hook\TP@toks{#1#2{##1}\edef#4{\the#2}}
       \else
%    \end{macrocode}
%
%
%    Otherwise same game for fake registers except that instead of
%    passing the register to |\TP@multi| we pass a temp fake one and
%    doing a def instead of using |\setlength| or |\setcounter|
%
%    and i haven't done the |\DelayEvaluation| bit for that case! as
%    i'm not sure what the best approach is for those
%    things\footnote{we might disallow it for that case in general ---
%    not a nice rule but an explainable one}
%
%    \begin{macrocode}
  \expandafter\ifx\@car##1..\@nil\MultiSelection
       \begingroup
        \TP@multi#1#2##1
       \endgroup
       \addto@hook:No\TP@toks
            {\expandafter\def\expandafter#4\expandafter{\the\TP@multi@toks}}
  \else
      #1#2{##1}
      \addto@hook:No\TP@toks
                  {\expandafter
                        \def
                   \expandafter
                         #4
                   \expandafter
                        {\the#2}}
       \fi\fi}}
\catcode`\:=12\relax
%    \end{macrocode}
%
%    \begin{macrocode}
\newtoks\TP@multi@toks
%    \end{macrocode}
%
% |\TP@multi| \marg{operation} \marg{register} |\MultiSelection|
% \marg{selector} \marg{case-list} \marg{else-case}
%
% This command builds up the |\ifcase| code from the three arguments
% of |\MultiSelection| and stores it in |\TP@multi@toks|. This code is
% supposed to be run in a group so a) we don't have to initialise
% |\TP@multi@toks| and b) all changes to the used registers not
% affecting the outside.
%
% Warning: this code uses |\@for| which will not work if put into files where
% ``:'' was made a letter!
%
%    \begin{macrocode}
%\catcode`\:=12\relax
\def\TP@multi #1#2#3#4#5#6{
   \global\TP@multi@toks{\ifcase #4}
   \@for\next:=\@empty #5\do{
     \expandafter \expandafter\expandafter\ifx\expandafter
                  \@car\next..\@nil\DelayEvaluation
       \TP@do@multi\next
     \else
       #1#2{\next}
       \TP@do@multi{\the#2}
     \fi
   }
   \global\addto@hook\TP@multi@toks{\else #6\fi}
  }
%\catcode`\:=11\relax
%    \end{macrocode}
%
%
% Since we intend to add |\or| to |\TP@multi@toks| within the |\@for|
% loop we have to hide it carefully or else we will get some unmatched
% conditionals.
%
%    \begin{macrocode}
\def\TP@do@multi#1{
     \global\expandafter\addto@hook\expandafter\TP@multi@toks
                 \expandafter{\expandafter\or #1 }
}
%    \end{macrocode}
%
% Since i like to set things like |item-label-text| using this
% mechanism i need to handle the `n' key specially.
%
% Actually i could have probably extended |\TPkeycommand| thus making
% this generally available to all f\meta{number} keys but was too lazy
% (or too stupid) to get it right first time so settled for the simple
% solution. 
%
% So |\TP@do| now calls |\TPnamecommand| for the `n' key. looks like
% this thus be fixed some time soon
%
%
%
%
%
%
%
%
%
%
%    \begin{macrocode}
\newlength\fake@length
%    \end{macrocode}
%
%
% \begin{macro}{\IfExistsInstanceTF}
%   tests that there is a \emph{default} definition
%    taken from xinitials.dtx:
%    \begin{macrocode}
\def\IfExistsInstanceTF#1#2{
  \expandafter\ifx\csname <>#1/#2\endcsname\relax
    \expandafter\@secondoftwo
  \else
    \expandafter\@firstoftwo
  \fi}
%    \end{macrocode}
%
% FMi: what happens if we are in collection FOO and there exists an
% instance I for type T within this collection but there doesn't exist
% an instance in the empty collection?
%
% What would happen if \ldots\  --- not clear to me what the sematics
% really should be. The code below is not better only different( and
% slower).\footnote{fix semantics}
%    \begin{macrocode}
\def\IfExistsInstanceTF#1#2{
  \@letinstance\@tempa{#1}{#2}
  \ifx\@tempa\relax
    \expandafter\@secondoftwo
  \else
    \expandafter\@firstoftwo
  \fi}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
% Setting it up:
%
%| \DeclareRestrictedTemplate|\\
%     |{T-type} {new-T-name} {source-T-name} {keyvals}|
% 
% This uses the same code as {T-type} {source-T-name} but adds
% settings from {keyvals}
%    \begin{macrocode}
\def\DeclareRestrictedTemplate#1#2#3#4{  
  % CCC do we need a group here??
  \letcc { TPD>/#1/#2 } { TPD>/#1/#3 }
  \letcc {  TP>/#1/#2 } {  TP>/#1/#3 }
  \TP@get@restrictions   {#1/#3}          % puts stuff in \TP@toks
  \setkeys{\the\TP@temptoks}                      % temp OK?
          {#4}                          % adds stuff to \TP@toks
  \TP@store@restrictions {#1/#2}{#1/#3}} %stores the contents of \TP@toks
%    \end{macrocode}
%
%    \begin{macrocode}
\newtoks \TP@temptoks
%    \end{macrocode}
%
%    \begin{macrocode}
\def\letcc#1#2{
  \expandafter \let 
    \csname #1 \expandafter \endcsname
       \csname #2 \endcsname}
%    \end{macrocode}
%
%
% \section{tprestrict}
% 
% Possible semantics:
% 
% a: just:-) changes the defaults  ie the new template has as 
%    defaults those of its source as modified by the supplied 
%    keyvals;
%    
% b: similar to a: but also removes some keywords ie the new template
%    will not accept the keywods whose values are set by the suppied
%     keyvals;
% 
% c: plan C.
% 
% 
% Towards an implementation of b: but without a restriction on what
%   keys appear where.
%
% Internals:
%
% These could probably be inlined, even when they do something!
%    \begin{macrocode}
\def\TP@get@restrictions#1{    % Returns to \TP@toks the restrictions 
                               % stored in the TP-structure (at present 
                               % in YAM) of the template #1
  \@ifundefined {TPR>/#1}
    {\TP@toks {}}
    {\TP@toks \expandafter\expandafter\expandafter
              {\csname TPR>/#1\endcsname}}
  \@ifundefined {TPO>/#1}
    {\@namedef {TPO>/#1} {#1}
     \TP@temptoks {#1} }                  % temp OK?
    {\TP@temptoks \expandafter\expandafter\expandafter 
                  {\csname TPO>/#1\endcsname} }}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@store@restrictions#1#2{  % Stores the contents of \TP@toks 
                                 % in the TP-structure (at present 
                                 % in YAM) of the template #1
  \expandafter\edef\csname TPR>/#1\endcsname{\the\TP@toks}
  \@ifundefined{TPO>/#2}
    {\@namedef{TPO>/#1}{#2}}
    {\letcc{TPO>/#1}{TPO>/#2}}}
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \Finale
%



