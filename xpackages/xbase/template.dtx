
% \iffalse
%<*dtx>
          \ProvidesFile{template.dtx}
%</dtx>
%<package>\NeedsTeXFormat{LaTeX2e}
%<package>\ProvidesPackage{template}
%<driver>\ProvidesFile{template.drv}
% \fi
%         \ProvidesFile{template.dtx}
          [1998/12/17 v0.06 template parsing + extra stuff fmi/car v1.0c]
%
% \iffalse
%<*driver>
 \documentclass{ltxdoc}
 \begin{document}
 \DocInput{template.dtx}
 \end{document}
%</driver>
% \fi
%
% \GetFileInfo{template.dtx}
%
% \title{The \textsf{template} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{DPC, FMi}
% \date{\filedate}
%  \maketitle
% 
% \changes{0.06}{1998/12/17}{generic functions reborn as templates}
%
% \section{Introduction}
% A \emph{Template} is a function that has a fixed number
% of \emph{mandatory arguments} and an additional set of \emph{keys}
% or `named attributes' that are set in a `key value list'. That is,
% a comma separated  set of assignments of the form:\\
% \meta{key$_1$} |=| \meta{value$_1$} |,|
% \meta{key$_2$} |=| \meta{value$_2$} \ldots
%
% More specific instances of the template may be declared  by
% specifying settings of the parameters. The key value list is parsed
% at the time the instance is declared, and an `internal' set of
% parameter assignments is passed to the template code.
%
% Templates come in three flavours. Templates  instances that
% are called by \emph{type} and \emph{name}, Templates for
% \emph{commands}, and templates for \emph{environments}.
%
%
% Templates for Commands are declared via the |\DeclareCommandTemplate|
% command which takes four argruments
% \begin{itemize}
% \item The \emph{name} of the template (no |\|).
% \item The number of arguments for the template.
% \item A list declaring the keys accepted by the template,
% with information about the action to take when the key is specified
% with a value.
% \item The code for the template. This may be arbitrary \TeX\
% code. At some point it should execute |\DoParameterAssignments|
% to run the parameter assigments.
%
% The mandatory arguments are accessed via |#1|, |#2|, \ldots
% \end{itemize}
%
% Templates for instances that are called by name have an additional
% (first) argument, to specify the type.
%
% Templates for environments have an additional (last) argument
% to denote the \emph{end code}.
%
% Each element of the key specification list is of the form:
% \begin{flushleft}
% \meta{key name} |=|
%       \meta{key type} \meta{optional default} \meta{internal code}
% \end{flushleft}
%
% The \meta{key types} are essentially specified by giving a symbolic
% representation of the assignment function to be used by \TeX.
%
% Currently the possibilities are
%
% \begin{center}\catcode`|=12
% \begin{tabular}{l|ll|l}
% key type& letter& internal code& argument form\\\hline
% Command & f\emph{n}&command name & command definition\\
% name    & n &       command name & command definition\\
% length  & l &       length register& calc length syntax\\
% count   & c &       count register& calc count syntax\\
% boolean & b &       name of \verb|\newif| switch& true or false\\
% switch  & s &       \marg{true code}\marg{false code}& true or false\\
% instance& i\marg{type}& command name& instance of this \emph{type}\\ 
% direct  & x &       Internal code& any\\
% general & g &       general code & any
% \end{tabular}
% \end{center}
%
% |f| takes a digit from 0--9 to denote the number of arguments.
% |n| is in fact the same as |f0|. When an instance is declared
% The value assigned to the key should be the definition of
% the command, using |#1|\ldots|#9| to denote the specified arguments.
% As an exception to this rule the replacement code may be of the form
% |\UseCommandTemplate| followed by the key settings for the template
% but without the mandatory arguments. In this case the `inner'
% instance declaration is `pre compiled' and the token assigned to
% the store the value assigned to this key will execute an instance
% of the template directly, it will not re-parse the keyword settings
% each time the instance is used.
%
% |c| takes an internal form a count register,
%  not a \LaTeX\ counter name.
%
% For |f|, |n|, |l|, and |c|, the assignment is done twice, once
% at the time an instance is \emph{declared}. (This may involve
% using \textsf{calc} expresions. Then the `primitive assignment'
% of the value (not using calc) is copied to the internal parameter
% list, to be executed when an instance is run. Sometimes you need the
% expression to be evaluated at the time an instance is run rather
% than the time it is declared. For example it may be an expression
% involving some values that are not fixed throughout a document.
% In this case the instance declaration may give a value in the
% form |\DelayedEvaluation|\marg{calc expression}. In this case
% the value is not evaluated when the instance is declared, and
% instead the entire expression is copied to the `internal parameter
% list' and is evaluated whenever the instance is used.
%
%
% Keys declared with |b| and |s| each take values either \emph{true} or
% \emph{false}. if the key zzz is declared with |b| then specifying
% |zzz=true| will essentially pass |\zzztrue| to the internal parameter
% list (although in fact |\zzztrue| need not be defined) . If instead
% zzz had been declared via |s|,  then |zzz=true| would pass the tokens
% of the \marg{true code} to the internal parameter list.
% 
% If a key is specified as |x|, then when used the \emph{internal code}
% will be copied to the internal parameter lists. This code may use |#1|
% to denote the value supplied to the key in the instance declaration.
% Note that this code is \emph{only} copied at the time the instance is
% declared. It is not executed at this time. It is executed when the
% instance is executed. 
%
% If a key is declared with |g| then the code is run at the time the
% instance is declared.by default \emph{nothing} is passed to the
% internal parameter list. This code may use |#1| to denote the
% value that will be supplied when an instance is declared.
% Any code that should be run when an instance is executed should
% be explicitly passed to the internal parameter list using
% |\addto@hook\TP@toks{|\ldots|}|
%
% A key declared with |i|\marg{type} takes as value the name of a
% declared instance of that type. The command token associated with
% the key will store a command essentially equivalent to a call
% to |\UseInstance|\marg{type}\marg{name}, but in a slightly optimised
% internal form.
%
% \section{Example}
%
% The example below may make this more clear.
%
% The following example shows a sketch of a template for
% setting captions. One might expect that a general float handling
% procedure arranges to call a command |\captionsetting| with three
% arguments. The float name , eg `Table' or `Fig.' etc., The float
% number eg `10' or `3--c' etc.\ and third and final argument with the
% caption text. It is the responsibility of the class designer to
% define |\captionsetting| by instantiating the template
% \emph{setcaption} with suitable parameters.
%
% The following is a complete working example, except that it does
% not typeset anything, it just gives tracing information on the
% terminal.
%
% First a length and a boolean switch used internally by the
% template
%\begin{verbatim}
% \newlength\cap@width
% \newif\if@topcaption
%\end{verbatim}
%
% Now we declare the new \emph{setcaption} template
%
% The first two arguments of |\DeclareGenericFunction| give the
% function name and its argument count.
% specified here.
%
%\begin{verbatim}
% \DeclareCommandTemplate{setcaption}{3}
%\end{verbatim}
%
% The third argument gives the declaration of the keys accepted
% by the \emph{setcaption} generic function.
%
% \emph{captionwidth} is a length parameter. Its value will be 
% fully evaluated bythe calc package, and this value passed
% to the generic function in the internal |\cap@width| register.
%
% \emph{paragraph-shape} is passed a name of a shape (eg `center')
% and this is internally stored in |\para@shape|, a macro with no
% arguments.
%
% \emph{number-format} takes as its value a function definition with
% two arguments. This may be either a pre-defined function, or
% an `inline' function, using |#1| and |#2|, as shown here.\footnote
% {It may also be an instance of a template, specified via
% \texttt{\string\UseCommandInstance},
% in which case a slightly
% different action is taken, see the implementation documentation.}
%
% Finally the \emph{position} key takes as argument either true or
% false.
%
%\begin{verbatim}
%  {captionwidth    =l       \cap@width,
%   paragraph-shape =n       \para@shape,
%   number-format   =f2      \num@format,
%   position        =b       @topcaption}
%\end{verbatim}
%
% The final argument to |\DeclareCommandTemplate| is essentially
% arbitrary \TeX\ code. It should normally run |\DoParameterAssignments|
% in order to access the parameters. This example doesn't
% actually do anything useful except make some typeouts.
%
% Note that |\DoParameterAssignments|
% which is evaluated first contains the parameter
% assignments, an internal version of the key value list
% also note that as we are using a convention in packages
% where white space is ignored, we use |~| for the space in typeouts.
%\begin{verbatim}
%  {
%   \begingroup
%    \DoParameterAssignments
% \typeout{width=\the\cap@width}
% \typeout{parashape=\para@shape}
% \typeout{position~(if~top)=\meaning\if@topcaption}
% \typeout{arg1=#1}
% \typeout{arg2=#2}
% \typeout{arg3=#3}
% % .............
%   \endgroup}
%\end{verbatim}
%
% If we assume the current line width is 30 pica.
%\begin{verbatim}
%\linewidth=30pc
%\end{verbatim}
%
% First we run an instance of the generic function with these
% parameter settings, and the three mandatory arguments supplied.
%\begin{verbatim}
% \UseCommandInstance{setcaption}{
%   captionwidth    = \linewidth - 24pt,
%   paragraph-shape = raggedright,
%   number-format   = \textbf{#1\unbreakablespace #2:},
%   position        =  top}
%   {table}{10}{The Caption Text}
%\end{verbatim}
%
% The parameter setting are parsed, and internally the following list
% of assignments are stored and then executed by
% |\DoParameterAssignments|.
%\begin{verbatim}
%  \cap@width =336.0pt\relax
%  \functiondefine 0\para@shape {raggedright}
%  \functiondefine 2\num@format {\textbf {##1\unbreakablespace ##2:}}
%  \@topcaptiontrue .
%\end{verbatim}
% Note that |\cap@width| is passed a fully evaluated length. Its
% setting does not explicitly depend on |\linewidth|.
% Also note that the testing for `top' has all been done by the parser,
% and the function itself is just passed the simpler
% |\@topcaptiontrue| switch.
%
% This instance thus produces the following terminal output:
%\begin{verbatim}
%  width=336.0pt
%  parashape=raggedright
%  position (if top)=\iftrue
%  arg1=table
%  arg2=10
%  arg3=TheCaptionText
%\end{verbatim}
%
% Normally one would not run such an instance directly, but would
% declare an instance of the template with fixed parameter settings.
%\begin{verbatim}
%\DeclareCommandInstance\captionsetting{setcaption}{
%   captionwidth    = \linewidth,
%   paragraph-shape = centerlast,
%   number-format   = \textsf{#1\unbreakablespace #2.},
%   position        = bottom}
%\end{verbatim}
%
% This could then be called by the float handling routines with the
% necessary arguments supplied. Our example
%\begin{verbatim}
%\captionsetting{table}{10}{The Caption Text}
%\end{verbatim}
% produces
%\begin{verbatim}
%  width=360.0pt
%  parashape=centerlast
%  position (if top)=\iffalse
%  arg1=table
%  arg2=10
%  arg3=TheCaptionText
%\end{verbatim}
%
% \StopEventually{}
% \CheckSum{0}
%
% \section{Implementation}
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
\RequirePackage{ldcsetup}
%    \end{macrocode}
%
% Ignore white space in this package.
%    \begin{macrocode}
\IgnoreWhiteSpace
%    \end{macrocode}
%
% Declare a private token register for building parameter lists.
% Having the number saves a few expandafters
% (probably not needed in the end).
%    \begin{macrocode}
\newtoks\TP@toks
%    \end{macrocode}
%
%
% \begin{macro}{\functiondefine}
% |\def| setup with a latex style `number of arguments' argument.
%    \begin{macrocode}
\def\functiondefine#1#2#3{%
  \def\@tempa##1#1##2##{%
    \expandafter\def\expandafter#2\@gobble##1#1}%
  \@tempa0##1##2##3##4##5##6##7##8##9{#3}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareCommandInstance}
% Declare a command name to be an instance of a generic function
% ie with a particular setting of the parameters.\\
% |#1| command name for function instance to be (globally) declared\\
% |#2| symbolic name of a generic function\\
% |#3| key value assignments for parameters of |#2|
%    \begin{macrocode}
\def\DeclareCommandInstance#1#2#3{
  \begingroup
    \TP@toks{}
    \toks@\expandafter\expandafter\expandafter
           {\csname TPD>/#2\endcsname\relax\relax}
  \setkeys{#2}{#3}
  \expandafter\TP@add@default\the\toks@
    \xdef#1{
      \expandafter\ifx\csname TP>/#2\endcsname\TP@dpa
        \the\TP@toks
      \else
        \noexpand\TP@assignments{\the\TP@toks}
        \expandafter\noexpand\csname TP>/#2\endcsname
      \fi}
  \endgroup}
%    \end{macrocode}
%
%    \begin{macrocode}
\long\def\TP@dpa{\DoParameterAssignments}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@add@default#1#2{
  \ifx#1\relax
   \else
     \@temptokena{#2}
     \edef\@tempa{{\the\@temptokena\the\TP@toks}}
     \TP@toks\@tempa
    \expandafter\TP@add@default
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\UseCommandTemplate}
% Directly use a template with a particular parameter setting.
% This is also picked up if used in a nested fashion inside a parameter
% list.\\
% |#1| symbolic name of a template.\\
% |#2| key value assignments for parameters of |#1|.
%    \begin{macrocode}
\def\UseCommandTemplate#1#2{
  \TP@toks{}
    \toks@\expandafter\expandafter\expandafter
           {\csname TPD>/#1\endcsname\relax\relax}
  \setkeys{#1}{#2}
  \expandafter\TP@add@default\the\toks@
  \TP@push
  \csname TP>/#1\endcsname}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DoParameterAssignments}
% Acces the list stored in |\TP@toks|.
%    \begin{macrocode}
\def\DoParameterAssignments{
  \expandafter\TP@pop\the\TP@stack\@@}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@pop#1#2\@@{
  \global\TP@stack{#2}
  #1}
%    \end{macrocode}
%
%    \begin{macrocode}
\newtoks\TP@stack
%    \end{macrocode}
%
%    \begin{macrocode}
\global\TP@stack{\relax}% avoid brace loss
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@assignments}
% Access the list stored in |\TP@toks|.
%    \begin{macrocode}
\def\TP@assignments{
  \afterassignment\TP@push\TP@toks}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@push{
  \global\TP@stack\expandafter
    {\expandafter{\the\expandafter\TP@toks\expandafter}
    \the\TP@stack}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareCommandTemplate}
%    \begin{macrocode}
\long\def\DeclareCommandTemplate#1#2#3#4{
%    \end{macrocode}
% Parse the key declaration, and execute the list with a suitable
% definition of |\KV@elt|.
%    \begin{macrocode}
  \let\KV@elt\TP@elt
  \def\KV@default@elt##1{
    \PackageError{template}{Missing = after ##1}\@ehd}
  \def\TP@name{#1}
  \toks@{}
  \KV@parse{#3}
%    \end{macrocode}
%
% Define the defaults 
%    \begin{macrocode}
  \expandafter\edef\csname TPD>/#1\endcsname{\the\toks@}
%    \end{macrocode}
%
% Define the generic function.
%    \begin{macrocode}
  \expandafter\newcommand\csname TP>/#1\endcsname[#2]{#4}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@elt}
% The list of undefined keys and values is put in the list of the form\\
% |\KV@elt|\marg{key}\marg{val}%^^A
% |\KV@elt|\marg{key}\marg{val}\ldots\\
% So just need to give this macro a suitable definition. We just need
% to look at the first token of the value, to see what sort of key
% it is, so call a helper function to split that off.
%    \begin{macrocode}
\def\TP@elt#1#2{%
  \TP@do{#1}#2\TP@do}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@do}
% Case switch on the possible key types.
%    \begin{macrocode}
\def\TP@f@shift#1#2{%
  \TP@testopt{#1}{\TPkeycommand{#1}{#2}}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@i@shift#1#2{%
  \TP@testopt{#1}{\TP@instance{#1}{#2}}}
%    \end{macrocode}
%
%      declaration |hd =i{head} \fooo| \\
%      use         |hd = mine|\\
% makes |\fooo| shorthand for |\UseInstance{head}{mine}|
%    \begin{macrocode}
\def\TP@instance#1#2#3{
  \TP@define@key{#1}{
    \TPinstance#3{#2}{##1}}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TPinstance#1#2#3{
    \expandafter\let\expandafter#1\csname>#2/#3\endcsname
    \expandafter\addto@hook\expandafter\TP@toks\expandafter{
             \expandafter\let\expandafter#1\csname>#2/#3\endcsname}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@do#1#2#3\TP@do{
  \ifx#2f
     \TP@f@shift{#1}#3\@@
  \else\ifx#2n
     \TP@testopt{#1}{\TPkeycommand{#1}0}#3\@@
  \else\ifx#2l
     \TP@testopt{#1}{\TP@register\setlength{#1}}#3\@@
  \else\ifx#2c
     \TP@testopt{#1}{\TP@register\SetInternalCounter{#1}}#3\@@
  \else\ifx#2b
     \TP@testopt{#1}{\TP@setboolean{#1}}#3\@@
  \else\ifx#2s
     \TP@testopt{#1}{\TP@booltest{#1}}#3\@@
  \else\ifx#2g
     \TP@testopt{#1}{\TP@setgeneral{#1}}#3\@@
  \else\ifx#2x
     \TP@testopt{#1}{\TP@setx{#1}}#3\@@
  \else\ifx#2i
     \TP@i@shift{#1}#3\@@
  \else
      \PackageError{template}{Unknown~key~type~ (#2)~for~#1}\@eha
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@testopt}
%    \begin{macrocode}
\def\TP@testopt#1#2{
  \@ifnextchar[%]
    {\TP@test@pt{#1}{#2}}
    {\TP@zap@@{#2}}}
%    \end{macrocode}
%
%    \begin{macrocode}
%    \end{macrocode}
\def\TP@zap@@#1#2\@@{
  #1{#2}}
%
%    \begin{macrocode}
\def\TP@test@pt#1#2[#3]#4\@@{
  #2
  {#4}
  \begingroup
    \TP@toks{}
    \let\TP@remove\@gobble
    \csname KV@\TP@name @#1\endcsname{#3}
  \expandafter
  \endgroup
  \expandafter
  \toks@\expandafter{
     \csname KV@\TP@name @#1\expandafter\endcsname\expandafter
         {\the\expandafter\TP@toks\expandafter}\the\toks@}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@setgenral}
%    \begin{macrocode}
\def\TP@setx#1#2{
  \TP@define@key{#1}{\addto@hook\TP@toks{#2}}}
\def\TP@setgeneral#1#2{
  \TP@define@key{#1}{#2}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@setboolean#1#2{
  \expandafter\let\csname if#2\endcsname\iftrue
  \TP@define@key{#1}{
    \TPsetboolean{#2}{##1}}
}
%    \end{macrocode}
%
% Modify so the boolean does not need to have been
%  declared with |\newif|
%    \begin{macrocode}
\def\TPsetboolean#1#2{
  \expandafter\ifx\csname if#2\endcsname\relax
    \PackageError{template}{Bad~boolean~setting~#1=#2}\@eha
  \else
    \expandafter\let\csname if#1\expandafter\endcsname
                      \csname if#2\endcsname
    \expandafter\addto@hook\expandafter\TP@toks\expandafter{
             \expandafter\let
             \csname if#1\expandafter\endcsname\csname if#2\endcsname}
   \fi}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@booltest#1#2{
  \TP@define@key{#1}{
    \TPbooltest{##1}#2}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@true{true}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TPbooltest#1#2#3{
% no error check on this yet.
  \def\@tempa{#1}
  \ifx\@tempa\TP@true
     \addto@hook\TP@toks{#2}
  \else
     \addto@hook\TP@toks{#3}
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\generalcode}
% The first token of the key type declaration is never executed, it
% Just is used to control the switch in |\TP@do|. So this could have
% an arbitrary definition, but define it like this so it does
% something sensible if it is accidently used in a different context.
%
% Not used in current version.
%    \begin{macrocode}
\let\generalcode\@firstofone
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@register}
% This is normally called automatically by |\DeclareGenericFunction|.
%
% Command for setting a generic function attribute whose name
% corresponds directly to a tex count or length register\\
% |#1| the fuction to set the value eg \setlength.\\
% |#2| key name.\\
% |#3| the register to set.
%
% This command \emph{fully evaluates} the argument at declare time,
% and assigns the value to the register. It also passes an assignment
% of the register to the final value into the parameter list for the
% generic function.
%
% If the value is a call to |\DelayEvaluation|, don't evaluate it now,
% just pass the whole assignment to the generic function.
%    \begin{macrocode}
\def\TP@register#1#2#3{
  \TP@define@key{#2}{
      \expandafter\ifx\@car##1\@nil\DelayEvaluation
        \addto@hook\TP@toks{#1#3{##1}}
       \else
      #1#3{##1}
      \expandafter\addto@hook\expandafter\TP@toks\expandafter{
                   \expandafter
                        #3
                        \expandafter=
                        \the#3\relax}
       \fi}}
%    \end{macrocode}
%
%    \begin{macrocode}
\let\DelayEvaluation\@firstofone
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TPkeycommand}
% Same for macro names. Again usually called automatically when
%  declaring a new generic function.\\
% |#1|  the key.\\
% |#2|   Determines how many arguments the function should have.\\
% |#3| The macro to be defined.
%
% If the `|##1|`, the value passed as the argument of the key |#1|
% to the macro |#3| is invoked starts with |\FunctionInstance|, then a
%  special procedure is taken. Instead of defining a macro with the
%  specified number of arguments, the paramater list of the nested
%  function instance is parsed, and |#3| is defined to be a macro
% expanding to that instance. In this case the specified generic
%  function is responsible for picking up the requested number of
%  arguments. (This is \emph{not} checked.)
%    \begin{macrocode}
\def\TP@define@key#1#2{%
  \edef\@tempa{
    \noexpand\TP@remove
    \expandafter\noexpand\csname KV@\TP@name @#1\endcsname}
  \expandafter\def
    \csname KV@\TP@name @#1\expandafter\endcsname
      \expandafter##\expandafter1
      \expandafter{\@tempa#2}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@remove#1{
  \def\@tempa##1#1##2##3#1##4\@@{
    \toks@{##1##3}}
  \expandafter\@tempa\the\toks@#1\relax#1\@@}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TPkeycommand#1#2#3{
  \TP@define@key{#1}{
%    \end{macrocode}
%
% |##1| can either be arbitrary inline code, in which case it will be
% defined with |\newcommand[val]| so it needs to use |#1| -- |#val|.
%
% Or it can be |\UseTemplate{some-type}{some-TP}{key settings}|
% as described above.
%    \begin{macrocode}
      \expandafter\ifx\@car##1.\@nil\UseTemplate
%    \end{macrocode}
% Define a scratch macro to be the function instance.
%    \begin{macrocode}
       {\TP@fudge##1}
%    \end{macrocode}
%
% The messing around with token registers stops |#| buildup.
%    \begin{macrocode}
        \expandafter\addto@hook\expandafter\TP@toks\expandafter{
                             \expandafter\KV@toks\expandafter{\TP@gtemp}
                             \edef#3{\the\KV@toks}}
      \else
%    \end{macrocode}
% same again for |\UseCommandTemplate| could share code\ldots
%    \begin{macrocode}
        \expandafter\ifx\@car##1.\@nil\UseCommandTemplate
         {\expandafter\DeclareCommandInstance
            \expandafter\TP@gtemp\@gobble##1}
          \expandafter\addto@hook\expandafter\TP@toks\expandafter{
                             \expandafter\KV@toks\expandafter{\TP@gtemp}
                             \edef#3{\the\KV@toks}}
%    \end{macrocode}
% else just put the code into the internal list as a command definition.
%    \begin{macrocode}
         \else
        \addto@hook\TP@toks{
                           \functiondefine#2#3{##1}}
        \fi
      \fi
      }
    }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareEnvironmentTemplate}
% |{name}{args}{spec}{begin code}{end code}|
%    \begin{macrocode}
\long\def\DeclareEnvironmentTemplate#1#2#3#4#5{
  \DeclareGenericFunction{#1}{#2}{#3}{#4}
  \long\expandafter\def\csname endTP>/#1\endcsname{#5}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\long\def\DeclareEnvironmentInstance#1#2#3{
  \expandafter\DefineFunctionInstance\csname#1\endcsname{#2}{#3}
  \expandafter\let\csname end#1\expandafter\endcsname
              \csname endTP>/#2\endcsname}
%    \end{macrocode}
%
% \end{macro}
%
% \begin{macro}{\DeclareTemplate}
% |{type}{templatename}{nofarg}{keywordspec}{code}|
%    \begin{macrocode}
\def\DeclareTemplate#1#2{
  \DeclareCommandTemplate{#1/#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareInstance}
% |{type}{instname}{templatename}{keyval}|
%    \begin{macrocode}
\long\def\DeclareInstance#1#2#3{
  \expandafter\DeclareCommandInstance\csname>#1/#2\endcsname{#1/#3}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\UseInstance}
% |{type}{instname}|
%    \begin{macrocode}
\def\UseInstance#1#2{
  \@ifundefined{>#1/#2}
     {\INSTANCEundefined}
     {\csname>#1/#2\endcsname}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\UseTemplate}
% |{type}{templatename}{keyval}|
%    \begin{macrocode}
\def\UseTemplate#1#2{
  \UseCommandTemplate{#1/#2}
}
%    \end{macrocode}
%
%    \begin{macrocode}
\long\def\TP@fudge#1#2#3{%
  \DeclareCommandInstance\TP@gtemp{#2/#3}}

\input{tprestrict}

\def\ShowTemplate#1#2{
   \typeout{*******~ Template:~ #1/#2~ *******}
   \typeout{*}
   \typeout{*~ Defaults:}
   \typeout{*}
   \typeout{\expandafter\meaning\csname TPD>/#1/#2\endcsname}
   \typeout{*}
   \typeout{*~ Body:}
   \typeout{*}
   \expandafter\show\csname TP>/#1/#2\endcsname}

\def\ShowInstance#1#2{
   \typeout{*******~ Instance:~ #1/#2~ *******}
   \typeout{*}
   \expandafter\show\csname >#1/#2\endcsname}


% added fakeregister (for length only so far)

\def\TP@do#1#2#3\TP@do{
  \ifx#2f
     \TP@f@shift{#1}#3\@@
  \else\ifx#2n
     \TP@testopt{#1}{\TPkeycommand{#1}0}#3\@@
  \else\ifx#2L
     \TP@testopt{#1}{\TP@fakeregister\setfakelength{#1}}#3\@@
  \else\ifx#2l
     \TP@testopt{#1}{\TP@register\setlength{#1}}#3\@@
  \else\ifx#2c
     \TP@testopt{#1}{\TP@register\SetInternalCounter{#1}}#3\@@
  \else\ifx#2b
     \TP@testopt{#1}{\TP@setboolean{#1}}#3\@@
  \else\ifx#2s
     \TP@testopt{#1}{\TP@booltest{#1}}#3\@@
  \else\ifx#2g
     \TP@testopt{#1}{\TP@setgeneral{#1}}#3\@@
  \else\ifx#2x
     \TP@testopt{#1}{\TP@setx{#1}}#3\@@
  \else\ifx#2i
     \TP@i@shift{#1}#3\@@
  \else
      \PackageError{template}{Unknown~key~type~ (#2)~for~#1}\@eha
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi}

\def\TP@fakeregister#1#2#3{
  \TP@define@key{#2}{
      \expandafter\ifx\@car##1\@nil\DelayEvaluation
        \addto@hook\TP@toks{\functiondefine0#3{##1}}
       \else
      #1{##1}
      \expandafter\addto@hook\expandafter\TP@toks\expandafter{
                   \expandafter
                        \functiondefine
                   \expandafter
                         0
                   \expandafter
                         #3
                   \expandafter
                        {\the\fake@length}}
       \fi}}
\newlength\fake@length
\def\setfakelength#1{
  \setlength\fake@length{#1}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\IfExistsInstanceTF}
%
%    taken from xinitials.dtx:
%    \begin{macrocode}
\def\IfExistsInstanceTF#1#2{
  \expandafter\ifx\csname >#1/#2\endcsname\relax
    \expandafter\@secondoftwo
  \else
    \expandafter\@firstoftwo
  \fi
}
%    \end{macrocode}
% \end{macro}
%
%
% \Finale
%



