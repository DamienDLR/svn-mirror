% \iffalse
%<*dtx>
          \ProvidesFile{genfunc.dtx}
%</dtx>
%<package>\NeedsTeXFormat{LaTeX2e}
%<package>\ProvidesPackage{template}
%<driver>\ProvidesFile{template.drv}
% \fi
%         \ProvidesFile{template.dtx}
          [1998/12/17 v0.06 template parsing]
%
% \iffalse
%<*driver>
 \documentclass{ltxdoc}
 \begin{document}
 \DocInput{template.dtx}
 \end{document}
%</driver>
% \fi
%
% \GetFileInfo{template.dtx}
%
% \title{The \textsf{template} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{DPC, FMi}
% \date{\filedate}
%  \maketitle
% 
% \changes{0.06}{1998/12/17}{generic functions reborn as templates}
%
% \section{Introduction}
% A \emph{Template} is a function that has a fixed number
% of \emph{mandatory arguments} and an additional set of \emph{keys}
% or `named attributes' that are set in a `key value list'. That is,
% a comma separated  set of assignments of the form:\\
% \meta{key$_1$} |=| \meta{value$_1$} |,|
% \meta{key$_2$} |=| \meta{value$_2$} \ldots
%
% More specific instances of the template may be declared  by
% specifying settings of the parameters. The key value list is parsed
% at the time the instance is declared, and an `internal' set of
% parameter assignments is passed to the generic function.
%
% Templates come in three flavours. Templates for instances that
% are called by \emph{type} and \emph{name}, Templates for commands,
% and templates for environments.
%
%
% Templates for Commands are declared via the |\DeclareCommand Template|
% command which takes four argruments
% \begin{itemize}
% \item The \emph{name} of the template (no |\|).
% \item The number of arguments for the template.
% \item A list declaring the keys accepted by the template,
% with information about the action to take when the key is specified
% with a value.
%
% Templates for instances that are called by name have an additional
% (first) argument, to specify the type.
%
% Templates for environments have an additional (last) argument
% to denote the \emph{end code}.
%
% Each element of the key specification list is of the form:
% \begin{flushleft}
% \meta{key name} |=| \meta{key type} \meta{optional default} \meta{internal code}
% \end{flushleft}
%
% The \meta{key types} are essentially specified by giving a symbolic
% representation of the
% assignment function to be used by \TeX.
% Currently the possibilities are
% \begin{itemize}
% \item |f|\marg{number}
% (|\functiondefine|\marg{number}). In this case the
% \meta{internal code} should be the name of a macro that is defined
% to be a macro with \meta{number} `visible' arguments, and replacement
% text to be given as the value of \meta{key name}.
%
% A definition of this macro will be passed to the generic function.
% \item |n| (|\functiondefine0|).
% \item |l| (|\setlength|).
%   In this case the \meta{internal code} should be
% a length register, which will be assigned the value passed as
% the argument of \meta{key name}.
%
% An assignment of the register will be passed to the generic function.
% \item |c| (|\SetInternalCounter|).
%    Count register version of the previous case.
% \item |g|\marg{general code}. (|\generalcode|\marg{general code}).
%   In this case there is no \meta{internal code}.
% The \meta{general code} may
% be arbitrary \TeX\ code, surrounded by |{ }|. In this case
% nothing is automatically passed to the generic function, although
% the code may explictly pass assignments as required. To make an
% assignment to a length register within  the \marg{general code} in
% such a way that it is passed to the generic function, use
% |\setTPlength| instead of |\setlength|. Similar
% commands\footnote{with equally stupid names}  exist for
% assigning to other register types and macros.
% \end{itemize}
%
% The example below may make this more clear.
% \item The code for the generic function. This may be arbitrary \TeX\
% code. At some point it should execute |\DoParameterAssignments|
% to run the parameter assigments.
%
% Care should be taken that |\DoParameterAssignments| occurs earlier
% in the definition than any call to another Generic Function, unless this
% call is within a local group. If this rule is broken, the internal
% parameter list set up for the Generic Function will be lost, and replaced
% by the parameters for the second function call.
%
% The mandatory arguments are accessed via |#1|, |#2|, \ldots
% \end{itemize}
%
% The following example shows a sketch of a generic function for
% setting captions. One might expect that a general float handling
% procedure arranges to call a command |\captionsetting| with three
% arguments. The float name , eg `Table' or `Fig.' etc., The float
% number eg `10' or `3--c' etc.\ and third and final argument with the
% caption text. It is the responsibility of the class designer to
% define |\captionsetting| by instantiating the generic function
% \emph{setcaption} with suitable parameters.
%
% \section{Example}
% The following is a complete working example, except that it does
% not typeset anything, it just gives tracing information on the
% terminal.
%
% First a length and a boolean switch used internally by the
% generic function.
%\begin{verbatim}
% \newlength\cap@width
% \newif\if@topcaption
%\end{verbatim}
%
% Now we declare the new \emph{setcaption} Generic Function.
% As described above, any instance of this function takes three
% arguments, but in the current implementation, the generic function
% itself has an extra (first) argument. 
%
% The first two arguments of |\DeclareGenericFunction| give the
% function name and its argument count.
% specified here.
%
%\begin{verbatim}
% \DeclareGenericFunction{setcaption}{3}
%\end{verbatim}
%
% The third argument gives the declaration of the keys accepted
% by the \emph{setcaption} generic function.
%
% \emph{captionwidth} is a length parameter. Its value will be 
% fully evaluated bythe calc package, and this value passed
% to the generic function in the internal |\cap@width| register.
%
% \emph{paragraph-shape} is passed a name of a shape (eg `center')
% and this is internally stored in |\para@shape|, a macro with no
% arguments.
%
% \emph{number-format} takes as its value a function definition with
% two arguments. This may be either a pre-defined function, or
% an `inline' function, using |#1| and |#2|, as shown here.\footnote
% {It may also be an instance of a generic function, specified via
% \texttt{\string\FunctionInstance}, in which case a slightly
% different action is taken, see the implementation documentation.}
%
% Finally the \emph{position} key takes as argument a token string
% but this is not directly passed to the generic function. Instead
% It is processed by the \meta{general code} and the Generic fuction
% is passed\footnote{This needs a nicer wrapper to hide the internal
% token register, but not today}
% |\@topcaptiontrue| just in the case the key value was
% `top'. Note that this processing only needs happen once, when an
% instance is declared, not every time the instance is used.
%\begin{verbatim}
%  {captionwidth    =   l       \cap@width,
%   paragraph-shape =   n       \para@shape,
%   number-format   =  f2       \num@format,
%   position        =  g{
%                        \def\@tempa{top}
%                        \def\@tempb{#1}
%                        \ifx\@tempa\@tempb
%                           \addto@hook\TP@toks{\@topcaptiontrue}
%                        \fi}}
%\end{verbatim}
%
% The final argument to |\DeclareGenericFunction| is essentially
% arbitrary \TeX\ code. It should normally run |\DoParameterAssignments|
% inside a local
% group in order to access the parameters. This example doesn't
% actually do anything useful except make some typeouts.
%
% Note that |\DoParameterAssignments|
% which is evaluated first contains the parameter
% assignments, an internal version of the key value list
% also note that as we are using a convention in packages
% where white space is ignored, we use |~| for the space in typeouts.
%\begin{verbatim}
%  {
%   \begingroup
%    \DoParameterAssignments
% \typeout{width=\the\cap@width}
% \typeout{parashape=\para@shape}
% \typeout{position~(if~top)=\meaning\if@topcaption}
% \typeout{arg1=#1}
% \typeout{arg2=#2}
% \typeout{arg3=#3}
% % .............
%   \endgroup}
%\end{verbatim}
%
% If we assume the current line width is 30 pica.
%\begin{verbatim}
%\linewidth=30pc
%\end{verbatim}
%
% First we run an instance of the generic function with these
% parameter settings, and the three mandatory arguments supplied.
%\begin{verbatim}
% \FunctionInstance{setcaption}{
%   captionwidth    = \linewidth - 24pt,
%   paragraph-shape = raggedright,
%   number-format   = \textbf{#1\unbreakablespace #2:},
%   position        =  top}
%   {table}{10}{The Caption Text}
%\end{verbatim}
%
% The parameter setting are parsed, and internally the following list
% of assignments are stored and then executed by |\DoParameterAssignments|.
%\begin{verbatim}
%  \cap@width =336.0pt\relax
%  \functiondefine 0\para@shape {raggedright}
%  \functiondefine 2\num@format {\textbf {##1\unbreakablespace ##2:}}
%  \@topcaptiontrue .
%\end{verbatim}
% Note that |\cap@width| is passed a fully evaluated length. Its
% setting does not explicitly depend on |\linewidth|.
% Also note that the testing for `top' has all been done by the parser,
% and the function itself is just passed the simpler
% |\@topcaptiontrue| switch.
%
% This instance thus produces the following terminal output:
%\begin{verbatim}
%  width=336.0pt
%  parashape=raggedright
%  position (if top)=\iftrue
%  arg1=table
%  arg2=10
%  arg3=TheCaptionText
%\end{verbatim}
%
% Normally one would not run such a function directly, but would
% declare an instance of the function with fixed paramater settings.
%\begin{verbatim}
%\DefineFunctionInstance\captionsetting{setcaption}{
%   captionwidth    = \linewidth,
%   paragraph-shape = centerlast,
%   number-format   = \textsf{#1\unbreakablespace #2.},
%   position        = bottom}
%\end{verbatim}
%
% This could then be called by the float handling routines with the
% necessary arguments supplied. Our example
%\begin{verbatim}
%\captionsetting{table}{10}{The Caption Text}
%\end{verbatim}
% produces
%\begin{verbatim}
%  width=360.0pt
%  parashape=centerlast
%  position (if top)=\iffalse
%  arg1=table
%  arg2=10
%  arg3=TheCaptionText
%\end{verbatim}
%
% \StopEventually{}
% \CheckSum{444}
%
% \section{Implementation}
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
\RequirePackage{ldcsetup}
%    \end{macrocode}
%
% Ignore white space in this package.
%    \begin{macrocode}
\IgnoreWhiteSpace
%    \end{macrocode}
%
% Declare a private token register for building parameter lists.
% Having the number saves a few expandafters
% (probably not needed in the end).
%    \begin{macrocode}
\newtoks\TP@toks
%\edef\TP@toksx{\the\allocationnumber}
%    \end{macrocode}
%
%
% \begin{macro}{\functiondefine}
% |\def| setup with a latex style `number of arguments' argument.
%    \begin{macrocode}
\def\functiondefine#1#2#3{%
  \def\@tempa##1#1##2##{%
    \expandafter\def\expandafter#2\@gobble##1#1}%
  \@tempa0##1##2##3##4##5##6##7##8##9{#3}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareCommandInstance}
% Declare a command name to be an instance of a generic function
% ie with a particular setting of the parameters.\\
% |#1| command name for function instance to be (globally) declared\\
% |#2| symbolic name of a generic function\\
% |#3| key value assignments for parameters of |#2|
%    \begin{macrocode}
\def\DeclareCommandInstance#1#2#3{
  \begingroup
    \TP@toks{}
    \toks@\expandafter\expandafter\expandafter
           {\csname TEMPD@#2\endcsname\relax\relax}
  \setkeys{#2}{#3}
  \expandafter\TP@add@default\the\toks@
    \xdef#1{
      \expandafter\ifx\csname TEMP@#2\endcsname\TP@dpa
        \the\TP@toks
      \else
        \noexpand\TP@assignments{\the\TP@toks}
        \expandafter\noexpand\csname TEMP@#2\endcsname
      \fi}
  \endgroup}
%    \end{macrocode}
%
%    \begin{macrocode}
\long\def\TP@dpa{\DoParameterAssignments}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@add@default#1#2{
  \ifx#1\relax
   \else
     \@temptokena{#2}
     \edef\@tempa{{\the\@temptokena\the\TP@toks}}
     \TP@toks\@tempa
    \expandafter\TP@add@default
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\UseCommandTemplate}
% Directly use a template with a particular parameter setting.
% This is also picked up if used in a nested fashion inside a parameter
% list.\\
% |#1| symbolic name of a template.\\
% |#2| key value assignments for parameters of |#1|.
%    \begin{macrocode}
\def\UseCommandTemplate#1#2{
  \TP@toks{}
    \toks@\expandafter\expandafter\expandafter
           {\csname TEMPD@#1\endcsname\relax\relax}
  \setkeys{#1}{#2}
  \expandafter\TP@add@default\the\toks@
  \TP@push
  \csname TEMP@#1\endcsname}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DoParameterAssignments}
% Acces the list stored in |\TP@toks|.
%    \begin{macrocode}
\def\DoParameterAssignments{
  \expandafter\TP@pop\the\TP@stack\@@}
\def\TP@pop#1#2\@@{
  \global\TP@stack{#2}
  #1}
%    \end{macrocode}
%
%    \begin{macrocode}
\newtoks\TP@stack
%    \end{macrocode}
%
%    \begin{macrocode}
\global\TP@stack{\relax}% avoid brace loss
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@assignments}
% Access the list stored in |\TP@toks|.
%    \begin{macrocode}
%\def\TP@assignments#1{
%  \TP@toks{\TP@replace{#1}}
%  \the\expandafter\TP@toks}
\def\TP@assignments{
  \afterassignment\TP@push\TP@toks}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@push{
  \global\TP@stack\expandafter
    {\expandafter{\the\expandafter\TP@toks\expandafter}
    \the\TP@stack}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@replace}
% Access the list stored in |\TP@toks|.
%    \begin{macrocode}
%\def\TP@replace#1#2\DoParameterAssignments{%
%  #2#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareCommandTemplate}
%    \begin{macrocode}
\long\def\DeclareCommandTemplate#1#2#3#4{
%    \end{macrocode}
% Parse the key declaration, and execute the list with a suitable
% definition of |\KV@elt|.
%    \begin{macrocode}
  \let\KV@elt\TP@elt
  \def\KV@default@elt##1{\PackageError{template}{Missing = after ##1}\@ehd}
  \def\TP@name{#1}
  \toks@{}
  \KV@parse{#3}
%    \end{macrocode}
%
% Define the defaults 
%    \begin{macrocode}
  \expandafter\edef\csname TEMPD@#1\endcsname{\the\toks@}
%    \end{macrocode}
%
% Define the generic function.
%    \begin{macrocode}
  \expandafter\newcommand\csname TEMP@#1\endcsname[#2]{#4}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@elt}
% The list of undefined keys and values is put in the list of the form\\
% |\KV@elt|\marg{key}\marg{val}%^^A
% |\KV@elt|\marg{key}\marg{val}\ldots\\
% So just need to give this macro a suitable definition. We just need
% to look at the first token of the value, to see what sort of key
% it is, so call a helper function to split that off.
%    \begin{macrocode}
\def\TP@elt#1#2{%
  \TP@do{#1}#2\TP@do}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@do}
% Case switch on the possible key types.
%    \begin{macrocode}
\def\TP@f@shift#1#2{%
  \TP@testopt{#1}{\TPkeycommand{#1}{#2}}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@i@shift#1#2{%
  \TP@testopt{#1}{\TP@instance{#1}{#2}}}
%    \end{macrocode}
%
%      declaration |hd =i{head} \fooo| \\
%      use         |hd = mine|\\
% makes |\fooo| shorthand for |\UseInstance{head}{mine}|
%    \begin{macrocode}
\def\TP@instance#1#2#3{
  \TP@define@key{#1}{
    \TPinstance#3{#2}{##1}}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TPinstance#1#2#3{
    \expandafter\let\expandafter#1\csname#2-#3\endcsname
    \expandafter\addto@hook\expandafter\TP@toks\expandafter{
             \expandafter\let\expandafter#1\csname #2-#3\endcsname}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@do#1#2#3\TP@do{
  \ifx#2f
     \TP@f@shift{#1}#3\@@
  \else\ifx#2n
     \TP@testopt{#1}{\TPkeycommand{#1}0}#3\@@
  \else\ifx#2l
     \TP@testopt{#1}{\TP@register\setlength{#1}}#3\@@
  \else\ifx#2c
     \TP@testopt{#1}{\TP@register\SetInternalCounter{#1}}#3\@@
  \else\ifx#2b
     \TP@testopt{#1}{\TP@setboolean{#1}}#3\@@
  \else\ifx#2s
     \TP@testopt{#1}{\TP@booltest{#1}}#3\@@
  \else\ifx#2g
     \TP@testopt{#1}{\TP@setgeneral{#1}}#3\@@
  \else\ifx#2x
     \TP@testopt{#1}{\TP@setx{#1}}#3\@@
  \else\ifx#2i
     \TP@i@shift{#1}#3\@@
  \else
      \PackageError{template}{Unknown~key~type~ (#2)~for~#1}\@eha
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi
    \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@testopt}
%    \begin{macrocode}
\def\TP@testopt#1#2{
  \@ifnextchar[%]
    {\TP@test@pt{#1}{#2}}
    {\TP@zap@@{#2}}}
%    \end{macrocode}
%
%    \begin{macrocode}
%    \end{macrocode}
\def\TP@zap@@#1#2\@@{
  #1{#2}}
%
%    \begin{macrocode}
\def\TP@test@pt#1#2[#3]#4\@@{
  #2
  {#4}
  \begingroup
    \TP@toks{}
    \let\TP@remove\@gobble
    \csname KV@\TP@name @#1\endcsname{#3}
  \expandafter
  \endgroup
  \expandafter
  \toks@\expandafter{
     \csname KV@\TP@name @#1\expandafter\endcsname\expandafter
         {\the\expandafter\TP@toks\expandafter}\the\toks@}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@setgenral}
%    \begin{macrocode}
\def\TP@setx#1#2{
  \TP@define@key{#1}{\addto@hook\TP@toks{#2}}}
\def\TP@setgeneral#1#2{
  \TP@define@key{#1}{#2}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@setboolean#1#2{
  \expandafter\let\csname if#2\endcsname\iftrue
  \TP@define@key{#1}{
    \TPsetboolean{#2}{##1}}
}
%    \end{macrocode}
%
% Modify so the boolean does not need to have been declared with |\newif|
%    \begin{macrocode}
\def\TPsetboolean#1#2{
  \expandafter\ifx\csname if#2\endcsname\relax
    \PackageError{template}{Bad~boolean~setting~#1=#2}\@eha
  \else
    \expandafter\let\csname if#1\expandafter\endcsname\csname if#2\endcsname
    \expandafter\addto@hook\expandafter\TP@toks\expandafter{
             \expandafter\let
             \csname if#1\expandafter\endcsname\csname if#2\endcsname}
   \fi}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@booltest#1#2{
  \TP@define@key{#1}{
    \TPbooltest{##1}#2}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@true{true}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TPbooltest#1#2#3{
% no error check on this yet.
  \def\@tempa{#1}
  \ifx\@tempa\TP@true
     \addto@hook\TP@toks{#2}
  \else
     \addto@hook\TP@toks{#3}
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\generalcode}
% The first token of the key type declaration is never executed, it
% Just is used to control the switch in |\TP@do|. So this could have
% an arbitrary definition, but define it like this so it does
% something sensible if it is accidently used in a different context.
%
% Not used in current version.
%    \begin{macrocode}
\let\generalcode\@firstofone
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TP@register}
% This is normally called automatically by |\DeclareGenericFunction|.
%
% Command for setting a generic function attribute whose name
% corresponds directly to a tex count or length register\\
% |#1| the fuction to set the value eg \setlength.\\
% |#2| key name.\\
% |#3| the register to set.
%
% This command \emph{fully evaluates} the argument at declare time,
% and assigns the value to the register. It also passes an assignment
% of the register to the final value into the parameter list for the
% generic function.
%
% If the value is a call to |\DelayEvaluation|, don't evaluate it now,
% just pass the whole assignment to the generic function.
%    \begin{macrocode}
\def\TP@register#1#2#3{
  \TP@define@key{#2}{
      \expandafter\ifx\@car##1\@nil\DelayEvaluation
        \addto@hook\TP@toks{#1#3{##1}}
       \else
      #1#3{##1}
      \expandafter\addto@hook\expandafter\TP@toks\expandafter{
                   \expandafter
                        #3
                        \expandafter=
                        \the#3\relax}
       \fi}}
%    \end{macrocode}
%
%    \begin{macrocode}
\let\DelayEvaluation\@firstofone
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TPkeycommand}
% Same for macro names. Again usually called automatically when
%  declaring a new generic function.\\
% |#1|  the key.\\
% |#2|   Determines how many arguments the function should have.\\
% |#3| The macro to be defined.
%
% If the `|##1|`, the value passed as the argument of the key |#1|
% to the macro |#3| is invoked starts with |\FunctionInstance|, then a
%  special procedure is taken. Instead of defining a macro with the
%  specified number of arguments, the paramater list of the nested
%  function instance is parsed, and |#3| is defined to be a macro
% expanding to that instance. In this case the specified generic
%  function is responsible for picking up the requested number of
%  arguments. (This is \emph{not} checked.)
%    \begin{macrocode}
\def\TP@define@key#1#2{%
  \edef\@tempa{
    \noexpand\TP@remove
    \expandafter\noexpand\csname KV@\TP@name @#1\endcsname}
  \expandafter\def
    \csname KV@\TP@name @#1\expandafter\endcsname\expandafter##\expandafter1
      \expandafter{\@tempa#2}}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TP@remove#1{
  \def\@tempa##1#1##2##3#1##4\@@{
    \toks@{##1##3}}
  \expandafter\@tempa\the\toks@#1\relax#1\@@}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\TPkeycommand#1#2#3{
  \TP@define@key{#1}{
%    \end{macrocode}
%
% |##1| can either be arbitrary inline code, in which case it will be
% defined with |\newcommand[val]| so it needs to use |#1| -- |#val|.
%
% Or it can be |\UseTemplate{some-type}{some-TP}{key settings}|
% as described above.
%    \begin{macrocode}
      \expandafter\ifx\@car##1.\@nil\UseTemplate
%    \end{macrocode}
% Define a scratch macro to be the function instance.
%    \begin{macrocode}
       {\TP@fudge##1}
%    \end{macrocode}
%
% The messing around with token registers stops |#| buildup.
%    \begin{macrocode}
        \expandafter\addto@hook\expandafter\TP@toks\expandafter{
                                    \expandafter\KV@toks\expandafter{\TP@gtemp}
                             \edef#3{\the\KV@toks}}
      \else
      \addto@hook\TP@toks{
                           \functiondefine#2#3{##1}}
      \fi
      }
    }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareEnvironmentTemplate}
% |{name}{args}{spec}{begin code}{end code}|
%    \begin{macrocode}
\long\def\DeclareEnvironmentTemplate#1#2#3#4#5{
  \DeclareGenericFunction{#1}{#2}{#3}{#4}
  \long\expandafter\def\csname endTEMP@#1\endcsname{#5}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\long\def\DeclareEnvironmentInstance#1#2#3{
  \expandafter\DefineFunctionInstance\csname#1\endcsname{#2}{#3}
  \expandafter\let\csname end#1\expandafter\endcsname
              \csname endTEMP@#2\endcsname}
%    \end{macrocode}
%
% \end{macro}
%
% \begin{macro}{\DeclareTemplate}
% |{type}{templatename}{nofarg}{keywordspec}{code}|
%    \begin{macrocode}
\def\DeclareTemplate#1#2{
  \DeclareCommandTemplate{#1=#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareInstance}
% |{type}{instname}{templatename}{keyval}|
%    \begin{macrocode}
\long\def\DeclareInstance#1#2#3{
  \expandafter\DeclareCommandInstance\csname#1-#2\endcsname{#1=#3}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\UseInstance}
% |{type}{instname}|
%    \begin{macrocode}
\long\def\UseInstance#1#2{\csname#1-#2\endcsname}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\UseTemplate}
% |{type}{templatename}{keyval}|
%    \begin{macrocode}
\def\UseTemplate#1#2{
  \UseCommandTemplate{#1=#2}
}

\long\def\TP@fudge#1#2#3{%
  \DeclareCommandInstance\TP@gtemp{#2=#3}}

%    \end{macrocode}
% \end{macro}
%
%
% \Finale
%



