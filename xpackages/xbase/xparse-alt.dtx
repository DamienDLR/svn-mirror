% \iffalse
%% File: xparse-alt.dtx (C) Copyright 1999 Frank Mittelbach, Chris Rowley, 
%%                      David Carlisle
%%                  (C) Copyright 2004-2008 Frank Mittelbach, 
%%                      LaTeX3 Project
%%                  (C) Copyright 2009 LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xbase bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%% 
%
%<*driver|package>
\RequirePackage{l3names}
%</driver|package>
%\fi
\GetIdInfo$Id$
  {Generic document command parser}
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{xparse-alt.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{xparse-alt} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Generic document command parser}
% \author{\Team}
% \date{\filedate}
% \maketitle
%
%\begin{documentation}
%
%\section{Creating document commands}
%
% This package implements high-level interface commands which allows
% the separation of document-level commands from their internal 
% implementations. This works by declaration commands that provide a 
% general specification method for the typical \LaTeX{} syntax, e.g.,
% star-form, optional arguments, and mandatory arguments. A command
% (or environment) declared in this way parses the input according to
% its spec and presents its findings in a normalized way for further
% processing.
% 
%\subsection{Argument specifier}
%
% An argument specification is a list of letters each representing a
% type of argument, i.e.,\texttt{m} is a mandatory argument (surrounded 
% by braces), \texttt{o} an optional argument (surrounded by brackets if
% present), and \texttt{s} represents a star (which might be present 
% or not). Thus the argument spec for headings as implemented by
% \cs{@startsection} in \LaTeXe\ would be represented by the
% three letters \texttt{som}. Other argument types are available and 
% can be added at will. For a complete list of built-in argument types 
% see the next section.
% 
% Lower-case letters are used for created normal, short arguments
% (those which will not accept \cs{par} tokens). On the other hand,
% upper-case letters represent \cs{long} arguments. 
% 
%\subsection{Parsing results}
%
% To normalise the result of parsing the input according to an
% argument specification it is important to uniquely identify all
% arguments found. For this reason each parsing operation initiated by
% one of the argument spec letters will result in an identifiable
% output as follows:
%\begin{description}
%  \item[m] will return the parsed argument surrounded by a brace
%    pair, i.e., will normally be the identity.
% \item[o] will return the parsed argument surrounded by a brace pair
%    if present. Otherwise it will return the token \cs{NoValue}.
% \item[d\{default\}] will return the parsed argument surrounded by a
%    brace pair if present. Otherwise it will return the |{default}|
%    as specified above.
% \item[l] Reads everything up to the first left brace as the
%   argument.
% \item[t\{\meta{token}\}] will return either the token 
%   \cs{c_true_bool} or \cs{c_false_bool} depending on whether or not 
%   the next token is \meta{token}.
% \item[s] will return either the token \cs{c_true_bool} or 
%   \cs{c_false_bool} depending on whether or not a star was parsed. 
%   This is just a shorthand for |t{*}|.
% \item[c] will parse the syntax |(|\meta{x}|,|\meta{y}|)|, i.e., a
%   coordinate pair and will return |{{|\meta{x}|}{|\meta{y}|}}| as
%   the result. If no open parentheses is scanned an error is
%   signalled.
% \item[p\{\{x-default\}\{y-default\}\}] behaves like \texttt{c}, i.e.,
%   parses a coordinate pair if present. If the coordinate pair is
%   missing it returns the default values instead.
%\end{description}
%  \cs{long} versions are available as the upper-case letters for the
%  first four specifiers. Long arguments do not make sense for 
%  \texttt{t}-, \texttt{s}-, \texttt{c}- or \texttt{p}-type arguments.
% 
% For example, given the spec |soomd{default}|, the input
% `|*[Foo]{Bar}|' would be parsed as:
%\begin{itemize} 
%  \item |#1| = |\c_true_bool|
%  \item |#2| = |{Foo}|
%  \item |#3| = |\NoValue|
%  \item |#4| = |{Bar}|
%  \item |#5| = |{default}|
%\end{itemize}
% whereas `|[One][Two]{}[three]|' would be parsed as:
%\begin{itemize} 
%  \item |#1| = |\c_false_bool|
%  \item |#2| = |{One}|
%  \item |#3| = |{Two}|
%  \item |#4| = |{}|
%  \item |#5| = |{Three}|
%\end{itemize}
% In other words there will be always exactly the same number of brace 
% groups or tokens as the number of letters in the argument spec.
% 
%\subsection{Applying the parsing results}
%
% Since the result of the parsing is a well-defined number of tokens or
% brace groups it is easy to pass them on in any order to any
% processing function. To this end the tokens or brace groups are
% associated with the standard argument specifiers in \TeX{} macros,
% i.e., |#1|, |#2|, and so forth. This limits the argument
% specification to a maximum number of 9 letters, but for practical
% applications this should be sufficient. The package will generate
% an error if you attempt to create a function with more than nine 
% arguments!
% 
%\subsection{Optional and mandatory arguments}
%
% The specifiers \texttt{c}, \texttt{l}, \texttt{L}, \texttt{m} and
% \texttt{M} indicate mandatory arguments: an error will result if
% the argument is missing. All other arguments are optional. However,
% this could lead to inconsistent spacing. Imagine a command 
% \cs{test} with signature \texttt{mo}. Calling it with the 
% optional argument |\test{arg}[opt]| will result in the following
% space being obeyed. So that the space is also obeyed if the optional
% argument is not give |\test{arg}|, spaces are not ignored when 
% searching for optional arguments at the end of a command. Thus
% |\test{arg}[opt]| will record a valid |#2| argument, whereas
% |\test{arg} [opt]| will show \cs{NoValue} for |#2|. This does not
% apply to optional arguments \emph{before} the last mandatory one, 
% where spaces are ignored and gaps can therefore be left.
% 
% It may be the case that the automatic decision is not the correct
% one when it comes to skipping spaces. There are therefore two
% over-ride markers. Adding \texttt{>} before an optional argument
% means that it has to follow directly after the preceding argument, 
% with no spaces skipped. On the other hand, adding \texttt{!} will 
% mean that spaces are skipped even if the optional argument comes at
% the end of the argument list.
% 
%\subsection{The interface builder}
%
% The interface-building commands are the preferred method for 
% creating document-level functions in \LaTeX3. All of the functions 
% generated in this way are naturally robust. 
%
%\begin{function}{%
%  \DeclareDocumentCommand|
%  \NewDocumentCommand|
%  \RenewDocumentCommand|
%  \ProvideDocumentCommand
%}
%  \begin{syntax}
%    "\DeclareDocumentCommand" <function> <arg spec> <code>
%  \end{syntax}
%  Declares <function> using <arg spec>, as described above, to
%  create the argument processing code. Within the <code>, |#1|, |#2|,
%  etc., denote the results of parsing the <arg spec> into \TeX\ 
%  arguments. 
%  
%  The \cs{Declare\ldots} function will ignore any existing
%  definition. \cs{New\ldots} will only work if <function> is not
%  already defined, while \cs{Renew\ldots} requires that <function>
%  already exists. Both issues errors if the requirement is no met.
%  In contrast, \cs{Provide\ldots} will \emph{only} define <function>
%  if it is not already defined and will do nothing otherwise.
%\end{function}
%
% As an example:
%\begin{verbatim}
%  \DeclareDocumentCommand {\chapter} { som } {
%    \IfBooleanTF {#1} {
%      \typesetnormalchapter {#2} {#3} 
%    }{
%      \typesetstarchapter {#3}
%  }
%\end{verbatim}
% would be a way to define a \cs{chapter} command which would
% essentially behave like the current \LaTeXe\ command (except that it
% would accept an optional argument even when a \texttt{*} was parsed).
% The \cs{typesetnormalchapter} could test its first argument for being
% \cs{NoValue} to see if an optional argument was present.
% 
%\subsection{Separating argument specification and implementation}
%
% Combining signature and top-level definition of a command \cs{foo} as
% in
%\begin{verbatim}
%  \DeclareDocumentCommand \foo { m c m } {
%    \typeout{1:#1}
%    \typeout{2:#2}
%    \typeout{3:#3}
%  }
%\end{verbatim}
% is fine in certain cases, e.g., if the user wants to declare a few
% commands this way in the preamble of a document. However in a class
% file it probably better to completely separate signature (i.e.,
% argument |#1| and |#2|) from top-level implementation (i.e., argument
% |#3|).
%
%\begin{function}{\DeclareDocumentCommandInterface}
%  \begin{syntax}
%    "\DeclareDocumentCommandInterface" 
%    ~~~~<function> <implementation> <arg spec>
%  \end{syntax}
%  Declares <function> with <arg spec>, with the internal implementation
%  of <function> stored under the name <implementation>.
%\end{function}
%
%\begin{function}{\DeclareDocumentCommandImplementation}
%  \begin{syntax}
%    "\DeclareDocumentCommandImplementation"
%    ~~~~<implementation> <num args> <code>
%  \end{syntax}
%  Declares <implementation> as the name of a command implementation
%  taking <num args>, and expanding to <code>.
%\end{function}
%
% Taking the example above, the two would then be used as:
%\begin{verbatim}
%  \DeclareDocumentCommandInterface \foo { bar } { m c m }
%  \DeclareDocumentCommandImplementation { bar } { 3 } {
%    \typeout{1:#1}
%    \typeout{2:#2}
%    \typeout{3:#3}
%  }
%\end{verbatim}
% In this way, the code for a command can be altered without needing 
% to touch the interface of the command.
% 
%\subsection{Utility functions}
%
%\begin{function}{\IfBoolean / (TF) (EXP)}
%  \begin{syntax}
%    "\IfBooleanTF" <token> <true code> <false code>
%  \end{syntax}
%  Executes <true code> if <token> is equal to \cs{c_true_bool} and
%  <false code> if it is equal to \cs{c_false_bool}.  
%  \begin{texnote}
%    These are document-level names for \cs{bool_if:N(TF)}.
%  \end{texnote}
%\end{function}
%  As mentioned earlier, the parsing result of a \texttt{s} or
%  |t{+}| arg spec will be one of these Boolean values. The result
%  can therefore be tested using \cs{IfBooleanTF}, with the
%  \texttt{T} and \texttt{F} variants as obvious short cuts.
%\begin{verbatim}
%  \DeclareDocumentCommand {\exampleone} { sm } {
%    \IfBooleanTF #1 {
%      \DoSomethingWithStar {#2} 
%    }{
%      \DoSomethingWithoutStar {#2}
%  }
%  \DeclareDocumentCommand {\exampletwo} { sm } {
%    \IfBooleanT #1 {
%      \DoSomethingWithStar {#2} 
%    }
%  }
%  \DeclareDocumentCommand {\examplethree} { sm } {
%    \IfBooleanF #1 {
%      \DoSomethingWithoutStar {#2} 
%    }
%  }
%\end{verbatim}
%
%\begin{function}{
%  \IfNoValue / (TF) |
%  \IfValue / (TF) 
%}
%  \begin{syntax}
%    "\IfNoValueTF" <tokens> <true code> <false code>
%  \end{syntax}
%  Executes <true code> if <tokens> is exactly equal to the marker
%  \cs{NoValue}, and <false code> otherwise. The test is reversed by
%  \cs{IfValue(TF)}.
%\end{function}
%
%\begin{variable}{\NoValue}
%  This is a special marker token returned when an optional argument
%  is not given, as opposed to be given as an empty value. It should be
%  tested for using the \cs{IfNoValue(TF)} tests.
%\end{variable}
%
% An example of testing for \cs{NoValue}:
%\begin{verbatim}
%  \DeclareDocumentCommand \testcmd {om} {
%    \IfNoValueTF {#1} {``#2''} {#1,#2}
%  }
%\end{verbatim}
%
%\subsection{Extending the argument specifier}
%
%\begin{function}{\DeclareArgumentType}
%  \begin{syntax}
%    "\DeclareArgumentType" <arg spec> <token> <method> <blank> 
%    ~~~~<default> <match> <return>
%  \end{syntax}
%  Declares an optional <arg spec>, which will start with <token>.
%  The <method> for comparing <token> with the input should be one
%  of \texttt{meaning}, \texttt{charcode} or \texttt{catcode}.
%  If <token> is not found, <blank> code is executed and <default>
%  if returned. If <token> is found, the scanner looks for the 
%  full <match> and uses this to produce a <return>. <match> is a 
%  primitive \TeX\ argument specification.
%
%  The <method> is used to choose the underlying \cs{peek_\ldots}
%  test used for the comparison. For example, use the 
%  \texttt{charcode} version if you want to pick up a literal 
%  \texttt{*} and not just something that has the same 
%  \emph{meaning} as a regular \texttt{*}.
%\end{function}
%
% This is perhaps clearer with an example\dots\ This is how the 
% \texttt{o} type is implemented:
%\begin{verbatim}
%  \DeclareArgumentType o [ {meaning} {} {\NoValue} {#1[#2]} {#2}
%\end{verbatim}
% In a similar fashion a |b| type expecting its argument inside |<|
% and |>| would be defined as
%\begin{verbatim}
%  \DeclareArgumentType b < {meaning} {} {\NoValue} {#1<#2>} {#2}
%\end{verbatim}
% Notice that these examples include a ``throw away'' |#1| which will
% ensure that no strange issues arise if there is a gap between a 
% mandatory argument and the next optional one.
% 
%\begin{function}{\DeclareArgumentTypeWithDefault}
%  \begin{syntax}
%    "\DeclareArgumentTypeWithDefault" <arg spec> 
%    ~~~~<token> <method> <match> <return>
%  \end{syntax}
%  Declares an optional <arg spec>, which will start with <token>.,
%  and which will set up a default when used.
%  The <method> for comparing <token> with the input should be one
%  of \texttt{meaning}, \texttt{charcode} or \texttt{catcode}.
%  If <token> is found, the scanner looks for the full <match> and 
%  uses this to produce a <return>. <match> is a primitive \TeX\ 
%  argument specification.
%\end{function}
%
% Once again, an example will probably help. The \texttt{d} specifier
% is implemented as:
%\begin{verbatim}
%  \DeclareArgumentTypeWithDefault d [ {meaning} {#1[#2]} {#2}
%\end{verbatim}
%  and again a similar \texttt{b} type could be implemented as
%\begin{verbatim}
%  \DeclareArgumentTypeWithDefault b < {meaning} {#1<#2>} {#2}
%\end{verbatim}
%
%\begin{function}{\DeclareSymbolArgument}
%  \begin{syntax}
%    "\DeclareSymbolArgument" 
%  \end{syntax}
%\end{function}
%
%\subsection{Coping with verbatim input}
%
% The scanning mechanism used by \pkg{xparse} means that it cannot be
% used to collect verbatim arguments. Instead, the concept of a 
% pseudo-argument can be used to deal with this type of material.
% Strictly speaking these aren't real arguments but instead read by 
% removing a begin group token and then using \cs{group_execute_after:N}
% to regain control. The definition of \cs{footnote} in plain \TeX\ uses
% this so that people can use \cs{verb} and the like inside the 
% footnotes.
%
%\begin{function}{\DeclarePseudoArgument}
%  \begin{syntax}
%    "\DeclarePseudoArgument"  <name> <num args> 
%    ~~~~<pre code> <post code>
%  \end{syntax}
%  Declares a pseudo-argument called <name>, which uses <num args>.
%  <pre code> is executed before collection of the argument, and
%  <post code> after.
%\end{function}
%
% Here is a silly example:
%\begin{verbatim}
%  \DeclarePseudoArgument {boxtest} {1} {
%    Before:~`#1',\hbox_set_inline_begin:N \l_tmpa_box 
%  }{
%    \hbox_set_inline_end: 
%    \iow_space:  
%    the~box:~\hbox_unpack_and_clear:N \l_tmpa_box 
%    ,~After:~`#1'
%  } 
%\end{verbatim}
%
%\begin{function}{\UsePseudoArgument}
%  \begin{syntax}
%    "\UsePseudoArgument"  <name> 
%  \end{syntax}
%  Uses pseudo-argument <name> in the replacement text of a
%  function. This must be given as the last item inside <code> for
%  a document command.
%\end{function}
%
% To continue with the \texttt{boxtest} example:
%\begin{verbatim}
%  \DeclareDocumentCommand {\sillyboxtest} {m} {
%    Testing~#1:~\UsePseudoArgument {boxtest} {#1}
%  }
%\end{verbatim}
% Then calling |\sillyboxtest{AB}{a\verb*+% $%&\+b}| produces
% \begin{quote}
%   Testing AB: Before: `AB', the box:
%   a\verb*+% $%&\+b, After: `AB'
% \end{quote}
%
%\subsection{Internal commands}
%
%\begin{function}{
%  \xparse_add_arg_type_>:|
%  \xparse_add_arg_type_!:
%}
%  \begin{syntax}
%    "\xparse_add_arg_type_>:"
%  \end{syntax}
% Special ``add'' functions which force the space-skipping mode for
% optional arguments.
%\end{function}
%
%\begin{function}{
%  \xparse_add_arg_type_l:|
%  \xparse_add_arg_type_L:|
%  \xparse_add_arg_type_m:|
%  \xparse_add_arg_type_M:|
%}
%  \begin{syntax}
%    "\xparse_add_arg_type_l:"
%  \end{syntax}
%  Add an argument of <type> to the \texttt{signature} token register.
%\end{function}
%
%\begin{function}{
%  \xparse_arg_l:w|
%  \xparse_arg_L:w
%}
%  \begin{syntax}
%    "\xparse_arg_l:w" <arg functions> 
%    ~~~~"\l_xparse_grabbed_args_toks" <arg>
%  \end{syntax}
%  For gathering brace-delimited arguments.
%\end{function}
% 
%\begin{function}{
%  \xparse_arg_m_1:w|
%  \xparse_arg_m_2:w|
%  \xparse_arg_m_3:w|
%  \xparse_arg_m_4:w|
%  \xparse_arg_m_5:w|
%  \xparse_arg_m_6:w|
%  \xparse_arg_m_7:w|
%  \xparse_arg_m_8:w|
%  \xparse_arg_m_9:w
%}
%  \begin{syntax}
%    "\xparse_arg_m_1:w" <arg functions> 
%    ~~~~"\l_xparse_grabbed_args_toks" <arg>
%  \end{syntax}
%  Used to gather one to nine mandatory <args>.
%\end{function}
%
%\begin{function}{\xparse_arg_M:w}
%  \begin{syntax}
%    "\xparse_arg_M:w" <arg functions> 
%    ~~~~"\l_xparse_grabbed_args_toks" <long arg>
%  \end{syntax}
%  Collects a single long mandatory argument.
%\end{function}
%
%\begin{function}{\xparse_check_and_add_argument_type:N}
%  \begin{syntax}
%    "\xparse_check_and_add_argument_type:N"
%    ~~~~<arg spec>
%  \end{syntax}
%  Ensures that <arg spec> is valid, and if so adds it to the 
%  list for building.
%\end{function}
%
%\begin{function}{\xparse_count_mandatory_args:n}
%  \begin{syntax}
%    "\xparse_count_mandatory_args:n" <signature>
%  \end{syntax}
%  Counts the number of mandatory arguments in <signature>.
%\end{function}
%
%\begin{function}{
%  \xparse_declare_cmd:Nnn|
%  \xparse_declare_cmd:cnn
%}
%  \begin{syntax}
%    "\xparse_declare_cmd:Nnn" <function> <signature>
%    ~~~~<code>
%  \end{syntax}
%  Declares <function> using <signature> for argument definition and
%  <code> as expansion.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareDocumentCommand}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\xparse_declare_cmd_interface:Nnn}
%  \begin{syntax}
%    "\xparse_declare_cmd_interface:Nnn" 
%    ~~~~<function> <implementation> <arg spec>
%  \end{syntax}
%  Declares <function> with <arg spec>, with the internal implementation
%  of <function> stored under the name <implementation>.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareDocumentCommandInterface}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\xparse_declare_cmd_implementation:nNn}
%  \begin{syntax}
%    "\xparse_declare_cmd_implementation:nNn"
%    ~~~~<implementation> <num args> <code>
%  \end{syntax}
%  Declares <implementation> as the name of a command implementation
%  taking <num args>, and expanding to <code>.
%  \begin{texnote}
%    This is the internal name for 
%    \cs{DeclareDocumentCommandImplementation}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\xparse_declare_shorthand:Nn}
%  \begin{syntax}
%    "\xparse_declare_shorthand:Nn"
%    ~~~~<arg spec> <replacement> 
%  \end{syntax}
%  Declares <arg spec> as a shorthand for <replacement>, which should
%  also be an <arg spec>.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareArgumentTypeShorthand}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\xparse_declare_opt_type:NNnnnnn}
%  \begin{syntax}
%    "\xparse_declare_opt_type:NNnnnnn" <arg spec> <token>  
%    ~~~~<method> <blank> <default> <match> <return>
%  \end{syntax}
%  Declares an optional <arg spec>, which will start with <token>.
%  The <method> for comparing <token> with the input should be one
%  of \texttt{meaning}, \texttt{charcode} or \texttt{catcode}.
%  If <token> is not found, <blank> code is executed and <default>
%  if returned. If <token> is found, the scanner looks for the 
%  full <match> and uses this to produce a <return>. <match> is a 
%  primitive \TeX\ argument specification.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareArgumentType}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\xparse_declare_opt_default_type:NNnnn}
%  \begin{syntax}
%    "\xparse_declare_opt_default_type:NNnnn" 
%    ~~~~<arg spec> <token>  <method> <match> <return>
%  \end{syntax}
%  Declares an optional <arg spec>, which will start with <token>.,
%  and which will set up a default when used.
%  The <method> for comparing <token> with the input should be one
%  of \texttt{meaning}, \texttt{charcode} or \texttt{catcode}.
%  If <token> is found, the scanner looks for the full <match> and 
%  uses this to produce a <return>. <match> is a primitive \TeX\ 
%  argument specification.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareArgumentTypeWithDefault}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\xparse_declare_pseudo_arg:nNnn}
%  \begin{syntax}
%    "\xparse_declare_pseudo_arg:nNnn" 
%    ~~~~<name> <num args> <pre code> <post code>
%  \end{syntax}
%  Declares a pseudo-argument called <name>, which uses <num args>.
%  <pre code> is executed before collection of the argument, and
%  <post code> after.
%  \begin{texnote}
%    This is the internal name for \cs{DeclarePseudoArgument}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\xparse_declare_symbol_arg:NN}
%  \begin{syntax}
%    "\xparse_declare_symbol_arg:NN" 
%    ~~~~<arg spec> <token> 
%  \end{syntax}
%  Declares <arg spec> to make <token> an optional argument.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareSymbolArgument}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\xparse_flush_m_args:}
%  \begin{syntax}
%    "\xparse_flush_m_args:" 
%  \end{syntax}
%  Adds an outstanding \texttt{m} arguments to the output signature.
%\end{function}
%
%\begin{function}{
%  \xparse_get_default_arg:n|
%  \xparse_get_default_long_arg:n
%}
%  \begin{syntax}
%    "\xparse_get_default_arg:n"  <default>
%  \end{syntax}
%  Save <default> argument to the signature.
%\end{function}
%
%\begin{function}{\xparse_if_no_value:n / (TF) }
%  \begin{syntax}
%    "\xparse_if_no_value:n" <tokens> <true code> <false code>
%  \end{syntax}
%  Executes <true code> if <tokens> is exactly equal to the marker
%  \cs{NoValue}, and <false code> otherwise.
%  \begin{texnote}
%    This is the internal name for \cs{IfNoValue(TF)} and 
%    \cs{IfValue(TF)}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{
%  \xparse_prepare_signature:n|
%  \xparse_prepare_signature:N
%}
%  \begin{syntax}
%    "\xparse_prepare_signature:n"  <arg specs>
%  \end{syntax}
%  Parse one or more <arg specs> and convert to an output <signature>.  
%\end{function}
%
%\begin{function}{\xparse_set_ignore_spaces:}
%  \begin{syntax}
%    "\xparse_set_ignore_spaces:"
%  \end{syntax}
%  Sets up the token list variable indicated whether to ignore spaces.  
%\end{function}
%
%\subsection{Variables and constants}
%
%\begin{variable}{\c_xparse_no_value_tl}
%  The marker value for \cs{NoValue}.
%\end{variable}
%
%\begin{variable}{\g_xparse_ignore_seq}
%  A short sequence for creating space-ignoring and space-obeying
%  functions.
%\end{variable}
%
%\begin{variable}{
%  \g_xparse_mandatory_specs_tl|
%  \g_xparse_need_arg_specs_tl
%}
%  Lists of mandatory argument specifiers, and those that take and
%  argument.
%\end{variable}
%
%\begin{variable}{\g_xparse_shorthands_prop}
%  Shorthands and replacement text.
%\end{variable}
%
%\begin{variable}{
%  \l_xparse_grabber_tl|
%  \l_xparse_map_tl|
%  \l_xparse_tmpa_tl
%}
%  Token lists for various intermediate values.
%\end{variable}
%
%\begin{variable}{\l_xparse_ignore_spaces_tl}
%  Used either blank or with the text |_ignore_spaces| to choose the
%  correct type of optional argument processing.
%\end{variable}
%
%\begin{variable}{
%  \l_xparse_grabbed_args_toks|
%  \l_xparse_signature_toks
%}
%  Token registers used in building the real function and arguments.
%\end{variable}
%
%\begin{variable}{
%  \l_xparse_m_args_int|
%  \l_xparse_mandatory_args_int|
%  \l_xparse_total_args_int
%}
%  Used to enumerate the \texttt{m} arguments, all mandatory arguments
%  and all arguments.
%\end{variable}
%
%\begin{variable}{\l_xparse_pseudo_post_arg_tl}
%  Used to recover control after a pseudo-argument has been read.
%\end{variable}
%
%\begin{variable}{
%  \l_xparse_space_force_bool
%  \l_xparse_space_ignore_bool
%}
%  Signal over-riding of the automatic system for skipping spaces.
%\end{variable}
% 
% \end{documentation}
% 
%\begin{implementation}
%
%\section{\pkg{xparse} implementation}
%
% The usual lead-off.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
\RequirePackage{expl3}
%</package>
%<*initex|package>
%    \end{macrocode}
%    
%\subsection{Variables and constants}
%
%\begin{macro}{\c_xparse_no_value_tl}
% No value, for testing.
%    \begin{macrocode}
\tl_new:Nn \c_xparse_no_value_tl { \NoValue }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\g_xparse_ignore_seq}
% There are two possibilities for optional argument handling.
%    \begin{macrocode}
\seq_new:N \g_xparse_ignore_seq
\seq_gpush:Nn \g_xparse_ignore_seq { }
\seq_gpush:Nn \g_xparse_ignore_seq { _ignore_spaces }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\g_xparse_mandatory_specs_tl}
%\begin{macro}{\g_xparse_need_arg_specs_tl}
% A list of mandatory argument types, set up with those defined by
% hand. Also one for specifiers with a default: this is automatically
% generated.
%    \begin{macrocode}
\tl_new:Nn \g_xparse_mandatory_specs_tl { c l L m M }
\tl_new:N \g_xparse_need_arg_specs_tl
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\g_xparse_shorthands_prop}
% Shorthands are stored as a property list.
%    \begin{macrocode}
\prop_new:N \g_xparse_shorthands_prop
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_grabbed_args_toks}
%\begin{macro}{\l_xparse_signature_toks}
% Various storage bins.
%    \begin{macrocode}
\toks_new:N \l_xparse_grabbed_args_toks
\toks_new:N \l_xparse_signature_toks
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_xparse_m_args_int}
%\begin{macro}{\l_xparse_mandatory_args_int}
%\begin{macro}{\l_xparse_total_args_int}
%  For tracking the arguments given and the number of arguments.
%    \begin{macrocode}
\int_new:N \l_xparse_m_args_int
\int_new:N \l_xparse_mandatory_args_int
\int_new:N \l_xparse_total_args_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_xparse_grabber_tl}
%\begin{macro}{\l_xparse_map_tl}
%\begin{macro}{\l_xparse_tmpa_tl}
% Some general-purpose variables.
%    \begin{macrocode}
\tl_new:N \l_xparse_grabber_tl
\tl_new:N \l_xparse_map_tl
\tl_new:N \l_xparse_tmpa_tl
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_xparse_ignore_spaces_tl}
% Used to contain flag text so that both space-ignoring and normal 
% functions can share the same definition.
%    \begin{macrocode}
\tl_new:N \l_xparse_ignore_spaces_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_pseudo_post_arg_tl}
% A temporary token list variable to store the post-arguments.
%    \begin{macrocode}
\tl_new:N \l_xparse_pseudo_post_arg_tl
%    \end{macrocode}
% \end{macro}
% 
%\begin{macro}{\l_xparse_space_force_bool}
%\begin{macro}{\l_xparse_space_ignore_bool}
% For changing the space-skipping decision.
%    \begin{macrocode}
\bool_new:N \l_xparse_space_force_bool
\bool_new:N \l_xparse_space_ignore_bool
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsection{Internal commands}
%
%\begin{macro}{\xparse_add_arg_type_>:}
%\begin{macro}{\xparse_add_arg_type_!:}
% For controlling spacing.
%    \begin{macrocode}
\cs_new_nopar:cn { xparse_add_arg_type_>: } {
  \int_decr:N \l_xparse_total_args_int
  \bool_set_true:N \l_xparse_space_force_bool
}
\cs_new_nopar:cn { xparse_add_arg_type_!: } {
  \int_decr:N \l_xparse_total_args_int
  \bool_set_true:N \l_xparse_space_ignore_bool
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_add_arg_type_l:}
%\begin{macro}{\xparse_add_arg_type_L:}
%\begin{macro}{\xparse_add_arg_type_m:}
%\begin{macro}{\xparse_add_arg_type_M:}
% The basic mandatory argument types are easy to implement. The only
% odd when is the most basic of all: to save complexity later, 
% \texttt{m} arguments are counted up for later inclusion 
% \emph{en masse}. \texttt{c} is included here as it acts like a
% mandatory argument: no need to worry about space skipping.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_arg_type_l: {
  \int_decr:N \l_xparse_mandatory_args_int
  \xparse_flush_m_args:
  \toks_put_right:Nn \l_xparse_signature_toks { \xparse_arg_l:w }
}
\cs_new_nopar:Nn \xparse_add_arg_type_L: {
  \int_decr:N \l_xparse_mandatory_args_int
  \xparse_flush_m_args:
  \toks_put_right:Nn \l_xparse_signature_toks { \xparse_arg_L:w }
}
\cs_new_nopar:Nn \xparse_add_arg_type_m: {
  \int_decr:N \l_xparse_mandatory_args_int
  \int_incr:N \l_xparse_m_args_int  
}
\cs_new_nopar:Nn \xparse_add_arg_type_M: {
  \int_decr:N \l_xparse_mandatory_args_int
  \xparse_flush_m_args:
  \toks_put_right:Nn \l_xparse_signature_toks { \xparse_arg_M:w }
}

%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_arg_l:w}
%\begin{macro}{\xparse_arg_L:w}
%\begin{macro}{\xparse_arg_M:w}
% The actual argument grabbers are all rather similar.
%    \begin{macrocode}
\cs_new_nopar:Npn \xparse_arg_l:w #1 \l_xparse_grabbed_args_toks #2# {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#2} }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new:Npn \xparse_arg_L:w #1 \l_xparse_grabbed_args_toks #2# {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#2} }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new:Npn \xparse_arg_M:w #1 \l_xparse_grabbed_args_toks #2 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#2} }
  #1 \l_xparse_grabbed_args_toks
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\xparse_arg_m_1:w}
%\begin{macro}{\xparse_arg_m_2:w}
%\begin{macro}{\xparse_arg_m_3:w}
%\begin{macro}{\xparse_arg_m_4:w}
%\begin{macro}{\xparse_arg_m_5:w}
%\begin{macro}{\xparse_arg_m_6:w}
%\begin{macro}{\xparse_arg_m_7:w}
%\begin{macro}{\xparse_arg_m_8:w}
%\begin{macro}{\xparse_arg_m_9:w}
% Grabbing 1--9 mandatory arguments. The one grabbing nine arguments
% will automatically end with \cs{toks_use:N} 
% \cs{l_xparse_grabbed_args_toks} anyway so we avoid problems with that
% one.
%    \begin{macrocode}
\cs_new_nopar:cpn 
  { xparse_arg_m_1:w } #1 \l_xparse_grabbed_args_toks #2 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#2} }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_2:w } #1 \l_xparse_grabbed_args_toks #2#3 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#2} {#3} }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_3:w } #1 \l_xparse_grabbed_args_toks #2#3#4 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#2} {#3} {#4} }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_4:w } #1 \l_xparse_grabbed_args_toks #2#3#4#5 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#2} {#3} {#4} {#5} }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_5:w } #1 \l_xparse_grabbed_args_toks #2#3#4#5#6 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks {
    {#2} {#3} {#4} {#5} {#6}
  }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_6:w } #1 \l_xparse_grabbed_args_toks #2#3#4#5#6#7 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks {
    {#2} {#3} {#4} {#5} {#6} {#7}
  }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_7:w } #1 \l_xparse_grabbed_args_toks #2#3#4#5#6#7#8 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks {
    {#2} {#3} {#4} {#5} {#6} {#7} {#8}
  }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_8:w } #1 \l_xparse_grabbed_args_toks #2#3#4#5#6#7#8#9 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks {
    {#2} {#3} {#4} {#5} {#6} {#7} {#8} {#9}
  }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_9:w } \toks_use:N \l_xparse_grabbed_args_toks 
    #1#2#3#4#5#6#7#8#9 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks {
    {#1} {#2} {#3} {#4} {#5} {#6} {#7} {#8} {#9}
  }
  \toks_use:N \l_xparse_grabbed_args_toks
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_check_and_add_argument_type:N}
% This function checks if the argument type actually exists and gives
% an error if it doesn't.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_check_and_add_argument_type:N  {
  \cs_if_free:cTF { xparse_add_arg_type_#1: } {
    \msg_error:nnx { xparse } { unknown~argument~type } {#1}
    \xparse_add_arg_type_m:
  }{
    \use:c { xparse_add_arg_type_#1: }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_count_mandatory_args:n}
%\begin{macro}[aux]{\xparse_count_mandatory_args:N}
% A running total of the mandatory arguments is needed. The odd
% \cs{use_i:nn} here is used to mop up the second argument for 
% specifiers which use them.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_count_mandatory_args:n {
  \int_zero:N \l_xparse_mandatory_args_int
  \xparse_count_mandatory_args:N #1 \q_nil
}
\cs_new_nopar:Nn \xparse_count_mandatory_args:N {
  \quark_if_nil:NF #1 {
    \tl_if_in:NnTF \g_xparse_mandatory_specs_tl {#1} {
      \int_incr:N \l_xparse_mandatory_args_int
    }{
      \tl_if_in:NnT \g_xparse_need_arg_specs_tl {#1} {
        \use_i:nn
      }
    }
    \xparse_count_mandatory_args:N
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_declare_cmd:Nnn}
%\begin{macro}{\xparse_declare_cmd:cnn}
% \cs{xparse_declare_document_command:Nnn} is a two-step procedure. The
% user level command \texttt{\textbackslash \meta{cmd}} contains the
% argument grabber whilst the internal command 
%  \texttt{\textbackslash\textbackslash \meta{cmd}} holds the actual
%  definition of what to do.
%    \begin{macrocode}
\cs_set:Nn \xparse_declare_cmd:Nnn {
  \xparse_count_mandatory_args:n {#2}
  \xparse_prepare_signature:n {#2}
  \cs_set_protected_nopar:Npx #1 {
    \exp_not:n { \toks_set:Nn \l_xparse_grabbed_args_toks }
      { \exp_not:c { \token_to_str:N #1 } }
    \toks_use:N \l_xparse_signature_toks
    \exp_not:n{ \toks_use:N \l_xparse_grabbed_args_toks }
  }
  \cs_generate_from_arg_count:cNnn 
    { \token_to_str:N #1 } \cs_set:Npn \l_xparse_total_args_int {#3}
}
\cs_generate_variant:Nn \xparse_declare_cmd:Nnn {c}
%    \end{macrocode} 
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_declare_cmd_interface:Nnn}
%\begin{macro}{\xparse_declare_cmd_implementation:nNn}
% Creating the abstracted implementation interface is very similar to
% the basic command definition system. It is only the code that is
% attached to the function that is different.
%    \begin{macrocode}
\cs_new:Nn \xparse_declare_cmd_interface:Nnn {
  \xparse_count_mandatory_args:n {#3}
  \xparse_prepare_signature:n {#3}
  \cs_set_protected_nopar:Npx #1 {
    \exp_not:n { \toks_set:Nn \l_xparse_grabbed_args_toks }
      { \exp_not:c { xparse_impl_ #2 } }
    \toks_use:N \l_xparse_signature_toks
    \exp_not:n{ \toks_use:N \l_xparse_grabbed_args_toks }
  }
  \xparse_declare_cmd_implementation:nNn 
    {#2} { \l_xparse_total_args_int } { 
    ``#1''
    \msg_warning:nnx { xparse } { no~command~implementation } {#2}
  }
}
\cs_new:Nn \xparse_declare_cmd_implementation:nNn {
  \cs_generate_from_arg_count:cNnn { xparse_impl_ #1 }
    \cs_set:Npn {#2} {#3}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_declare_opt_type:NNnnnnn}
%\begin{macro}[aux]{\xparse_declare_opt_type_add:N}
%\begin{macro}[aux]{\xparse_declare_opt_type_grab:NNNnnn}
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_declare_opt_type:NNnnnnn {
  \xparse_declare_opt_type_add:N #1
  \xparse_declare_opt_type_grab:NNNnnn 
    \cs_set_nopar:cpx #1 #2 {#3} {#4} {#5}
  \xparse_define_helper:Nnnn #1 {#3} {#6} {#7}  
  \tl_to_uppercase:n { 
    \tl_set:Nn \l_xparse_tmpa_tl {#1}
  }
  \xparse_declare_opt_type_add:N \l_xparse_tmpa_tl
  \xparse_declare_opt_type_grab:NNNnnn 
    \cs_set:cpx \l_xparse_tmpa_tl #2 {#3} {#4} {#5}
  \xparse_define_helper:Nnnn \l_xparse_tmpa_tl {#3} {#6} {#7}
}
%    \end{macrocode}
% The functions for adding to the constructed signature are created
% in such a way that both lower- and upper-case versions use the same
% auxiliary.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_declare_opt_type_add:N {
  \cs_set_nopar:cpx { xparse_add_arg_type_ #1 : } {
    \exp_not:n {
      \xparse_flush_m_args:
      \xparse_ignore_set:
      \toks_put_right:Nx \l_xparse_signature_toks 
    } {
      \exp_not:N \exp_not:c { 
        xparse_arg_ #1 \exp_not:N \l_xparse_ignore_spaces_tl :w 
      }
    }
  }
}
%    \end{macrocode}
% The grabber functions are created separately, so that the long and
% short ones can use virtually the same code.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_declare_opt_type_grab:NNNnnn {
  \seq_map_variable:NNn \g_xparse_ignore_seq \l_xparse_map_tl {
    #1 
      { xparse_arg_ #2 \l_xparse_map_tl :w } 
      ##1 \l_xparse_grabbed_args_toks {
      \exp_not:c { peek_ #4 \l_xparse_map_tl :NTF } \exp_not:N #3 {
        \exp_not:c { xparse_ #2 _ #4 _help:nw } {##1}          
      }{
        \exp_not:n {
          #5 \toks_put_right:Nn \l_xparse_grabbed_args_toks {#6}
        }
        ##1 \exp_not:N \l_xparse_grabbed_args_toks
      }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\xparse_declare_opt_default_type:NNnnn}
% Similar to the system without a default. There is a need to set up
% the correct default argument grabber, which means a couple of extra
% lines. The rest is simple.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_declare_opt_default_type:NNnnn {
  \tl_set:Nn \l_xparse_grabber_tl { \xparse_get_default_arg:n }
  \xparse_declare_opt_default_type_add:N #1
  \xparse_declare_opt_default_type_grab:NNNn 
    \cs_set_nopar:cpx #1 #2 {#3}
  \xparse_define_helper:Nnnn #1 {#3} {#4} {#5}
  \tl_to_uppercase:n { 
    \tl_set:Nn \l_xparse_tmpa_tl {#1}
  }
  \tl_set:Nn \l_xparse_grabber_tl { \xparse_get_default_long_arg:n }
  \xparse_declare_opt_default_type_add:N \l_xparse_tmpa_tl
  \xparse_declare_opt_default_type_grab:NNNn 
    \cs_set:cpx \l_xparse_tmpa_tl #2 {#3}
  \xparse_define_helper:Nnnn \l_xparse_tmpa_tl {#3} {#4} {#5} 
}
\cs_new_nopar:Nn \xparse_declare_opt_default_type_add:N {
  \tl_gput_right:Nx \g_xparse_need_arg_specs_tl {#1}
  \cs_set_nopar:cpx { xparse_add_arg_type_ #1 : } {
    \exp_not:n {
      \xparse_flush_m_args:
      \xparse_ignore_set:
      \toks_put_right:Nx \l_xparse_signature_toks 
    } {
      \exp_not:N \exp_not:c { 
        xparse_arg_ #1 \exp_not:N \l_xparse_ignore_spaces_tl :w 
      }
    }
    \exp_not:n {
      \cs_set_eq:NN \xparse_prepare_next:w
    } 
    \exp_after:wN \exp_not:N \l_xparse_grabber_tl
  }
}
\cs_new_nopar:Nn \xparse_declare_opt_default_type_grab:NNNn {
  \seq_map_variable:NNn \g_xparse_ignore_seq \l_xparse_map_tl {
    #1 
      { xparse_arg_ #2 \l_xparse_map_tl :w } 
      ##1##2 \l_xparse_grabbed_args_toks {
      \exp_not:c { peek_ #4 \l_xparse_map_tl :NTF } \exp_not:N #3 {
        \exp_not:c { xparse_ #2 _ #4 _help:nw } {##2}          
      }{
        \exp_not:n { \toks_put_right:Nn \l_xparse_grabbed_args_toks }
          { {##1} }
        ##2 \exp_not:N \l_xparse_grabbed_args_toks
      }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_declare_pseudo_arg:nNnn}
% Creating a pseudo-argument means saving the code to execute before and
% after the collected material in two functions which take the 
% appropriate number of arguments. A precaution is taken in case the
% pseudo argument is not given in braces, then a group is scanned for.
% If one is found, the \meta{post code} is set up to hook into things
% after the group ends. The test will remove the group token if it
% exists, so there is a need to add it back in afterwards!
%    \begin{macrocode}
\cs_new:Nn \xparse_declare_pseudo_arg:nNnn {
  \cs_set:cn { xparse_pseudo_pre_arg_ #1 : \prg_replicate:nn {#2} {n} } 
    {#3}
  \cs_set:cn { xparse_pseudo_post_arg_ #1 : \prg_replicate:nn {#2} {n} } 
    {#4}
  \cs_set_nopar:cn { xparse_pseudo_nobrace_arg_ #1 :N } {
    ##1 \l_xparse_pseudo_post_arg_tl
  }
  \cs_generate_from_arg_count:cNnn { xparse_pseudo_arg_#1:w } 
    \cs_set:Npx {#2} {
    \exp_not:c {
       xparse_pseudo_pre_arg_ #1 : \prg_replicate:nn {#2} {n}
    }
    \use:c{ use_ \intexpr_eval:n {#2} _parameter: }
    \exp_not:n { \tl_set:Nn \l_xparse_pseudo_post_arg_tl } {
      \exp_not:c { 
        xparse_pseudo_post_arg_ #1 : \prg_replicate:nn {#2} {n} 
      }
      \use:c{ use_ \intexpr_eval:n {#2} _parameter: }
    }
    \exp_not:n { 
      \peek_catcode_remove_ignore_spaces:NTF \c_group_begin_token 
    } {
      \exp_not:n {
        \c_group_begin_token
        \group_execute_after:N \l_xparse_pseudo_post_arg_tl
      }
    }{
      \exp_not:c{ xparse_pseudo_nobrace_arg_ #1 :N }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_declare_shorthand:Nn}
% Declaring a shorthand is simply a case of adding to the list.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_declare_shorthand:Nn {
  \prop_gput:Nnn \g_xparse_shorthands_prop {#1} {#2}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_declare_symbol_arg:NN}
%\begin{macro}[aux]{\xparse_declare_symbol_add:N}
% Making a new symbol argument has two parts. First, the \texttt{add}
% function is defined. It checks whether to ignore spaces, based on
% the current mandatory argument count, then adds the appropriate
% function to the signature. The second phase is to make the functions
% themselves. Two are needed, and so a mapping makes life a bit easier.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_declare_symbol_arg:NN {
  \xparse_declare_symbol_arg_add:N #1
  \seq_map_variable:NNn \g_xparse_ignore_seq \l_xparse_map_tl {
    \cs_set_nopar:cpx 
      { xparse_arg_ #1 \l_xparse_map_tl :w } 
      ##1##2 \l_xparse_grabbed_args_toks {
      \exp_not:c { peek_ #2 _remove \l_xparse_map_tl :NTF } ##1 {
        \exp_not:n {
          \toks_put_right:Nn \l_xparse_grabbed_args_toks \c_true_bool
        }
        ##2 \exp_not:N \l_xparse_grabbed_args_toks
      }{
        \exp_not:n {
          \toks_put_right:Nn \l_xparse_grabbed_args_toks \c_false_bool
        }
        ##2 \exp_not:N \l_xparse_grabbed_args_toks
      }
    }
  }
}
\cs_new_nopar:Nn \xparse_declare_symbol_arg_add:N {
  \tl_gput_right:Nx \g_xparse_need_arg_specs_tl {#1}
  \cs_set_nopar:cpn { xparse_add_arg_type_ #1 : } {
    \xparse_flush_m_args:
    \xparse_ignore_set:
    \toks_put_right:Nx \l_xparse_signature_toks {
      \exp_not:c { xparse_arg_ #1 \l_xparse_ignore_spaces_tl :w }
    }
    \cs_set_eq:NN \xparse_prepare_next:w \xparse_get_default_arg:n
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}[aux]{\xparse_define_helper:Nnnn}
%  A generic helper function for optional arguments.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_define_helper:Nnnn {
  \cs_set_nopar:cpn { xparse_ #1 _ #2 _help:nw } #3 {
    \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#4} }
    ##1 \l_xparse_grabbed_args_toks
  }
}
%    \end{macrocode}
%  \end{macro}
%
%\begin{macro}{\xparse_flush_m_args:}
% As \texttt{m} arguments are simply counted, there is a need to add 
% them to the token register in a block.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_flush_m_args: {
  \intexpr_compare:nF { \l_xparse_m_args_int = \c_zero } {
    \toks_put_right:Nx \l_xparse_signature_toks {
      \exp_not:c { xparse_arg_m_ \int_use:N \l_xparse_m_args_int :w }
    }
  }
  \int_zero:N \l_xparse_m_args_int
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_get_default_arg:n}
%\begin{macro}{\xparse_get_default_long_arg:n}
% Collecting default arguments is pretty easy. The \texttt{next} 
% function needs to be reset so that the loop continues.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_get_default_arg:n {
  \toks_put_right:Nn \l_xparse_signature_toks { {#1} }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \xparse_prepare_signature:N
}
\cs_new:Nn \xparse_get_default_long_arg:n {
  \toks_put_right:Nn \l_xparse_signature_toks { {#1} }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \xparse_prepare_signature:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}[TF]{\xparse_if_no_value:n}
%\begin{macro}[aux]{\xparse_if_no_value_aux:}
% The test start by making a token list variable out of the first
% argument and then check if it is equal to
% \cs{c_xparse_no_value_tl} which contains \cs{NoValue}.
% If not, take a closer look at |#1|. Peek ahead at the first token in
% |#1| and then call the function \cs{xparse_if_no_value_aux:} but only
% if |#1| is not empty or a blank space: in that case we can execute
% the \meta{false} code immediately. We must use this test at some
% point otherwise the macros for checking tokens will break since the
% argument may be empty.
%    \begin{macrocode}
\prg_new_conditional:Nnn \xparse_if_no_value:n {TF,T,F} {
  \tl_set:Nx \l_xparse_tmpa_tl { \exp_not:n {#1} }
  \tl_if_eq:NNTF \l_xparse_tmpa_tl \c_xparse_no_value_tl {
    \prg_return_true:
  }{
    \tl_if_blank:nTF {#1} {
      \prg_return_false:
    }{
      \peek_after:NN \xparse_if_no_value_aux: #1 \q_nil {#1}
    }
  }
}
%    \end{macrocode}
% Now we simply check the argument specification of the token. If
% it is not a macro the function \cs{token_get_arg_spec:N} returns
% \cs{scan_stop:}. Then check if \cs{l_xparse_tmpa_tl} is empty, 
% because this means we have a macro taking zero arguments and we can 
% expand it once safely. Otherwise we just exit and execute the false 
% code. Remember that we have the sequence |{#1}| waiting after the 
% \cs{q_nil} in \cs{xparse_if_no_value:nTF} above. 
%    \begin{macrocode}
\cs_new:Nn \xparse_if_no_value_aux: {
  \tl_set:Nx \l_xparse_tmpa_tl  {\token_get_arg_spec:N \l_peek_token }
  \tl_if_empty:NTF \l_xparse_tmpa_tl {
    \use_i_delimit_by_q_nil:nw { \exp_args:No \xparse_if_no_value:nTF }
  }{
    \use_i_delimit_by_q_nil:nw { \use_i:nn \prg_return_false: }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_set_ignore_spaces:}
% A short function to check if an optional argument should ignore
% spaces.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_ignore_set: {
  \intexpr_compare:nTF { \l_xparse_mandatory_args_int > \c_zero } {
    \tl_set:Nn \l_xparse_ignore_spaces_tl { _ignore_spaces }
  }{
    \tl_clear:N \l_xparse_ignore_spaces_tl
  }
  \bool_if:NT \l_xparse_space_force_bool {
    \tl_clear:N \l_xparse_ignore_spaces_tl
  }
  \bool_if:NT \l_xparse_space_ignore_bool {
    \tl_set:Nn \l_xparse_ignore_spaces_tl { _ignore_spaces }
  }
  \bool_set_false:N \l_xparse_space_force_bool
  \bool_set_false:N \l_xparse_space_ignore_bool
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_prepare_signature:n}
% Creating the signature is a case of working through the input and
% turning into the output in \cs{l_xparse_signature_toks}. A track is
% also kept of the total number of arguments. This function sets 
% everything up then hands off to the parser.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_prepare_signature:n  {
  \int_zero:N \l_xparse_total_args_int
  \int_zero:N \l_xparse_m_args_int
  \toks_clear:N \l_xparse_signature_toks
  \xparse_prepare_signature:N #1 \q_nil
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\xparse_prepare_signature:N}
%\begin{macro}[aux]{\xparse_prepare_signature_aux:N}
%\begin{macro}[aux]{\xparse_prepare_next:w}
% The main signature-preparation loop is in two parts, to keep the code 
% a little clearer. Most of the checks here is pretty clear, with a key
% point to watch what is next on the stack so that the loop continues
% correctly. The shorthand code avoids the need to back up and go round
% again.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_prepare_signature:N {
  \quark_if_nil:NTF #1 {
    \xparse_flush_m_args:
  }{
    \prop_if_in:NnTF \g_xparse_shorthands_prop {#1} {
      \prop_get:NnN \g_xparse_shorthands_prop {#1} \l_xparse_tmpa_tl
      \exp_last_unbraced:NV \xparse_prepare_signature_aux:N 
        \l_xparse_tmpa_tl
    }{
      \xparse_prepare_signature_aux:N #1
    }
  }
}
\cs_new_nopar:Nn \xparse_prepare_signature_aux:N {
  \int_incr:N \l_xparse_total_args_int
  \intexpr_compare:nTF { \l_xparse_total_args_int > \c_nine } {
    \msg_error:nn { xparse } { too~many~args }
  }{
    \xparse_check_and_add_argument_type:N #1
    \xparse_prepare_next:w
  }
}
\cs_new_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\subsection{Generated specifiers}
%
% Several of the specifiers are created using the generic code above. 
% There is a bit of adjustment as \texttt{c} and \texttt{p} cannot be
% \cs{long}.
%    \begin{macrocode}
\xparse_declare_opt_type:NNnnnnn 
  c ( { meaning } { % } ) {
    \msg_error:nn { xparse } { no~co-ordinate }
  } { {00} } { #1 ( #2 , #3 ) } { {#2} {#3} }
\cs_gundefine:N \xparse_add_arg_type_C:
\xparse_declare_opt_default_type:NNnnn
  d [ { meaning } { #1 [ #2 ] } {#2}  % ]
\xparse_declare_opt_type:NNnnnnn 
  o [ { meaning } { } {\NoValue} { #1 [ #2 ] } {#2} % ]
\xparse_declare_opt_default_type:NNnnn
  p ( { meaning } { #1 ( #2 , #3 ) } { {#2} {#3} } % ) 
\cs_gundefine:N \xparse_add_arg_type_P:
\xparse_declare_shorthand:Nn s { t{*} }
\xparse_declare_symbol_arg:NN {t} { meaning }
%    \end{macrocode}
%
%\subsection{Messages}
%    
% Some error messages.   
%    \begin{macrocode}
\msg_new:nnn { xparse } { already~defined } {
  Command~name~`\token_to_str:N #1'~already~defined!
}
\msg_new:nnn { xparse } { no~command~implementation } {
  No~implementation~for~`#1'~defined.
}
\msg_new:nnn { xparse } { no~co-ordinate } {
  Missing~co-ordinate~argument.~A~value~of~(0,0)~is~assumed.
}
\msg_new:nnn { xparse } { not~yet~defined } {
  Command~`\token_to_str:N #1'~not~yet~defined!
}
\msg_new:nnn { xparse } { too~many~args } {
  Your~signature~contains~more~than~nine~specifiers.~TeX~only~allows~
  up~to~nine~arguments~for~each~macro!
}
\msg_new:nnn { xparse } { unknown~argument~type } {
  Unknown~argument~type~`#1'~replaced~by~`m'.~Fingers~crossed ...
}
%    \end{macrocode}
%    
%\subsection{User functions}
%
% The user functions are more or less just the internal functions 
% renamed. Of course, these are the \emph{only} \LaTeX3 document 
% functions that should be created this way.
%
%\begin{macro}{\DeclareDocumentCommand}
%\begin{macro}{\NewDocumentCommand}
%\begin{macro}{\RenewDocumentCommand}
%\begin{macro}{\ProvideDocumentCommand}
% The user macros are pretty simple wrappers around the internal ones.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \DeclareDocumentCommand {
  \xparse_declare_cmd:Nnn 
}
\cs_new_protected_nopar:Npn \NewDocumentCommand #1 {
  \cs_if_exist:NTF #1 { 
    \msg_error:nnx { xparse } { already~defined } {#1}
    \use_none:nn
  }{
    \xparse_declare_cmd:Nnn #1
  }
}
\cs_new_protected_nopar:Npn \RenewDocumentCommand #1 {
  \cs_if_exist:NTF #1 {
    \xparse_declare_cmd:Nnn #1
  }{  
    \msg_error:nnx { xparse } { not~yet~defined } {#1}
    \use_none:nn
  }
}
\cs_new_protected_nopar:Npn \ProvideDocumentCommand #1 {
  \cs_if_exist:NTF #1 { 
    \use_none:nn
  }{
    \xparse_declare_cmd:Nnn #1
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\DeclareDocumentCommandInterface}
%\begin{macro}{\DeclareDocumentCommandImplementation}
% The more abstract interface is similar.
%    \begin{macrocode}
\cs_new_protected:Npn \DeclareDocumentCommandInterface {
  \xparse_declare_cmd_interface:Nnn
}
\cs_new_protected:Npn \DeclareDocumentCommandImplementation {
  \xparse_declare_cmd_implementation:nNn
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\DeclareArgumentType}
%\begin{macro}{\DeclareArgumentTypeWithDefault}
%\begin{macro}{\DeclarePseudoArgument}
%\begin{macro}{\DeclareSymbolArgument}
% Some very simple re-naming.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \DeclareArgumentType {
  \xparse_declare_opt_type:NNnnnnn
}
\cs_new_protected_nopar:Npn \DeclareArgumentTypeWithDefault { 
  \xparse_declare_opt_default_type:NNnnn
}
\cs_new_protected_nopar:Npn \DeclarePseudoArgument {
  \xparse_declare_pseudo_arg:nNnn
}
\cs_new_protected_nopar:Npn \DeclareSymbolArgument {
  \xparse_declare_symbol_arg:NN
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\UsePseudoArgument}
% Using a pseudo-argument is just a question of calling the internal
% function.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \UsePseudoArgument #1 {
  \use:c { xparse_pseudo_arg_ #1 :w }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[TF]{\IfBoolean}
% The logical \meta{true} and \meta{false} statements are just the 
% normal \cs{c_true_bool} and \cs{c_false_bool}, so testing for them is
% done with the \cs{bool_if:NTF} functions from \textsf{l3prg}.
%    \begin{macrocode}
\cs_new_eq:NN \IfBooleanTF \bool_if:NTF
\cs_new_eq:NN \IfBooleanT  \bool_if:NT
\cs_new_eq:NN \IfBooleanF  \bool_if:NF
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[TF]{\IfNoValue}
%\begin{macro}[TF]{\IfValue}
% Document names for the \cs{NoValue} tests.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \IfNoValueTF {
  \xparse_if_no_value:nTF
}
\cs_new_protected_nopar:Npn \IfNoValueT  {
  \xparse_if_no_value:nT
}
\cs_new_protected_nopar:Npn \IfNoValueF {
  \xparse_if_no_value:nF
}
\cs_new_protected:Npn  \IfValueTF #1#2#3 {
  \xparse_if_no_value:nTF {#1} {#3} {#2}
}
\cs_new_protected_nopar:Npn \IfValueT {
  \xparse_if_no_value:nF
}
\cs_new_protected_nopar:Npn \IfValueF {
  \xparse_if_no_value:nT
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\NoValue}
% \cs{NoValue} is just a text string and we define it as a token list
%  variable. 
%    \begin{macrocode}
\tl_new:Nn \NoValue { -NoValue- }
%    \end{macrocode}
%\end{macro}
%    
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
% 
% \PrintIndex
