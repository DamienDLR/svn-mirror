% \iffalse
%% File: xparse-alt.dtx (C) Copyright 1999 Frank Mittelbach, Chris Rowley, 
%%                      David Carlisle
%%                  (C) Copyright 2004-2008 Frank Mittelbach, 
%%                      LaTeX3 Project
%%                  (C) Copyright 2009 LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xbase bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%% 
%
%<*driver|package>
\RequirePackage{l3names}
%</driver|package>
%\fi
\GetIdInfo$Id$
  {Generic document command parser}
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{xparse-alt.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{xparse-alt} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Generic document command parser}
% \author{\Team}
% \date{\filedate}
% \maketitle
%
%\begin{documentation}
%
%\section{Creating document commands}
%
% This package implements high-level interface commands which allows
% the separation of document-level commands from their internal 
% implementations. This works by declaration commands that provide a 
% general specification method for the typical \LaTeX\ syntax, e.g.,
% star-form, optional arguments, and mandatory arguments. A command
% (or environment) declared in this way parses the input according to
% its spec and presents its findings in a normalized way for further
% processing.
% 
%\subsection{Argument specifier}
%
% An argument specification is a list of letters each representing a
% type of argument, i.e.,\texttt{m} is a mandatory argument (surrounded 
% by braces), \texttt{o} an optional argument (surrounded by brackets if
% present), and \texttt{s} represents a star (which might be present 
% or not). Thus the argument spec for headings as implemented by
% \cs{@startsection} in \LaTeXe\ would be represented by the
% three letters \texttt{som}. Other argument types are available and 
% can be added at will. For a complete list of built-in argument types 
% see the next section.
% 
% Lower-case letters are used for created normal, short arguments
% (those which will not accept \cs{par} tokens). On the other hand,
% upper-case letters represent \cs{long} arguments. 
% 
% To normalise the result of parsing the input according to an
% argument specification it is important to uniquely identify all
% arguments found. Arguments can be broadly divided into two
% groups, those which are mandatory (i.e., omitting them will result in
% an error) and those which are optional (and thus can be omitted 
% entirely). The first group is made up of:
%\begin{description}
%  \item[m] will return the parsed argument surrounded by a brace
%    pair, i.e., will normally be the identity.
%  \item[M] as \texttt{m}, but accepts \cs{par} tokens.
%  \item[l] reads everything up to the first left brace as the
%    argument. 
%  \item[L] as \texttt{l}, but accepts \cs{par} tokens.
%\end{description}

%\begin{description} 
%  \item[d\meta{token1}\meta{token2}] will return the content
%    between \meta{token1} and \meta{token2}, if \meta{token1} is
%    found. Otherwise returns the default value, or \texttt{-NoValue-}
%    if no default is available.
%  \item[D] as \texttt{d}, but accepts \cs{par} tokens.       
%  \item[o] searches for content between square brackets, and returns 
%    it if found. This is a shorthand for \texttt{d[]}.
%  \item[O] as \texttt{o}, but accepts \cs{par} tokens.
% \item[t\meta{token}] will return either the token 
%   \cs{c_true_bool} or \cs{c_false_bool} depending on whether or not 
%   the next token is \meta{token}.
% \item[s] will return either the token \cs{c_true_bool} or 
%   \cs{c_false_bool} depending on whether or not a star was parsed. 
%   This is just a shorthand for |t{*}|.
%\end{description}
% The optional specifiers all accept an optional argument (given in
% \emph{braces}), which is used to supply a default if the argument
% is not given. If no default is supplied, the special value 
% \texttt{-No Value-} will be returned. This can be tested for using
% \cs{IfNoValue(TF)}. In the \texttt{p} case, only \emph{one}
% \texttt{-No Value-} is returned if no input is given.
%  
% For example, given the string |soomo{default}|, the input
% `|*[Foo]{Bar}|' would be parsed as:
%\begin{itemize} 
%  \item |#1| = |\c_true_bool|
%  \item |#2| = |{Foo}|
%  \item |#3| = |-No Value-|
%  \item |#4| = |{Bar}|
%  \item |#5| = |{default}|
%\end{itemize}
% whereas `|[One][Two]{}[three]|' would be parsed as:
%\begin{itemize} 
%  \item |#1| = |\c_false_bool|
%  \item |#2| = |{One}|
%  \item |#3| = |{Two}|
%  \item |#4| = |{}|
%  \item |#5| = |{Three}|
%\end{itemize}
% In other words there will be always exactly the same number of brace 
% groups or tokens as the number of letters in the argument specifier.
% 
%\subsection{Applying the parsing results}
%
% Since the result of the parsing is a well-defined number of tokens or
% brace groups it is easy to pass them on in any order to any
% processing function. To this end the tokens or brace groups are
% associated with the standard argument specifiers in \TeX{} macros,
% i.e., |#1|, |#2|, and so forth. This limits the argument
% specification to a maximum number of 9 letters, but for practical
% applications this should be sufficient. The package will generate
% an error if you attempt to create a function with more than nine 
% arguments!
% 
%\subsection{Optional and mandatory arguments}
%
% The specifiers \texttt{l}, \texttt{L}, \texttt{m} and
% \texttt{M} indicate mandatory arguments: an error will result if
% the argument is missing. All other arguments are optional. However,
% this could lead to inconsistent spacing. Imagine a command 
% \cs{test} with signature \texttt{mo}. Calling it with the 
% optional argument |\test{arg}[opt]| will result in the following
% space being obeyed. So that the space is also obeyed if the optional
% argument is not give |\test{arg}|, spaces are not ignored when 
% searching for optional arguments at the end of a command. Thus
% |\test{arg}[opt]| will record a valid |#2| argument, whereas
% |\test{arg} [opt]| will show \cs{NoValue} for |#2|. This does not
% apply to optional arguments \emph{before} the last mandatory one, 
% where spaces are ignored and gaps can therefore be left.
% 
% It may be the case that the automatic decision is not the correct
% one when it comes to skipping spaces. There are therefore two
% over-ride markers. Adding |^| before an optional argument
% means that it has to follow directly after the preceding argument, 
% with no spaces skipped. On the other hand, adding \texttt{!} will 
% mean that spaces are skipped even if the optional argument comes at
% the end of the argument list.
% 
%\subsection{The interface builder}
%
% The interface-building commands are the preferred method for 
% creating document-level functions in \LaTeX3. All of the functions 
% generated in this way are naturally robust. 
%
%\begin{function}{%
%  \DeclareDocumentCommand|
%  \NewDocumentCommand|
%  \RenewDocumentCommand|
%  \ProvideDocumentCommand
%}
%  \begin{syntax}
%    "\DeclareDocumentCommand" <function> <arg spec> <code>
%  \end{syntax}
%  Declares <function> using <arg spec>, as described above, to
%  create the argument processing code. Within the <code>, |#1|, |#2|,
%  etc., denote the results of parsing the <arg spec> into \TeX\ 
%  arguments. 
%  
%  The \cs{Declare\ldots} function will ignore any existing
%  definition. \cs{New\ldots} will only work if <function> is not
%  already defined, while \cs{Renew\ldots} requires that <function>
%  already exists. Both issues errors if the requirement is no met.
%  In contrast, \cs{Provide\ldots} will \emph{only} define <function>
%  if it is not already defined and will do nothing otherwise.
%\end{function}
%
% As an example:
%\begin{verbatim}
%  \DeclareDocumentCommand \chapter { s o m } {
%    \IfBooleanTF {#1} {
%      \typesetnormalchapter {#2} {#3} 
%    }{
%      \typesetstarchapter {#3}
%  }
%\end{verbatim}
% would be a way to define a \cs{chapter} command which would
% essentially behave like the current \LaTeXe\ command (except that it
% would accept an optional argument even when a \texttt{*} was parsed).
% The \cs{typesetnormalchapter} could test its first argument for being
% \cs{NoValue} to see if an optional argument was present.
% 
%\begin{function}{%
%  \DeclareDocumentEnvironment|
%  \NewDocumentEnvironment|
%  \RenewDocumentEnvironment|
%  \ProvideDocumentEnvironment
%}
%  \begin{syntax}
%    "\DeclareDocumentEnvironment" <env> <arg spec>
%    ~~~~<start code> <end code>
%  \end{syntax}
%  Declares <env> as an environment taking <arg spec> arguments 
%  at \cs{begin}\{<env>\}. The <start code> is executed at the beginning
%  of the environment, and the <end code> at the end. Both parts may
%  use the arguments defined by <arg spec>.
%  
%  The \cs{Declare\ldots} function will ignore any existing
%  definition. \cs{New\ldots} will only work if <function> is not
%  already defined, while \cs{Renew\ldots} requires that <function>
%  already exists. Both issues errors if the requirement is no met.
%  In contrast, \cs{Provide\ldots} will \emph{only} define <function>
%  if it is not already defined and will do nothing otherwise.
%\end{function}
%
% For example, the \LaTeXe\ \texttt{figure} environment might look
% like:
%\begin{verbatim}
%  \DeclareDocumentEnvironment { figure } { s o m } {
%    \IfBooleanTF {#1} {
%      \IfNoValueTF {#2} {
%        \CreateTwoColumnFloat {tbp} {#3}
%      }{
%        \CreateTwoColumnFloat {#2} {#3}
%      }
%    }{
%      \IfNoValueTF {#2} {
%        \CreateOneColumnFloat {tbp} {#3}
%      }{
%        \CreateOneColumnFloat {#2} {#3}
%      }
%  }{ % Nothing to do here!
%  }
%\end{verbatim}
%
%\subsection{Utility functions}
%
%\begin{function}{\IfBoolean / (TF) (EXP)}
%  \begin{syntax}
%    "\IfBooleanTF" <token> <true code> <false code>
%  \end{syntax}
%  Executes <true code> if <token> is equal to \cs{c_true_bool} and
%  <false code> if it is equal to \cs{c_false_bool}.  
%  \begin{texnote}
%    These are document-level names for \cs{bool_if:N(TF)}.
%  \end{texnote}
%\end{function}
%  As mentioned earlier, the parsing result of a \texttt{s} or
%  |t{+}| arg spec will be one of these Boolean values. The result
%  can therefore be tested using \cs{IfBooleanTF}, with the
%  \texttt{T} and \texttt{F} variants as obvious short cuts.
%\begin{verbatim}
%  \DeclareDocumentCommand \exampleone { s m } {
%    \IfBooleanTF #1 {
%      \DoSomethingWithStar {#2} 
%    }{
%      \DoSomethingWithoutStar {#2}
%  }
%  \DeclareDocumentCommand \exampletwo { s m } {
%    \IfBooleanT #1 {
%      \DoSomethingWithStar {#2} 
%    }
%  }
%  \DeclareDocumentCommand \examplethree { s m } {
%    \IfBooleanF #1 {
%      \DoSomethingWithoutStar {#2} 
%    }
%  }
%\end{verbatim}
%
%\begin{function}{\IfNoValue / (TF) (EXP)}
%  \begin{syntax}
%    "\IfNoValue" <arg> <true code> <false code>
%  \end{syntax}
%  Executes <true code> if <arg> is equal to the special 
%  \texttt{-NoValue-} marker and <false code> otherwise.  
%  \begin{texnote}
%    These are document-level names for \cs{xparse_if_no_value:n(TF)}.
%  \end{texnote}
%\end{function}
%\begin{verbatim}
%  \DeclareDocumentCommand \exampleone { o m } {
%    \IfNoValueTF {#1} {
%      \DoSomethingJustWithMandatoryArgument {#2}
%    }{
%      \DoSomethingBothArguments {#1} {#2}
%    }
%  }
%\end{verbatim}
%
%\subsection{Internal functions}
%
%\begin{function}{\xpare_add_arg_mandatory_create:N}
%  \begin{syntax}
%    "\xpare_add_arg_mandatory_create:N" <type>
%  \end{syntax}
%  Creates a standard \cs{xparse_add_arg_type_<type>:} function for
%  a mandatory argument.
%\end{function}
%
%\begin{function}{
%  \xparse_add_arg_type_^:|
%  \xparse_add_arg_type_!:
%}
%  \begin{syntax}
%    "\xparse_add_arg_type_^:"
%  \end{syntax}
% Special ``add'' functions which force the space-skipping mode for
% optional arguments.
%\end{function}
%
%\begin{function}{
%  \xparse_add_arg_type_d:|
%  \xparse_add_arg_type_D:|
%  \xparse_add_arg_type_m:|
%  \xparse_add_arg_type_t:
%}
%  \begin{syntax}
%    "\xparse_add_arg_type_m:"
%  \end{syntax}
%  Add an argument of <type> to the \texttt{signature} token register:
%  these are created manually.
%\end{function}
%
%\begin{function}{
%  \xparse_arg_m_1:w|
%  \xparse_arg_m_2:w|
%  \xparse_arg_m_3:w|
%  \xparse_arg_m_4:w|
%  \xparse_arg_m_5:w|
%  \xparse_arg_m_6:w|
%  \xparse_arg_m_7:w|
%  \xparse_arg_m_8:w|
%  \xparse_arg_m_9:w
%}
%  \begin{syntax}
%    "\xparse_arg_m_1:w" <arg functions> 
%    ~~~~"\l_xparse_grabbed_args_toks" <arg>
%  \end{syntax}
%  Used to gather one to nine mandatory <args>.
%\end{function}
%
%\begin{function}{
%  \xparse_arg_d:w|
%  \xparse_arg_d_no_spaces:w|
%  \xparse_arg_D:w|
%  \xparse_arg_D_no_spaces:w|
%  \xparse_arg_l:w|
%  \xparse_arg_L:w|
%  \xparse_arg_M:w|
%  \xparse_arg_t:w|
%  \xparse_arg_t_no_spaces:w
%}
%  \begin{syntax}
%    "\xparse_arg_l:w" <arg functions> 
%    ~~~~"\l_xparse_grabbed_args_toks" <arg>
%  \end{syntax}
%  For gathering basic argument types.
%\end{function}
% 
%\begin{function}{
%  \xparse_arg_m_1:w|
%  \xparse_arg_m_2:w|
%  \xparse_arg_m_3:w|
%  \xparse_arg_m_4:w|
%  \xparse_arg_m_5:w|
%  \xparse_arg_m_6:w|
%  \xparse_arg_m_7:w|
%  \xparse_arg_m_8:w|
%  \xparse_arg_m_9:w
%}
%  \begin{syntax}
%    "\xparse_arg_m_1:w" <arg functions> 
%    ~~~~"\l_xparse_grabbed_args_toks" <arg>
%  \end{syntax}
%  Used to gather one to nine mandatory <args>.
%\end{function}
%
%\begin{function}{\xparse_check_and_add:N}
%  \begin{syntax}
%    "\xparse_check_and_add:N"
%    ~~~~<arg spec>
%  \end{syntax}
%  Ensures that <arg spec> is valid, and if so adds it to the 
%  list for building.
%\end{function}
%
%\begin{function}{\xparse_count_mandatory_args:n}
%  \begin{syntax}
%    "\xparse_count_mandatory_args:n" <signature>
%  \end{syntax}
%  Counts the number of mandatory arguments in <signature>.
%\end{function}
%
%\begin{function}{
%  \xparse_count_type_!:w|
%  \xparse_count_type_^:w|
%  \xparse_count_type_d:w|
%  \xparse_count_type_D:w|
%  \xparse_count_type_m:w|
%  \xparse_count_type_t:w
%}
%  \begin{syntax}
%    "\xparse_count_type_!:w" 
%  \end{syntax}
%  Used by \cs{xparse_count_mandatory_args:n} to count arguments.
%\end{function}
%
%\begin{function}{
%  \xparse_declare_cmd:Nnn|
%  \xparse_declare_cmd:cnn
%}
%  \begin{syntax}
%    "\xparse_declare_cmd:Nnn" <function> <signature>
%    ~~~~<code>
%  \end{syntax}
%  Declares <function> using <signature> for argument definition and
%  <code> as expansion.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareDocumentCommand}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\xparse_declare_env:nnnn}
%  \begin{syntax}
%    "\xparse_declare_env:nnnn" <env> <arg spec>
%    ~~~~<start code> <end code>
%  \end{syntax}
%  Declares <env> as an environment taking <arg spec> arguments 
%  at \cs{begin}\{<env>\}. The <start code> is eceutre at the beginning
%  of the environment, and the <end code> at the end. Both parts may
%  use the arguments defined by <arg spec>.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareDocumentEnvironment}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{
%  \xparse_declare_arg_shorthand:Nn
%}
%  \begin{syntax}
%    "\xparse_declare_arg_shorthand:Nn"
%    ~~~~<arg spec> <replacement> 
%  \end{syntax}
%  Declares <arg spec> as a shorthand for <replacement>, which should
%  also be an <arg spec>. 
%\end{function}
%
%\begin{function}{\xparse_flush_m_args:}
%  \begin{syntax}
%    "\xparse_flush_m_args:" 
%  \end{syntax}
%  Adds an outstanding \texttt{m} arguments to the output signature.
%\end{function}
%
%\begin{function}{
%  \xparse_get_arg:n|
%  \xparse_get_arg_long:n
%}
%  \begin{syntax}
%    "\xparse_get_arg:n" <argument>
%  \end{syntax}
%  Save <argument> to the signature, if it exists.
%\end{function}
%
%\begin{function}{\xparse_get_three_args:nnw}
%  \begin{syntax}
%    "\xparse_get_three_args:nnw" <arg1> <arg2>
%  \end{syntax}
%  Saves <arg1>  and <arg2> to the signature, then checks for a third
%  argument and saves it if available.
%\end{function}
%
%\begin{function}{\xparse_if_no_value:n / (TF) (EXP)}
%  \begin{syntax}
%    "\xparse_if_no_value:n" <arg> <true code> <false code>
%  \end{syntax}
%  Executes <true code> if <arg> is equal to the special 
%  \texttt{-NoValue-} marker and <false code> otherwise.  
%\end{function}
%
%\begin{function}{
%  \xparse_prepare_signature:n|
%  \xparse_prepare_signature:N
%}
%  \begin{syntax}
%    "\xparse_prepare_signature:n"  <arg specs>
%  \end{syntax}
%  Parse one or more <arg specs> and convert to an output <signature>.  
%\end{function}
%
%\begin{function}{\xparse_set_spacing:}
%  \begin{syntax}
%    "\xparse_set_ignore_spaces:"
%  \end{syntax}
%  Sets up the token list variable indicated whether to ignore spaces.  
%\end{function}
%
%\subsection{Variables and constants}
%
%\begin{variable}{\g_xparse_shorthands_prop}
%  Shorthands and replacement text.
%\end{variable}
%
%\begin{variable}{
%  \l_xparse_args_m_int|
%  \l_xparse_args_mandatory_int|
%  \l_xparse_args_total_int
%}
%  Used to enumerate the \texttt{m} arguments, all mandatory arguments
%  and all arguments.
%\end{variable}
%
%\begin{variable}{\l_xparse_env_args_toks}
%  Token register to pass arguments to the end of an environment from
%  the beginning.
%\end{variable}
%
%\begin{variable}{\l_xparse_grabbed_args_toks}
%  Token register for arguments as they are picked up for passing on to
%  user functions.
%\end{variable}
%
%\begin{variable}{\l_xparse_signature_toks}
%  Token register used to build up the signature for the internal 
%  function.
%\end{variable}
%
%\begin{variable}{
%  \l_xparse_space_force_bool|
%  \l_xparse_space_ignore_bool
%}
%  Signal over-riding of the automatic system for skipping spaces.
%\end{variable}
%
%\begin{variable}{\l_xparse_spaces_tl}
%  For setting whether spaces are ignored when searching for an optional
%  argument.
%\end{variable}
%
%\begin{variable}{\l_xparse_tmpa_tl}
%  A scratch variable.
%\end{variable}
% 
%\end{documentation}
% 
%\begin{implementation}
%
%\section{\pkg{xparse} implementation}
%
% The usual lead-off.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
\RequirePackage{expl3}
%</package>
%<*initex|package>
%    \end{macrocode}
%    
%\subsection{Variables and constants}
%
%\begin{macro}{\g_xparse_shorthands_prop}
% Shorthands are stored as a property list.
%    \begin{macrocode}
\prop_new:N \g_xparse_shorthands_prop
%    \end{macrocode}
%\end{macro}
%    
%\begin{macro}{\l_xparse_args_m_int}
%\begin{macro}{\l_xparse_args_mandatory_int}
%\begin{macro}{\l_xparse_args_total_int}
%  For tracking the number of \texttt{m} arguments, the number of
%  mandatory arguments and the total number of arguments.
%    \begin{macrocode}
\int_new:N \l_xparse_args_m_int
\int_new:N \l_xparse_args_mandatory_int
\int_new:N \l_xparse_args_total_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_xparse_space_force_bool}
%\begin{macro}{\l_xparse_space_ignore_bool}
% For changing the space-skipping decision.
%    \begin{macrocode}
\bool_new:N \l_xparse_space_force_bool
\bool_new:N \l_xparse_space_ignore_bool
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_xparse_spaces_tl}
% For setting up whether to check spacing.
%    \begin{macrocode}
\tl_new:N \l_xparse_spaces_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_tmpa_tl}
% A general purpose token list variable.
%    \begin{macrocode}
\tl_new:N \l_xparse_tmpa_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_grabbed_args_toks}
%\begin{macro}{\l_xparse_signature_toks}
% Token registers for grabbing arguments and making signatures.
%    \begin{macrocode}
\toks_new:N \l_xparse_grabbed_args_toks
\toks_new:N \l_xparse_signature_toks
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_xparse_env_args_toks}
% Used to pass arguments to the end of an environment.
%    \begin{macrocode}
\toks_new:N \l_xparse_env_args_toks
%    \end{macrocode}
%\end{macro}
%    
%\subsection{Internal commands}
%
%\begin{macro}{\xparse_add_arg_type_^:}
%\begin{macro}{\xparse_add_arg_type_!:}
% For controlling spacing, some ``adding'' functions that do not add
% anything at all!
%    \begin{macrocode}
\cs_new_nopar:cn { xparse_add_arg_type_^: } {
  \int_decr:N \l_xparse_args_total_int
  \bool_set_true:N \l_xparse_space_force_bool
}
\cs_new_nopar:cn { xparse_add_arg_type_!: } {
  \int_decr:N \l_xparse_args_total_int
  \bool_set_true:N \l_xparse_space_ignore_bool
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xpare_add_arg_mandatory_create:N}
% General purpose routines to create argument adders.
%    \begin{macrocode}
\cs_new_nopar:Nn \xpare_add_arg_mandatory_create:N {
  \cs_new_nopar:cn { xparse_add_arg_type_ #1 : } {
    \int_decr:N \l_xparse_args_mandatory_int
    \xparse_flush_m_args:
    \toks_put_right:Nx \l_xparse_signature_toks { 
      \exp_not:c { xparse_arg_ #1 :w }
    }
  }
  \cs_new_nopar:cpn { xparse_count_type_ #1 :w } {
    \int_incr:N \l_xparse_args_mandatory_int
    \xparse_count_mandatory_args:N
  }
}
\xpare_add_arg_mandatory_create:N l
\xpare_add_arg_mandatory_create:N L
\xpare_add_arg_mandatory_create:N M
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\xparse_add_arg_type_d:}
%\begin{macro}{\xparse_add_arg_type_D:}
% The \texttt{d} and \texttt{D} types need to collect up a bit more
% information. This is done using a two-part system, first collecting
% the two mandatory arguments then the one optional braced one.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_arg_type_d: {
  \xparse_flush_m_args:
  \xparse_set_spacing:
  \toks_put_right:Nx \l_xparse_signature_toks { 
    \exp_not:c { xparse_arg_d \l_xparse_spaces_tl :w }
  }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_get_three_args:nnw
  \cs_set_eq:NN \xparse_get_third_arg:w \xparse_get_arg:n
}
\cs_new_nopar:Nn \xparse_add_arg_type_D: {
  \xparse_flush_m_args:
  \xparse_set_spacing:
  \toks_put_right:Nx \l_xparse_signature_toks { 
    \exp_not:c { xparse_arg_D \l_xparse_spaces_tl :w }
  }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_get_three_args:nnw
  \cs_set_eq:NN \xparse_get_third_arg:w \xparse_get_arg_long:n
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}{\xparse_add_arg_type_m:}
% Adding the basic \texttt{m} argument is done by hand.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_arg_type_m: {
  \int_decr:N \l_xparse_args_mandatory_int
  \int_incr:N \l_xparse_args_m_int  
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\xparse_add_arg_type_t:}
% The \texttt{t} argument always grabs one token.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_arg_type_t: {
  \xparse_flush_m_args:
  \xparse_set_spacing:
  \toks_put_right:Nx \l_xparse_signature_toks { 
    \exp_not:c { xparse_arg_t \l_xparse_spaces_tl :w }
  }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_get_arg:n
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_arg_d:w}
%\begin{macro}{\xparse_arg_d_no_spaces:w}
%\begin{macro}[aux]{\xparse_arg_d_common:w}
%\begin{macro}[aux]{\xparse_arg_d_aux:w}
%\begin{macro}{\xparse_arg_D:w}
%\begin{macro}{\xparse_arg_D_no_spaces:w}
%\begin{macro}[aux]{\xparse_arg_D_aux:w}
% The generic delimited argument grabber works in very much the
% same way as the \texttt{c} and \texttt{p} grabbers.
%    \begin{macrocode}
\cs_new_nopar:Npn \xparse_arg_d:w {
   \xparse_arg_d_common:w { _ignore_spaces }
}
\cs_new_nopar:Npn \xparse_arg_d_no_spaces:w {
   \xparse_arg_d_common:w { }
}
\cs_new_nopar:Npn \xparse_arg_d_common:w 
  #1#2#3#4#5 \l_xparse_grabbed_args_toks {
  \cs_set_nopar:Npn \xparse_arg_d_aux:w ##1 #2 ##2 #3 {
    \toks_put_right:Nn \l_xparse_grabbed_args_toks { {##2} }
    ##1 \l_xparse_grabbed_args_toks
  }
  \use:c { peek_meaning #1 :NTF } #2 { 
    \xparse_arg_d_aux:w {#5}
  }{
    \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#4} }
    #5 \l_xparse_grabbed_args_toks
  }
}
\cs_new_nopar:Npn \xparse_arg_d_aux:w {}
\cs_new_nopar:Npn \xparse_arg_D:w {
   \xparse_arg_D_common:w { }
}
\cs_new_nopar:Npn \xparse_arg_D_no_spaces:w {
   \xparse_arg_D_common:w { _ignore_spaces }
}
\cs_new:Npn \xparse_arg_D_common:w 
  #1#2#3#4#5 \l_xparse_grabbed_args_toks {
  \cs_set:Npn \xparse_arg_D_aux:w ##1 #2 ##2 #3 {
    \toks_put_right:Nn \l_xparse_grabbed_args_toks { {##2} }
    ##1 \l_xparse_grabbed_args_toks
  }
  \use:c { peek_meaning #1 :NTF } #2 { 
    \xparse_arg_D_aux:w {#5}
  }{
    \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#4} }
    #5 \l_xparse_grabbed_args_toks
  }
}
\cs_new:Npn \xparse_arg_D_aux:w {}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\xparse_arg_l:w}
%\begin{macro}{\xparse_arg_L:w}
%\begin{macro}{\xparse_arg_M:w}
% Argument grabbers for mandatory \TeX\ arguments are pretty simple.
%    \begin{macrocode}
\cs_new_nopar:Npn \xparse_arg_l:w #1 \l_xparse_grabbed_args_toks #2# {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#2} }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new:Npn \xparse_arg_L:w #1 \l_xparse_grabbed_args_toks #2# {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#2} }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new:Npn \xparse_arg_M:w #1 \l_xparse_grabbed_args_toks #2 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#2} }
  #1 \l_xparse_grabbed_args_toks
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\xparse_arg_m_1:w}
%\begin{macro}{\xparse_arg_m_2:w}
%\begin{macro}{\xparse_arg_m_3:w}
%\begin{macro}{\xparse_arg_m_4:w}
%\begin{macro}{\xparse_arg_m_5:w}
%\begin{macro}{\xparse_arg_m_6:w}
%\begin{macro}{\xparse_arg_m_7:w}
%\begin{macro}{\xparse_arg_m_8:w}
%\begin{macro}{\xparse_arg_m_9:w}
% Grabbing 1--9 mandatory arguments. The one grabbing nine arguments
% will automatically end with \cs{toks_use:N} 
% \cs{l_xparse_grabbed_args_toks} anyway so we avoid problems with that
% one.
%    \begin{macrocode}
\cs_new_nopar:cpn 
  { xparse_arg_m_1:w } #1 \l_xparse_grabbed_args_toks #2 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#2} }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_2:w } #1 \l_xparse_grabbed_args_toks #2#3 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#2} {#3} }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_3:w } #1 \l_xparse_grabbed_args_toks #2#3#4 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#2} {#3} {#4} }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_4:w } #1 \l_xparse_grabbed_args_toks #2#3#4#5 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks { {#2} {#3} {#4} {#5} }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_5:w } #1 \l_xparse_grabbed_args_toks #2#3#4#5#6 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks {
    {#2} {#3} {#4} {#5} {#6}
  }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_6:w } #1 \l_xparse_grabbed_args_toks #2#3#4#5#6#7 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks {
    {#2} {#3} {#4} {#5} {#6} {#7}
  }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_7:w } #1 \l_xparse_grabbed_args_toks #2#3#4#5#6#7#8 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks {
    {#2} {#3} {#4} {#5} {#6} {#7} {#8}
  }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_8:w } #1 \l_xparse_grabbed_args_toks #2#3#4#5#6#7#8#9 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks {
    {#2} {#3} {#4} {#5} {#6} {#7} {#8} {#9}
  }
  #1 \l_xparse_grabbed_args_toks
}
\cs_new_nopar:cpn 
  { xparse_arg_m_9:w } \toks_use:N \l_xparse_grabbed_args_toks 
    #1#2#3#4#5#6#7#8#9 {
  \toks_put_right:Nn \l_xparse_grabbed_args_toks {
    {#1} {#2} {#3} {#4} {#5} {#6} {#7} {#8} {#9}
  }
  \toks_use:N \l_xparse_grabbed_args_toks
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\xparse_arg_t:w}
%\begin{macro}{\xparse_arg_t_no_spaces:w}
%\begin{macro}[aux]{\xparse_arg_t_common:w}
% Dealing with a token is quite easy. Check the match, remove the 
% token if needed and add a flag to the output.
%    \begin{macrocode}
\cs_new_nopar:Npn \xparse_arg_t:w {
  \xparse_arg_t_common:w { _ignore_spaces }
}
\cs_new_nopar:Npn \xparse_arg_t_no_spaces:w {
  \xparse_arg_t_common:w { }
}
\cs_new_nopar:Npn \xparse_arg_t_common:w 
  #1#2#3 \l_xparse_grabbed_args_toks {
  \use:c { peek_meaning_remove #1 :NTF } #2 { 
    \toks_put_right:Nn \l_xparse_grabbed_args_toks { \c_true_bool }
    #3 \l_xparse_grabbed_args_toks
  }{
    \toks_put_right:Nn \l_xparse_grabbed_args_toks { \c_false_bool }
    #3 \l_xparse_grabbed_args_toks
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_check_and_add:N}
% This function checks if the argument type actually exists and gives
% an error if it doesn't.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_check_and_add:N  {
  \cs_if_free:cTF { xparse_add_arg_type_#1: } {
    \msg_error:nnx { xparse } { unknown~argument~type } {#1}
    \xparse_add_arg_type_m:
  }{
    \use:c { xparse_add_arg_type_#1: }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_count_mandatory_args:n}
%\begin{macro}[aux]{\xparse_count_mandatory_args:N}
% A running total of the mandatory arguments is needed. The trick here
% is to let each primitive argument specifier deal with the next part
% of the input in the correct way.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_count_mandatory_args:n {
  \int_zero:N \l_xparse_args_mandatory_int
  \xparse_count_mandatory_args:N #1 \q_nil
}
\cs_new_nopar:Nn \xparse_count_mandatory_args:N {
  \quark_if_nil:NF #1 {
    \prop_if_in:NnTF \g_xparse_shorthands_prop {#1} {
      \prop_get:NnN \g_xparse_shorthands_prop {#1} \l_xparse_tmpa_tl
      \exp_last_unbraced:NV \xparse_count_mandatory_args:N
        \l_xparse_tmpa_tl
    }{
      \use:c { xparse_count_type_ #1 :w }
    }    
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}{\xparse_count_type_!:w}
%\begin{macro}{\xparse_count_type_^:w}
%\begin{macro}{\xparse_count_type_d:w}
%\begin{macro}{\xparse_count_type_D:w}
%\begin{macro}{\xparse_count_type_m:w}
%\begin{macro}{\xparse_count_type_t:w}
% Some of the counting functions need to be done by hand. 
%    \begin{macrocode}
\cs_new_eq:cN { xparse_count_type_!:w } \xparse_count_mandatory_args:N
\cs_new_eq:cN { xparse_count_type_^:w } \xparse_count_mandatory_args:N
\cs_new_nopar:Npn \xparse_count_type_d:w #1#2 {
  \peek_meaning_ignore_spaces:NTF \c_group_begin_token {
    \use_i:nn \xparse_count_mandatory_args:N
  }{
    \xparse_count_mandatory_args:N
  }
}
\cs_new_eq:NN \xparse_count_type_D:w \xparse_count_type_d:w
\cs_new_nopar:Npn \xparse_count_type_m:w  {
  \int_incr:N \l_xparse_args_mandatory_int
  \xparse_count_mandatory_args:N
}
\cs_new_nopar:Npn \xparse_count_type_t:w #1  {
  \xparse_count_mandatory_args:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_declare_cmd:Nnn}
%\begin{macro}{\xparse_declare_cmd:cnn}
% \cs{xparse_declare_document_command:Nnn} is a two-step procedure. The
% user level command \texttt{\textbackslash \meta{cmd}} contains the
% argument grabber whilst the internal command 
% \texttt{\textbackslash\textbackslash \meta{cmd}} holds the actual
% definition of what to do.
%    \begin{macrocode}
\cs_new:Nn \xparse_declare_cmd:Nnn {
  \xparse_count_mandatory_args:n {#2}
  \xparse_prepare_signature:n {#2}
  \cs_set_protected_nopar:Npx #1 {
    \exp_not:n { \toks_set:Nn \l_xparse_grabbed_args_toks }
      { \exp_not:c { \token_to_str:N #1 } }
    \toks_use:N \l_xparse_signature_toks
    \exp_not:n{ \toks_use:N \l_xparse_grabbed_args_toks }
  }
  \cs_generate_from_arg_count:cNnn 
    { \token_to_str:N #1 } \cs_set:Npn \l_xparse_args_total_int {#3}
}
\cs_generate_variant:Nn \xparse_declare_cmd:Nnn {c}
%    \end{macrocode} 
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_declare_env:nnnn}
% The idea here is to make sure that the end of the environment has the
% same arguments available as the beginning.
%    \begin{macrocode}
\cs_new:Nn \xparse_declare_env:nnnn {
  \xparse_declare_cmd:cnn { environment_begin_ #1 :w } {#2} {
    \group_begin:
      \toks_set_eq:NN \l_xparse_env_args_toks
        \l_xparse_grabbed_args_toks
      #3
  }
  \cs_set_nopar:cpx { environment_end_ #1 :w } {
      \exp_not:N \exp_last_unbraced:NV 
      \exp_not:c { environment_end_ #1 _aux:N }
      \exp_not:N \l_xparse_env_args_toks
    \exp_not:N \group_end:
  } 
  \cs_set_nopar:cx { environment_end_ #1 _aux:N } {
    \exp_not:c { environment_end_ #1 _aux :w }
  }
  \cs_generate_from_arg_count:cNnn 
    { environment_end_ #1 _aux :w } \cs_set:Npn
    \l_xparse_args_total_int {#4}
%</initex|package>
%<*package>
  \cs_set_eq:cc {#1} { environment_begin_ #1 :w } 
  \cs_set_eq:cc { end #1 } { environment_end_ #1 :w }
%</package>
%<*initex|package>
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_declare_arg_shorthand:Nn}
% Declaring a shorthand is simply a case of adding to the list. 
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_declare_arg_shorthand:Nn {
  \prop_gput:Nnn \g_xparse_shorthands_prop {#1} {#2}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_flush_m_args:}
% As \texttt{m} arguments are simply counted, there is a need to add 
% them to the token register in a block.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_flush_m_args: {
  \intexpr_compare:nF { \l_xparse_args_m_int = \c_zero } {
    \toks_put_right:Nx \l_xparse_signature_toks {
      \exp_not:c { xparse_arg_m_ \int_use:N \l_xparse_args_m_int :w }
    }
  }
  \int_zero:N \l_xparse_args_m_int
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_get_arg:n}
%\begin{macro}{\xparse_get_arg_long:n}
% Collecting default arguments is pretty easy. The \texttt{next} 
% function needs to be reset so that the loop continues.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_get_arg:n {
  \toks_put_right:Nn \l_xparse_signature_toks { {#1} }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \xparse_prepare_signature:N
}
\cs_new:Nn \xparse_get_arg_long:n {
  \toks_put_right:Nn \l_xparse_signature_toks { {#1} }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \xparse_prepare_signature:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}{\xparse_get_three_args:nnw}
%\begin{macro}[aux]{\xparse_get_third_arg:w}
% There is a need to get three arguments for the \texttt{d} and
% \texttt{D} specifiers. By collecting two here, the third (which may
% be \cs{long}) can be handled by the functions above.
%    \begin{macrocode}
\cs_new_nopar:Npn \xparse_get_three_args:nnw #1#2 {
  \toks_put_right:Nn \l_xparse_signature_toks { {#1} {#2} }
  \peek_meaning_ignore_spaces:NTF \c_group_begin_token {
    \xparse_get_third_arg:w
  }{
    \xparse_get_third_arg:w { -NoValue- }
  }
}
\cs_new_nopar:Npn \xparse_get_third_arg:w {}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}[TF]{\xparse_if_no_value:n}
% Tests for ``no value''.
%    \begin{macrocode}
\prg_new_conditional:Nnn \xparse_if_no_value:n {TF,T,F} {
  \tl_if_eq:nnTF {#1} { -NoValue- } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_prepare_signature:n}
% Creating the signature is a case of working through the input and
% turning into the output in \cs{l_xparse_signature_toks}. A track is
% also kept of the total number of arguments. This function sets 
% everything up then hands off to the parser.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_prepare_signature:n  {
  \int_zero:N \l_xparse_args_m_int
  \int_zero:N \l_xparse_args_total_int
  \toks_clear:N \l_xparse_signature_toks
  \xparse_prepare_signature:N #1 \q_nil
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\xparse_prepare_signature:N}
%\begin{macro}[aux]{\xparse_prepare_signature_aux:N}
%\begin{macro}[aux]{\xparse_prepare_next:w}
% The main signature-preparation loop is in two parts, to keep the code 
% a little clearer. Most of the checks here is pretty clear, with a key
% point to watch what is next on the stack so that the loop continues
% correctly. 
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_prepare_signature:N {
  \quark_if_nil:NTF #1 {
    \xparse_flush_m_args:
  }{
    \prop_if_in:NnTF \g_xparse_shorthands_prop {#1} {
      \prop_get:NnN \g_xparse_shorthands_prop {#1} \l_xparse_tmpa_tl
      \exp_last_unbraced:NV \xparse_prepare_signature_aux:N 
        \l_xparse_tmpa_tl
    }{
      \xparse_prepare_signature_aux:N #1
    }
  }
}
\cs_new_nopar:Nn \xparse_prepare_signature_aux:N {
  \int_incr:N \l_xparse_args_total_int
  \xparse_check_and_add:N #1
  \xparse_prepare_next:w
}
\cs_new_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_set_spacing:}
% A short function to check if an optional argument should ignore
% spaces.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_set_spacing: {
  \tl_clear:N \l_xparse_spaces_tl
  \intexpr_compare:nF { \l_xparse_args_mandatory_int > \c_zero } {
    \tl_set:Nn \l_xparse_spaces_tl { _no_spaces }
  }
  \bool_if:NT \l_xparse_space_force_bool {
    \tl_set:Nn \l_xparse_spaces_tl { _no_spaces }
  }
  \bool_if:NT \l_xparse_space_ignore_bool {
    \tl_clear:N \l_xparse_spaces_tl
  }
  \bool_set_false:N \l_xparse_space_force_bool
  \bool_set_false:N \l_xparse_space_ignore_bool
}
%    \end{macrocode}
%\end{macro}
%
% The optional argument types are created.
%    \begin{macrocode}
\xparse_declare_arg_shorthand:Nn o { d[] } 
\xparse_declare_arg_shorthand:Nn O { D[] } 
\xparse_declare_arg_shorthand:Nn s { t* }
%    \end{macrocode}
%    
%\subsection{Messages}
%    
% Some error messages.   
%    \begin{macrocode}
\msg_new:nnn { xparse } { command~already~defined } {%
  Command name `\token_to_str:N #1' already defined!%
}
\msg_new:nnnn { xparse } { command~not~yet~defined } {%
  Command `\token_to_str:N #1' not yet defined!%
}{%
  You have used \token_to_str:N \RenewDocumentCommand, or similar\\%
  with a command that was never defined.  Perhaps you meant
  \token_to_str:N \NewDocumentCommand.%
}
\msg_new:nnn { xparse } { environment~already~defined } {%
  Environment `#1' already defined!%
}
\msg_new:nnn { xparse } { environment~not~yet~defined } {%
  Environment `#1' not yet defined!%
}
\msg_new:nnn { xparse } { no~co-ordinate } {%
  Missing co-ordinate argument. A value of (0,0) is~assumed.%
}
\msg_new:nnn { xparse } { unknown~argument~type } {
  Unknown~argument~type~`#1'~replaced~by~`m'.~Fingers~crossed ...%
}
%    \end{macrocode}
%    
%\subsection{User functions}
%
% The user functions are more or less just the internal functions 
% renamed. 
%
%\begin{macro}{\DeclareDocumentCommand}
%\begin{macro}{\NewDocumentCommand}
%\begin{macro}{\RenewDocumentCommand}
%\begin{macro}{\ProvideDocumentCommand}
% The user macros are pretty simple wrappers around the internal ones.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \DeclareDocumentCommand {
  \xparse_declare_cmd:Nnn 
}
\cs_new_protected_nopar:Npn \NewDocumentCommand #1 {
  \cs_if_exist:NTF #1 { 
    \msg_error:nnx { xparse } { command~already~defined } {#1}
    \use_none:nn
  }{
    \xparse_declare_cmd:Nnn #1
  }
}
\cs_new_protected_nopar:Npn \RenewDocumentCommand #1 {
  \cs_if_exist:NTF #1 {
    \xparse_declare_cmd:Nnn #1
  }{  
    \msg_error:nnx { xparse } { command~not~yet~defined } {#1}
    \use_none:nn
  }
}
\cs_new_protected_nopar:Npn \ProvideDocumentCommand #1 {
  \cs_if_exist:NTF #1 { 
    \use_none:nn
  }{
    \xparse_declare_cmd:Nnn #1
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\DeclareDocumentEnvironment}
%\begin{macro}{\NewDocumentEnvironment}
%\begin{macro}{\RenewDocumentEnvironment}
%\begin{macro}{\ProvideDocumentEnvironment}
% Very similar for environments.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \DeclareDocumentEnvironment {
  \xparse_declare_env:nnnn
}
\cs_new_protected_nopar:Npn \NewDocumentEnvironment #1 {
  \cs_if_exist:cTF { environment_begin_ #1 :w } { 
    \msg_error:nnx { xparse } { environment~already~defined } {#1}
    \use_none:nnn
  }{
    \xparse_declare_env:nnnn {#1}
  }
}
\cs_new_protected_nopar:Npn \RenewDocumentEnvironment #1 {
  \cs_if_exist:cTF { environment_begin_ #1 :w } {
    \xparse_declare_env:nnnn {#1}
  }{  
    \msg_error:nnx { xparse } { environment~not~yet~defined } {#1}
    \use_none:nnn
  }
}
\cs_new_protected_nopar:Npn \ProvideDocumentEnvironment #1 {
  \cs_if_exist:cTF { environment_begin_ #1 :w } { 
    \use_none:nnn
  }{
    \xparse_declare_env:nnnn {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[TF]{\IfBoolean}
% The logical \meta{true} and \meta{false} statements are just the 
% normal \cs{c_true_bool} and \cs{c_false_bool}, so testing for them is
% done with the \cs{bool_if:NTF} functions from \textsf{l3prg}.
%    \begin{macrocode}
\cs_new_eq:NN \IfBooleanTF \bool_if:NTF
\cs_new_eq:NN \IfBooleanT  \bool_if:NT
\cs_new_eq:NN \IfBooleanF  \bool_if:NF
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[TF]{\IfNoValue}
% Simple re-naming. 
%    \begin{macrocode}
\cs_new_eq:NN \IfNoValueF  \xparse_if_no_value:nF 
\cs_new_eq:NN \IfNoValueT  \xparse_if_no_value:nT 
\cs_new_eq:NN \IfNoValueTF \xparse_if_no_value:nTF 
%    \end{macrocode}
%\end{macro}
%    
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
% 
% \PrintIndex
