% \iffalse
%% File: template.dtx (C) Copyright 1999-2001 David Carlisle, Frank Mittelbach
%%                    (C) Copyright 2004-2009 Frank Mittelbach, LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xbase bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%% 
%
%<*driver|package>
\RequirePackage{l3names}
%</driver|package>
%\fi
\GetIdInfo$Id$
  {template: prototype document functions}
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{template-new.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{template} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{\Team}
% \date{\filedate}
% \maketitle
% 
%\begin{documentation}
%
%\section{Templates: prototype document functions}
%
%\end{documentation}
%
%\begin{implementation}
%
%\subsection{Implementation}
%
% \pkg{template} builds on \pkg{xparse}, which will then load 
% \pkg{expl3}. So for a \LaTeXe\ package only \pkg{xparse} has to be
% required directly. In format mode, this can be skipped as the 
% \pkg{template} should follow after the \pkg{xparse} stuff.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
\RequirePackage{xparse}
%</package>
%<*initex|package>
%    \end{macrocode}
%    
%\subsubsection{Variables and constants}
%
%\begin{macro}{\c_template_code_root_tl}
%\begin{macro}{\c_template_defaults_root_tl}
%\begin{macro}{\c_template_instances_root_tl}
%\begin{macro}{\c_template_keytypes_root_tl}
%\begin{macro}{\c_template_restrict_root_tl}
%\begin{macro}{\c_template_values_root_tl}
%\begin{macro}{\c_template_vars_root_tl}
% So that literal values are kept to a minimum, 
%    \begin{macrocode}
\tl_new:Nn \c_template_code_root_tl      { template_code >  }
\tl_new:Nn \c_template_defaults_root_tl  { template_defaults >  }
\tl_new:Nn \c_template_instances_root_tl { template_instances >  }
\tl_new:Nn \c_template_keytypes_root_tl  { template_keytypes >  }
\tl_new:Nn \c_template_restrict_root_tl  { template_restrict >  }
\tl_new:Nn \c_template_values_root_tl    { template_values >  }
\tl_new:Nn \c_template_vars_root_tl      { template_vars >  }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_template_assignments_toks}
% When creating an instance, the assigned values are collected here. A
% toks is needed as there can be |#| tokens.
%    \begin{macrocode}
\toks_new:N \l_template_assignments_toks
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_template_collection_tl}
% The current instance collection name is stored here.
%    \begin{macrocode}
\tl_new:N \l_template_collection_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_template_default_tl}
% The default value for a key is recovered here from the property list
% in which it is stored. The internal implementation of property lists
% means that this is safe even with unescaped |#| tokens.
%    \begin{macrocode}
\tl_new:N \l_template_default_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_template_error_bool}
% A flag for errors to be carried forward.
%    \begin{macrocode}
\bool_new:N \l_template_error_bool
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_template_full_name_tl}
% The full name of a template includes the type. This needs to be
% stored so that it is available to various key defining and using
% functions.
%    \begin{macrocode}
\tl_new:N \l_template_full_name_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_template_restrict_bool}
% A flag to indicate that a template is being restricted.
%    \begin{macrocode}
\bool_new:N \l_template_restrict_bool
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_template_restricted_clist}
% A scratch list for restricting templates.
%    \begin{macrocode}
\clist_new:N \l_template_restricted_clist
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_template_instance_type_prop}
% The number of arguments needed by each type of instance needs to be
% recorded for each type. This is most conveniently done using a
% property list, with the type name as the index.
%    \begin{macrocode}
\prop_new:N \l_template_template_type_prop
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_template_key_name_tl}
%\begin{macro}{\l_template_keytype_tl}
%\begin{macro}{\l_template_keytype_arg_tl}
%\begin{macro}{\l_template_value_tl}
%\begin{macro}{\l_template_var_tl}
% When defining each key in a template, the name and type of the key
% need to be separated and stored. Any argument needed by the
% keytype is also stored separately.
%    \begin{macrocode}
\tl_new:N \l_template_key_name_tl
\tl_new:N \l_template_keytype_tl
\tl_new:N \l_template_keytype_arg_tl
\tl_new:N \l_template_value_tl
\tl_new:N \l_template_var_tl
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_template_keytypes_prop}
%\begin{macro}{\l_template_values_prop}
%\begin{macro}{\l_template_vars_prop}
% To avoid needing too many difficult-to-follow csname assignments,
% various scratch token registers are used to build up data, which is
% then transferred
%    \begin{macrocode}
\prop_new:N \l_template_keytypes_prop
\prop_new:N \l_template_values_prop
\prop_new:N \l_template_vars_prop
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_template_tmp_dim}
%\begin{macro}{\l_template_tmp_int}
%\begin{macro}{\l_template_tmp_skip}
% For pre-processing the data stored by \pkg{template}, a number of 
% scratch variables are needed. The assignments are made to these in the
% first instance, unless evalution is delayed.
%    \begin{macrocode}
\dim_new:N \l_template_tmp_dim
\int_new:N \l_template_tmp_int
\skip_new:N \l_template_tmp_skip
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_template_tmp_tl}
% A scratch variable for comparisons and so on.
%    \begin{macrocode}
\tl_new:N \l_template_tmp_tl
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Saving and recovering property lists}
%
% The various property lists for templates have to be shuffled in
% and out of storage.
%
%\begin{macro}{\template_store_defaults:n}
%\begin{macro}{\template_store_keytypes:n}
%\begin{macro}{\template_store_restrictions:n}
%\begin{macro}{\template_store_values:n}
%\begin{macro}{\template_store_vars:n}
% The defaults and keytypes are transferred from the scratch property
% lists to the `proper' lists for the template being created.
%    \begin{macrocode}
\cs_new:Nn \template_store_defaults:n {
  \cs_if_free:cT { l_ \c_template_defaults_root_tl #1 _prop } {
    \prop_new:c { l_ \c_template_defaults_root_tl #1 _prop }
  }
  \prop_set_eq:cN { l_ \c_template_defaults_root_tl #1 _prop }
    \l_template_values_prop
}
\cs_new:Nn \template_store_keytypes:n {
  \cs_if_free:cT { l_ \c_template_keytypes_root_tl #1 _prop } {
    \prop_new:c { l_ \c_template_keytypes_root_tl #1 _prop }
  }
  \prop_set_eq:cN { l_ \c_template_keytypes_root_tl #1 _prop }
    \l_template_keytypes_prop
}
\cs_new:Nn \template_store_values:n {
  \cs_if_free:cT { l_ \c_template_values_root_tl #1 _prop } {
    \prop_new:c { l_ \c_template_values_root_tl #1 _prop }
  }
  \prop_set_eq:cN { l_ \c_template_values_root_tl #1 _prop }
    \l_template_values_prop
}
\cs_new:Nn \template_store_restrictions:n {
  \clist_set_eq:cN { l_ \c_template_restrict_root_tl #1 _clist }
    \l_template_restrict_clist
}
\cs_new:Nn \template_store_vars:n {
  \cs_if_free:cT { l_ \c_template_vars_root_tl #1 _prop } {
    \prop_new:c { l_ \c_template_vars_root_tl #1 _prop }
  }
  \prop_set_eq:cN { l_ \c_template_vars_root_tl #1 _prop }
    \l_template_vars_prop
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_recover_defaults:n}
%\begin{macro}{\template_recover_keytypes:n}
%\begin{macro}{\template_recover_restrictions:n}
%\begin{macro}{\template_recover_values:n}
%\begin{macro}{\template_recover_vars:n}
% Recovering the stored data for a template is rather less complex 
% than storing it. All that happens is the data is  transferred from 
% the permanent to the scratch storage.
%    \begin{macrocode}
\cs_new:Nn \template_recover_defaults:n {
  \prop_set_eq:Nc \l_template_values_prop
    { l_ \c_template_defaults_root_tl #1 _prop }
}
\cs_new:Nn \template_recover_keytypes:n {
  \prop_set_eq:Nc \l_template_keytypes_prop
    { l_ \c_template_keytypes_root_tl #1 _prop }
}
\cs_new:Nn \template_recover_restrictions:n {
  \clist_set_eq:Nc \l_template_restrict_clist
    { l_ \c_template_restrict_root_tl #1 _clist }
}
\cs_new:Nn \template_recover_values:n {
  \prop_set_eq:Nc \l_template_values_prop
    { l_ \c_template_values_root_tl #1 _prop }
}
\cs_new:Nn \template_recover_vars:n {
  \prop_set_eq:Nc \l_template_vars_prop
    { l_ \c_template_vars_root_tl #1 _prop }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\subsection{Testing existence and validity}
%
% There are a number of checks needed for either the existence of
% a template type, template or instance. There are also some for the
% validity of a particular call. All of these are collected up here.
% 
%\begin{macro}{\template_if_arg_agreement:nNTF}
% A test agreement between the number of arguments for the template
% type and that specified when creating a template.
%    \begin{macrocode}
\prg_new_conditional:Nnn \template_if_arg_agreement:nN { TF } {
  \prop_get:NnN \l_template_template_type_prop {#1} \l_template_tmp_tl
  \tl_if_eq:nVTF {#2} \l_template_tmp_tl {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_if_eval_later:nTF}
% Tests for the first token in a string being \cs{AttributeValue} or
% \cs{DelayEvalution}.
%    \begin{macrocode}
\prg_new_conditional:Nnn \template_if_eval_later:n { TF } {
  \tl_if_eq:noTF { \AttributeValue } { \tl_head:w #1 \q_nil } {
    \prg_return_true:
  }{
    \tl_if_eq:noTF { \DelayEvalution } { \tl_head:w #1 \q_nil } {
      \prg_return_true:
    }{
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[TF]{\template_if_instance_exist:nnn}
% Testing for an instance is collection dependent.
%    \begin{macrocode}
\prg_new_conditional:Nnn \template_if_instance_exist:nnn { T, F, TF } {
  \cs_if_exist:cTF { \c_template_instances_root_tl #1 / #2 / #3 :w } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_if_keys_exist:nnTF}
% To check that the keys for a template have been set up before trying
% to create any code, a simple check for the correctly-named keytype
% property list.
%    \begin{macrocode}
\prg_new_conditional:Nnn \template_if_keys_exist:nn { TF } {
  \cs_if_exist:cTF { l_ \c_template_keytypes_root_tl #1 / #2 _prop } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_if_keytype_exist:nTF}
%\begin{macro}{\template_if_keytype_exist:VTF}
% The test for valid keytypes looks for a function to set up the key,
% which is part of the `code' side of the template definition. This 
% avoids having different lists for the two parts of the process. There
% are two tests so that both local and global keytypes can be tested 
% using the same system.
%    \begin{macrocode}
\prg_new_conditional:Nnn \template_if_keytype_exist:n { TF } {
  \cs_if_exist:cTF { template_store_value_ \l_template_keytype_tl :n } {
    \prg_return_true:
  }{
    \cs_if_exist:cTF {
      template_store_value_ 
      \tl_tail:V \l_template_keytype_tl 
      :n 
    } {
      \prg_return_true:
    }{
      \prg_return_false:
    }
  }
}
\cs_generate_variant:Nn \template_if_keytype_exist:nTF { V }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%
%\begin{macro}{\template_if_template_exist:nnTF}
% A template is only fully declared if the code has been set up, 
% which can be checked by looking for the template function itself.
%    \begin{macrocode}
\prg_new_conditional:Nnn \template_if_template_exist:nn { TF } {
  \cs_if_exist:cTF { \c_template_code_root_tl #1 / #2 :w } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_if_type_exist:nTF}
% To check that a particular template type is valid.
%    \begin{macrocode}
\prg_new_conditional:Nnn \template_if_type_exist:n { TF } {
  \prop_if_in:NnTF \l_template_template_type_prop {#1} {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%    
%\subsubsection{Creating new template types}
%
%\begin{macro}{\template_declare_template_type:nN}
% Although the instance type is the `top level' of the template system,
% it is actually very easy to implement. All that happens is that the
% number of arguments required is recorded, indexed by the name of the 
% template type.
%    \begin{macrocode}
\cs_new:Nn \template_declare_template_type:nN {
  \prop_put:Nnn \l_template_template_type_prop {#1} {#2}
}
%    \end{macrocode}
%\end{macro}
%
%\subsection{Design part of template declaration}
%
% The `design' part of a template declaration defines the general
% behaviour of each key, and possibly a default value. However, it does
% not include the implementation. This means that what happens here is
% the two properties are saved to appropriate lists, which can then
% be used later to recover the information when implementing the keys.
% 
%\begin{macro}{\template_declare_template_keys:nnNn}
% The main function for the `design' part of creating a template starts
% by checking that the template type exists and that the number of 
% arguments required agree. If that is all fine, then the two storage
% areas for defaults and keytypes are initialised. The mechanism is then
% set up for the \pkg{l3keyval} module to actually parse the keys. 
% Finally, the code hands of to the storage routine to save the parsed
% information properly.
%    \begin{macrocode}
\cs_new:Nn \template_declare_template_keys:nnNn {
  \template_if_type_exist:nTF {#1} {
    \template_if_arg_agreement:nNTF {#1} #3 {
      \prop_clear:N \l_template_values_prop
      \prop_clear:N \l_template_keytypes_prop
      \cs_set_eq:NN \KV_key_no_value_elt:n \template_parse_keys_elt:n
      \cs_set_eq:NN \KV_key_value_elt:nn \template_parse_keys_elt:nn
      \KV_parse_space_removal_sanitize:n {#4}
      \template_store_defaults:n { #1 / #2 }
      \template_store_keytypes:n { #1 / #2 }
    }{
      \msg_error:nnxx { template } { bad-arg-count } {#1} {#3}
    }
  }{
    \msg_error:nnx { template } { unknown-template-type } {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_parse_keys_elt:n}
% Processing the key part of the key--value pair is always carried out
% using this function, even if a value was found. First, the key name
% is separated from the keytype, and if necessary the keytype is 
% separated into two parts. This information is then used to check that
% the keytype is valid, before storing the keytype (plus argument if
% necessary) as a property of the key name. 
%    \begin{macrocode}
\cs_new:Nn \template_parse_keys_elt:n {
  \template_split_keytype:n {#1}
  \bool_if:NF \l_template_error_bool {
    \template_if_keytype_exist:VTF \l_template_keytype_tl {
      \tl_set:Nx \l_template_tmp_tl {
        \l_template_keytype_tl .
        \l_template_keytype_arg_tl
      }
      \prop_put:NVV \l_template_keytypes_prop \l_template_key_name_tl
        \l_template_tmp_tl
    }{
      \msg_error:nnx { template } { invalid-keytype } 
        { \l_template_keytype_tl }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_parse_keys_elt:nn}
% For keys which have a default, the keytype and key name are first
% separated out by the \cs{template_parse_keys_elt:n}
% routine, before storing the default value in the scratch property list.
%    \begin{macrocode}
\cs_new:Nn \template_parse_keys_elt:nn {
  \template_parse_keys_elt:n {#1}
  \use:c { template_store_value_ \l_template_keytype_tl :n } {#2}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_split_keytype:n}
%\begin{macro}[aux]{\template_split_keytype_aux:w}
% The keytype and key name should be separated by `\texttt{:}'. As the
% definition might be given inside or outside of a code block, spaces
% are removed and the category code of colons is standardised. After
% that, the standard delimited argument metho is used to separate the
% two parts.
%    \begin{macrocode}
\group_begin:
\char_make_other:N \&
\char_set_lccode:nn { `\& } { `\: }
\tl_to_lowercase:n {
  \group_end:
  \cs_new:Nn \template_split_keytype:n {
    \bool_set_false:N \l_template_error_bool
    \tl_set:Nn \l_template_tmpa_tl {#1}
    \tl_replace_all_in:Nnn \l_template_tmpa_tl { ~ } { }
    \tl_replace_all_in:Nnn \l_template_tmpa_tl { : } { & }
    \tl_if_in:VnTF \l_template_tmpa_tl { & } {
      \exp_after:wN \template_split_keytype_aux:w \l_template_tmpa_tl
        \q_stop
    }{
      \bool_set_true:N \l_template_error_bool
      \msg_error:nnx { template } { no-keytype } {#1}
    }
  }
  \cs_new:Npn \template_split_keytype_aux:w #1 & #2 \q_stop {
    \tl_set:Nn \l_template_key_name_tl {#2}
    \template_split_keytype_arg:n {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_split_keytype_arg:n}
%\begin{macro}{\template_split_keytype_arg:V}
%\begin{macro}[aux]{\template_split_keytype_arg_aux:w}
% The second stage of storting out the keytype is to check for an
% argument. This is separated from the type itself by a full stop, so
% there is a second test followed by a second delimited function.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_split_keytype_arg:n {
  \tl_if_in:nnTF {#1} { . } {
    \template_split_keytype_arg_aux:w #1 \q_stop
  }{
    \tl_set:Nn \l_template_keytype_tl {#1}
    \tl_clear:N \l_template_keytype_arg_tl
  }
}
\cs_generate_variant:Nn \template_split_keytype_arg:n { V }
\cs_new:Npn \template_split_keytype_arg_aux:w #1 . #2 \q_stop {
  \tl_set:Nn \l_template_keytype_tl {#1}
  \tl_set:Nn \l_template_keytype_arg_tl {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\subsubsection{Storing values}
%
% As \pkg{template} pre-processes key values for efficiency reasons,
% there is a need to convert the values given as defaults into
% `ready to use' data. The same general idea is true when an instance
% is declared. However, assignments are not made until an instance is
% used, and so there has to be some intermediate storage. Furthermore,
% the ability to delay evalution of results is needed. To achieve these
% aims, a series of `process and store' functions are defined here.
% 
% All of the information about the key (the key name and the keytype)
% is already stored as variables. The same property list is always used
% to store the data, meaning that the only argument required is the
% value to be processed and potentially stored.
%
%\begin{macro}{\template_store_value_boolean:n}
% Storing Boolean values requires a test for delayed evalution, but
% is different to the various numerical variable types as there are
% only two possible values to store. So the code here tests the default
% switch and then records the meaning (either \texttt{true} or 
% \texttt{false}).
%    \begin{macrocode}
\cs_new:Nn \template_store_value_boolean:n {
  \template_if_eval_later:nTF {#1} {
    \prop_put:NVn \l_template_values_prop \l_template_key_name_tl {#1}
  }{
    \bool_if:NTF #1 {
      \prop_put:NVn \l_template_values_prop \l_template_key_name_tl
        { true }
    }{
      \prop_put:NVn \l_template_values_prop \l_template_key_name_tl
        { false }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_store_value_function:n}
%\begin{macro}{\template_store_value_function:n}
%\begin{macro}{\template_store_value_instance:n}
%\begin{macro}{\template_store_value_tokenlist:n}
% With no need to worry about delayed evalution, these keytypes all
% just store the input directly.
%    \begin{macrocode}
\cs_new:Nn \template_store_value_code:n {
  \prop_put:NVn \l_template_values_prop \l_template_key_name_tl {#1}
}
\cs_new:Nn \template_store_value_function:n {
  \prop_put:NVn \l_template_values_prop \l_template_key_name_tl {#1}
}
\cs_new:Nn \template_store_value_instance:n {
  \prop_put:NVn \l_template_values_prop \l_template_key_name_tl {#1}
}
\cs_new:Nn \template_store_value_tokenlist:n {
  \prop_put:NVn \l_template_values_prop \l_template_key_name_tl {#1}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_store_value_integer:n}
%\begin{macro}{\template_store_value_length:n}
%\begin{macro}{\template_store_value_skip:n}
% Storing the value of a number is in all cases more or less the same.
% If evalution is taking place now, assignment is made to a scratch
% variable, and this result is then stored. On the other hand, if
% evalution is delayed the current data is simply stored `as is'.
%    \begin{macrocode}
\cs_new:Nn \template_store_value_integer:n {
  \template_if_eval_later:nTF {#1} {
    \prop_put:NVn \l_template_values_prop \l_template_key_name_tl {#1}
  }{
    \int_set:Nn \l_template_tmp_int {#1}
    \prop_put:NVV \l_template_values_prop \l_template_key_name_tl
      \l_template_tmp_int
  }
}
\cs_new:Nn \template_store_value_length:n {
  \template_if_eval_later:nTF {#1} {
    \prop_put:NVn \l_template_values_prop \l_template_key_name_tl {#1}
  }{
    \dim_set:Nn \l_template_tmp_dim {#1}
    \prop_put:NVV \l_template_values_prop \l_template_key_name_tl
      \l_template_tmp_dim
  }
}
\cs_new:Nn \template_store_value_skip:n {
  \template_if_eval_later:nTF {#1} {
    \prop_put:NVn \l_template_values_prop \l_template_key_name_tl {#1}
  }{
    \skip_set:Nn \l_template_tmp_skip {#1}
    \prop_put:NVV \l_template_values_prop \l_template_key_name_tl
      \l_template_tmp_skip
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
% 
%\subsubsection{Implementation part of template declaration}
%
%\begin{macro}{\template_declare_template_code:nnNnn}
% The main function for implementing a template starts with a couple of
% simple checks to make sure that there are no obvious mistakes: the
% number of arguments must agree and the template keys must have been
% declared. 
%    \begin{macrocode}
\cs_new:Nn \template_declare_template_code:nnNnn {
  \template_if_type_exist:nTF {#1} {
    \template_if_arg_agreement:nNTF {#1} #3 {
      \template_if_keys_exist:nnTF {#1} {#2} {
        \template_store_key_implementation:nnn {#1} {#2} {#4}
        \cs_generate_from_arg_count:cNnn 
          { \c_template_code_root_tl #1 / #2 :w } \cs_set:Npn {#3} {#5}
      }{
        \msg_error:nnxx { template } { code-no-keys } {#1} {#2}
      }
    }{
      \msg_error:nnxx { template } { bad-arg-count } {#1} {#3}
    }
  }{
    \msg_error:nnx { template } { unknown-template-type } {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_store_key_implementation:nnn}
% Actually storing the implementation part of a template is quite easy
% as it only requires the list of keys given to be turned into a 
% property list. There is also some error-checking to do, hence the need
% to have the list of defined keytypes available.
%    \begin{macrocode}
\cs_set:Nn \template_store_key_implementation:nnn {
  \template_recover_keytypes:n { #1 / #2 }
  \prop_clear:N \l_template_vars_prop
  \cs_set_eq:NN \KV_key_no_value_elt:n \template_parse_vars_elt:n
  \cs_set_eq:NN \KV_key_value_elt:nn \template_parse_vars_elt:nn
  \KV_parse_space_removal_sanitize:n {#3}
  \template_store_vars:n { #1 / #2 }
  \clist_clear:N \l_template_restrict_clist
  \template_store_restrictions:n { #1 / #2 }
  \prop_if_empty:NF \l_template_keytypes_prop {
    \msg_error:nnxx { template } { key-mismatch } {#1} {#2}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_parse_vars_elt:n}
% At the implementation stage, every key must have a vlaue given. So
% this is an error function.
%    \begin{macrocode}
\cs_new:Nn \template_parse_vars_elt:n {
  \msg_error:nnx { template } { key-not-declared } {#1}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_parse_vars_elt:nn}
% The actual storage part here is very simple: the storage bin name
% is placed into the property list. At the same time, a comparison is
% made with the keytypes defined earlier: if there is a mismatch then
% an error is raised.
%    \begin{macrocode}
\cs_new:Nn \template_parse_vars_elt:nn {
  \prop_if_in:NnTF \l_template_keytypes_prop {#1} {
    \prop_del:Nn \l_template_keytypes_prop {#1}
    \prop_put:Nnn \l_template_vars_prop {#1} {#2}
  }{
    \msg_error:nnx { template } { key-not-declared } {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Edting template defaults}
%
% Template defaults can be edited either with no other changes or
% to prevent further editing, forming a ``restricted template''.
% In the later case, a new template results, whereas simple editing 
% does not produce a new template name.
% 
%\begin{macro}{\template_declare_restricted:nnnn}
% Creating a resticted template means copying the old template to the
% new one first.
%    \begin{macrocode}
\cs_new:Nn \template_declare_restricted:nnnn {
  \template_if_keys_exist:nnTF {#1} {#3} {
    \template_set_template_eq:nn { #1 / #2 } { #1 / #3 }
    \bool_set_true:N \l_template_restrict_bool
    \template_edit_defaults_aux:nnn {#1} {#2} {#4}
  }{
   \msg_error:nnxx { template } { unknown-template } {#1} {#2}
 }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_edit_defaults:nnn}
%\begin{macro}[aux]{\template_edit_defaults_aux:nnn}
% Editing the template defaults means getting the values back out
% of the store, then parsing the list of new values before putting
% the updated list back into storage. The auxiliary function is used
% to allow code-sharing with the template-restriction system.
%    \begin{macrocode}
\cs_new:Npn \template_edit_defaults:nnn {
  \bool_set_false:N \l_template_restrict_bool
  \template_edit_defaults_aux:nnn
}
\cs_new:Nn \template_edit_defaults_aux:nnn {
  \template_if_keys_exist:nnTF {#1} {#2} {
    \template_recover_defaults:n { #1 / #2 }
    \template_recover_restrictions:n { #1 / #2 }
    \template_parse_values:nn { #1 / #2 } {#3}
    \template_store_defaults:n { #1 / #2 }
    \template_store_restrictions:n { #1 / #2 }
  }{
   \msg_error:nnxx { template } { unknown-template } {#1} {#2}
 }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_parse_values:nn}
% The routine to parse values is the same for both editing a 
% template and setting up an instance. So the code here does only the
% minimum necessary for reading the values.
%    \begin{macrocode}
\cs_new:Nn \template_parse_values:nn {
  \template_recover_keytypes:n {#1}
  \clist_clear:N \l_template_restricted_clist
  \cs_set_eq:NN \KV_key_no_value_elt:n \template_parse_values_elt:n
  \cs_set_eq:NN \KV_key_value_elt:nn \template_parse_values_elt:nn
  \KV_parse_space_removal_sanitize:n {#2}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_parse_values_elt:n}
% Every key needs a value, so this is just an error routine.
%    \begin{macrocode}
\cs_new:Nn \template_parse_values_elt:n {
  \bool_set_true:N \l_template_error_bool
  \msg_error:nnx { template } { key-no-value } {#1}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_parse_values_elt:nn}
%\begin{macro}[aux]{\template_parse_values_elt_aux:nn}
% To store the value, find the keytype then call the saving function.
% These need the current key name saved as \cs{l_template_key_name_tl}.
% When a template is being restricted, the setting code will be 
% skipped for restricted keys.
%    \begin{macrocode}
\cs_new:Nn \template_parse_values_elt:nn {
  \prop_if_in:NnTF \l_template_keytypes_prop {#1} {
    \bool_if:NTF \l_template_restrict_bool {
      \clist_if_in:NnF \l_template_restricted_clist {#1} {
        \template_parse_values_elt_aux:nn {#1} {#2}
      }
    }{
      \template_parse_values_elt_aux:nn {#1} {#2}
    }
  }{
    \msg_error:nnx { template } { unknown-key } {#1}
  }
}
\cs_new:Nn \template_parse_values_elt_aux:nn {
  \clist_put_right:Nn \l_template_restricted_clist {#1}
  \prop_get:NnN \l_template_keytypes_prop {#1} \l_template_tmp_tl
  \template_split_keytype_arg:V \l_template_tmp_tl
  \tl_set:Nn \l_template_key_name_tl {#1}
  \use:c { template_store_value_ \l_template_keytype_tl :n } {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_set_template_eq:nn}
% To copy a tempalte, each of the lists plus the code has to be copied
% across. To keep this independent of the list storage system, it is
% all done with two-part shuffles.
%    \begin{macrocode}
\cs_new:Nn \template_set_template_eq:nn {
  \template_recover_defaults:n {#2}
  \template_store_defaults:n {#2}
  \template_recover_keytypes:n {#2}
  \template_store_keytypes:n {#2}
  \template_recover_keyvars:n {#2}
  \template_store_keyvars:n {#2} 
  \cs_set_eq:cc { \c_template_code_root_tl #1 :w }
    { \c_template_code_root_tl #2 :w } 
}
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Creating instances of templates}
%
%\begin{macro}{\template_declare_instance:nnnnn}
%\begin{macro}[aux]{\template_declare_instance_aux:nnnnn}
% Maing an instance has two distinct parts. First, the keys given are
% parsed to transfer the values into the structured data format used
% internally. This allows the default and given values to be combined
% with no repetition. In the second step, the structured data is
% converted to pre-defined variable assignments, and these are stored
% in the function for the instance. A final check is also made so that
% there is always an instance `outside' of any collection.
%    \begin{macrocode}
\cs_new:Nn \template_declare_instance:nnnnn {
  \template_if_template_exist:nnTF {#1} {#2} {
    \template_recover_defaults:n { #1 / #2 }
    \template_declare_instance_aux:nnnnn {#1} {#2} {#3} {#4} {#5}
  }{
    \msg_error:nnxx { template } { code-no-keys } {#1} {#2}
  }
}
\cs_new:Nn \template_declare_instance_aux:nnnnn {
  \bool_set_false:N \l_template_error_bool
  \template_parse_values:nn { #1 / #2 } {#5}
  \bool_if:NF \l_template_error_bool {
    \template_store_values:n { #1 / #3 / #4 }
    \template_convert_to_assignments:
    \cs_set:cpx { \c_template_instances_root_tl #1 / #3 / #4 :w } {
      \exp_not:N \template_assignments_push:n {
        \exp_not:V \l_template_assignments_toks
      }
      \exp_not:c { \c_template_code_root_tl #1 / #2 :w }
    }
    \template_if_instance_exist:nnnF {#1} { } {#4} {
      \cs_set_eq:cc
        { \c_template_instances_root_tl #1 /    / #4 :w }
        { \c_template_instances_root_tl #1 / #3 / #4 :w }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_edit_instance:nnnnn}
% Editing an instance is almost indentical to declaring one. The only
% variation is the source of the values to use. When editing, they are
% recovered from the previous instance run.
%    \begin{macrocode}
\cs_new:Nn \template_edit_instance:nnnnn {
  \template_if_template_exist:nnTF {#1} {#2} {
    \template_if_instance_exist:nnnTF {#1} {#3} {#4} {
      \template_recover_values:n { #1 / #3 / #4 }
      \template_declare_instance_aux:nnnnn {#1} {#2} {#3} {#4} {#5}
    }{
      \msg_error:nnxx { template } { unknown-instance } {#1} {#3}
    }
  }{
    \msg_error:nnxx { template } { unknown-template } {#1} {#2}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_convert_to_assignments:}
%\begin{macro}[aux]{\template_convert_to_assignments_aux:nn}
% The idea on converting to a set of assignments is to loop over each
% key, so that the loop order follows the declaration order of the keys.
% For each key, if a value is available this is recovered along with 
% the variable to save it in. The assignment itself is left to a 
% keytype-specific function.
%    \begin{macrocode}
\cs_new:Nn \template_convert_to_assignments: {
  \toks_clear:N \l_template_assignments_toks
  \prop_map_function:NN \l_template_keytypes_prop 
    \template_convert_to_assignments_aux:nn
}
\cs_new:Nn \template_convert_to_assignments_aux:nn {
  \prop_if_in:NnT \l_template_values_prop {#1} {
    \prop_get:NnN \l_template_values_prop {#1} \l_template_value_tl
    \prop_get:NnN \l_template_vars_prop {#1} \l_template_var_tl
    \template_split_keytype_arg:n {#2}
    \tl_if_eq:VnF \l_template_keytype_tl { code } {
      \exp_args:NV \cs_if_exist:NF \l_template_var_tl {
        \msg_error:nnx { template } { undeclared-variable }
          { \exp_not:V \l_template_var_tl }
      }
    }
    \use:c { template_assign_ \l_template_keytype_tl : }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsubsection{Assigning values to variables}
%
%\begin{macro}{\template_assign_boolean:}
%\begin{macro}{\templage_assign_+boolean:}
%\begin{macro}{\templage_assign_boolean_aux:n}
% Setting a Boolean value is slightly different to everythign else 
% as the value can be used to work out which \texttt{set} function to
% call. As long as there is no need to recover things from another 
% variable, everything is pretty easy.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_assign_boolean: {
  \template_assign_boolean_aux:n { boolean_set }
}
\cs_new_nopar:cn  { template_assign_ + boolean: } {
  \template_assign_boolean_aux:n { boolean_gset }
}
\cs_new_nopar:Nn \template_assign_tokenlist_aux:n {
  \template_if_attrib_value:VT \l_template_value_tl {
    \template_attrib_to_value:
  }
  \toks_put_left:Nx \l_template_assignments_toks {
    \exp_not:c { #1 _ \l_template_value_tl :N }
    \exp_not:V \l_template_var_tl
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_assign_code:}
%\begin{macro}{\template_assign_code:n}
% Assigning general code to a key needs a scratch function to be created
% and run when \cs{DoParameterAssignment} is called. So the appropriate
% definition then use is created in the toks.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_assign_code: {
  \toks_put_left:Nx \l_template_assignments_toks {
    \exp_not:N \cs_set:Nx \exp_not:N \template_assign_code:n {
      \exp_not:V \l_template_var_tl
    }
    \exp_not:N \template_assign_code:n
      { \exp_not:V \l_template_value_tl }
  }
}
\cs_new:Nn \template_assign_code:n { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_assign_function:}
%\begin{macro}{\templage_assign_+function:}
%\begin{macro}[aux]{\template_assign_function_aux:N}
% For functions, the toks needs to have a cs-generation step created.
% This looks a bit messy but is only actually one function.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_assign_function: {
  \template_assign_function_aux:N \cs_set:Npn
}
\cs_new_nopar:cn  { template_assign_ + function: } {
  \template_assign_function_aux:N \cs_gset:Npn
}
\cs_new_nopar:Nn \template_assign_function_aux:N {
  \toks_put_left:Nx \l_template_assignments_toks {
    \exp_not:N \cs_generate_from_arg_count:NNnn
      \exp_not:V \l_template_var_tl
      \exp_not:N #1
      { \exp_not:V \l_template_keytype_arg_tl }
      { \exp_not:V \l_template_value_tl }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_assign_integer:}
%\begin{macro}{\template_assign_+integer:}
%\begin{macro}{\template_assign_length:}
%\begin{macro}{\template_assign_+length:}
%\begin{macro}{\template_assign_skip:}
%\begin{macro}{\template_assign_+skip:}
% All of the calcuated assignements use the same underlying code, with
% only the low-level assignment function changing.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_assign_integer: {
  \template_assign_variable:N \int_set:Nn
}
\cs_new_nopar:cn { template_assign_ + integer: } {
  \template_assign_variable:N \int_gset:Nn
}
\cs_new_nopar:Nn \template_assign_length: {
  \template_assign_variable:N \dim_set:Nn
}
\cs_new_nopar:cn { template_assign_ + length: } {
  \template_assign_variable:N \dim_gset:Nn
}
\cs_new_nopar:Nn \template_assign_skip: {
  \template_assign_variable:N \skip_set:Nn
}
\cs_new_nopar:cn { template_assign_ + skip: } {
  \template_assign_variable:N \skip_gset:Nn
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_assign_tokenlist:}
%\begin{macro}{\template_assign_+tokenlist:}
%\begin{macro}{\template_assign_tokenlist_aux:N}
% Storing lists of tokens is easy: no complex calculations and no
% need to worry about numbers of arguments.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_assign_tokenlist: {
  \template_assign_tokenlist_aux:N \tl_set:Nn
}
\cs_new_nopar:cn  { template_assign_ + tokenlist: } {
  \template_assign_tokenlist_aux:N \tl_gset:Nn
}
\cs_new_nopar:Nn \template_assign_tokenlist_aux:N {
  \toks_put_left:Nx \l_template_assignments_toks {
    \exp_not:N #1 \exp_not:V \l_template_var_tl 
      { \exp_not:V \l_template_value_tl }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_assign_variable:N}
% A general-purpose function for all of the numerical assignments. 
% As long as the value is not coming from another variable, the stored
% value is simply transferred for output.
%    \begin{macrocode}
\cs_new_nopar:Nn \template_assign_variable:N {
  \template_if_attrib_value:VT \l_template_value_tl {
    \template_attrib_to_value:
  }
  \toks_put_left:Nx \l_template_assignments_toks {
    \exp_not:N #1 \exp_not:V \l_template_var_tl 
       { \exp_not:V \l_template_value_tl }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_attrib_to_value:}
%\begin{macro}{\template_attrib_to_value_aux:w}
% The idea here is to recover the attribute value of another key. To
% do that, the marker is removed and a look up takes place. If this
% is successful, then the name of the variable of the attribute is 
% returned. This assumes that the value will be used in context where
% it will be converted to a value, for example when setting a number.
%    \begin{macrocode}
\cs_new:Nn \template_attrib_to_value: {
  \exp_after:wN \template_attrib_to_value_aux:w \l_template_value_tl
}
\cs_new:Npn \template_attrib_to_value_aux:w \AttributeValue #1 {
  \tl_set:Nn \l_template_tmp_tl {#1}
  \prop_if_in:NnTF \l_template_vars_prop {#1} {
    \prop_get:NnN \l_template_vars_prop {#1}  \l_template_value_tl
  }{
    \msg_error:nnx { template } { unknown-attribute } {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\template_if_attrib_value:nT}
%\begin{macro}{\template_if_attrib_value:VT}
% Tests for the first token in a string being \cs{AttributeValue}, where
% \cs{DelayEvalution} is not important.
%    \begin{macrocode}
\prg_set_conditional:Nnn \template_if_attrib_value:n { T } {
  \tl_if_eq:noTF { \AttributeValue } { \tl_head:w #1 \q_nil } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
\cs_generate_variant:Nn \template_if_attrib_value:nT { V }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsubsection{Using instances}
%
%\begin{macro}{\template_use_instance:nn}
% Using an instance is just a question of finding the appropriate
% function. There is the possibility that a collection instance exists,
% so this is checked before trying the general instance. If nothing is
% found, an error is raised.
%    \begin{macrocode}
\cs_new:Nn \template_use_instance:nn {
  \template_if_instance_exist:nnnTF 
    {#1} {\l_template_collection_tl} {#2} {
    \use:c { 
      \c_template_instances_root_tl #1 / \l_template_collection_tl /#2 
      :w
    }
  }{
    \template_if_instance_exist:nnnTF {#1} { } {#2} {
      \use:c { \c_template_instances_root_tl #1 / / #2 :w }
    }{
      \msg_error:nnxx { template } { unknown-instance } {#1} {#2}
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_use_collection:n}
% Switching to an instance collection is just a question of setting the
% appropriate token list.
%    \begin{macrocode}
\cs_new:Nn \template_use_collection:n {
  \tl_set:Nn \l_template_collection_tl {#1}
}
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Assignment manipulation}
%
% A few functions to transfer assignments about, as this is needed by
% \cs{DoParameterAssignments}.
% 
%\begin{macro}{\template_assignments_pop:n}
% To actually use the assignments.
%    \begin{macrocode}
\cs_new:Nn \template_assignments_pop: {
  \toks_use:N \l_template_assignments_toks 
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_assignments_push:n}
% Here, the assignments are stored for later use.
%    \begin{macrocode}
\cs_new:Nn \template_assignments_push:n {
  \toks_set:Nn \l_template_assignments_toks {#1}
}
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Showing  templates and instances}
%
%\begin{macro}{\template_show_code:nn}
% Showing the code for a template is just a translation of 
% \cs{cs_show:c}.
%    \begin{macrocode}
\cs_new:Nn \template_show_code:nn {
  \cs_show:c { \c_template_code_root_tl #1 / #2 :w }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\template_show_defaults:nn}
%\begin{macro}{\template_show_keytypes:nn}
%\begin{macro}{\template_show_values:nnn}
%\begin{macro}{\template_show_vars:nn}
% Showing the internal data is a case of getting the appropriate 
% property list back, then displaying the scratch variable.
%    \begin{macrocode}
\cs_new:Nn \template_show_defaults:nn {
  \template_recover_defaults:n { #1 / #2 }
  \prop_display:N \l_template_values_prop
}
\cs_new:Nn \template_show_keytypes:nn {
  \template_recover_keytypes:n { #1 / #2 }
  \prop_display:N \l_template_keytypes_prop
}
\cs_new:Nn \template_show_values:nnn {
  \template_recover_values:n { #1 / #2 / #3 }
  \prop_display:N \l_template_values_prop
}
\cs_new:Nn \template_show_vars:nn {
  \template_recover_vars:n { #1 / #2 }
  \prop_display:N \l_template_vars_prop
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\subsubsection{Messages}
%
%    \begin{macrocode}
\msg_new:nnn { template } { bad-arg-count } {%
  Template type `#1' does not take #2 arguments.%
}
\msg_new:nnnn { template } { code-no-keys } {%
  No key definitions for template `#2' of type `#1'.%
}{%
  You have probably given \token_to_str:N \DeclareTemplateCode \\%
  before giving \token_to_str:N \DeclareTemplateKeys.%
}
\msg_new:nnnn { template } { undeclared-variable } {%
  The variable #1 has not been declared.%
}{%  
  Before declaring an instance, all of the required variables\\%
  must be created.%
}
\msg_new:nnn { template } { invalid-keytype } {%
  The keytype `#1' is not valid.%
}
\msg_new:nnn { template } { key-mismatch } {%
  Some keys declared for template `#2' of type `#1'\\%
  have no implementation given.%
}
\msg_new:nnn { template } { key-no-code } {%
  The key `#1' has no implementation given.%
}
\msg_new:nnn { template } { key-not-declared } {%
  An implementation was given for key `#1',\\%
  but it was never declared.%
}
\msg_new:nnn { template } { key-no-value } {%
  The key `#1' has no value.%
}
\msg_new:nnn { template } { no-keytype } {%
  The key description `#1' does not contain a keytype.%
}
\msg_new:nnn { template } { unknown-key } {%
  The key `#1' is unknown.%
}
\msg_new:nnnn { template } { unknown-attribute } {%
  The attribute `#1' is unknown.%
}{%
  There is a definition in the current template reading\\%
  \token_to_str:N \AttributeValue 
  \token_to_str:N { #1 \token_to_str:N }\\%
  but there is no key called `#1'.%
}
\msg_new:nnn { template } { unknown-instance } {%
  The instance `#2' of type `#1' is unknown.%
}
\msg_new:nnn { template } { unknown-template } {%
  The template `#2' of type `#1' is unknown.%
}
\msg_new:nnn { template } { unknown-template-type } {%
  The template type `#1' is unknown.%
}
%    \end{macrocode}
%    
%\subsubsection{User functions}
%
% The user functions provided by \pkg{template} are pretty much direct
% copies of internal ones. However, by sticking to the \pkg{xparse}
% approach only the appropriate arguments are long.
% 
%\begin{macro}{\DeclareTemplateType}
%\begin{macro}{\DeclareTemplateKeys}
%\begin{macro}{\DeclareTemplateCode}
%\begin{macro}{\DeclareRestrictedTemplate}
%\begin{macro}{\EditTemplateDefaults}
%\begin{macro}{\DeclareInstance}
%\begin{macro}{\DeclareCollectionInstance}
%\begin{macro}{\EditInstance}
%\begin{macro}{\EditCollectionInstance}
%\begin{macro}{\UseInstance}
%\begin{macro}{\UseCollection}
% All simple translations, with the appropriate long/short argument
% filtering.
%    \begin{macrocode}
\NewDocumentCommand \DeclareTemplateType { m m } {
  \template_declare_template_type:nN {#1} #2
}
\NewDocumentCommand \DeclareTemplateKeys { m m m +m } {
  \template_declare_template_keys:nnNn {#1} {#2} #3 {#4}
}
\NewDocumentCommand \DeclareTemplateCode { m m m +m +m } {
  \template_declare_template_code:nnNnn {#1} {#2} #3 {#4} {#5}
}
\NewDocumentCommand \DeclareRestrictedTemplate { m m m +m } {
  \template_declare_restricted:nnnn {#1} {#2} {#3} {#4}
}
\NewDocumentCommand \DeclareInstance { m m m +m } {
  \template_declare_instance:nnnnn {#1} {#3} { } {#2} {#4} 
}
\NewDocumentCommand \DeclareCollectionInstance { m m m m +m } {
  \template_declare_instance:nnnnn {#2} {#4} {#1} {#3} {#5}
}
\NewDocumentCommand \EditTemplateDefaults { m m +m } {
  \template_edit_defaults:nnn {#1} {#2} {#3}
}
\NewDocumentCommand \EditInstance { m m m +m } {
  \template_edit_instance:nnnnn {#1} {#3} { } {#2} {#4} 
}
\NewDocumentCommand \EditCollectionInstance { m m m m +m } {
  \template_edit_instance:nnnnn {#2} {#4} {#1} {#3} {#5}
}
\NewDocumentCommand \UseInstance { m m } {
  \template_use_instance:nn {#1} {#2}
}
\NewDocumentCommand \UseCollection { m } {
  \template_use_collection:nn {#1} 
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\ShowTemplateCode}
%\begin{macro}{\ShowTemplateDefaults}
%\begin{macro}{\ShowTemplateKeytypes}
%\begin{macro}{\ShowTemplateVariables}
%\begin{macro}{\ShowInstanceValues}
%\begin{macro}{\ShowCollectionInstanceValues}
% The show functions are again just translation.
%    \begin{macrocode}
\NewDocumentCommand \ShowTemplateCode { m m } {
  \template_show_code:nn {#1} {#2}
}
\NewDocumentCommand \ShowTemplateDefaults { m m } {
  \template_show_defaults:nn {#1} {#2}
}
\NewDocumentCommand \ShowTemplateKeytypes { m m } {
  \template_show_keytypes:nn {#1} {#2}
}
\NewDocumentCommand \ShowTemplateVariables { m m } {
  \template_show_vars:nn {#1} {#2}
}
\NewDocumentCommand \ShowInstanceValues { m m } {
  \template_show_values:nnn {#1} { } {#2}
}
\NewDocumentCommand \ShowCollectionInstanceValues { m m m } {
  \template_show_values:nnn {#1} {#2} {#3}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[TF]{\IfInstanceExist}
% More direct translation: only the base instance is checked for.
%    \begin{macrocode}
\DeclareExpandableDocumentCommand \IfInstanceExistTF { m m } {
  \template_if_instance_exists:nnnTF {#1} { } {#2} 
}
\DeclareExpandableDocumentCommand \IfInstanceExistT { m m } {
  \template_if_instance_exists:nnnT {#1} { } {#2} 
}
\DeclareExpandableDocumentCommand \IfInstanceExistF { m m } {
  \template_if_instance_exists:nnnF {#1} { } {#2}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\AttributeValue}
%\begin{macro}{\DelayEvalution}
% These are both do nothing functions. Both simply dump their arguments
% when executed: this should not happen with \cs{AttributeValue}.
%    \begin{macrocode}
\NewDocumentCommand \AttributeValue { +m } {#1}
\NewDocumentCommand \DelayEvalution { +m } {#1}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\DoParameterAssignments}
% A short call to use a token register by proxy.
%    \begin{macrocode}
\DeclareDocumentCommand \DoParameterAssignments { } {
  \template_assignments_pop:
}
%    \end{macrocode}
%\end{macro}
%   
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
%\end{implementation}
