% \iffalse
%% File: xparse.dtx (C) Copyright 1999 Frank Mittelbach, Chris Rowley, 
%%                      David Carlisle
%%                  (C) Copyright 2004-2008 Frank Mittelbach, 
%%                      LaTeX3 Project
%%                  (C) Copyright 2009 LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xbase bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%% 
%
%<*driver|package>
\RequirePackage{l3names}
%</driver|package>
%\fi
\GetIdInfo$Id$
  {Generic document command parser}
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{xparse.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{xparse} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Generic document command parser}
% \author{\Team}
% \date{\filedate}
% \maketitle
%
%\begin{documentation}
%
%\section{Creating document commands}
%
% The \pkg{xparse} package provides a high-level interface for
% producing document-level commands. In that way, it is intended as
% a replacement for the \LaTeXe\ \cs{newcommand} macro. However,
% \pkg{xparse} works so that the interface to a function (optional
% arguments, stars and mandatory arguments, for example) is separate
% from the internal implementation. \pkg{xparse} provides a normalised
% input for the internal form of a function, independent of the 
% document-level argument arrangement.
% 
%\subsection{Specifying arguments}
%
% Before introducing the functions used to create document commands,
% the method for specifiying arguments with \pkg{xparse} will be 
% illustrated. In order to allow each argument to be defined 
% independently, \pkg{xparse} does not simply need to know the 
% number of arguments for a function, but also the nature of each
% one. This is done by constructing an \emph{argument specification},
% which defines the number of arguments, the type of each argument
% and any additional information needed for \pkg{xparse} to read the
% user input and properly pass it thorugh to internal functions. 
% 
% The basic form of the argument specifier is a list of letters, where
% each letter defines a type of argument. As will be described below,
% some of the types need additional information, such as default values.
% The argument types can be divided into two, those which are mandatory
% (potentially raising an error if not found) and those which are 
% optional. The mandatory types are:
%\begin{itemize}
%  \item[m] A standard mandatory argument, which will be passed to the
%    internal code surronded by a brace pair. This is the \pkg{xparse}
%    type specifier for a normal \TeX\ argument.
%  \item[l] An argument which reads everything up to the first
%    open group token: in standard \LaTeX\ this is a left brace. 
%  \item[u] Reads an argument `until' \meta{tokens} are encountered,
%    where the desired \meta{tokens} are given as an argument to the
%    specifier: \texttt{u\marg{tokens}}.
%\end{itemize}
% The optional argument types are:
%\begin{itemize}
%  \item[o] A standard \LaTeX\ optional argument, which will supply
%    the special \cs{NoValue} token if not given (as described later).
%  \item[d] An optional argument which is delimited by \meta{token1}
%    and \meta{token2}, which are given as arguments: 
%    \texttt{d\meta{token1}\meta{token2}}. As with \texttt{o}, if no
%    value is given the special token \cs{NoValue} is returned.
%  \item[O] As for \texttt{o}, but returns \meta{default} if no
%    value is given.  Should be given as \texttt{O\marg{default}}.
%  \item[D] As for \texttt{d}, but returns \meta{default} if no
%    value is given: \texttt{D\meta{token1}\meta{token2}\marg{default}}.
%    Internally, the \texttt{o}, \texttt{d} and \texttt{O} types are
%    shortcuts to an appropriated-constructed \texttt{D} type argument.
%  \item[s] An optional star, which will result in a value 
%    \cs{BooleanTrue} if a star is present and \cs{BooleanFalse}
%    otherwise (as described later).
%  \item[t] An optional \meta{token}, which will result in a value 
%    \cs{BooleanTrue} if a star is present and \cs{BooleanFalse}
%    otherwise. Given as \texttt{t\meta{token}}.
%  \item[g] An optional argument given inside a pair of \TeX\ group
%    tokens (in standard \LaTeX, |{| \ldots |}|).
%\end{itemize}
%
% Using these specifiers, it is possible to create complex input syntax
% very easily. % For example, given the argument definition 
% `|s o o m O{default}|', the input `|*[Foo]{Bar}|' would be parsed as:
%\begin{itemize} 
%  \item |#1| = |\BooleanTrue|
%  \item |#2| = |{Foo}|
%  \item |#3| = |\NoValue|
%  \item |#4| = |{Bar}|
%  \item |#5| = |{default}|
%\end{itemize}
% whereas `|[One][Two]{}[three]|' would be parsed as:
%\begin{itemize} 
%  \item |#1| = |\BooleanFalse|
%  \item |#2| = |{One}|
%  \item |#3| = |{Two}|
%  \item |#4| = |{}|
%  \item |#5| = |{Three}|
%\end{itemize}
% In other words there will be always exactly the same number of brace 
% groups or tokens as the number of letters in the argument specifier.
% 
% Two more tokens have a special meaning when creating an argument 
% specifier. First, \texttt{+} is used to make an argument \cs{long}
% (to accept paragraph tokens). In contrast to \LaTeXe's 
% \cs{newcommand}, this applies on an argument-by-argument basis.
% So modififying the example to `|s o o +m O{default}|' means that
% the mandatory argument is now \cs{long}, whereas the optional
% arguments are not.
% 
% Secondly, the token \texttt{>} is used to introduce so called
% `argument processors'. These are a somewhat advanced topic, and
% are covered in Section~\ref{sec:processors}.
% 
%\subsection{Declaring commands and environments}
% 
% With the concept of an argument specifier defined, it is now 
% possible to describe the methods available for creating both
% functions and environments using \pkg{xparse}.
% 
% The interface-building commands are the preferred method for 
% creating document-level functions in \LaTeX3. All of the functions 
% generated in this way are naturally robust (using the \eTeX\ 
% \cs{protected} mechanism).
% 
%\begin{function}{
%  \DeclareDocumentCommand|
%  \NewDocumentCommand|
%  \RenewDocumentCommand|
%  \ProvideDocumentCommand
%}
%  \begin{syntax}
%    "\DeclareDocumentCommand" <function> <arg spec> <code>
%  \end{syntax}
%  This family of commands are used to create a document-level
%  <function>. The argument specification for te function is
%  given by <arg spec>, and the function will execute <code>.
%  
%  As an example:
%  \begin{verbatim}
%    \DeclareDocumentCommand \chapter { s o m } {
%      \IfBooleanTF {#1} {
%        \typesetnormalchapter {#2} {#3} 
%      }{
%        \typesetstarchapter {#3}
%      }
%    }
%  \end{verbatim}
%  would be a way to define a \cs{chapter} command which would
%  essentially behave like the current \LaTeXe\ command (except that it
%  would accept an optional argument even when a \texttt{*} was parsed).
%  The \cs{typesetnormalchapter} could test its first argument for being
%  \cs{NoValue} to see if an optional argument was present.
% 
%  The difference between the \cs{Declare\ldots}, \cs{New\ldots}
%  \cs{Renew\ldots} and \cs{Provide\ldots} versions is the behaviour
%  if <function> is already defined. 
%  \begin{itemize}
%    \item \cs{DeclareDocumentCommand} will always create the new 
%      definition, irrespective of any existing <function> with the 
%      same name. 
%   \item \cs{NewDocumentCommand} will issue an error if <function>
%     has already been defined.
%   \item \cs{RenewDocumentCommand} will issue an error if <function>
%     has not previously been defined.
%   \item \cs{ProvideDocumentCommand} creates a new definition fo
%     <function> only if one has not already been given.
%  \end{itemize}  
%  
%  \begin{texnote}
%     Unlike \LaTeXe's \cs{newcommand} and relatives, the \pkg{xparse}
%     \cs{DeclareDocumentCommand} set of functions do not prevent 
%     creation of functions with names starting \cs{end\ldots}.
%  \end{texnote}
%\end{function} 
%
%\begin{function}{%
%  \DeclareDocumentEnvironment|
%  \NewDocumentEnvironment|
%  \RenewDocumentEnvironment|
%  \ProvideDocumentEnvironment
%}
%  \begin{syntax}
%    "\DeclareDocumentEnvironment" <environment> <arg spec>
%    ~~~~<start code> <end code>
%  \end{syntax}
%  These commands work in the same way as \cs{DeclareDocumentCommand},
%  etc., but create environments (\cs{begin}|{|<function>|}| \ldots
%  \cs{end}|{|<function>|}|). Both the <start code> and <end code>
%  may access the arguments as defined by <arg spec>.
%  
%  \begin{texnote}
%    In contrast to \LaTeXe, these commands do not create a pair of
%    macros \cs{<environment>} and \cs{end<environment>}. Thus \LaTeX3
%    environments have to be accessed using the \cs{begin} \ldots
%    \cs{end} mechanism.
%  \end{texnote}
%\end{function}
%
%\subsection{Testing special values}
%
%\begin{variable}{\NoValue} 
%  \cs{NoValue} is a special marker returned by \pkg{xparse} if no 
%  value is given for an optional argument. If typeset (which should
%  not happen),  it will print the value \texttt{-NoValue-}.
%\end{variable}
%
%\begin{function}{\IfNoValue / (TF) (EXP)}
%  \begin{syntax}
%    "\IfNoValue" <argument> <true code> <false code>
%  \end{syntax}
%  The \cs{IfNoValue} tests are used to check if <argument> (|#1|,
%  |#2|, etc.) is the special \cs{NoValue} token. For example
%  \begin{verbatim}
%    \DeclareDocumentCommand \foo { o m } {
%      \IfNoValueTF {#1} {
%        \DoSomethingJustWithMandatoryArgument {#2}
%      }{
%        \DoSomethingBothArguments {#1} {#2}
%      }
%    }
%  \end{verbatim}
%  will use a different internal function if the optional argument
%  is given than if it is not present.
%  
%  As the \cs{IfNoValue} tests are expandable, it is possible to test
%  these values later, for example at the point of typesetting or in
%  an expansion context.
%\end{function}
%
%\begin{variable}{
%  \BooleanFalse|
%  \BooleanTrue
%} 
%  The \texttt{true} and \texttt{false} flags set when searching for
%  an optional token (using \texttt{s} or \texttt{t<token>}) have
%  names which are accessible outside of code blocks. 
%\end{variable}
%
%\begin{function}{\IfBoolean / (TF) (EXP)}
%  \begin{syntax}
%    "\IfBooleanTF" <argument> <true code> <false code>
%  \end{syntax}
%  Used to test if <argument> (|#1|, |#2|, etc.) is \cs{BooleanTrue}
%  or \cs{BooleanFalse}. For example
%  \begin{verbatim}
%    \DeclareDocumentCommand \foo { s m } {
%      \IfBooleanTF #1 {
%        \DoSomethingWithStar {#2} 
%      }{
%        \DoSomethingWithoutStar {#2}
%    }
%  \end{verbatim}
%  checks for a star as the first argument, then chooses the action to
%  take based on this information.
%\end{function}
%
%\subsection{Argument processors}
%\label{sec:processors}
%
% \pkg{xparse} introdues the idea of an argument processor, which is
% applied to an argument after it has been grabbed by the underlying
% system but before it is passed to \meta{code}. An argument processor
% can therefore be used to regularise input at an early stage, allowing
% the internal functions to be completely independent of input form.
% 
% Each argument processor is specified by the syntax 
% \texttt{>\marg{processor}} in the argument specification. Processors
% are applied from right to left, so that 
%\begin{verbatim}
%  >{\ProcessorB} >{\ProcessorA} m
%\end{verbatim}
% would apply \cs{ProcessorA} 
% followed by \cs{ProcessorB} to the \texttt{m} argument. Processors are
% not applied to \cs{NoValue}.
% 
%\begin{function}{\xparse_arg_to_str:n}
%  \begin{syntax}
%    "\xparse_arg_to_str:n" <grabbed argument>
%  \end{syntax}
%  The \cs{xparse_arg_to_str:n} processor applies the \LaTeX3
%  \cs{tl_to_str:n} function to the grabbed argument before passing
%  it through to the <code> of a <function>. For example
%  \begin{verbatim}
%    \DeclareDocumentCommand \foo { >{\xparse_arg_to_str:n} m } {
%      #1 % Which is a string
%    }
%  \end{verbatim}
%  
%  As can be seen here, processor functions must have a last \texttt{n}
%  argument, so that they pick up the <grabbed argument>, which is
%  passed to them by \pkg{xparse} for processing.
%\end{function}
%
%\begin{function}{\xparse_arg_split_on_comma:n}
%  \begin{syntax}
%    "\\xparse_arg_split_on_comma:n" <grabbed argument>
%  \end{syntax}
%  The \cs{xparse_arg_split_coords:n} processor splits the 
%  grabbed argument at the first comma, returning the two
%  parts of the result in braces. If no comma is found, the second
%  part of the returned value is empty. This function is intended to
%  aid the processing of co-ordinate pairs. For exmple
%  \begn{verbatim}
%    \DeclareDocumentCommand \foo 
%      { >{\xparse_arg_split_on_comma:n} D(){0,0} m }
%      { \foo_internal:nnn #1 {#2} }
%  \end{verbatim}
%  will result in \cs{foo_internal:nnn} receiving one co-ordinate as 
%  |#1| and the second as |#2|.
%\end{function}
%
%\begin{variable}{\l_xparse_arg_toks}
%  Processor functions should return the processed argument in the
%  variable \cs{l_xparse_arg_toks}. This will always be empty when the
%  processor function is called by \pkg{xparse}, even if more than one
%  argument processor is applied.
%\end{variable}
%  
%\subsection{Variables and constants}
%
%\begin{variable}{\c_xparse_shorthands_prop}
%  Shorthands and replacement text.
%\end{variable}
%
%\begin{variable}{\l_xparse_args_toks}
%  Token register for arguments as they are picked up for passing on to
%  user functions.
%\end{variable}
%
%\begin{variable}{\l_xparse_environment_args_toks}
%  Token register to pass arguments to the end of an environment from
%  the beginning.
%\end{variable}
%
%\begin{variable}{\l_xparse_long_bool}
%  Flag used to indicate creation of \cs{long} arguments.
%\end{variable}
%
%\begin{variable}{\l_xparse_m_args_int}
%  Used to enumerate the \texttt{m} arguments with no modifications.
%\end{variable}
%
%\begin{variable}{\l_xparse_m_only_bool}
%  Flag used to indicate that all arguments are of type \texttt{m}.
%\end{variable}
%
%\begin{variable}{
%  \l_xparse_processor_int|
%  \l_xparse_processor_use_int
%}
%  For counting up processors as defined and as used, respectively.
%\end{variable}
%
%\begin{variable}{\l_xparse_signature_toks}
%  For constucting the signature of the functionm defined.
%\end{variable}
%
%\begin{variable}{\l_xparse_tmp_tl}
%  Scratch space.
%\end{variable}
%
%\begin{variable}{\l_xparse_total_args_int}
%  Used to enumerate the total number of arguments.
%\end{variable}
%
%\subsection{Internal functions}
%
%\begin{function}{\xparse_add_arg:n}
%  \begin{syntax}
%    "\xparse_add_arg:n" <grabbed arg>
%  \end{syntax}
%  Adds <grabbed arg> to the output \pkg{xparse} supplies to the
%  defined <code>, applying any post-processing that is needed.
%\end{function}
%
%\begin{function}{\xparse_add_grabber:N}
%  \begin{syntax}
%    "\xparse_add_grabber:N" <grabber type>
%  \end{syntax}
%  Adds appropriate grabber for <grabber type> to the signature
%  being constructed, making it \cs{long} if necessary.
%\end{function}
%
%\begin{function}{
%  \xparse_add_type_+:|
%  \xparse_add_type_>:|
%  \xparse_add_type_d:|
%  \xparse_add_type_D:|
%  \xparse_add_type_g:|
%  \xparse_add_type_G:|
%  \xparse_add_type_l:|
%  \xparse_add_type_m:|
%  \xparse_add_type_t:|
%  \xparse_add_type_u:
%}
%  \begin{syntax}
%    "\xparse_add_type_u:"
%  \end{syntax}
%  Carry out necessary processes to add given <type> of argument to 
%  the siganture being constructed.
%\end{function}
%
%\begin{function}{\xparse_check_and_add:N}
%  \begin{syntax}
%    "\xparse_check_and_add:N" <arg spec>
%  \end{syntax}
%  Ensures that <arg spec> is valid, and if so adds it to the signature
%  being constructed.
%\end{function}
%
%\begin{function}{
%  \xparse_declare_cmd:Nnn|
%  \xparse_declare_cmd:cnn
%}
%  \begin{syntax}
%    "\xparse_declare_cmd:Nnn" <function> <signature>
%    ~~~~<code>
%  \end{syntax}
%  Declares <function> using <signature> for argument definition and
%  <code> as expansion.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareDocumentCommand}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\xparse_declare_env:nnnn}
%  \begin{syntax}
%    "\xparse_declare_env:nnnn" <env> <arg spec>
%    ~~~~<start code> <end code>
%  \end{syntax}
%  Declares <env> as an environment taking <arg spec> arguments 
%  at \cs{begin}\{<env>\}. The <start code> is eceutre at the beginning
%  of the environment, and the <end code> at the end. Both parts may
%  use the arguments defined by <arg spec>.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareDocumentEnvironment}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\xparse_flush_m_args:}
%  \begin{syntax}
%    "\xparse_flush_m_args:" 
%  \end{syntax}
%  Adds an outstanding \texttt{m} arguments to the signature.
%\end{function}
%
%\begin{function}{
%  \xparse_grab_D:w     |
%  \xparse_grab_D_long:w|
%  \xparse_grab_G:w     |
%  \xparse_grab_G_long:w|
%  \xparse_grab_l:w     |
%  \xparse_grab_l_long:w|
%  \xparse_grab_m:w     |
%  \xparse_grab_m_long:w|
%  \xparse_grab_m_1:w   |
%  \xparse_grab_m_2:w   |
%  \xparse_grab_m_3:w   |
%  \xparse_grab_m_4:w   |
%  \xparse_grab_m_5:w   |
%  \xparse_grab_m_6:w   |
%  \xparse_grab_m_7:w   |
%  \xparse_grab_m_8:w   |
%  \xparse_grab_t:w     |
%  \xparse_grab_t_long:w|
%  \xparse_grab_u:w     |
%  \xparse_grab_u_long:w
%}
%  \begin{syntax}
%    "\xparse_grab_D:w" <arg data> "\l_xparse_args_toks"
%  \end{syntax}
%  Argument grabbing functions, which re-arrange other <arg data>
%  so that the argument is read correctly.
%\end{function}
%
%\begin{function}{\xparse_if_no_value:n / (TF) (EXP)}
%  \begin{syntax}
%    "\xparse_if_no_value:n" <arg> <true code> <false code>
%  \end{syntax}
%  Executes <true code> if <arg> is equal to the special 
%  \cs{NoValue} marker and <false code> otherwise.  
%\end{function}
%
%\begin{function}{
%  \xparse_prepare_signature:n|
%  \xparse_prepare_signature:N
%}
%  \begin{syntax}
%    "\xparse_prepare_signature:n"  <arg specs>
%  \end{syntax}
%  Parse one or more <arg specs> and convert to an output <signature>.  
%\end{function}
%
%\begin{function}{\xparse_process_arg:n}
%  \begin{syntax}
%    "\xparse_process_arg:n" <processor>
%  \end{syntax}
%  Sets up code to apply <processor> to next grabbed argument.
%\end{function}
%
%\begin{function}{\xparse_prepare_next:w}
%  \begin{syntax}
%    "\xparse_next:w"
%  \end{syntax}
%  Function to call to loop parsing of <arg spec>, which may need to
%  collect additional information for the previous <type>.
%\end{function}
%
%\end{documentation}
% 
%\begin{implementation}
%
%\section{\pkg{xparse} implementation}
%
% The usual lead-off: only needed for the package, of course (one day we
% may have a \LaTeX3 kernel).
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
\RequirePackage{expl3}
%</package>
%<*initex|package>
%    \end{macrocode}
%    
%\subsection{Variables and constants}
%
%\begin{macro}{\c_xparse_shorthands_prop}
% Shorthands are stored as a property list: this is set up here as it
% is a constant.
%    \begin{macrocode}
\prop_new:N \c_xparse_shorthands_prop
\prop_put:Nnn \c_xparse_shorthands_prop { o } { d[] }
\prop_put:Nnn \c_xparse_shorthands_prop { O } { D[] }
\prop_put:Nnn \c_xparse_shorthands_prop { s } { t* }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_arg_toks}
% Token registers for single grabbed argument when post-processing.
%    \begin{macrocode}
\toks_new:N \l_xparse_arg_toks
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_args_toks}
% Token registers for grabbed arguments.
%    \begin{macrocode}
\toks_new:N \l_xparse_args_toks
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_environment_args_toks}
% Used to pass arguments to the end of an environment.
%    \begin{macrocode}
\toks_new:N \l_xparse_environment_args_toks
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_long_bool}
% A flag for \cs{long} arguments.
%    \begin{macrocode}
\bool_new:N \l_xparse_long_bool
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_m_args_int}
% The number of simple \texttt{m} arguments is tracked so they can be
% dumped \emph{en masse}.
%    \begin{macrocode}
\int_new:N \l_xparse_m_args_int
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_m_only_bool}
% A flag to indicate that only \texttt{m} arguments have been found.
%    \begin{macrocode}
\bool_new:N \l_xparse_m_only_bool
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_processor_int}
%\begin{macro}{\l_xparse_processor_use_int}
% For keeping a count of post-processors and then using them.
%    \begin{macrocode}
\int_new:N \l_xparse_processor_int
\int_new:N \l_xparse_processor_use_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_xparse_signature_toks}
% Token registers for making signatures.
%    \begin{macrocode}
\toks_new:N \l_xparse_signature_toks
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_tmp_tl}
% A general purpose token list variable.
%    \begin{macrocode}
\tl_new:N \l_xparse_tmp_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_total_args_int}
% Thje total number of arguments is used to create the internal function
% which has a fixed number of arguments.
%    \begin{macrocode}
\int_new:N \l_xparse_total_args_int
%    \end{macrocode}
%\end{macro}
%    
%\subsection{Internal commands}
%
%\begin{macro}{\xparse_add_arg:n}
%\begin{macro}[aux]{\xparse_add_arg_aux:n}
%\begin{macro}[aux]{\xparse_add_arg_aux:V}
% The argument-storing system provides a single point for interfacing
% with processors. They are done in a loop, couning upward. Notice that
% a set of braces are added back around the result of processing so that
% the internal function will correctly pick up one argument for each
% input argument.
%    \begin{macrocode}
\cs_new:Nn \xparse_add_arg:n {
  \intexpr_compare:nTF { \l_xparse_processor_int = \c_zero } {
    \toks_put_right:Nn \l_xparse_args_toks { {#1} }
  }{
    \xparse_if_no_value:nTF {#1} {
      \int_zero:N \l_xparse_processor_int
      \toks_put_right:Nn \l_xparse_args_toks { {#1} }
    }{
      \int_zero:N \l_xparse_processor_use_int
      \xparse_add_arg_aux:n {#1}
    }
  }
}
\cs_new:Nn \xparse_add_arg_aux:n {
  \int_incr:N \l_xparse_processor_use_int
  \use:c { xparse_processor_ \int_use:N \l_xparse_processor_use_int :n }
    {#1}
  \intexpr_compare:nTF { 
    \l_xparse_processor_use_int = \l_xparse_processor_int 
  } {
    \toks_put_right:No \l_xparse_args_toks {
      \exp_after:wN { \toks_use:N \l_xparse_arg_toks }
    }
    \int_zero:N \l_xparse_processor_int
  }{
    \xparse_add_arg_aux:V \l_xparse_arg_toks
  }  
}
\cs_generate_variant:Nn \xparse_add_arg_aux:n { V }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_add_grabber:N}
% A shortcut to add the appropriate grabber to the signature, possibly
% \cs{long}, and to then clear the flag.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_grabber:N {
  \toks_put_right:Nx \l_xparse_signature_toks {
    \exp_not:c { 
      xparse_grab_ #1 \bool_if:NT \l_xparse_long_bool { _long } :w
    }
  }
  \bool_set_false:N \l_xparse_long_bool
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_+:}
% Making the next argument \cs{long} means setting the flag and
% knocking one back off the totatl argument count. The \texttt{m}
% arguments are recorded here as this has to be done for every case
% where there is then a \cs{long} argument.
%    \begin{macrocode}
\cs_new_nopar:cn { xparse_add_type_+: } {
  \xparse_flush_m_args:
  \bool_set_true:N \l_xparse_long_bool 
  \bool_set_false:N \l_xparse_m_only_bool
  \int_decr:N \l_xparse_total_args_int
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_>:}
%\begin{macro}[aux]{\xparse_add_type_>_aux:}
% Preprocessors are simply added to the signature.
%    \begin{macrocode}
\cs_new_nopar:cn { xparse_add_type_>: } {
  \xparse_flush_m_args:
  \int_decr:N \l_xparse_total_args_int
  \cs_set_eq:Nc \xparse_prepare_next:w { xparse_add_type_>_aux:n }
}
\cs_new:cn { xparse_add_type_>_aux:n } {
  \toks_put_right:Nn \l_xparse_signature_toks {  
    \xparse_process_arg:n {#1}
  }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \xparse_prepare_signature:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_d:}
%\begin{macro}[aux]{\xparse_add_type_d_aux:NN}
% To save on repeated code, \texttt{d} is actually turned into
% the same grabber as is used by \texttt{D}, by putting the
% \cs{NoValue} default in the correct place.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_d: {
  \xparse_flush_m_args:
  \xparse_add_grabber:N D
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_add_type_d_aux:NN
}
\cs_new:Nn \xparse_add_type_d_aux:NN {
  \toks_put_right:Nn \l_xparse_signature_toks { #1#2 { \NoValue } }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \xparse_prepare_signature:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_D:}
%\begin{macro}[aux]{\xparse_add_type_D_aux:NNN}
% The \texttt{D} version is much the same as \texttt{d}, execpt the
% default value has to be picked up.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_D: {
  \xparse_flush_m_args:
  \xparse_add_grabber:N D
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_add_type_D_aux:NNN
}
\cs_new:Nn \xparse_add_type_D_aux:NNN {
  \toks_put_right:Nn \l_xparse_signature_toks { #1#2 {#3} }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \xparse_prepare_signature:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_g:}
% Optional grouped arguments are easy: an alias for \texttt{g} with
% a \cs{NoValue} default.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_g: {
  \xparse_flush_m_args:
  \xparse_add_grabber:N G
  \toks_put_right:Nn \l_xparse_signature_toks { { \NoValue } }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_G:}
%\begin{macro}[aux]{\xparse_add_type_G_aux:n}
% Optional braced arguments with a default just need to find that
% value.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_G: {
  \xparse_flush_m_args:
  \xparse_add_grabber:N G
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_add_type_G_aux:N
}
\cs_new:Nn \xparse_add_type_G_aux:N {
  \toks_put_right:Nn \l_xparse_signature_toks { {#1} }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \xparse_prepare_signature:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_l:}
% Finding \texttt{l} arguments is very simple.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_l: {
  \xparse_flush_m_args:
  \xparse_add_grabber:N l
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_m:}
% The \texttt{m} type is special as only \cs{long} arguments are
% explicitly handled. For non-\cs{long} arguments, the total number
% is counted and dealt with \emph{en masse} later.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_m: {
  \bool_if:NTF \l_xparse_long_bool {
    \bool_set_false:N \l_xparse_long_bool
    \toks_put_right:Nn \l_xparse_signature_toks 
      { \xparse_grab_m_long:w }
  }{
    \intexpr_compare:nTF { \l_xparse_processor_int = \c_zero } {
      \int_incr:N \l_xparse_m_args_int
    }{
      \toks_put_right:Nn \l_xparse_signature_toks { \xparse_grab_m:w }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_t:}
%\begin{macro}[aux]{\xparse_add_type_t_aux:N}
% Setting up a \texttt{t} argument has two steps: add to the signature,
% then set up to collect and store one more token.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_t: {
  \xparse_flush_m_args:
  \xparse_add_grabber:N t
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_add_type_t_aux:N
}
\cs_new:Nn \xparse_add_type_t_aux:N {
  \toks_put_right:Nn \l_xparse_signature_toks { #1 }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \xparse_prepare_signature:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_u:}
%\begin{macro}[aux]{\xparse_add_type_u_aux:n}
% Setting up a \texttt{u} argument is very similar to a \texttt{t} one,
% with the naming difference that the auxiliary function expects a 
% braced argument.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_u: {
  \xparse_flush_m_args:
  \xparse_add_grabber:N u
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_add_type_u_aux:n
}
\cs_new_eq:NN \xparse_add_type_u_aux:n \xparse_add_type_B_aux:N
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_check_and_add:N}
% This function checks if the argument type actually exists and gives
% an error if it doesn't.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_check_and_add:N  {
  \cs_if_free:cTF { xparse_add_type_#1: } {
    \msg_error:nnx { xparse } { unknown-argument-type } {#1}
    \xparse_add_type_m:
  }{
    \use:c { xparse_add_type_#1: }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_declare_cmd:Nnn}
%\begin{macro}{\xparse_declare_cmd:cnn}
%\begin{macro}[aux]{\xparse_declare_cmd_all_m:Nn}
%\begin{macro}[aux]{\xparse_declare_cmd_mixed:Nn}
% First, the signature is set up from the argument specification. There
% is then a check: if only \texttt{m} arguments are needed (which 
% includes functions with no arguments at all) then the definition is
% simple. On the other hand, if the signature is more complex then an 
% internal function actually contains the code with the user function
% as a simple wrapper.
%    \begin{macrocode}
\cs_new:Nn \xparse_declare_cmd:Nnn {
  \xparse_prepare_signature:n {#2}
  \bool_if:NTF \l_xparse_m_only_bool {
    \xparse_declare_cmd_all_m:Nn #1 {#3}
  }{
    \xparse_declare_cmd_mixed:Nn #1 {#3}
  }
}
\cs_generate_variant:Nn \xparse_declare_cmd:Nnn { cnn }
\cs_new:Nn \xparse_declare_cmd_all_m:Nn {
  \cs_generate_from_arg_count:NNnn 
    #1 \cs_set_protected_nopar:Npn \l_xparse_total_args_int {#2}
}
\cs_new:Nn \xparse_declare_cmd_mixed:Nn {
  \cs_set_protected_nopar:Npx #1 {
    \exp_not:n { 
      \int_zero:N \l_xparse_processor_int
      \toks_set:Nn \l_xparse_args_toks 
    } { \exp_not:c { \token_to_str:N #1 } }
    \toks_use:N \l_xparse_signature_toks
    \exp_not:n{ \toks_use:N \l_xparse_args_toks }
  }
  \cs_generate_from_arg_count:cNnn 
    { \token_to_str:N #1 } \cs_set:Npn \l_xparse_total_args_int {#2}
}
%    \end{macrocode} 
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_declare_env:nnnn}
% The idea here is to make sure that the end of the environment has the
% same arguments available as the beginning.
%    \begin{macrocode}
\cs_new:Nn \xparse_declare_env:nnnn {
  \xparse_declare_cmd:cnn { environment_begin_ #1 :w } {#2} {
    \group_begin:
      \toks_set_eq:NN \l_xparse_environment_args_toks 
        \l_xparse_args_toks
      #3
  }
  \cs_set_nopar:cpx { environment_end_ #1 :w } {
      \exp_not:N \exp_last_unbraced:NV 
      \exp_not:c { environment_end_ #1 _aux:N }
      \exp_not:N \l_xparse_environment_args_toks
    \exp_not:N \group_end:
  } 
  \cs_set_nopar:cx { environment_end_ #1 _aux:N } {
    \exp_not:c { environment_end_ #1 _aux :w }
  }
  \cs_generate_from_arg_count:cNnn 
    { environment_end_ #1 _aux :w } \cs_set:Npn
    \l_xparse_total_args_int {#4}
%</initex|package>
%<*package>
  \cs_set_eq:cc {#1} { environment_begin_ #1 :w } 
  \cs_set_eq:cc { end #1 } { environment_end_ #1 :w }
%</package>
%<*initex|package>
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_flush_m_args:}
% As \texttt{m} arguments are simply counted, there is a need to add 
% them to the token register in a block. As this function can only
% be called if something other than \texttt{m} turns up, the flag can 
% be switched here.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_flush_m_args: {
  \cs_if_exist:cT { 
    xparse_grab_m_ \int_use:N \l_xparse_m_args_int :w 
  } {
    \toks_put_right:Nx \l_xparse_signature_toks {
       \exp_not:c { xparse_grab_m_ \int_use:N \l_xparse_m_args_int :w }
    }
  }
  \int_zero:N \l_xparse_m_args_int
  \bool_set_false:N \l_xparse_m_only_bool
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_grab_D:w}
%\begin{macro}{\xparse_grab_D_long:w}
%\begin{macro}[aux]{\xparse_grab_D_aux:NNnnN}
%\begin{macro}[aux]{\xparse_grab_D_aux:w}
% The generic delimited argument grabber.
%    \begin{macrocode}
\cs_new:Npn \xparse_grab_D:w #1#2#3#4 \l_xparse_args_toks {
  \xparse_grab_D_aux:NNnnN #1 #2 {#3} {#4} \cs_set_nopar:Npn
}
\cs_new:Npn \xparse_grab_D_long:w #1#2#3#4 \l_xparse_args_toks {
  \xparse_grab_D_aux:NNnnN #1 #2 {#3} {#4} \cs_set:Npn
}
\cs_set:Nn \xparse_grab_D_aux:NNnnN {
  #5 \xparse_grab_D_aux:w #1 ##1 #2 {
    \xparse_add_arg:n {##1}
    #4 \l_xparse_args_toks
  }
  \peek_charcode:NTF #1 { 
    \xparse_grab_D_aux:w 
  }{
    \xparse_add_arg:n {#3}
    #4 \l_xparse_args_toks
  }
}
\cs_new:Npn \xparse_grab_D_aux:w { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_grab_G:w}
%\begin{macro}{\xparse_grab_G_long:w}
%\begin{macro}[aux]{\xparse_grab_G_aux:nnN}
%\begin{macro}[aux]{\xparse_grab_G_aux:n}
% Optional groups are checed by meaning, so that the same code will 
% work with, for example, Con\TeX{}t-like input.
%    \begin{macrocode}
\cs_new:Npn \xparse_grab_G:w #1#2 \l_xparse_args_toks {
  \xparse_grab_G_aux:nnN {#1} {#2} \cs_set_nopar:Nn
}
\cs_new:Npn \xparse_grab_G_long:w #1#2 \l_xparse_args_toks {
  \xparse_grab_G_aux:nnN {#1} {#2} \cs_set:Nn
}
\cs_set:Nn \xparse_grab_G_aux:nnN {
  #3 \xparse_grab_G_aux:n {
    \xparse_add_arg:n {##1}
    #2 \l_xparse_args_toks
  }
  \peek_meaning:NTF \c_group_begin_token { 
    \xparse_grab_G_aux:n 
  }{
    \xparse_add_arg:n {#1}
    #2 \l_xparse_args_toks
  }
}
\cs_new:Npn \xparse_grab_G_aux:n { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_grab_l:w}
%\begin{macro}{\xparse_grab_l_long:w}
%\begin{macro}[aux]{\xparse_grab_l_aux:nN}
%\begin{macro}[aux]{\xparse_grab_l_aux:w}
% Argument grabbers for mandatory \TeX\ arguments are pretty simple.
%    \begin{macrocode}
\cs_new:Npn \xparse_grab_l:w #1 \l_xparse_args_toks {
  \xparse_grab_l_aux:nN {#1} \cs_set_nopar:Npn
}
\cs_new:Npn \xparse_grab_l_long:w #1 \l_xparse_args_toks { 
  \xparse_grab_l_aux:nN {#1} \cs_set:Npn
}
\cs_new:Nn \xparse_grab_l_aux:nN {
  #2 \xparse_grab_l_aux:w ##1## {
    \xparse_add_arg:n \l_xparse_args_toks {##1}
    #1 \l_xparse_args_toks
  }
  \xparse_grab_l_aux:w
}
\cs_new:Nn \xparse_grab_l_aux:w { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_grab_m:w}
%\begin{macro}{\xparse_grab_m_long:w}
%\begin{macro}[aux]{\xparse_grab_m_aux:n}
% Collecting a single mandatory argument is quite easy.
%    \begin{macrocode}
\cs_new:Npn \xparse_grab_m:w #1 \l_xparse_args_toks {
  \cs_set_nopar:Nn \xparse_grab_m_aux:n {
    \xparse_add_arg:n {##1}
    #1 \l_xparse_args_toks
  }
  \xparse_grab_m_aux:n
}
\cs_new:Npn \xparse_grab_m_long:w #1 \l_xparse_args_toks {
  \cs_set:Nn \xparse_grab_m_aux:n {
    \xparse_add_arg:n {##1}
    \showthe\l_xparse_args_toks
    #1 \l_xparse_args_toks
  }
  \xparse_grab_m_aux:n
}
\cs_new:Nn \xparse_grab_m_aux:n { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_grab_m_1:w}
%\begin{macro}[aux]{\xparse_grab_m_1_aux:n}
%\begin{macro}{\xparse_grab_m_2:w}
%\begin{macro}[aux]{\xparse_grab_m_2_aux:nn}
%\begin{macro}{\xparse_grab_m_3:w}
%\begin{macro}[aux]{\xparse_grab_m_3_aux:nnn}
%\begin{macro}{\xparse_grab_m_4:w}
%\begin{macro}[aux]{\xparse_grab_m_4_aux:nnnn}
%\begin{macro}{\xparse_grab_m_5:w}
%\begin{macro}[aux]{\xparse_grab_m_5_aux:nnnnn}
%\begin{macro}{\xparse_grab_m_6:w}
%\begin{macro}[aux]{\xparse_grab_m_6_aux:nnnnnn}
%\begin{macro}{\xparse_grab_m_7:w}
%\begin{macro}[aux]{\xparse_grab_m_7_aux:nnnnnnn}
%\begin{macro}{\xparse_grab_m_8:w}
%\begin{macro}[aux]{\xparse_grab_m_8_aux:nnnnnnnn}
% Grabbing 1--8 mandatory arguments. We don't need to worry about 
% nine arguments as this is only possible if everything is 
% mandatory. Each function has an auxiliary so that \cs{par} tokens
% from other arguments still work.
%    \begin{macrocode}
\cs_new:cpn { xparse_grab_m_1:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_1_aux:n } {
    \toks_put_right:Nn \l_xparse_args_toks { {##1} }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_1_aux:n }
}
\cs_new_nopar:cn { xparse_grab_m_1_aux:n } { }
\cs_new:cpn { xparse_grab_m_2:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_2_aux:nn } {
    \toks_put_right:Nn \l_xparse_args_toks { {##1} {##2} }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_2_aux:nn }
}
\cs_new_nopar:cn { xparse_grab_m_2_aux:nn } { }
\cs_new:cpn { xparse_grab_m_3:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_3_aux:nnn } {
    \toks_put_right:Nn \l_xparse_args_toks { {##1} {##2} {##3} }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_3_aux:nnn }
}
\cs_new_nopar:cn { xparse_grab_m_3_aux:nnn } { }
\cs_new:cpn { xparse_grab_m_4:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_4_aux:nnnn } {
    \toks_put_right:Nn \l_xparse_args_toks { {##1} {##2} {##3} {##4} }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_4_aux:nnnn }
}
\cs_new_nopar:cn { xparse_grab_m_4_aux:nnnn } { }
\cs_new:cpn { xparse_grab_m_5:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_5_aux:nnnnn } {
    \toks_put_right:Nn \l_xparse_args_toks { 
      {##1} {##2} {##3} {##4} {##5} 
    }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_5_aux:nnnnn }
}
\cs_new_nopar:cn { xparse_grab_m_5_aux:nnnnn } { }
\cs_new:cpn { xparse_grab_m_6:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_6_aux:nnnnnn } {
    \toks_put_right:Nn \l_xparse_args_toks { 
      {##1} {##2} {##3} {##4} {##5} {##6}
    }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_6_aux:nnnnnn }
}
\cs_new_nopar:cn { xparse_grab_m_6_aux:nnnnnn } { }
\cs_new:cpn { xparse_grab_m_7:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_7_aux:nnnnnnn } {
    \toks_put_right:Nn \l_xparse_args_toks { 
      {##1} {##2} {##3} {##4} {##5} {##6} {##7} 
    }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_7_aux:nnnnnnn }
}
\cs_new_nopar:cn { xparse_grab_m_7_aux:nnnnnnn } { }
\cs_new:cpn { xparse_grab_m_8:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_8_aux:nnnnnnnn } {
    \toks_put_right:Nn \l_xparse_args_toks { 
      {##1} {##2} {##3} {##4} {##5} {##6} {##7} {##8} 
    }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_8_aux:nnnnnnnn }
}
\cs_new_nopar:cn { xparse_grab_m_8_aux:nnnnnnnn } { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_grab_t:w}
%\begin{macro}{\xparse_grab_t_long:w}
%\begin{macro}[aux]{\xparse_grab_t_aux:NnN}
%\begin{macro}[aux]{\xparse_grab_t_aux:}
% Dealing with a token is quite easy. Check the match, remove the 
% token if needed and add a flag to the output.
%    \begin{macrocode}
\cs_new:Npn \xparse_grab_t:w #1#2 \l_xparse_args_toks {
  \xparse_grab_t_aux:NnN #1 {#2} \cs_set_nopar:Nn
}
\cs_new:Npn \xparse_grab_t_long:w #1#2 \l_xparse_args_toks {
  \xparse_grab_t_aux:NnN #1 {#2} \cs_set:Nn
}
\cs_new:Nn \xparse_grab_t_aux:NnN {
  #3 \xparse_grab_t_aux: {
    \peek_charcode_remove:NTF #1 { 
      \xparse_add_arg:n { \BooleanTrue }
      #2 \l_xparse_args_toks
    }{
      \xparse_add_arg:n { \BooleanFalse }
      #2 \l_xparse_args_toks
    }
  }
  \xparse_grab_t_aux:
}
\cs_new:Nn \xparse_grab_t_aux: { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_grab_u:w}
%\begin{macro}{\xparse_grab_u_long:w}
%\begin{macro}[aux]{\xparse_grab_u_aux:NnN}
%\begin{macro}[aux]{\xparse_grab_u_aux:w}
% Grabbing up to a list of tokens is quite easy: define the grabber,
% and then collect.
%    \begin{macrocode}
\cs_new:Npn \xparse_grab_u:w #1#2 \l_xparse_args_toks {
  \xparse_grab_u_aux:NnN {#1} {#2} \cs_set_nopar:Npn
}
\cs_new:Npn \xparse_grab_u_long:w #1#2 \l_xparse_args_toks {
  \xparse_grab_u_aux:NnN {#1} {#2} \cs_set:Npn
}
\cs_new:Nn \xparse_grab_u_aux:NnN {
  #3 \xparse_grab_u_aux:w ##1 #1 {
    \xparse_add_arg:n {##1}
    #2 \l_xparse_args_toks
  }
  \xparse_grab_u_aux:w
}
\cs_new:Nn \xparse_grab_u_aux:w { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[TF]{\xparse_if_no_value:n}
% Tests for \cs{NoValue}.
%    \begin{macrocode}
\prg_new_conditional:Nnn \xparse_if_no_value:n {TF,T,F} {
  \tl_if_eq:nnTF {#1} { \NoValue } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_prepare_signature:n}
% Creating the signature is a case of working through the input and
% turning into the output in \cs{l_xparse_signature_toks}. A track is
% also kept of the total number of arguments. This function sets 
% everything up then hands off to the parser.
%    \begin{macrocode}
\cs_new:Nn \xparse_prepare_signature:n  {
  \bool_set_true:N \l_xparse_m_only_bool
  \bool_set_false:N \l_xparse_long_bool
  \int_zero:N \l_xparse_m_args_int
  \int_zero:N \l_xparse_processor_int
  \toks_clear:N \l_xparse_signature_toks
  \int_zero:N \l_xparse_total_args_int
  \xparse_prepare_signature:N #1 \q_nil
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_prepare_signature:N}
%\begin{macro}[aux]{\xparse_prepare_signature_aux:N}
% The main signature-preparation loop is in two parts, to keep the code 
% a little clearer. Most of the checks here is pretty clear, with a key
% point to watch what is next on the stack so that the loop continues
% correctly. 
%    \begin{macrocode}
\cs_new:Nn \xparse_prepare_signature:N {
  \quark_if_nil:NTF #1 {
    \bool_if:NF \l_xparse_m_only_bool {
      \xparse_flush_m_args:
    }
  }{
    \prop_if_in:NnTF \c_xparse_shorthands_prop {#1} {
      \prop_get:NnN \c_xparse_shorthands_prop {#1} \l_xparse_tmp_tl
      \exp_last_unbraced:NV \xparse_prepare_signature_aux:N 
        \l_xparse_tmp_tl
    }{
      \xparse_prepare_signature_aux:N #1
    }
  }
}
\cs_new_nopar:Nn \xparse_prepare_signature_aux:N {
  \int_incr:N \l_xparse_total_args_int
  \xparse_check_and_add:N #1
  \xparse_prepare_next:w
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_prepare_next:w}
% Initially, the next action to take is to find the next symbol. 
% However, that might not always be the case, and in some cases more 
% than one token is absorbed (hence \texttt{:w}).
%    \begin{macrocode}
\cs_new_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_process_arg:n}
% Processors are saved for use later during the grabbbing process.
%    \begin{macrocode}
\cs_new:Nn \xparse_process_arg:n {
  \int_incr:N \l_xparse_processor_int
  \cs_set:cn { xparse_processor_ \int_use:N \l_xparse_processor_int :n }
    { #1 {##1} }
}
%    \end{macrocode}
%\end{macro}
%
%\subsection{Argument processors}
%
%\begin{macro}{\xparse_arg_to_str:n}
% A basic argument processor: as much an example as anything else.
%    \begin{macrocode}
\cs_new:Nn \xparse_arg_to_str:n {
  \toks_set:Nx \l_xparse_arg_toks {
    \tl_to_str:n {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_arg_split_on_comma:n}
%\begin{macro}[aux]{\xparse_arg_split_on_comma_aux:w}
% Turns a co-ordinate pair into two separate values.
%    \begin{macrocode}
\cs_new:Nn \xparse_arg_split_on_comma:n {
  \tl_if_in:nnTF {#1} { , } {
    \xparse_arg_split_on_comma_aux:w #1 \q_stop
  }{
    \toks_set:Nn \l_xparse_arg_toks { {#1} { } }
  }
}
\cs_new:Npn \xparse_arg_split_on_comma_aux:w #1 , #2 \q_stop {
  \toks_set:Nn \l_xparse_arg_toks { {#1} {#2} }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%    
%\subsection{Messages}
%    
% Some error messages.   
%    \begin{macrocode}
\msg_new:nnn { xparse } { command-already-defined } {%
  Command name `\token_to_str:N #1' already defined!%
}
\msg_new:nnnn { xparse } { command-not-yet-defined } {%
  Command `\token_to_str:N #1' not yet defined!%
}{%
  You have used \token_to_str:N \RenewDocumentCommand, or similar\\%
  with a command that was never defined.\\%
  Perhaps you meant \token_to_str:N \NewDocumentCommand.%
}
\msg_new:nnn { xparse } { environment-already-defined } {%
  Environment `#1' already defined!%
}
\msg_new:nnn { xparse } { environment-not-yet-defined } {%
  Environment `#1' not yet defined!%
}
\msg_new:nnn { xparse } { unknown-argument-type } {%
  Unknown argument type `#1' replaced by `m'. Fingers crossed ...%
}
%    \end{macrocode}
%    
%\subsection{User functions}
%
% The user functions are more or less just the internal functions 
% renamed. 
% 
%\begin{macro}{\BooleanFalse}
%\begin{macro}{\BooleanTrue}
% Design-space names for the Boolean values.
%    \begin{macrocode}
\cs_new_eq:NN \BooleanFalse \c_false_bool
\cs_new_eq:NN \BooleanTrue  \c_true_bool
%    \end{macrocode}
%\end{macro}
%\end{macro}
% 
%\begin{macro}{\DeclareDocumentCommand}
%\begin{macro}{\NewDocumentCommand}
%\begin{macro}{\RenewDocumentCommand}
%\begin{macro}{\ProvideDocumentCommand}
% The user macros are pretty simple wrappers around the internal ones.
%    \begin{macrocode}
\cs_new_protected:Npn \DeclareDocumentCommand {
  \xparse_declare_cmd:Nnn 
}
\cs_new_protected:Npn \NewDocumentCommand #1 {
  \cs_if_exist:NTF #1 { 
    \msg_error:nnx { xparse } { command-already-defined } {#1}
    \use_none:nn
  }{
    \xparse_declare_cmd:Nnn #1
  }
}
\cs_new_protected:Npn \RenewDocumentCommand #1 {
  \cs_if_exist:NTF #1 {
    \xparse_declare_cmd:Nnn #1
  }{  
    \msg_error:nnx { xparse } { command-not-yet-defined } {#1}
    \use_none:nn
  }
}
\cs_new_protected:Npn \ProvideDocumentCommand #1 {
  \cs_if_exist:NTF #1 { 
    \use_none:nn
  }{
    \xparse_declare_cmd:Nnn #1
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\DeclareDocumentEnvironment}
%\begin{macro}{\NewDocumentEnvironment}
%\begin{macro}{\RenewDocumentEnvironment}
%\begin{macro}{\ProvideDocumentEnvironment}
% Very similar for environments.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \DeclareDocumentEnvironment {
  \xparse_declare_env:nnnn
}
\cs_new_protected_nopar:Npn \NewDocumentEnvironment #1 {
  \cs_if_exist:cTF { environment_begin_ #1 :w } { 
    \msg_error:nnx { xparse } { environment-already-defined } {#1}
    \use_none:nnn
  }{
    \xparse_declare_env:nnnn {#1}
  }
}
\cs_new_protected_nopar:Npn \RenewDocumentEnvironment #1 {
  \cs_if_exist:cTF { environment_begin_ #1 :w } {
    \xparse_declare_env:nnnn {#1}
  }{  
    \msg_error:nnx { xparse } { environment-not-yet-defined } {#1}
    \use_none:nnn
  }
}
\cs_new_protected_nopar:Npn \ProvideDocumentEnvironment #1 {
  \cs_if_exist:cTF { environment_begin_ #1 :w } { 
    \use_none:nnn
  }{
    \xparse_declare_env:nnnn {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\DeclareExpandableDocumentCommand}
%\begin{macro}{\NewExpandableDocumentCommand}
%\begin{macro}{\RenewExpandableDocumentCommand}
%\begin{macro}{\ProvideExpandableDocumentCommand}
% The expanable versions of the basic functions are essentially the same.
%    \begin{macrocode}
\cs_new_protected:Npn \DeclareExpandableDocumentCommand {
  \xparse_declare_cmd_exp:Nnn 
}
\cs_new_protected:Npn \NewExpandableDocumentCommand #1 {
  \cs_if_exist:NTF #1 { 
    \msg_error:nnx { xparse } { command-already-defined } {#1}
    \use_none:nn
  }{
    \xparse_declare_cmd_exp:Nnn #1
  }
}
\cs_new_protected:Npn \RenewExpandableDocumentCommand #1 {
  \cs_if_exist:NTF #1 {
    \xparse_declare_cmd_exp:Nnn #1
  }{  
    \msg_error:nnx { xparse } { command-not-yet-defined } {#1}
    \use_none:nn
  }
}
\cs_new_protected:Npn \ProvideExpandableDocumentCommand #1 {
  \cs_if_exist:NTF #1 { 
    \use_none:nn
  }{
    \xparse_declare_cmd_exp:Nnn #1
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[TF]{\IfBoolean}
% The logical \meta{true} and \meta{false} statements are just the 
% normal \cs{c_true_bool} and \cs{c_false_bool}, so testing for them is
% done with the \cs{bool_if:NTF} functions from \textsf{l3prg}.
%    \begin{macrocode}
\cs_new_eq:NN \IfBooleanTF \bool_if:NTF
\cs_new_eq:NN \IfBooleanT  \bool_if:NT
\cs_new_eq:NN \IfBooleanF  \bool_if:NF
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[TF]{\IfNoValue}
% Simple re-naming. 
%    \begin{macrocode}
\cs_new_eq:NN \IfNoValueF  \xparse_if_no_value:nF 
\cs_new_eq:NN \IfNoValueT  \xparse_if_no_value:nT 
\cs_new_eq:NN \IfNoValueTF \xparse_if_no_value:nTF 
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\NoValue}
% The marker for no value being give: this can be typeset safely.
% This is coded by hand as making it \cs{protected} ensures that it
% will not turn into anything else by accident.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \NoValue { -NoValue- }
%    \end{macrocode}
%\end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
% 
% \PrintIndex
