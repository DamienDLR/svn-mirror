% \iffalse
%%
%% (C) Copyright 1999 Frank Mittelbach, Chris Rowley, David Carlisle
%% All rights reserved.
%%
%% Not for distribution
%% 
%<*dtx>
          \ProvidesFile{xparse.dtx}
%</dtx>
%<package>\NeedsTeXFormat{LaTeX2e}
%<package>\ProvidesPackage{xparse}
%<driver>\ProvidesFile{xparse.drv}
% \fi
%         \ProvidesFile{xparse.dtx}
          [1999/01/16 v0.03 generic document command parser]
%
% \iffalse
%<*driver>
 \documentclass{ltxdoc}
 \usepackage{textcomp}
 \begin{document}
 \DocInput{xparse.dtx}
 \end{document}
%</driver>
% \fi
%
% \GetFileInfo{xparse.dtx}
%
% \title{The \textsf{xparse} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi, CAR, DPC}
% \date{\filedate}
%  \maketitle
% 
% \section{Interface}
%
% This package implements high-level interface commands for class file
% writers which allows the separation of formatting commands
% (typically instances of so-called `templates') and their arguments
% from the signature of document-level commands.
%
% This works by declaration commands that provide a general
% specification method for the typical \LaTeX{} syntax, e.g.,
% star-form, optional arguments, and mandatory arguments. A command
% (or environment) declared in this way parses the input according to
% its spec and presents its findings in a normalized way for further
% processing.
%
% \subsection{Argument spec}
%
% An argument specification is a list of letters each representing a
% type of argument, i.e., |m| is a mandatory argument (surrounded by
% braces), |o| an optional argument (surrounded by backets if
% present), and |s| represents a star (which might be present or
% not).\footnote{Other argument types such as \texttt{c} for picture
% coordinates could be integrated in principle.} Thus the argument
% spec for headings as implemented by |\@startsection| in standard
% \LaTeX{} would be represented by the three letters |som|.
%
% \subsection{Parsing results}
%
% To normalise the result of parsing the input according to an
% argument specification it is important to uniquely identify all
% arguments found. For this reason each parsing operation initiated by
% one of the argument spec letters will result in an identifiable
% output as follows:
% \begin{description}
% \item[m] will return the parsed argument surrounded by a brace pair,
%   i.e., will normally be the identity;
% \item[o] will return the parsed argument surrounded by a brace pair
%   if present. Otherwise it will return the token |\NoString|;
% \item[s] will return either the token |\BooleanTrue| or
%   |\BooleanFalse| depending on whether or not a star was parsed.
% \end{description}
% For example, given the spec |soomo| the input |*[Foo]{Bar}| would be
% parsed as |\BooleanTrue{Foo}\NoString{Bar}\NoString|. In other words
% there will be always exactly the same number of brace groups or
% tokens as the number of letters in the argument spec.
%
% \subsection{Applying the parsing results}
% 
% Since the result of the parsing is a welldefined number of tokens or
% brace groups it is easy to pass them on in any order to any
% processing function. To this end the tokens or brace groups are
% associated with the standard argument specifiers in \TeX{} macros,
% i.e., |#1|, |#2|, and so forth. This limits the argument
% specification to a maximum number of 9 letters, but for practical
% applications this should be sufficient.
%
% \subsection{The class designer interface}
%
% This package provides two commands for declaring commands
% and environments to be used within the document body.
%
% \DescribeMacro\DeclareDocumentCommand
% The |\DeclareDocumentCommand| declaration takes three arguments. The
% first argument is the name of the command to be declared, the second
% is the argument specification in the syntax described above, and the
% third is the action to be carried out once the arguments are
% parsed. Within the third argument |#1|, |#2|, etc.\ denote the
% result of the parsing, e.g.,
%\begin{verbatim}
%  \DeclareDocumentCommand{\chapter}{som}
%    { \IfBooleanTF {#1}
%        { \typesetstarchapter   {#3} }
%        { \typesetnormalchapter {#2}{#3} }
%    }
%\end{verbatim}
% would be a way to define a |\chapter| command which would
% essentially behave like the current \LaTeX{} command (except that it
% would accept an optional argument even when a |*| was parsed). The
% |\typesetnormalchapter| could test its first argument for being
% |\NoString| to see if an optional argument was present.
%
% Of course something like the |\IfBooleanTF| test could also be
% placed inside a function that would process all three arguments, thus
% using the templates and their instances as provided by the
% \texttt{template} package such a declaration would probably look
% more like the following example:
%\begin{verbatim}
%  \DeclareDocumentCommand{\chapter}{som}
%    { \UseInstance {head} {A-head-main} {#1} {#2} {#3} }
%\end{verbatim}
%
% Using the |\DeclareDocumentCommand| interface it is easy to modify
% the document-level syntax while still applying the same
% layout-generating functions, e.g., a class that would not support
% optional arguments or star forms for the heading commands could
% define |\chapter| like this:
%\begin{verbatim}
%  \DeclareDocumentCommand{\chapter}{m}
%    { \UseInstance {head} {A-head-main} \BooleanFalse \NoString {#1} }
%\end{verbatim}
% while a class that would allow for an additional optional argument
% (for whatever reason) could define it like that:
%\begin{verbatim}
%  \DeclareDocumentCommand{\chapter}{somo}
%    { \doSomethingWithTheExtraOptionalArg {#4}
%      \UseInstance {head} {A-head-main} {#1} {#2} {#3} }
%\end{verbatim}
%
% Commands declared in this way are automatically robust (in David's
% implementation).
%
% \DescribeMacro\DeclareDocumentEnvironment
% The |\DeclareDocumentEnvironment| declaration is similar to
% |\DeclareDocumentCommand| execpt that it takes four arguments: the
% first being the environment name (without a backslash), the second
% again the argument-spec, and the third and forth are the actions
% taken at start end end of the environment. The parsed arguments are
% available to both the start and the finish as |#1|, |#2|, etc.
%
% \subsubsection{A boolean data type}
%
% \DescribeMacro\BooleanTrue
% \DescribeMacro\BooleanFalse
% The parsing result for a star is presented as the token
% |\BooleanTrue| or |\BooleanFalse| respectively. 
%
% \DescribeMacro\IfBooleanTF
% \DescribeMacro\IfBooleanT
% \DescribeMacro\IfBooleanF
% To test for these values the macro |\IfBooleanTF| can be used. It
% expects as its first argument either |\BooleanTrue| or
% |\BooleanFalse| and executes its second or third argument depending
% on this value. |\IfBooleanT| and |\IfBooleanF| are obvious
% shortcuts. 
%
% It is worth thinking about whether or not this type is needed at all
% or if it would be enough to only use |\IfSomethingTF|!
%
% \subsubsection{Comparing tokens in a quarky way}
%
% Something like |\NoString| would perhaps be best implemented as a
% ltx3 quark, i.e. a token which expands to itself as this is
% can be easily tested even if hidden inside a macro. The unfortunate
% sideeffect however is that it will result in a tight loop if it ever
% gets executed by mistake.
%
% \DescribeMacro\NoString
% For this reason |\NoString| is defined to expand to the string
% |-NoString-| which would get typeset if ever executed thus clearly
% indicating the type of error the writer made.
%
% However this makes testing for this token slightly complicated as in
% that case the test
%\begin{verbatim}
%   \def\seen{#1}
%   \def\containsNoString{\NoString}
%   \ifx\seen\containsNoString
%\end{verbatim}
% will be true if |#1| was |\NoString| but false if if |#1| itself
% contains a macro which contains |\NoString|; a case that happens
% unfortunately very often in pratice.  Using unguarded |\edef| to
% define |\seen| is out of question as |#1| typically is either
% |\NoString| or arbitrary user input (which is likely to die horribly
% even in a |\protected@edef|.
%
% \DescribeMacro\IfSomethingTF 
% \DescribeMacro\IfSomethingT 
% \DescribeMacro\IfSomethingF
% Therefore the |\IfSomethingTF| test uses a slower recursive
% procedure: it tests if |#1| and |#2| are equal. If they are testing
% stops and the true-case (argument |#3|) will be executed. If not, it
% expands the first token of |#2| and checks if the resulting
% token-list is identical to |#2| (this would happen if this first
% token is unexpandable or |#2| is empty). In the latter case testing
% terminates and the false-case (argument |#4|) will be
% executed. However if the token-list created this way differs from
% |#2| the macro recurses using this token-list in place of |#2|.
%
% \DescribeMacro\IfNoStringTF 
% \DescribeMacro\IfNoStringT
% \DescribeMacro\IfNoStringF
% \DescribeMacro\IfStringTF 
% \DescribeMacro\IfStringT 
% \DescribeMacro\IfStringF 
% The test |\IfNoStringTF| is imlpemented as an application of
% |\IfSomethingTF|, i.e.,
%\begin{verbatim}
%   \def\IfNoStringTF{\IfSomethingTF\NoString}
%\end{verbatim}
% where the three arguments (test token, true and false case) are
% picked up by |\IfSomethingTF|. Similar tests for other quark-like
% tokens could be defined similarly. |\IfStringTF| is the same test
% with the true/false case exchanged.
%
% \StopEventually{}
% \CheckSum{0}
%
% \section{Implementation}
%
% Set up certain defaults including to ignore white space
% within the body of this package.
%    \begin{macrocode}
%<*package>
\RequirePackage{ldcsetup}
\IgnoreWhiteSpace
%    \end{macrocode}
%
%
% \subsection{The Mittelbach/Rowley prove-of-concept
%             implementation for the parsing}
%
% \begin{macro}{\DeclareDocumentCommand}
%    \begin{macrocode}
%<*obsolete>
\def\DeclareDocumentCommand #1 #2  {
%  \parse@countargs {#2} % sets \@tempc    % Not implemented yet
  \def\parse@csname{#1}
  \def\parse@spec{#2}
  \afterassignment \declare@dt@
  \toks@
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\declare@dt@}
%    \begin{macrocode}
\def \declare@dt@ {
  \expandafter \edef \parse@csname
    { \noexpand \parse@something
        { \parse@spec }
        { \the\toks@ }
        % { \@tempc }
    }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareDocumentEnvironment}
%    \begin{macrocode}
\def\DeclareDocumentEnvironment #1 #2  {
%  \parse@countargs {#2} % sets \@tempc    % Not implemented yet
  \def\parse@csname{#1}
  \def\parse@spec{#2}
  \afterassignment \declare@de@
  \toks@
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\declare@de@}
%    \begin{macrocode}
\def \declare@de@ {
  \expandafter \edef \csname \parse@csname \endcsname
    { \begingroup
      \noexpand \parse@something
        { \parse@spec } 
        { \the\toks@ }
        % { \@tempc }
    }
  \afterassignment \declare@dee@
  \toks@
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\declare@dee@}
%    \begin{macrocode}
\def \declare@dee@ {
  \expandafter \edef \csname end\parse@csname \endcsname
    { \noexpand \parse@apply
        { \the\toks@ }
        \noexpand \parse@results
      \endgroup
    }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\parse@apply}
%    \begin{macrocode}
\def\parse@apply #1 {
      \renewcommand \parse@tempa [\the\parse@cnt] {#1}
      \expandafter \parse@tempa %    #2 implicit
}
\let\parse@tempa\@empty % or \renew... might bulk the first time
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\parse@something}
%    \begin{macrocode}
%% CCC here and elsewhere there are some suggestions for
%      not counting args at run-time
\def \parse@something #1 #2 {  % #3
  \parse@body {#2}
  % \parse@cnt #3
  \parse@cnt \m@ne  % REMOVE
  \parse@args #1x \parse@args {}
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcount\parse@cnt
\newtoks\parse@body
%    \end{macrocode}
%
%    \begin{macrocode}
\def\parse@args #1 #2\parse@args #3 {
  \advance \parse@cnt \@ne % REMOVE
  \csname parse@#1 \endcsname {#2}{#3}
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \parse@s #1 #2 {
  \@ifstar
      { \parse@args #1 \parse@args { #2 \BooleanTrue } }
      { \parse@args #1 \parse@args { #2 \BooleanFalse } }
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \parse@m #1 #2 #3 {
      \parse@args #1 \parse@args { #2 {#3} }
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \parse@x #1 #2 { 
      \def \parse@results {#2}   % for environment
%      \def \parse@tempa {
%        \renewcommand \parse@tempb [\the\parse@cnt] 
%      } 
%      \expandafter \parse@tempa \expandafter { \the \parse@body } 
%      \parse@tempb #2
      \expandafter \parse@apply \expandafter { \the \parse@body } 
                            \parse@results % \parse@apply expands this!
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \parse@o #1 #2 {
  \@ifnextchar [
      { \parse@o@ {#1}{#2} }
      { \parse@args #1 \parse@args { #2 \NoString } }
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \parse@o@ #1 #2 [#3] {
      \parse@args #1 \parse@args { #2 {#3} }
}
%</obsolete>
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{The Carlisle implementation for the parsing}
%
% Not implemented in this version is |\DeclareDocumentEnvironment|
% (excerise for the reader).
%
%    \begin{macrocode}
% seemed to need this.
\newtoks\@temptokenb
%
% #1 csname
% #2 soom argument spec
% #3 code
% in #2 currently supported types are
%     s star
%     o [optional]
%     m {mandatory}
% #3 is just grabbed so as to not get a space in the argument spec
%    for def.
%
\def\DeclareDocumentCommand #1 #2 #3{
%
% needed to count no of arguments
   \@tempcnta\z@
%
% builds up list of argument parsers \@ddc@s\@ddc@m etc
   \toks@{}
%
% builds up #1#2#3#4 argument spec
   \@temptokena\toks@
%
% builds up list of m-argument parsers \@ddc@m\@ddc@m 
% occurred since start or since argument of another type.
   \@temptokenb\toks@
%
% Start parsing argument spec
   \@ddc#2X
%
% Define top level command, this just has the wrapper command
% \@ddc@ then the argument grabbers from \toks@ then the original
% command name (in case we need to \protect) then the internal
% command with the code.
% The \long below could be \relax if wanted to have a star-non-long
% form of this, cf newcommand*. The argument preamble for
% \def comes from \@temptokena.
   \edef#1{
    \noexpand\@ddc@
    {\the\toks@}
    \expandafter\noexpand\csname\string#1\endcsname
    \noexpand#1
    }
   \long\expandafter\def\csname\string#1\expandafter\endcsname
          \the\@temptokena{#3}}

%
% #1 set of argument grabbers
% #2 internal command
% #3 top level command for \protecting
\def\@ddc@#1#2#3{
  \ifx\protect\@typeset@protect
    \expandafter\@firstofone
  \else
    \protect#3\expandafter\@gobble
  \fi
% The command+arguments so far are kept in a brace group until
% the last moment for ease of processing. So need to \@firstofone
% that away.
  {#1\@firstofone#2}}


% #1 one of s o m.
\def\@ddc#1{
  \ifx #1X
% fini
  \else
  \ifx #1m
% If doing an m, just stick another \@ddc@m in a temporary list.
  \@temptokenb\expandafter{%
     \the\@temptokenb
     \@ddc@m}
  \else
% Otherwise for o and s
% in \toks@ first add any `m' argument parsers saved up
% then add \@ddc@o or \@ddc@s.
  \toks@\expandafter{%
     \the\expandafter\toks@
     \the\expandafter\@temptokenb
     \csname @ddc@#1\endcsname}
% clear list of m's
   \@temptokenb{}
  \fi
% add one to arg count.
  \advance\@tempcnta\@ne
% Internally all arguments are non delimited args, so add
% #<n> to the list in \@temptokena
  \@temptokena\expandafter{
     \the\expandafter\@temptokena\expandafter##\the\@tempcnta}
%
% loop
  \expandafter
  \@ddc
%
  \fi}

%
% #1 any remaining argument grabbers
% #2 internal csname + arguments already collected
\long\def\@ddc@s#1\@firstofone#2{
% put back the rest of the argument grabbers, but add new
% (boolean) argument to list of arguments inside the group.
  \@ifstar
    { #1\@firstofone{#2 \BooleanTrue}}
    { #1\@firstofone{#2 \BooleanFalse}}}

%
% #1 any remaining argument grabbers
% #2 internal csname + arguments already collected
\long\def\@ddc@m#1\@firstofone#2#3{
% put back the rest of the argument grabbers, but copy
%  argument to list of arguments inside the group.
% Any `m' at the end will be discarded and the internal
% command will pick up its own arguments.
   #1\@firstofone{#2{#3}}}

% #1 any remaining argument grabbers
% #2 internal csname + arguments already collected
\long\def\@ddc@o#1\@firstofone#2{
% put back the rest of the argument grabbers, but copy
% argument (now with {} or \NoString to list of arguments
%  inside the group.
   \@ifnextchar[
     {\@ddc@o@{#1}{#2}}
     {#1\@firstofone{#2\NoString}}}
%
% helper to remove []
\long\def\@ddc@o@#1#2[#3]{
  #1\@firstofone{#2{#3}}}
%    \end{macrocode}
%
%
%
% \subsection{A Boolean datatype}
%
% \begin{macro}{\BooleanFalse}
% \begin{macro}{\BooleanTrue}
%    \begin{macrocode}
\def\BooleanFalse{TF}
\def\BooleanTrue{TT}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\IfBooleanTF}
% \begin{macro}{\IfBooleanT}
% \begin{macro}{\IfBooleanF}
%    \begin{macrocode}
\def\IfBooleanTF #1 {
   \if#1
       \expandafter\@firstoftwo
   \else
       \expandafter\@secondoftwo
   \fi
}
\def\IfBooleanT #1 #2 { 
   \IfBooleanTF {#1} {#2} \@empty
}
\def\IfBooleanF #1 { 
   \IfBooleanTF {#1} \@empty
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \subsection{A Quark-like datatype}
%
%
% \begin{macro}{\IfSomethingTF}
% \begin{macro}{\IfSomethingT}
% \begin{macro}{\IfSomethingF}
% Setting up the stage \ldots
%    \begin{macrocode}
\def\IfSomethingTF#1{\def\something@in{#1} \If@SomethingTF}
\def\IfSomethingT#1#2#3{\def\something@in{#1} \If@SomethingTF{#2}{#3}\@empty}
\def\IfSomethingF#1#2#3{\def\something@in{#1} \If@SomethingTF{#2}\@empty{#3}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\If@SomethingTF}
% \ldots and then for the recursive part:
%    \begin{macrocode}
\def\If@SomethingTF#1{
   \def\something@tmp{#1}
   \ifx\something@tmp\something@in
%fini true
     \expandafter\@secondofthree
   \else
       \expandafter\def\expandafter\something@tmpb\expandafter{#1}
       \ifx\something@tmp\something@tmpb
%fini false
         \expandafter\expandafter\expandafter\@thirdofthree
       \else
%try again expanded
         \expandafter\expandafter\expandafter\@firstofone
       \fi
   \fi
   {\expandafter\If@SomethingTF\expandafter{#1}}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@secondofthree}
% \begin{macro}{\@thirdofthree}
% Some helpers missing in \LaTeX{}:
%    \begin{macrocode}
\def\@secondofthree#1#2#3{#2}
\def\@thirdofthree #1#2#3{#3}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsection{Testing for \texttt{\textbackslash NoString}}
%
%
% \begin{macro}{\NoString}
%    \begin{macrocode}
\def\NoString{-NoString-}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\IfNoStringTF}
% \begin{macro}{\IfNoStringT}
% \begin{macro}{\IfNoStringF}
%    \begin{macrocode}
\def\IfNoStringTF{\IfSomethingTF\NoString}
\def\IfNoStringT {\IfSomethingT \NoString}
\def\IfNoStringF {\IfSomethingF \NoString}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\IfStringTF}
% \begin{macro}{\IfStringT}
% \begin{macro}{\IfStringF}
%    \begin{macrocode}
\def\IfStringTF #1 #2 #3 { \IfNoStringTF {#1} {#3} {#2} }
\let \IfStringT \IfNoStringF
\let \IfStringF \IfNoStringT
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
%
% \Finale
%
\endinput
