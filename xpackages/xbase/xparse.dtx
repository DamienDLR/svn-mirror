% \iffalse
%% File: xparse.dtx (C) Copyright 1999 Frank Mittelbach, Chris Rowley, David Carlisle
%%                  (C) Copyright 2004 Frank Mittelbach, LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3a of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xbase bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{%
  \def\fileversion{#3}%
  \def\filedate{#4}%
%<package> \ProvidesPackage{#2}[#4 #3 #5 #6]%
}
\next$Id$
          {generic document command parser}
% \fi
%
%
% \iffalse
%<*driver>
  \documentclass{ltxdoc}
  \usepackage{textcomp}
  \makeatletter
  \providecommand*\eTeX{%
    \if b\expandafter\@car\f@series\@nil\boldmath\fi
    $\m@th\varepsilon$-\TeX}
  \makeatother
% \usepackage{ldcdoc}
  \begin{document}
  \catcode`\_=11
  \catcode`\:=11
  \DocInput{xparse.dtx}
  \end{document}
%</driver>
% \fi
%
% \CheckSum{558}
%
%
% \title{The \textsf{xparse} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi, CAR, DPC, MH}
% \date{\copyright~\filedate}
%  \maketitle
%
% \begin{abstract}
% The interfaces described in this document are not meant to be final
% but only as a basis for discussion. Building productive applications
% using the current code is discouraged.
% \end{abstract}
%
% \section{Interface}
%
% This package implements high-level interface commands for class file
% writers which allows the separation of formatting commands
% (typically instances of so-called `templates') and their arguments
% from the signature of document-level commands.
%
% This works by declaration commands that provide a general
% specification method for the typical \LaTeX{} syntax, e.g.,
% star-form, optional arguments, and mandatory arguments. A command
% (or environment) declared in this way parses the input according to
% its spec and presents its findings in a normalized way for further
% processing.
%
% \subsection{Argument spec}
%
%
%  An argument specification is a list of letters each representing a
%  type of argument, i.e., |m| is a mandatory argument (surrounded by
%  braces), |o| an optional argument (surrounded by brackets if
%  present), and |s| represents a star (which might be present or not).
%  Thus the argument spec for headings as implemented by
%  |\@startsection| in standard \LaTeX{} would be represented by the
%  three letters |som|. Other argument types are available and can be
%  added at will. For a complete list of built-in argument types see
%  the next section.
%
%  There is one important argument specifier worth taking note of. The
%  |P| does not behave as a normal argument specifier but allows the
%  next argument to take an argument containing the |\par| token which
%  is not allowed by default.
%
%
%  \subsection{Parsing results}
%
%  To normalise the result of parsing the input according to an
%  argument specification it is important to uniquely identify all
%  arguments found. For this reason each parsing operation initiated by
%  one of the argument spec letters will result in an identifiable
%  output as follows:
%  \begin{description}
%    \item[m]
%    will return the parsed argument surrounded by a brace pair,
%    i.e., will normally be the identity;
%    \item[o]
%    will return the parsed argument surrounded by a brace pair
%    if present. Otherwise it will return the token |\NoValue|;
%    \item[O\textbraceleft default\textbraceright]
%    will return the parsed argument surrounded by a brace pair if
%    present. Otherwise it will return the |{default}| as specified
%    above.
%    \item[s]
%    will return either the token |\BooleanTrue| or |\BooleanFalse|
%    depending on whether or not a star was parsed.
%    \item[S\textbraceleft \meta{symbol}\textbraceright]
%    will return either the token |\BooleanTrue| or |\BooleanFalse|
%    depending on whether or not the next token is \meta{symbol}.
%    \item[c] will parse the syntax |(|\meta{x}|,|\meta{y}|)|, i.e., a
%    coordinate pair and will return |{{|\meta{x}|}{|\meta{y}|}}| as
%    the result. If no open parentheses is scanned an error is
%    signalled.
%    \item[C\textbraceleft\textbraceleft x-default\textbraceright
%    \textbraceleft y-default\textbraceright\textbraceright]
%    behaves like |c|, i.e., parses a coordinate pair if present. If
%    the coordinate pair is missing it returns the default values
%    instead.
%  \end{description}
%  For example, given the spec |soomO{default}| the input |*[Foo]{Bar}|
%  would be parsed as |\BooleanTrue{Foo}\NoValue{Bar}{default}|. In
%  other words there will be always exactly the same number of brace
%  groups or tokens as the number of letters in the argument spec.
%
%  There are a few exceptions to this rule as the r\^ole of following
%  letters is to affect how the next argument is read.
%  \begin{description}
%    \item[P] will cause the next argument to allow |\par| in it's
%    argument. Thus the specification |mPmm| will cause the command to
%    read three mandatory arguments but only the second can contain the
%    |\par| token.
%    \item[W] will cause the next argument to \emph{not} ignore a space
%    when trying to scan ahead for a special symbol such as a |*| or an
%    optional argument. This is mostly useful when the last argument(s)
%    of a document command are optional (see example later on).
%  \end{description}
%
%
%
%
%  \subsection{Applying the parsing results}
%
%  Since the result of the parsing is a well defined number of tokens or
%  brace groups it is easy to pass them on in any order to any
%  processing function. To this end the tokens or brace groups are
%  associated with the standard argument specifiers in \TeX{} macros,
%  i.e., |#1|, |#2|, and so forth. This limits the argument
%  specification to a maximum number of 9 letters, but for practical
%  applications this should be sufficient.
%
%  \subsection{The class designer interface}
%
%  This package provides commands for declaring commands
%  and environments to be used within the document body.
%
%  \DescribeMacro\DeclareDocumentCommand
%  The |\DeclareDocumentCommand| declaration takes three arguments. The
%  first argument is the name of the command to be declared, the second
%  is the argument specification in the syntax described above, and the
%  third is the action to be carried out once the arguments are
%  parsed. Within the third argument |#1|, |#2|, etc.\ denote the
%  result of the parsing, e.g.,
%  \begin{verbatim}
%  \DeclareDocumentCommand{\chapter}{som}
%    { \IfBooleanTF {#1}
%        { \typesetnormalchapter {#2}{#3} }
%        { \typesetstarchapter   {#3} }
%    }
%  \end{verbatim}
%  would be a way to define a |\chapter| command which would
%  essentially behave like the current \LaTeX{} command (except that it
%  would accept an optional argument even when a |*| was parsed). The
%  |\typesetnormalchapter| could test its first argument for being
%  |\NoValue| to see if an optional argument was present.
%
%  Of course something like the |\IfNoValueTF| test could also be
%  placed inside a function that would process all three arguments, thus
%  using the templates and their instances as provided by the
%  \texttt{template} package such a declaration would probably look
%  more like the following example:
%  \begin{verbatim}
%  \DeclareDocumentCommand{\chapter}{som}
%    { \UseInstance {head} {A-head-main} {#1} {#2} {#3} }
%  \end{verbatim}
%
%  Using the |\DeclareDocumentCommand| interface it is easy to modify
%  the document-level syntax while still applying the same
%  layout-generating functions, e.g., a class that would not support
%  optional arguments or star forms for the heading commands could
%  define |\chapter| like this:
%  \begin{verbatim}
%   \DeclareDocumentCommand{\chapter}{m}
%     { \UseInstance {head} {A-head-main} \BooleanFalse \NoValue {#1} }
%  \end{verbatim}
%  while a class that would allow for an additional optional argument
%  (for whatever reason) could define it like that:
%  \begin{verbatim}
%   \DeclareDocumentCommand{\chapter}{somo}
%     { \doSomethingWithTheExtraOptionalArg {#4}
%       \UseInstance {head} {A-head-main} {#1} {#2} {#3} }
%  \end{verbatim}
%  \DescribeMacro\ReDeclareDocumentCommand
%  \DescribeMacro\ProvideDocumentCommand
%  The commands |\ReDeclareDocumentCommand| and
%  |\ProvideDocumentCommand| work just like |\DeclareDocumentCommand|
%  with the exception that |\Re..| can only redefine an existing
%  command and |\Provide...| will only define the command if it is
%  already free.
%
%
%  \DescribeMacro\DeclareDocumentEnvironment
%  \DescribeMacro\ReDeclareDocumentEnvironment
%  \DescribeMacro\ProvideDocumentEnvironment
%  The |\DeclareDocumentEnvironment| declaration is similar to
%  |\DeclareDocumentCommand| except that it takes four arguments: the
%  first being the environment name (without a backslash), the second
%  again the argument-spec, and the third and forth are the actions
%  taken at start end end of the environment. The parsed arguments are
%  available to both the start and the finish as |#1|, |#2|,
%  etc.
%
%  All commands and environments defined with the above commands are
%  automatically robust.
%
%
%
% \subsection{A different interface (for class design?)}
%
%  Combining signature and top-level definition of a command |\foo| as
%  in
%  \begin{verbatim}
%  \DeclareDocumentCommand \foo { m c m }
%  { \typeout{1:#1}
%    \typeout{2:#2}
%    \typeout{3:#3}
%  }
%  \end{verbatim}
%  is fine in certain cases, e.g., if the user wants to declare a few
%  commands this way in the preamble of a document. However in a class
%  file it probably better to completely separate signature (i.e.,
%  argument \#1 and \#2) from top-level implementation (i.e., argument
%  \#3).
%
%
%  \begin{verbatim}
%  \DeclareDocumentCommandInterface \foo {bar} { m c m }
%  \end{verbatim}
%  The above now declare only the signature of the command |\foo| and
%  states that the implementation is to be found under the label |bar|.
%
%  A bunch of such statements would then for the first time clearly
%  define a document class (i.e., what a document class instance needs
%  to define to be compliant).
%
%  An instance would then consist of a lot of declarations of the type
%  \begin{verbatim}
%  \DeclareDocumentCommandImplementation {bar} {3}
%  { \typeout{1:#1}
%    \typeout{2:#2}
%    \typeout{3:#3}
%  }
%  \end{verbatim}
%  i.e., defining how to format things being referenced as part of the
%  signature.
%
%  The functions |\DeclareDocumentCommandInterface| and
%  |\DeclareDocumentCommandImplementation| are implemented for now but
%  it is not sure if they will stay. If a document command is defined
%  with |\DeclareDocumentCommandInterface| but there is no matching
%  interface it prints the label in quotes as |``bar''|.
%
%
%
%
%  \subsection{Checking for a value or boolean}
%
%  It would make perfect sense to make |\NoValue| a \LaTeX3 quark but
%  as there is a real danger of it getting executed by accident it is
%  best not to as it would result in an infinite loop.
%
%  \DescribeMacro\NoValue
%  For this reason |\NoValue| is defined to expand to the string
%  |-NoValue-| which would get typeset if ever executed thus clearly
%  indicating the type of error the writer made.
%
%  However this makes testing for this token slightly complicated as in
%  that case the test
%  \begin{verbatim}
%  \tlp_set:Nn \l_seen_tlp {#1}
%  \tlp_set:Nn \l_hidden_novalue_tlp {\NoValue}
%  \tlp_if_eq:NNTF \l_seen_tlp \l_hidden_novalue_tlp
%  \end{verbatim}
%  will be true if |#1| was |\NoValue| but false if if |#1| itself
%  contains a macro which contains |\NoValue|; a case that happens
%  unfortunately very often in practice.  Using an unguarded |x| type
%  expansion to define |\l_seen_tlp| is out of the question as |#1| is
%  typically either |\NoValue| or arbitrary user input for which we
%  can't properly guard it unless we are sure people only use robust
%  commands. When running a pure \LaTeX3 format where all document
%  commands are robust this is perhaps something to be looked at again
%  but when running on top of \LaTeXe{} we have to be careful.
%
%  Therefore we use a somewhat different procedure as implemented in
%  the internal \LaTeX3 function |\tlist_if_eq_alt:nnTF|. See the
%  implementation notes for that function if you're interested.
%
%  \DescribeMacro\IfNoValueTF
%  \DescribeMacro\IfNoValueT
%  \DescribeMacro\IfNoValueF
%  \DescribeMacro\IfValueTF
%  \DescribeMacro\IfValueT
%  \DescribeMacro\IfValueF
%  These macros are used for checking if an optional argument was present as in
%  the example below.
%  \begin{verbatim}
%  \DeclareDocumentCommand\testcmd{om}{
%    \IfNoValueTF{#1}{``#2''}{#1,#2}
%  }
%  \end{verbatim}
%
%
%  \DescribeMacro\BooleanTrue
%  \DescribeMacro\BooleanFalse
%  The parsing result for a star etc.\ is presented as the token
%  |\BooleanTrue| or |\BooleanFalse| respectively!
%
%  \DescribeMacro\IfBooleanTF
%  \DescribeMacro\IfBooleanT
%  \DescribeMacro\IfBooleanF
%  To test for these values the macro |\IfBooleanTF| can be used. It
%  expects as its first argument either |\BooleanTrue| or
%  |\BooleanFalse| and executes its second or third argument depending
%  on this value. |\IfBooleanT| and |\IfBooleanF| are obvious
%  shortcuts.
%
%  At one point in time I thought that one can represent everything
%  using |\NoValue|, e.g., for the star case either return |*| or
%  |\NoValue|. However, this slows down processing of commands like
%  |\\*| considerably since they would then have to use a slower
%  internal test instead of a fast two-way switch.
%
%
%  \subsection{New argument types and shorthands}
%
%  New argument types can be added at in a fairly straight forward
%  manner with the command
%  |\DeclareArgumentType|\DescribeMacro\DeclareArgumentType. This
%  command takes six arguments: |#1| is a symbol denoting the argument
%  type, |#2| is the token the scanner should look for, |#3| is for
%  executing a special action (like an error message) if no argument is
%  found, |#4| is the default value in case of a missing argument, |#5|
%  is what the scanner will encounter, and finally |#6| is what the
%  scanner grabs from the argument type. This is perhaps clearer with
%  an example\dots{} This is how the |o| type is implemented:
%  \begin{verbatim}
%  \DeclareArgumentType o [ {} {\NoValue} {#1[#2]} {#2}
%  \end{verbatim}
%  In a similar fashion a |b| type expecting its argument inside |<|
%  and |>| would be defined as
%  \begin{verbatim}
%  \DeclareArgumentType b < {} {\NoValue} {#1<#2>} {#2}
%  \end{verbatim}
%
%  \DescribeMacro\DeclareArgumentTypeWithDefault
%  |\DeclareArgumentTypeWithDefault| is even simpler as this type
%  expects the default value to be input at the time of argument
%  specification. Thus arguments |#3| and |#4| from above are
%  unnecessary and are simply absent. Thus the |O| type is
%  implemented\footnote{I would say it is at best wishful thinking that
%  the interface could be something like
%  \texttt{\cs{DeclareArgumentTypeWithDefault}
%  C\{2\}\{(\#1,\#2)\}\{\{\#1\}\{\#2\}\}} as it would be quite
%  troublesome implementationwise and the current syntax isn't that
%  difficult to use.} as
%  \begin{verbatim}
%  \DeclareArgumentTypeWithDefault O [ {#1[#2]} {#2}
%  \end{verbatim}
%  and again a similar |B| type could be implemented as
%  \begin{verbatim}
%  \DeclareArgumentTypeWithDefault B < {#1<#2>} {#2}
%  \end{verbatim}
%
%
%  There is also a possibility to define a shorthand for a specific
%  sequence of arguments with the command
%  \DescribeMacro\DeclareArgumentTypeShorthand
%  |\DeclareArgumentTypeShorthand|. As an example the |s| argument type
%  is just a different way of saying |S{*}| so it's simply implemented
%  as
%  \begin{verbatim}
%  \DeclareArgumentTypeShorthand s {S{*}}
%  \end{verbatim}
%  Similarly one could add a shorthand |M| for inserting five mandatory
%  arguments where the latter is allowed to take |\par| in its
%  argument:
%  \begin{verbatim}
%  \DeclareArgumentTypeShorthand M {mmmmPm}
%  \end{verbatim}
%
%
%
%
% \subsection{Some comments on the need for the \texttt{O} specifier}
%
% With |\newcommand| there is the possibility of specifying a default
% for an optional argument which is stored away in a more or less
% efficient manner. For example below is the old definition of
% |\linebreak| as can be found in the \LaTeX2e kernel:
%\begin{verbatim}
%\def\linebreak{\@testopt{\@no@lnbk-}4}
%\def\@no@lnbk #1[#2]{%
%  \ifvmode
%    \@nolnerr
%  \else
%    \@tempskipa\lastskip
%    \unskip
%    \penalty #1\@getpen{#2}%
%    \ifdim\@tempskipa>\z@
%      \hskip\@tempskipa
%      \ignorespaces
%    \fi
%  \fi}
%\end{verbatim}
% Ignoring for the moment that the above is slightly optimised an
% expansion of this code under |\tracingall| will result in about 90
% lines of tracing output.
% If we reimplement this using |\DeclarDocumentCommand\linebreak{o}|
% we have to use |\IfNoValueTF| to find out if an argument was present
% which (because of the careful expansion we do internally)
% results in about twice as much of tracing lines. In contrast using
% |O{4}| as below we end up with 110 lines, which seems roughly the
% price we have to pay for the extra generality available (though this
% could perhaps even be reduced by a better implementation of the
% parsing machine as originally done by David, before i talked him
% into adding support for arguments in the end code of an environment).
%
%\begin{verbatim}
%\DeclareDocumentCommand\linebreak { O{4} }
% {
%  \ifvmode
%    \@nolnerr
%  \else
%    \@tempskipa\lastskip
%    \unskip
% %    \IfNoValueTF{#1}
% %       {\break}
% %       {\penalty -\@getpen{#1}}
%    \penalty -\@getpen{#1}
%    \ifdim\@tempskipa>\z@
%      \hskip\@tempskipa
%      \ignorespaces
%    \fi
%  \fi
% }
%\end{verbatim}
%
%
% \subsection{A somewhat complicated example}
%
% This example reimplements the |\makebox| and |\framebox| interface
% of \LaTeX{} both of which are unfortunately quite overloaded
% syntactically. For this reason the example isn't meant to show good
% coding practice but to show the power of the interface even though
% applied in a somewhat bad way.
%
% |\makebox| and |\framebox| support the following different document
% syntax forms:
% \begin{itemize}
% \item
% |\makebox{A}|: only a single mandatory argument.
%
% \item
% |\makebox[20pt]{B}|: one optional argument specify the box width.
%
%
% \item
% |\makebox[30pt][r]{C}|: two optional arguments the second specifying
%    the text position within the box being made (l,c,r being allowed
%    with c being the default).
%
% \item
% |\makebox(20,30){D}|: within picture mode the width is specified not
% as an optional argument in brackets but as a coordinate pair.
%
% \item
% |\makebox(0,0)[lt]{E}|: in that case an optional argument following
% coordinate pair denotes the placement within the box which can have
% different values compared to case C above.
% \end{itemize}
%
% To cater for this overloaded structure we can define |\makebox| to
% be something like the following:
%\begin{verbatim}
%\DeclareDocumentCommand \makebox { C{\NoValue} o O{c} m}
% { \IfNoValueTF{#1}
%     { \ltx@maketextbox{#2}{#3}{#4} }
%     { \ltx@makepicbox #1  {#2}{#4} } }
%\end{verbatim}
% In other words: if we do not see a coordinate pair first (i.e.,
% first argument is |\NoValue| then we expect up to two optional
% arguments (the width of the box or |\NoValue| if not given and the
% placement specifier with a default of |c| if not given) and one
% mandatory one which is the text. In that case we pass argument 2 to
% 4 to an internal function |\ltx@maketextbox| which builds the text
% box.
%
% Otherwise, if the first argument is a coordinate pair we parse an
% optional argument denoting the placement specifier. Since
% \texttt{xparse} doesn't support variant syntax we actually parse for
% another optional argument (which has no meaning in that case and is
% in fact ignored if present) followed by a mandatory one containing
% the box text. In that case we pass the coordinate pair (|#1|), the
% specifier (|#2|), and the text (|#4|) to the function
% |\ltx@makepicbox| which builds the picture box. Note the special
% handling of the coordinatesD: which are passed without surrounding
% braces to |\ltx@makepicbox|: since the coordinate argument looks
% like |{x-val}{y-val}| the receiving function |\ltx@makepicbox| gets
% the |x-val| as argument one and the |y-val| as argument two.
%
% A definition for |\framebox| would look more or less identical
% except that we would need to pass the arguments to slightly
% different internal functions. The alternative is to give the
% internal functions an extra argument that controls whether or not a
% frame is bying built.
%
% \begin{macro}{\ltx@makepicbox}
% So here is a possible implementation of |\ltx@makepicbox| that
% builds a picture box with or without frame. It takes the following
% mandatory arguments:
% \begin{enumerate}
% \item x-part of coordinate
% \item y-part of coordinate
% \item placement specifier, e.g., |lt| or |\NoValue|
% \item text of box
% \item the token |\frame| (if a frame should surround the box) or the
% token |\@firstofone| --- not pretty i agree
% \end{enumerate}
%\begin{verbatim}
%\def\ltx@makepicbox#1#2#3#4#5
%  {
%   #5{
%     \vbox to#2\unitlength
%      {\let\mb@b\vss \let\mb@l\hss\let\mb@r\hss
%       \let\mb@t\vss
%       \IfNoValueF{#3}
%        {
%         \@tfor\reserved@a :=#3\do{
%           \if s\reserved@a
%             \let\mb@l\relax\let\mb@r\relax
%           \else
%             \expandafter\let\csname mb@\reserved@a\endcsname\relax
%           \fi}%
%        }
%       \mb@t
%       \hb@xt@ #1\unitlength{\mb@l #4\mb@r}
%       \mb@b
%       \kern\z@}
%   }
%  }
%\end{verbatim}
% \end{macro}
%
%
%
% \begin{macro}{\ltx@maketextbox}
% For the text case the internal function could  take the following
% mandatory arguments:
% \begin{enumerate}
% \item width of the box or |\NoValue| (denoting to build the box at
% natural width)
% \item placement specifier, e.g., |l|. (No test for |\NoValue| being undertaken)
% \item text of box
% \item the token |\fbox| (if a frame should surround the box) or the
% token |\mbox|
% \end{enumerate}
% The actual code is taken straight from the current \LaTeX{} kernel
% and looks kind of scary.
%\begin{verbatim}
%\def\ltx@maketextbox#1#2#3#4
% {
%  \IfNoValueTF{#1}
%     {#4{#3}}
%     {
%      \leavevmode
%      \@begin@tempboxa\hbox{#3}
%       \setlength\@tempdima{#1}
%       \ifx#4\fbox
%         \setbox\@tempboxa\hb@xt@\@tempdima
%              {\kern\fboxsep\csname bm@#2\endcsname\kern\fboxsep}
%         \@frameb@x{\kern-\fboxrule}
%       \else
%         \hb@xt@\@tempdima{\csname bm@#2\endcsname}
%       \fi
%      \@end@tempboxa
%     }
% }
%\end{verbatim}
% \end{macro}
%
% \begin{macro}{\makebox}
% \begin{macro}{\framebox}
% Given the above internal functions the declarations of |\makebox|
% and |\framebox| would then look like this:
%\begin{verbatim}
%\DeclareDocumentCommand \makebox { C{\NoValue} o O{c} m}
% { \IfNoValueTF{#1}
%     { \ltx@maketextbox{#2}{#3}{#4}\mbox }
%     { \ltx@makepicbox #1  {#2}{#4}\@firstofone } }
%
%\DeclareDocumentCommand \framebox { C{\NoValue} o O{c} m}
% { \IfNoValueTF{#1}
%     { \ltx@maketextbox{#2}{#3}{#4}\fbox }
%     { \ltx@makepicbox #1  {#2}{#4}\frame } }
%\end{verbatim}
% \end{macro}
% \end{macro}
%
%
%
%  Here's another example which shows how one can use the |W| specifier.
%  The \textsf{amsmath} environments use their own definition of |\\|
%  which goes under the name |\math@cr|. As there is a good chance the
%  next line of math begins with either an asterisk or something in
%  square brackets this often leads to errors. The following example
%  definition works (I \emph{did} try it).
%  \begin{verbatim}
%  \DeclareDocumentCommand\math@cr{WsWO{\z@}}{
%    \IfBooleanTF{#1}
%    { \global\@eqpen\@M }{
%      \global\@eqpen
%        \ifnum\dspbrk@lvl <\z@
%          \interdisplaylinepenalty
%        \else
%          -\@getpen\dspbrk@lvl
%        \fi
%    }
%    \math@cr@@@
%    \noalign{\vskip#2\relax}
%  }
%  \end{verbatim}
%  Note that this definition automatically avoids problems within the
%  alignments even if it is called as |\\&|.
%
%
%
%
% \subsection{Open issues}
%
% In this section unresolved issues or ideas to think about and
% perhaps implement are collected. There is no particular order to
% them.
%
% \begin{itemize}
% \item
%   Support for parsing verbatim type of arguments was considered (and
%   actually implemented at one stage. E.g.,
%   |g{|\meta{prepare-parsing}|}| where |g| first run
%   \meta{prepare-parsing} (which might involve |catcode|
%   changes)\footnote{urg horror!}, then look at the next token: if
%   that would be a |{| it would scan a brace delimited argument
%   (reverting catcodes of |{| and |}| if needed) otherwise would scan
%   for an argument delimited by that token so that something like
%   |\verb+%\+| would scan |%\| as its argument assuming that the
%   \meta{prepare-parsing} turned |%| and |\| into non-letters.
%
%   All kind of nasty problems lurking especially no proper error
%   checks possible and of course as we all know such commands would
%   then not work inside arguments of other commands. At least they
%   would have some restrictions.
%
%   Also no way to make the parsing smart by not accepting newlines as
%   part of the code (|\verb| does this right now and this is really
%   helpful as it catches runaways nicely).
%
%
% \item
%   \textsf{xparse} should probably go into the \LaTeX3 kernel in which
%   case it should also provide the definitions of |\begin| and |\end|
%   and this raises a few questions: Will environments be defined as
%   control sequences |\foo| and |\endfoo|? If they are do we then want
%   to include support for a separate command |\foo| and if so what
%   about using the environment forms in special scanner mechanisms
%   where we \emph{can't} use |\begin{foo}|? In those cases one could
%   use a special command like what the \textsf{fancyvrb} package
%   provides with the command |\VerbatimEnvironment| and all packages
%   that define such special arguments should then also make sure that
%   the |\foo| command issued on its own should cause an error.
%   Another solution would be to simply define environments as
%   |\beginfoo| and |\endfoo| and then let |\begin| check if it was
%   used to call an environment or a command. If the latter is the
%   case then insert grouping as that could be handled by |\beginfoo|
%   itself. When |\end| is reached check if |\endfoo| exists. If it
%   does then use that, otherwise we were probably using a normal
%   command which should just close the group.
% \end{itemize}
%
%
%  \subsection{Rejected ideas---and why}
%
%  Let's say the document command |\testmo| has signature |mo|. If we
%  call it as |\testmo{arg} [opt]| a following space will be obeyed.
%  However calling it with the mandatory argument only as in
%  |\testmo{arg}| will gobble a following space because the peek ahead
%  in the |o| type ignores spaces. We can record that a space has been
%  gobbled when peeking ahead and we can also put it back in if needed
%  but I have only ever seen one request for this and in that case the
%  better solution was to use a signature |mWo| so that no spaces are
%  allowed between the mandatory and the optional argument. One could
%  even argue that this is the most appropriate thing to do if the user
%  is really that sensitive to spaces! In any case it is not
%  implemented here as it creates an unnecessary overhead for something
%  that is never used and a simple solution exists.
%
%
%
% \StopEventually{}
%
% \section{Implementation}
%
%  Versions prior to and including 1.19 contained several different
%  implementations. These are gone now but can be looked at by
%  getting an older version of the package from the CVS repository.
%
%  First the required packages.
%    \begin{macrocode}
%<*package>
\RequirePackage{l3tlp,l3num,l3toks,l3prg,l3int}
\CodeStart
\AtEndOfPackage{\CodeStop}
%    \end{macrocode}
%
%
%
%  \subsection{Error and warning messages}
%
%  Here we define the error message we're going to use in this package.
%
%  \begin{macro}{\xparse_already_defined_error_msg:N}
%  \begin{macro}{\xparse_not_yet_defined_error_msg:N}
%  \begin{macro}{\xparse_begins_with_end_error_msg:N}
%  \begin{macro}{\xparse_unknown_arg_type_error_msg:N}
%  \begin{macro}{\xparse_number_of_arguments_error_msg:Nn}
%  \begin{macro}{\xparse_no_command_implementation_warning:n}
%  The names should give the function's purpose away.
%    \begin{macrocode}
\def_new:Npn \xparse_already_defined_error_msg:N #1 {
  \xparse_error:x {
    Command~name~`\token_to_string:N #1'~ already~defined!
  }
}
\def_new:Npn \xparse_not_yet_defined_error_msg:N #1 {
  \xparse_error:x {
    Command~`\token_to_string:N #1'~ not~ yet~defined!
  }
}
\def_new:Npn \xparse_begins_with_end_error_msg:N #1 {
  \xparse_error:x {
    Command~`\token_to_string:N #1'~begins~with~
    `\token_to_string:N \end'!
  }
}
%    \end{macrocode}
%  This one is for when we've encountered an unknown argument type in
%  the argument specification. We can try to recover by putting in an
%  |m| type instead and hope for the best.
%    \begin{macrocode}
\def_new:Npn \xparse_unknown_arg_type_error_msg:N #1{
  \xparse_error:x {
    Unknown~ argument~ type~ `#1'~
    I'll~ substitute~ it~ with~ `m'~ for~ now.~ Fingers~ crossed...
  }
}
%    \end{macrocode}
%  A message for people using the wrong number of arguments.
%    \begin{macrocode}
\def_new:Npn \xparse_number_of_arguments_error_msg:Nn #1#2 {
  \xparse_error:x{
    You're~ trying~ to~ define~ the~ command~ `\token_to_string:N #1'~
    with~ \int_use:N \int_eval:n{#2}~ arguments~ but~ I~ only~
    allow~ 0-9~ arguments.~ I~ can~ probably~ not~ help~ you~ here
  }
}
\def_new:Npn \xparse_no_command_implementation_warning:n #1 {
  \xparse_warning:x {No~ implementation~ for~ `#1'~ defined}
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\xparse_error:x}
%  \begin{macro}{\xparse_warning:x}
%  Here's how we produce the error messages and warnings currently.
%  This awaits a proper error message module!
%    \begin{macrocode}
\def_new:Npn \xparse_error:x #1{\tex_errmessage:D {xparse~error:~#1}}
\def_new:Npn \xparse_warning:x #1{\io_put_term:x{xparse~warning:~#1}}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
%
%  \subsection{Checking for valid command names}
%
%
%  \begin{macro}{\xparse_if_definable:NT}
%  \begin{macro}{\xparse_if_definable:cT}
%  A definable command is either |\c_undefined| or |\scan_stop:| and
%  furthermore we won't allow it to start with |\end|.
%  If the command is definable we do what was asked for otherwise
%  we give an appropriate error message.
%    \begin{macrocode}
\def_new:Npn \xparse_if_definable:NTF #1 {
%    \end{macrocode}
%  First check if the control sequence is free.
%    \begin{macrocode}
  \cs_free:NTF #1
%    \end{macrocode}
%  If free check if it begins with |\end|.
%    \begin{macrocode}
  {
    \xparse_begins_with_end:NTF #1
    { \xparse_begins_with_end_error_msg:N #1 \use_arg_ii:nn }
    \use_arg_i:nn
  }
%    \end{macrocode}
%  If not free give an error message.
%    \begin{macrocode}
  { \xparse_already_defined_error_msg:N #1 \use_arg_ii:nn }
}
\def_new:Npn \xparse_if_definable:cTF {
  \exp_args:Nc \xparse_if_definable:NTF
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \begin{macro}{\xparse_if_redefinable:NTF}
%  \begin{macro}{\xparse_if_redefinable:cTF}
%  A re-definable command is almost the same as above but here we
%  demand that it already exists. As |\cs_free:NTF| is an expandable
%  test we can reverse it with |\etex_unless:D|.
%    \begin{macrocode}
\def_new:Npn \xparse_if_redefinable:NTF #1 {
  \exp_after:NN \etex_unless:D \cs_free:NTF #1
  {
    \xparse_begins_with_end:NTF #1
    { \xparse_begins_with_end_error_msg:N #1 \use_arg_ii:nn }
    \use_arg_i:nn
  }
  { \xparse_not_yet_defined_error_msg:N #1 \use_arg_ii:nn }
}
\def_new:Npn \xparse_if_redefinable:cTF {
  \exp_args:Nc \xparse_if_redefinable:NTF
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\xparse_begins_with_end:NTF}
%  \begin{macro}{\xparse_begins_with_end_aux:N}
%  Finally we need the magic function for checking if the control
%  sequence begins with |\end|.
%  We wish to determine if the control sequence in question begins with
%  |\end| which is forbidden. The end goal is to get a control sequence
%  consisting of the first three letters to test against |\end| with
%  |\cs_if_eq_p:NN|. The function |\cs_to_str:N| will remove the |\|
%  from a command name and return the rest of the characters with
%  category code 12. Thus using an |f| type expansion to get the first
%  three characters is perfectly safe as it'll stop right there. Then
%  we turn these three letters into a control sequence with a simple
%  expansion which is then tested with |\xparse_begins_with_end_aux:N|.
%    \begin{macrocode}
\def_new:Npn \xparse_begins_with_end:NTF #1 {
%    \end{macrocode}
%  We do it all in a group as there is no need to fill up the hash
%  table with weird three letter control sequences.
%    \begin{macrocode}
  \group_begin:
    \exp_args:Nc \xparse_begins_with_end_aux:N {
      \tlist_head_iii:f { \cs_to_str:N #1 ??}
    }
}
%    \end{macrocode}
%  After the above expansion tricks we now have a real control sequence
%  to test against |\end|. We end the group again.
%    \begin{macrocode}
\def_new:Npn \xparse_begins_with_end_aux:N #1 {
  \if:w \cs_if_eq_p:NN #1 \end
    \group_end:
    \exp_after:NN \use_arg_i:nn
  \else:
    \group_end:
    \exp_after:NN \use_arg_ii:nn
  \fi:
}
%    \end{macrocode}
%  Note that these definitions make no use of temporary variables.
%  \end{macro}
%  \end{macro}
%
%
%  \subsection{Defining a simple command}
%
%
%  All commands and environments defined with \textsf{xparse}
%  eventually call upon a macro taking between zero and nine arguments.
%  Hence it makes perfect sense to define a low level command for this
%  task. It also means we can catch errors and recover fairly
%  gracefully plus giving a proper \LaTeX{} error message rather than
%  \TeX's
%  \begin{verbatim}
%  ! You already have nine parameters.
%  \end{verbatim}
%
%  \begin{macro}{\xparse_define_simple_command:NNnn}
%  \begin{macro}{\xparse_define_simple_command:cNnn}
%  \begin{macro}{\xparse_define_simple_command_aux:NNn}
%  This command defines command |#1| with the function |#2| as having
%  |#3| arguments.
%    \begin{macrocode}
\def_new:Npn \xparse_define_simple_command:NNnn #1#2#3{
%    \end{macrocode}
%  First off we check if the number of arguments are in the allowed
%  range.
%    \begin{macrocode}
  \prg_logic_test:nTF {
    \prg_logic_or_p:nn
    { \int_compare_p:nNn {#3} < \c_zero }
    { \int_compare_p:nNn {#3} > 9 }
  }
%    \end{macrocode}
%  The \meta{true} branch means we are outside the allowed range and we
%  give an error message.
%    \begin{macrocode}
  {
    \xparse_number_of_arguments_error_msg:Nn #1{#3}
%    \end{macrocode}
%  Gobble the definition so we won't get any more errors.
%    \begin{macrocode}
    \use_none:n
  }
%    \end{macrocode}
%  Otherwise everything is cool. Check if we have a simple command with
%  no arguments.
%    \begin{macrocode}
  {
    \int_compare:nNnTF {#3}= \c_zero
%    \end{macrocode}
%  If we have no arguments just make a simple definition.
%    \begin{macrocode}
    {#2 #1}
%    \end{macrocode}
%  Otherwise call the cavalry! This little expansion trick ensures that
%  the number can be given as an \meta{int} register.
%    \begin{macrocode}
    {
      \exp_args:NNNo
      \xparse_define_simple_command_aux:NNn #2 #1
        {\int_use:N \int_eval:n{#3}}
    }
  }
}
\def_new:Npn \xparse_define_simple_command:cNnn {
  \exp_args:Nc \xparse_define_simple_command:NNnn
}
\def_new:Npn \xparse_define_simple_command_aux:NNn #1#2#3{
%    \end{macrocode}
%  First set a token register to contain everything from one to nine
%  arguments.
%    \begin{macrocode}
  \toks_set:Nn \l_tmpa_toks{##1##2##3##4##5##6##7##8##9}
%    \end{macrocode}
%  Then read everything up to the number given in this function and
%  throw away everything else. Thus for $|#2|=2$ we would only use
%  |##1##| and then we insert the |2| to get it right.
%    \begin{macrocode}
  \def\tmp:w##1#3##2\q_nil{##1#3}
%    \end{macrocode}
%  I just use the |f| type expansion because I can't remember how many
%  expansions I need to get it right\dots
%    \begin{macrocode}
  \toks_set:Nf \l_tmpa_toks {
    \exp_after:NN \tmp:w \toks_use:N \l_tmpa_toks \q_nil
  }
  \exp_after:NN #1 \exp_after:NN #2 \toks_use:N \l_tmpa_toks
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%
%  \subsection{The high level commands}
%
%
%  Here we set up the functions for defining and redefining document
%  commands and environments. It's all rather straight forward here so
%  I've saved on the comments.
%
%  \begin{macro}{\DeclareDocumentCommand}
%  \begin{macro}{\ReDeclareDocumentCommand}
%  In case we can't do what the user wanted we gobble the next
%  arguments from the input stream. For commands there are two
%  arguments waiting.
%    \begin{macrocode}
\def_new:Npn \DeclareDocumentCommand #1 {
  \xparse_if_definable:NTF #1
  { \xparse_declare_document_command:Nnn #1 }
  \use_none:nn
}
\def_new:Npn \ReDeclareDocumentCommand #1 {
  \xparse_if_redefinable:NTF #1
  { \xparse_declare_document_command:Nnn #1 }
  \use_none:nn
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\DeclareDocumentEnvironment}
%  \begin{macro}{\ReDeclareDocumentEnvironment}
%  Three arguments for environments.
%    \begin{macrocode}
\def_new:Npn \DeclareDocumentEnvironment #1 {
  \xparse_if_definable:cTF {#1}
  { \xparse_declare_document_environment:cnnn {#1} }
  \use_none:nnn
}
\def_new:Npn \ReDeclareDocumentEnvironment #1 {
  \xparse_if_redefinable:cTF {#1}
  { \xparse_declare_document_environment:cnnn {#1} }
  \use_none:nnn
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ProvideDocumentCommand}
%  \begin{macro}{\ProvideDocumentEnvironment}
%  When providing a command we just check if the control sequence is
%  free. If it is let |\DeclareDocument...| do the rest, otherwise
%  gobble the next arguments.
%    \begin{macrocode}
\def_new:Npn \ProvideDocumentCommand #1{
  \cs_free:NTF #1
  { \DeclareDocumentCommand #1}
  \use_none:nn
}
\def_new:Npn \ProvideDocumentEnvironment #1{
  \cs_free:cTF {#1}
  { \DeclareDocumentEnvironment {#1} }
  \use_none:nnn
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
%
%  \subsection{The low level definitions}
%
%
%  First some helper functions
%  \begin{macro}{\l_xparse_grabbed_args_toks}
%  \begin{macro}{\l_xparse_end_environment_args_toks}
%  \begin{macro}{\l_xparse_mandatory_args_int}
%  \begin{macro}{\l_xparse_total_args_int}
%  We need some \meta{token} registers to keep track of things. We also
%  allocate an \meta{int} register to keep track of the number of
%  arguments.
%    \begin{macrocode}
\toks_new:N \l_xparse_grabbed_args_toks
\toks_new:N \l_xparse_end_environment_args_toks
\int_new:N \l_xparse_mandatory_args_int
\int_new:N \l_xparse_total_args_int
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\xparse_declare_document_command:Nnn}
%  \begin{macro}{\xparse_declare_document_command:cnn}
%  |\xparse_declare_document_command:Nnn| is a two step procedure. The
%  user level command |\|\meta{cmd} contains the argument grabbers
%  while the internal command |\\|\meta{cmd} holds the actual
%  definition of what to do with the arguments. Naturally this calls
%  for every such user level command to be robust which is done using
%  the \eTeX{} protection feature.
%    \begin{macrocode}
\def_long:Npn \xparse_declare_document_command:Nnn #1 #2 #3{
%    \end{macrocode}
%  First we prepare the signature.
%    \begin{macrocode}
  \xparse_prepare_signature:n {#2}
%    \end{macrocode}
%  Now for the document command. Make it robust and make sure it starts
%  with |\toks_set:Nn \l_xparse_grabbed_args_toks {\\|\meta{cmd}|}|.
%    \begin{macrocode}
  \pref_robust:D \def:Npx #1 {
    \exp_not:n { \toks_set:Nn \l_xparse_grabbed_args_toks }
    {\exp_not:c {\token_to_string:N #1}}
%    \end{macrocode}
%  Then add the argument grabbers.
%    \begin{macrocode}
    \toks_use:N \l_xparse_grabbed_args_toks
%    \end{macrocode}
%  Finally execute |\toks_use:N \l_xparse_grabbed_args_toks| which now
%  holds the grabbed arguments enclosed in braces and starts with the
%  internal command |\\|\meta{cmd}.
%    \begin{macrocode}
    \exp_not:n{ \toks_use:N \l_xparse_grabbed_args_toks}
  }
%    \end{macrocode}
%  Define the internal command by making it a |\long| macro with number
%  of arguments equal to |\l_xparse_total_args_int| and definition as
%  given by |#3|. Even though this internal macro allows |\par| in its
%  argument the decision is left to the individual argument grabbers.
%    \begin{macrocode}
  \xparse_define_simple_command:cNnn {\token_to_string:N #1}
  \def_long:Npn {\l_xparse_total_args_int}{#3}
}
\def_new:Npn \xparse_declare_document_command:cnn {
  \exp_args:Nc \xparse_declare_document_command:Nnn
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\xparse_declare_document_environment:cnnn}
%  |\xparse_declare_document_environment:cnnn| is almost the same. In
%  order to use the grabbed arguments we take them from
%  |\l_xparse_grabbed_args_toks| just before they are executed. We
%  also insert a |\group_begin:| as it will otherwise fail miserably
%  in case a user tries to use it without |\begin ... \end|.
%    \begin{macrocode}
\def_long_new:Npn \xparse_declare_document_environment:cnnn #1#2#3#4 {
  \xparse_declare_document_command:cnn {#1}{#2}
  { \group_begin:
      \toks_set_eq:NN \l_xparse_end_environment_args_toks
                      \l_xparse_grabbed_args_toks
      #3
  }
%    \end{macrocode}
%  We let |\end|\meta{envir} equal to a standard version which will do
%  all the work.
%    \begin{macrocode}
  \let:cN {end #1} \xparse_parsed_end_environment:
%    \end{macrocode}
%  Now define |\end\\|\meta{envir}.
%    \begin{macrocode}
  \xparse_define_simple_command:cNnn {end \token_to_string:N \\ #1}
    \def_long:Npn {\l_xparse_total_args_int}{#4}
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\xparse_parsed_end_environment:}
%  \begin{macro}{\xparse_parsed_end_environment_aux:N}
%  |\end|\meta{envir} is set equal to |\xparse_parsed_end_environment:|
%  which then executes |\end\\|\meta{envir}. The |\\|\meta{envir} comes
%  from the argument grabbing. The remainder of the token list is the
%  grabbed arguments. We better make this robust as well.
%    \begin{macrocode}
\def_robust_new:Npn \xparse_parsed_end_environment: {
  \exp_after:NN \xparse_parsed_end_environment_aux:N
    \toks_use:N \l_xparse_end_environment_args_toks
  \group_end:
}
\def_new:Npn \xparse_parsed_end_environment_aux:N #1{
  \use:c {end \token_to_string:N #1 }
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
%  \subsubsection{A class designer interface}
%
%  Below is the implementation of |\DeclareDocumentCommandInterface|
%  and the close cousin |\DeclareDocumentCommandImplementation|.
%  It is an open issue whether this concept should be supported.
%
%  \begin{macro}{\DeclareDocumentCommandInterface}
%  With this macro we define the document command |#1| to have
%  signature |#3| which does the argument grabbing. The arguments are
%  passed on to the internal command |\impl-#2|.
%    \begin{macrocode}
\def_long_new:Npn \DeclareDocumentCommandInterface #1 #2 #3{
  \xparse_prepare_signature:n {#3}
  \pref_robust:D \def:Npx #1 {
    \exp_not:n { \toks_set:Nn \l_xparse_grabbed_args_toks }
    {\exp_not:c {impl-#2}}
    \toks_use:N\l_xparse_grabbed_args_toks
    \exp_not:n{ \toks_use:N \l_xparse_grabbed_args_toks}
  }
%    \end{macrocode}
%  Define the internal command by making it a |\long| macro as we did
%  for |\DeclareDocumentCommand| but give it just a default definition
%  instead (usually an error message).
%    \begin{macrocode}
  \xparse_define_simple_command:cNnn {impl-#2} \def_long:Npn
    {\l_xparse_total_args_int}
    {\xparse_undefined_command_implementation:n{#2}}
}
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\xparse_undefined_command_implementation:n}
%  What to do if no implementation is made and the command is
%  called. Let's just typeset the name in quotes indicating that
%  something is wrong.
%    \begin{macrocode}
\def_new:Npn \xparse_undefined_command_implementation:n #1{
  ``#1''
%  \ensuremath{\langle\textit{#1}\rangle}
  \xparse_no_command_implementation_warning:n {#1}
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\DeclareDocumentCommandImplementation}
%  Defines the internal command |\impl-#1| with |#2| arguments
%  and definition |#3|.
%    \begin{macrocode}
\def_long_new:Npn \DeclareDocumentCommandImplementation #1 #2 #3{
  \xparse_define_simple_command:cNnn {impl-#1} \def_long:Npn {#2}{#3}
}
%    \end{macrocode}
% \end{macro}
%
%
%  \subsection{Creating the signature}
%
%
%
%  \begin{macro}{\xparse_prepare_signature:n}
%  The actual preparation of the signature is always the same but we
%  have different ways of handling it afterwards, so we make it a
%  separate function.
%    \begin{macrocode}
\def_new:Npn \xparse_prepare_signature:n #1 {
%    \end{macrocode}
%  Initialize the counter taking care of the number of arguments. In
%  case we reach more than nine we will give an error message later on.
%    \begin{macrocode}
  \int_zero:N \l_xparse_total_args_int
%    \end{macrocode}
%  Clear the token register we use when building the signature and the
%  number of ``normal'' mandatory arguments.
%    \begin{macrocode}
  \toks_clear:N \l_xparse_grabbed_args_toks
  \int_zero:N \l_xparse_mandatory_args_int
%    \end{macrocode}
%  Then call |\xparse_parse_signature:n|
%    \begin{macrocode}
  \xparse_parse_signature:n #1 \q_nil
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%  \begin{macro}{\xparse_parse_signature:n}
%  |\xparse_parse_signature:n| reads the signature one token/brace
%  group at a time and builds a list of argument grabbers which is
%  stored in |\l_xparse_grabbed_args_toks|. The function is recursive
%  which is why we use a quark to delimit it.
%    \begin{macrocode}
\def_new:Npn \xparse_parse_signature:n #1{
%    \end{macrocode}
%  Check if we reached the end of the signature.
%    \begin{macrocode}
  \quark_if_nil:NTF #1
%    \end{macrocode}
%  If we did we may have pending |m| type arguments so we clear them
%  out here. Otherwise we just continue.
%    \begin{macrocode}
  { \xparse_add_remaining_m_args: }
  {
    \bool_if:NTF \l_xparse_special_marker_bool
%    \end{macrocode}
%  Previous letter in the signature was a special marker so we set it
%  false again and then we clear out any remaining |m| type arguments.
%    \begin{macrocode}
    {
      \bool_set_false:N \l_xparse_special_marker_bool
      \xparse_add_remaining_m_args:
    }
%    \end{macrocode}
%  If no special marker was found we clear the token list pointer
%  containing the text string we use internally.
%    \begin{macrocode}
    {
      \tlp_clear:N \l_xparse_special_marker_tlp
    }
    \int_incr:N \l_xparse_total_args_int
    \xparse_check_and_add_argument_type:N #1
%    \end{macrocode}
%  Then we run the loop again.
%    \begin{macrocode}
    \xparse_read_arg_type_or_grab_default:n
  }
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\xparse_check_and_add_argument_type:N}
%  This function checks if the argument type actually exists and gives
%  an error if it doesn't.
%    \begin{macrocode}
\def_new:Npn \xparse_check_and_add_argument_type:N #1 {
  \cs_free:cTF {xparse_add_arg_type_#1:}
  { \xparse_unknown_arg_type_error_msg:N #1
    \int_incr:N \l_xparse_mandatory_args_int
  }
%    \end{macrocode}
%  Otherwise we just add it with its dedicated function.
%    \begin{macrocode}
  { \use:c {xparse_add_arg_type_#1:} }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\xparse_read_arg_type_or_grab_default:n}
%  \begin{macro}{\xparse_grab_default_arg:n}
%  \begin{macro}{\xparse_grab_default_allowpar_arg:n}
%  \begin{macro}{\xparse_grab_default_obeyspace_arg:n}
%  The function for grabbing a default value. It can be either |\long|
%  or non-|\long| (which in my world equals `short').
%    \begin{macrocode}
\let_new:NN \xparse_read_arg_type_or_grab_default:n
            \xparse_parse_signature:n
\def_new:Npn \xparse_grab_default_arg:n #1{
  \toks_put_right:Nn \l_xparse_grabbed_args_toks {{#1}}
  \let:NN \xparse_read_arg_type_or_grab_default:n
          \xparse_parse_signature:n
  \xparse_parse_signature:n
}
\def_long_new:Npn \xparse_grab_default_allowpar_arg:n #1{
  \toks_put_right:Nn \l_xparse_grabbed_args_toks {{#1}}
  \let:NN \xparse_read_arg_type_or_grab_default:n
          \xparse_parse_signature:n
  \xparse_parse_signature:n
}
%    \end{macrocode}
%  This is just so that it'll grab the argument the right way.
%    \begin{macrocode}
\let_new:NN \xparse_grab_default_obeyspace_arg:n
            \xparse_grab_default_arg:n
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%
%  \subsection{The argument types}
%
%
%
%  All argument types must be denoted by single letters.\footnote{You
%  can use a multi-letter sequence to denote a shorthand but it
%  requires you to put two brace groups around it in the signature and
%  it's not officially supported.} We have three categories of letters:
%  Special markers, basic argument types, and shorthands.
%
%
%  \subsubsection{Special markers}
%
%  We will allow some special markers to denote special handling of the
%  next argument.
%  \begin{macro}{\l_xparse_special_marker_bool}
%  \begin{macro}{\l_xparse_special_marker_tlp}
%  The boolean will be used to record if the previous letter in the
%  signature was a special marker and the token list pointer will
%  record the text string we'll use for this type of marker.
%    \begin{macrocode}
\bool_new:N \l_xparse_special_marker_bool
\tlp_new:Nn \l_xparse_special_marker_tlp {}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\xparse_add_special_marker:Nn}
%  The purpose of a special marker like |P| or |W| is to make it
%  convenient to input special variations of other argument types. We
%  do so by letting these special versions have names with a
%  recognizable string in them so that you have for example
%  |\xparse_O:w| for adding a normal |O| type argument and then there
%  is |\xparse_allowpar_O:w| which allows a |\par| token in its
%  argument. Hence when the signature parser encounters such a marker
%  it decrements the argument counter so that doesn't get out of whack,
%  sets the boolean |\l_xparse_special_marker_bool| so that we know a
%  special marker was seen on the next go and finally set the text
%  string in |\l_xparse_special_marker_tlp|.
%    \begin{macrocode}
\def_new:Npn \xparse_add_special_marker:Nn #1#2{
  \def_new:cpn {xparse_add_arg_type_#1:}{
    \int_decr:N \l_xparse_total_args_int
    \bool_set_true:N \l_xparse_special_marker_bool
    \tlp_set:Nn \l_xparse_special_marker_tlp {#2}
  }
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\xparse_add_arg_type_P:}
%  \begin{macro}{\xparse_add_arg_type_W:}
%  Make the |P| type add an |allowpar_| version and |W| an
%  |obeyspace_| version.
%    \begin{macrocode}
\xparse_add_special_marker:Nn P {allowpar_}
\xparse_add_special_marker:Nn W {obeyspace_}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
%  \subsubsection{The default argument types}
%
%
%
%  When scanning the signature we need to add the argument type which
%  is done by a function |\xparse_add_arg_type_|\meta{X}|:|, where
%  \meta{X} is the letter denoting the argument type. If not found an
%  error message is issued ny |\xparse_unknown_arg_type_error_msg:N|.
%
%  By default the package implements the argument types  |m|, |S|, |c|,
%  |C|, |o|, and |O| argument types as low level ones. The |s| type is
%  a shorthand as we shall see later.
%
%  As we don't make every single |m| argument a separate grabber all
%  other types must clear out any pending |m|s.
%
%  \paragraph{Mandatory arguments}
%
%  Below follows the implementation of mandatory arguments.
%
%  \begin{macro}{\xparse_add_arg_type_m:}
%  If we hit a special marker earlier we insert that type, otherwise we
%  just put an |m| on the stack of non-|\long| argument grabbers.
%    \begin{macrocode}
\def_new:Npn \xparse_add_arg_type_m: {
  \tlp_if_empty:NTF \l_xparse_special_marker_tlp
  { \int_incr:N \l_xparse_mandatory_args_int }
  {
    \toks_put_right:Nx \l_xparse_grabbed_args_toks {
      \exp_not:c {xparse_ \l_xparse_special_marker_tlp m:w }
    }
  }
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\xparse_add_remaining_m_args:}
%  And here is the function for clearing out normal pending |m|
%  arguments.
%    \begin{macrocode}
\def:Npn \xparse_add_remaining_m_args: {
  \int_compare:nNnF \l_xparse_mandatory_args_int = \c_zero
  {
    \toks_put_right:Nx \l_xparse_grabbed_args_toks {
      \exp_not:c{xparse_m
        \int_use:N \l_xparse_mandatory_args_int
        :w }
    }
    \int_zero:N \l_xparse_mandatory_args_int
  }
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\xparse_m1:w}
%  \begin{macro}{\xparse_m2:w}
%  \begin{macro}{\xparse_m3:w}
%  \begin{macro}{\xparse_m4:w}
%  \begin{macro}{\xparse_m5:w}
%  \begin{macro}{\xparse_m6:w}
%  \begin{macro}{\xparse_m7:w}
%  \begin{macro}{\xparse_m8:w}
%  \begin{macro}{\xparse_m9:w}
%  Grabbing 1--9 mandatory arguments. The one grabbing nine arguments
%  will automatically end with
%  |\toks_use:N \l_xparse_grabbed_args_toks| anyway so we avoid
%  problems with that one.
%    \begin{macrocode}
\def_new:cpn {xparse_m1:w} #1 \l_xparse_grabbed_args_toks#2{
  \toks_put_right:Nn \l_xparse_grabbed_args_toks{{#2}}
  #1 \l_xparse_grabbed_args_toks
}
\def_new:cpn {xparse_m2:w} #1 \l_xparse_grabbed_args_toks #2#3{
  \toks_put_right:Nn \l_xparse_grabbed_args_toks{{#2}{#3}}
  #1 \l_xparse_grabbed_args_toks
}
\def_new:cpn {xparse_m3:w} #1 \l_xparse_grabbed_args_toks #2#3#4{
  \toks_put_right:Nn \l_xparse_grabbed_args_toks{{#2}{#3}{#4}}
  #1 \l_xparse_grabbed_args_toks
}
\def_new:cpn {xparse_m4:w} #1 \l_xparse_grabbed_args_toks #2#3#4#5{
  \toks_put_right:Nn \l_xparse_grabbed_args_toks{{#2}{#3}{#4}{#5}}
  #1 \l_xparse_grabbed_args_toks
}
\def_new:cpn {xparse_m5:w} #1 \l_xparse_grabbed_args_toks #2#3#4#5#6{
  \toks_put_right:Nn \l_xparse_grabbed_args_toks{{#2}{#3}{#4}{#5}{#6}}
  #1 \l_xparse_grabbed_args_toks
}
\def_new:cpn {xparse_m6:w} #1 \l_xparse_grabbed_args_toks #2#3#4#5#6#7{
  \toks_put_right:Nn \l_xparse_grabbed_args_toks
                     {{#2}{#3}{#4}{#5}{#6}{#7}}
  #1 \l_xparse_grabbed_args_toks
}
\def_new:cpn {xparse_m7:w} #1 \l_xparse_grabbed_args_toks#2#3#4#5#6#7#8{
  \toks_put_right:Nn \l_xparse_grabbed_args_toks
                     {{#2}{#3}{#4}{#5}{#6}{#7}{#8}}
  #1 \l_xparse_grabbed_args_toks
}
\def_new:cpn {xparse_m8:w} #1\l_xparse_grabbed_args_toks
                                                       #2#3#4#5#6#7#8#9{
  \toks_put_right:Nn \l_xparse_grabbed_args_toks
                     {{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}}
  #1 \l_xparse_grabbed_args_toks
}
\def_new:cpn {xparse_m9:w} \toks_use:N \l_xparse_grabbed_args_toks
                                                     #1#2#3#4#5#6#7#8#9{
  \toks_put_right:Nn \l_xparse_grabbed_args_toks
                     {{#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}}
  \toks_use:N \l_xparse_grabbed_args_toks
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\xparse_allowpar_m:w}
%  The |m| type allowing |\par| tokens. We only define one of them as
%  two in a row would be quite rare.
%    \begin{macrocode}
\def_long_new:Npn \xparse_allowpar_m:w #1 \l_xparse_grabbed_args_toks#2{
  \toks_put_right:Nn \l_xparse_grabbed_args_toks{{#2}}
  #1 \l_xparse_grabbed_args_toks
}
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\xparse_obeyspace_m:w}
%  This one should never happen but it might happen to some user who
%  types |Wm|. We just let it be the same as a normal argument.
%    \begin{macrocode}
\let_new:Nc \xparse_obeyspace_m:w {xparse_m1:w}
%    \end{macrocode}
%  \end{macro}
%
%  \paragraph{Adding a symbol argument type}
%
%  \begin{macro}{\xparse_add_arg_type_S:}
%  \begin{macro}{\xparse_S:w}
%  \begin{macro}{\xparse_obeyspace_S:w}
%  Implementing the |S| type is fairly straight forward. It needs to
%  grab a default argument. First we must clear out any pending |m|
%  arguments.
%    \begin{macrocode}
\def_new:Npn \xparse_add_arg_type_S: {
  \xparse_add_remaining_m_args:
  \toks_put_right:Nx \l_xparse_grabbed_args_toks
  { \exp_not:c {xparse_ \l_xparse_special_marker_tlp S:w } }
  \let:Nc \xparse_read_arg_type_or_grab_default:n
          {xparse_grab_default_ \l_xparse_special_marker_tlp arg:n}
}
%    \end{macrocode}
%  The actual grabber functions just issue a
%  |\peek_remove_char_spaces:NTF| on the symbol chosen. If found, we
%  put a |\c_true| on the argument stack and |\c_false| otherwise.
%    \begin{macrocode}
\def_new:Npn \xparse_S:w #1 #2 \l_xparse_grabbed_args_toks{
  \peek_remove_char_spaces:NTF #1
  {
    \toks_put_right:Nn \l_xparse_grabbed_args_toks \c_true
    #2 \l_xparse_grabbed_args_toks
  }
  {
    \toks_put_right:Nn \l_xparse_grabbed_args_toks \c_false
    #2 \l_xparse_grabbed_args_toks
  }
}
%    \end{macrocode}
%  Same as above but obeys spaces when peeking ahead.
%    \begin{macrocode}
\def_new:Npn \xparse_obeyspace_S:w #1 #2 \l_xparse_grabbed_args_toks{
  \peek_remove_char:NTF #1
  {
    \toks_put_right:Nn \l_xparse_grabbed_args_toks \c_true
    #2 \l_xparse_grabbed_args_toks
  }
  {
    \toks_put_right:Nn \l_xparse_grabbed_args_toks \c_false
    #2 \l_xparse_grabbed_args_toks
  }
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%  \paragraph{Adding delimited arguments}
%
%
%  \begin{macro}{\DeclareArgumentType}
%  Argument types that read their argument delimited as the |o| type
%  can be defined with this function. |#1| is the letter associated
%  with the type, |#2| the left delimiter \LaTeX{} will look for, |#3|
%  can be used for an error message or such in case of a missing value,
%  and |#4| the value inserted in case the optional argument is missing.
%  The last two arguments control how the arguments are picked up and
%  parsed on to the inner parsing.
%    \begin{macrocode}
\def:Npn \DeclareArgumentType #1#2#3#4#5#6{
  \def:cpn {xparse_#1:w}##1\l_xparse_grabbed_args_toks{
    \peek_char_spaces:NTF #2
    { \use:c{xparse_#1_help:nw}{##1} }
    {
      #3 \toks_put_right:Nn \l_xparse_grabbed_args_toks {#4}
      ##1 \l_xparse_grabbed_args_toks
    }
  }
  \def:cpn {xparse_obeyspace_#1:w}##1\l_xparse_grabbed_args_toks{
    \peek_char:NTF #2
    { \use:c{xparse_#1_help:nw}{##1} }
    {
      #3 \toks_put_right:Nn \l_xparse_grabbed_args_toks {#4}
      ##1 \l_xparse_grabbed_args_toks
    }
  }
  \def_long:cpn {xparse_allowpar_#1:w}##1\l_xparse_grabbed_args_toks{
    \peek_char_spaces:NTF #2
    { \use:c{xparse_allowpar_#1_help:nw}{##1} }
    {
      #3 \toks_put_right:Nn \l_xparse_grabbed_args_toks {#4}
      ##1 \l_xparse_grabbed_args_toks
    }
  }
  \def:cpn {xparse_add_arg_type_#1:}
  {
    \xparse_add_remaining_m_args:
    \toks_put_right:Nx \l_xparse_grabbed_args_toks
    {\exp_not:c {xparse_ \l_xparse_special_marker_tlp #1:w}}
  }
  \xparse_define_helper:Nnn #1{#5}{#6}
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\DeclareArgumentTypeDefaultValue}
%  The same as above but expects a default value in the signature.
%  Therefore it doesn't have the arguments of the default value and
%  what to do if it is missing like the above.
%    \begin{macrocode}
\def_new:Npn \DeclareArgumentTypeDefaultValue #1#2#3#4{
  \def:cpn {xparse_#1:w}##1##2\l_xparse_grabbed_args_toks{
    \peek_char_spaces:NTF #2
    { \use:c{xparse_#1_help:nw} {##2} }
    {
      \toks_put_right:Nn \l_xparse_grabbed_args_toks {{##1}}
      ##2 \l_xparse_grabbed_args_toks }
  }
  \def:cpn {xparse_obeyspace_#1:w}##1##2\l_xparse_grabbed_args_toks{
    \peek_char:NTF #2
    { \use:c{xparse_#1_help:nw} {##2} }
    {
      \toks_put_right:Nn \l_xparse_grabbed_args_toks {{##1}}
      ##2 \l_xparse_grabbed_args_toks
    }
  }
  \def_long:cpn {xparse_allowpar_#1:w}##1##2\l_xparse_grabbed_args_toks{
    \peek_char_spaces:NTF #2
    { \use:c{xparse_allowpar_#1_help:nw}{##2} }
    {
      \toks_put_right:Nn \l_xparse_grabbed_args_toks {{##1}}
      ##2 \l_xparse_grabbed_args_toks
    }
  }
%    \end{macrocode}
%  Now the function for adding the type when the signature is parsed.
%  Once added to |\l_xparse_grabbed_args_toks| we set it equal to the
%    \begin{macrocode}
  \def:cpn {xparse_add_arg_type_#1:}{
    \xparse_add_remaining_m_args:
    \toks_put_right:Nx \l_xparse_grabbed_args_toks
    { \exp_not:c {xparse_ \l_xparse_special_marker_tlp #1:w} }
    \let:Nc \xparse_read_arg_type_or_grab_default:n
    {xparse_grab_default_ \l_xparse_special_marker_tlp arg:n}
  }
  \xparse_define_helper:Nnn #1{#3}{{#4}}
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\xparse_define_helper:Nnn}
%  All we need now is the helper functions. We define a generic
%  interface that should be fairly easy to use.
%    \begin{macrocode}
\def:Npn \xparse_define_helper:Nnn #1#2#3{
  \toks_set:Nn \l_tmpa_toks
  {
    #2
    {
      \toks_put_right:Nn \l_xparse_grabbed_args_toks {#3}
      ##1 \l_xparse_grabbed_args_toks
    }
  }
%    \end{macrocode}
%  The next bit looks a little ugly but that's life.
%    \begin{macrocode}
  \toks_set:Nx \l_tmpa_toks {
    \exp_not:n {\def:cpn{xparse_#1_help:nw}}
    \toks_use:N \l_tmpa_toks
    \exp_not:n {\def:cpn{xparse_allowpar_#1_help:nw}}
    \toks_use:N\l_tmpa_toks
  }
  \toks_use:N \l_tmpa_toks
}
%    \end{macrocode}
%  \end{macro}
%
%  All the above may seem like an awful lot of trouble but it is
%  general and it allows the following simple definitions:
%    \begin{macrocode}
\DeclareArgumentType o[{}{\NoValue}{#1[#2]}{{#2}}
%    \end{macrocode}
%  For the |c| type we add give an error message.
%    \begin{macrocode}
\DeclareArgumentType c({
  \xparse_error:x{
    Missing~ coordinate~ argument.~ A~ value~ of~ (0,0)~ is~ assumed}
  }
  {{00}}
  {#1(#2,#3)}{{{#2}{#3}}}
\DeclareArgumentTypeDefaultValue O[{#1[#2]}{#2}
\DeclareArgumentTypeDefaultValue C({#1(#2,#3)}{{#2}{#3}}
%    \end{macrocode}
%
%
%
% Wishful thinking:
%    \begin{macrocode}
%\DeclareArgumentType b<{}{\NoValue}{#1<#2>}{#2}
%\DeclareArgumentTypeDefaultValue B<{#1<#2>}{#2}
% \DeclareArgumentType b{<#1>}{{#1}}{}{\NoValue}
% \DeclareArgumentTypeWithDefault B{<#1>}{{#1}}
%    \end{macrocode}
%
%
%  \subsubsection{Argument shorthands}
%
%
%  \begin{macro}{\DeclareArgumentTypeShorthand}
%  Letting a letter or symbol be a shorthand for a more complicated
%  structure is rather easy actually. Due to the order in which
%  commands are called in the main loop |\xparse_parse_signature:n|
%  we know that that particular control sequence will be waiting right
%  after calling |\xparse_add_arg_type_|\meta{X}|:|. So when defining a
%  shorthand we simply gobble the |\xparse_parse_signature:n|,
%  decrement the counter keeping track of the number of arguments so
%  that it still has the right value, and then put
%  |\xparse_parse_signature:n| back into the input stream with the
%  value of the shorthand in front of it. The disadvantage of this
%  scheme is that we have to cheat and give it the wrong name as it
%  should have a |w| argument specification but I hope you can forgive
%  this little white lie.
%    \begin{macrocode}
\def_new:Npn \DeclareArgumentTypeShorthand #1#2{
  \def_new:cpn {xparse_add_arg_type_#1:}
    \xparse_read_arg_type_or_grab_default:n {
    \int_decr:N \l_xparse_total_args_int
    \xparse_read_arg_type_or_grab_default:n #2
  }
}
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\xparse_add_arg_type_s:}
%  Defining the |s| type is easy now since it really means |S{*}|
%    \begin{macrocode}
\DeclareArgumentTypeShorthand s {S{*}}
%    \end{macrocode}
%  \end{macro}


%  \subsection{Checking for optional values}
%
%
%  \begin{macro}{\BooleanTrue}
%  \begin{macro}{\BooleanFalse}
%  \begin{macro}{\IfBooleanTF}
%  \begin{macro}{\IfBooleanT}
%  \begin{macro}{\IfBooleanF}
%  The logical \meta{true} and \meta{false} statements are just our
%  normal |\c_true| and |\c_false|.
%    \begin{macrocode}
\let_new:NN \BooleanTrue \c_true
\let_new:NN \BooleanFalse \c_false
%    \end{macrocode}
%  Checking for the presence of a star or a symbol is done with these
%  commands that are simply lifted from \textsf{l3prg}.
%    \begin{macrocode}
\let_new:NN \IfBooleanTF \prg_logic_test:nTF
\let_new:NN \IfBooleanT \prg_logic_test:nT
\let_new:NN \IfBooleanF \prg_logic_test:nF
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\NoValue}
%  |\NoValue| is just a text string and we define it as a token list
%  pointer.
%    \begin{macrocode}
\tlp_new:Nn \NoValue {-NoValue-}
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\IfNoValueTF}
%  \begin{macro}{\IfNoValueT}
%  \begin{macro}{\IfNoValueF}
%  \begin{macro}{\IfValueTF}
%  \begin{macro}{\IfValueT}
%  \begin{macro}{\IfValueF}
%  |\IfNoValueTF| and its varieties are implemented as subcases of
%  |\tlist_if_eq_alt:onTF|.
%    \begin{macrocode}
\def_new:Npn \IfNoValueTF {\tlist_if_eq_alt:onTF \NoValue}
\def_new:Npn \IfNoValueT #1#2{\tlist_if_eq_alt:onTF \NoValue{#1}{#2}{}}
\def_new:Npn \IfNoValueF #1 {\tlist_if_eq_alt:onTF \NoValue {#1}{}}
%    \end{macrocode}
%  For |\IfValueTF| we just reverse the arguments.
%    \begin{macrocode}
\def_new:Npn \IfValueTF #1#2#3 {
  \tlist_if_eq_alt:onTF \NoValue {#1}{#3}{#2}
}
\let_new:NN \IfValueT \IfNoValueF
\let_new:NN \IfValueF \IfNoValueT
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
% \Finale
%
\endinput
%
% $Log$
% Revision 1.20  2005/04/06 21:24:47  morten
% Total rewrite - there is only one implementation in the package now. Documentation updated to match the changes.
%
%
%
