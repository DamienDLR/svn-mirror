% \iffalse
%% File: xparse.dtx (C) Copyright 1999 Frank Mittelbach, Chris Rowley, 
%%                      David Carlisle
%%                  (C) Copyright 2004-2008 Frank Mittelbach, 
%%                      LaTeX3 Project
%%                  (C) Copyright 2009 LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xbase bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%% 
%
%<*driver|package>
\RequirePackage{l3names}
%</driver|package>
%\fi
\GetIdInfo$Id$
  {Generic document command parser}
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass{l3doc}
\begin{document}
  \DocInput{xparse.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{xparse} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Generic document command parser}
% \author{\Team}
% \date{\filedate}
% \maketitle
%
%\begin{documentation}
%
%\section{Creating document commands}
%
% The \pkg{xparse} package provides a high-level interface for
% producing document-level commands. In that way, it is intended as
% a replacement for the \LaTeXe\ \cs{newcommand} macro. However,
% \pkg{xparse} works so that the interface to a function (optional
% arguments, stars and mandatory arguments, for example) is separate
% from the internal implementation. \pkg{xparse} provides a normalised
% input for the internal form of a function, independent of the 
% document-level argument arrangement.
% 
%\subsection{Specifying arguments}
%
% Before introducing the functions used to create document commands,
% the method for specifiying arguments with \pkg{xparse} will be 
% illustrated. In order to allow each argument to be defined 
% independently, \pkg{xparse} does not simply need to know the 
% number of arguments for a function, but also the nature of each
% one. This is done by constructing an \emph{argument specification},
% which defines the number of arguments, the type of each argument
% and any additional information needed for \pkg{xparse} to read the
% user input and properly pass it thorugh to internal functions. 
% 
% The basic form of the argument specifier is a list of letters, where
% each letter defines a type of argument. As will be described below,
% some of the types need additional information, such as default values.
% The argument types can be divided into two, those which define 
% arguments that are mandatory (potentially raising an error if not 
% found) and those which define optional arguments. The mandatory types
% are:
%\begin{itemize}[font=\ttfamily]
%  \item[m] A standard mandatory argument, which can either be a single
%    token alone or multiple tokens surrounded by curly braces.
%    Regardless of the input, the argument will be passed to the
%    internal code surrounded by a brace pair. This is the \pkg{xparse}
%    type specifier for a normal \TeX\ argument.
%  \item[l] An argument which reads everything up to the first
%    open group token: in standard \LaTeX\ this is a left brace. 
%  \item[u] Reads an argument `until' \meta{tokens} are encountered,
%    where the desired \meta{tokens} are given as an argument to the
%    specifier: \texttt{u}\marg{tokens}.
%\end{itemize}
% The types which define optional arguments are:
%\begin{itemize}[font=\ttfamily]
%  \item[o] A standard \LaTeX\ optional argument, surrounded with square 
%    brackets, which will supply
%    the special \cs{NoValue} token if not given (as described later).
%  \item[d] An optional argument which is delimited by \meta{token1}
%    and \meta{token2}, which are given as arguments: 
%    \texttt{d}\meta{token1}\meta{token2}. As with \texttt{o}, if no
%    value is given the special token \cs{NoValue} is returned.
%  \item[O] As for \texttt{o}, but returns \meta{default} if no
%    value is given.  Should be given as \texttt{O}\marg{default}.
%  \item[D] As for \texttt{d}, but returns \meta{default} if no
%    value is given: \texttt{D}\meta{token1}\meta{token2}\marg{default}.
%    Internally, the \texttt{o}, \texttt{d} and \texttt{O} types are
%    shortcuts to an appropriated-constructed \texttt{D} type argument.
%  \item[s] An optional star, which will result in a value 
%    \cs{BooleanTrue} if a star is present and \cs{BooleanFalse}
%    otherwise (as described later).
%  \item[t] An optional \meta{token}, which will result in a value 
%    \cs{BooleanTrue} if \meta{token} is present and \cs{BooleanFalse}
%    otherwise. Given as \texttt{t}\meta{token}.
%  \item[g] An optional argument given inside a pair of \TeX\ group
%    tokens (in standard \LaTeX, |{| \ldots |}|).
%\end{itemize}
%
% Using these specifiers, it is possible to create complex input syntax
% very easily. For example, given the argument definition 
% `|s o o m O{default}|', the input `|*[Foo]{Bar}|' would be parsed as:
%\begin{itemize}[nolistsep]
%  \item |#1| = |\BooleanTrue|
%  \item |#2| = |{Foo}|
%  \item |#3| = |\NoValue|
%  \item |#4| = |{Bar}|
%  \item |#5| = |{default}|
%\end{itemize}
% whereas `|[One][Two]{}[three]|' would be parsed as:
%\begin{itemize}[nolistsep]
%  \item |#1| = |\BooleanFalse|
%  \item |#2| = |{One}|
%  \item |#3| = |{Two}|
%  \item |#4| = |{}|
%  \item |#5| = |{Three}|
%\end{itemize}
% Note that after parsing the input there will be always exactly the 
% same number of brace groups or tokens as the number of letters in the 
% argument specifier.
% 
% Two more tokens have a special meaning when creating an argument 
% specifier. First, \texttt{+} is used to make an argument long (to 
% accept paragraph tokens). In contrast to \LaTeXe's \cs{newcommand}, 
% this applies on an argument-by-argument basis. So modifying the 
% example to `|s o o +m O{default}|' means that the mandatory argument 
% is now \cs{long}, whereas the optional arguments are not.
% 
% Secondly, the token \texttt{>} is used to declare so-called
% `argument processors', which can be used to modify the contents of an
% argument before it is passed to the macro definition. The use of 
% argument processors is a somewhat advanced topic, (or at least a less 
% commonly used feature) and is covered in Section~\ref{sec:processors}.
% 
%\subsection{Declaring commands and environments}
% 
% With the concept of an argument specifier defined, it is now 
% possible to describe the methods available for creating both
% functions and environments using \pkg{xparse}.
% 
% The interface-building commands are the preferred method for 
% creating document-level functions in \LaTeX3. All of the functions 
% generated in this way are naturally robust (using the \eTeX\ 
% \cs{protected} mechanism).
% 
%\begin{function}{
%  \DeclareDocumentCommand|
%  \NewDocumentCommand|
%  \RenewDocumentCommand|
%  \ProvideDocumentCommand
%}
%  \begin{syntax}
%    "\DeclareDocumentCommand" <function> \Arg{arg spec} \Arg{code}
%  \end{syntax}
%  This family of commands are used to create a document-level
%  <function>. The argument specification for the function is
%  given by <arg spec>, and the function will execute <code>.
%  
%  As an example:
%  \begin{verbatim}
%    \DeclareDocumentCommand \chapter { s o m } {
%      \IfBooleanTF {#1} {
%        \typesetnormalchapter {#2} {#3} 
%      }{
%        \typesetstarchapter {#3}
%      }
%    }
%  \end{verbatim}
%  would be a way to define a \cs{chapter} command which would
%  essentially behave like the current \LaTeXe\ command (except that it
%  would accept an optional argument even when a \texttt{*} was parsed).
%  The \cs{typesetnormalchapter} could test its first argument for being
%  \cs{NoValue} to see if an optional argument was present.
% 
%  The difference between the \cs{Declare\ldots}, \cs{New\ldots}
%  \cs{Renew\ldots} and \cs{Provide\ldots} versions is the behaviour
%  if <function> is already defined. 
%  \begin{itemize}
%    \item \cs{DeclareDocumentCommand} will always create the new 
%      definition, irrespective of any existing <function> with the 
%      same name. 
%   \item \cs{NewDocumentCommand} will issue an error if <function>
%     has already been defined.
%   \item \cs{RenewDocumentCommand} will issue an error if <function>
%     has not previously been defined.
%   \item \cs{ProvideDocumentCommand} creates a new definition for
%     <function> only if one has not already been given.
%  \end{itemize}  
%  
%  \begin{texnote}
%     Unlike \LaTeXe's \cs{newcommand} and relatives, the 
%     \cs{DeclareDocumentCommand} function do not prevent creation of 
%     functions with names starting \cs{end\ldots}.
%  \end{texnote}
%\end{function} 
%
%\begin{function}{%
%  \DeclareDocumentEnvironment|
%  \NewDocumentEnvironment|
%  \RenewDocumentEnvironment|
%  \ProvideDocumentEnvironment
%}
%  \begin{syntax}
%    "\DeclareDocumentEnvironment" \Arg{environment} \Arg{arg spec}
%    ~~~~\Arg{start code} \Arg{end code}
%  \end{syntax}
%  These commands work in the same way as \cs{DeclareDocumentCommand},
%  etc., but create environments (\cs{begin}|{|<function>|}| \ldots
%  \cs{end}|{|<function>|}|). Both the <start code> and <end code>
%  may access the arguments as defined by <arg spec>.
%  
%  \begin{texnote}
%    When loaded as part of a \LaTeX3 format, these, these commands do
%    not create a pair of macros \cs{<environment>} and 
%    \cs{end<environment>}. Thus \LaTeX3 environments have to be 
%    accessed using the \cs{begin} \ldots \cs{end} mechanism. When 
%    \pkg{xparse} is loaded as a \LaTeXe\ package, \cs{<environment>}
%    and \cs{end<environment>} are defined, as this is necessary to 
%    allow the new environment to work!
%  \end{texnote}
%\end{function}
%
%\subsection{Testing special values}
%
% Optional arguments created using \pkg{xparse} make use of dedicated
% variables to return information about the nature of the argument
% received.
%
%\begin{variable}{\NoValue} 
%  \cs{NoValue} is a special marker returned by \pkg{xparse} if no 
%  value is given for an optional argument. If typeset (which should
%  not happen),  it will print the value \texttt{-NoValue-}.
%\end{variable}
%
%\begin{function}{\IfNoValue / (TF) (EXP)}
%  \begin{syntax}
%    "\IfNoValueTF" \Arg{argument} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  The \cs{IfNoValue} tests are used to check if <argument> (|#1|,
%  |#2|, etc.) is the special \cs{NoValue} token. For example
%  \begin{verbatim}
%    \DeclareDocumentCommand \foo { o m } {
%      \IfNoValueTF {#1} {
%        \DoSomethingJustWithMandatoryArgument {#2}
%      }{
%        \DoSomethingBothArguments {#1} {#2}
%      }
%    }
%  \end{verbatim}
%  will use a different internal function if the optional argument
%  is given than if it is not present.
%  
%  As the \cs{IfNoValue} tests are expandable, it is possible to test
%  these values later, for example at the point of typesetting or in
%  an expansion context.
%\end{function}
%
%\begin{variable}{
%  \BooleanFalse|
%  \BooleanTrue
%} 
%  The \texttt{true} and \texttt{false} flags set when searching for
%  an optional token (using \texttt{s} or \texttt{t}<token>) have
%  names which are accessible outside of code blocks. 
%\end{variable}
%
%\begin{function}{\IfBoolean / (TF) (EXP)}
%  \begin{syntax}
%    "\IfBooleanTF" <argument> \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Used to test if <argument> (|#1|, |#2|, etc.) is \cs{BooleanTrue}
%  or \cs{BooleanFalse}. For example
%  \begin{verbatim}
%    \DeclareDocumentCommand \foo { s m } {
%      \IfBooleanTF #1 {
%        \DoSomethingWithStar {#2} 
%      }{
%        \DoSomethingWithoutStar {#2}
%      }  
%    }
%  \end{verbatim}
%  checks for a star as the first argument, then chooses the action to
%  take based on this information.
%\end{function}
%
%\subsection{Argument processors}
%\label{sec:processors}
%
% \pkg{xparse} introduces the idea of an argument processor, which is
% applied to an argument \emph{after} it has been grabbed by the 
% underlying system but before it is passed to \meta{code}. An argument 
% processor can therefore be used to regularise input at an early stage, 
% allowing the internal functions to be completely independent of input 
% form. Processors are applied to user input and to default values for
% optional arguments, but \emph{not} to the special \cs{NoValue} marker.
% 
% Each argument processor is specified by the syntax 
% \texttt{>}\marg{processor} in the argument specification. Processors
% are applied from right to left, so that 
%\begin{verbatim}
%  >{\ProcessorB} >{\ProcessorA} m
%\end{verbatim}
% would apply \cs{ProcessorA} 
% followed by \cs{ProcessorB} to the tokens grabbed by the \texttt{m} 
% argument. 
%
%\begin{variable}{\l_xparse_arg_toks}
%  \pkg{xparse} defines a very small set of processor functions. In the
%  main, it is anticipated that code writers will want to create their
%  own processors. These need to accept one argument, which is the
%  tokens as grabbed (or as returned by a previous processor function).
%  Processor functions should return the processed argument in the
%  variable \cs{l_xparse_arg_toks}. This will always be empty when the
%  processor function is called by \pkg{xparse}, even if more than one
%  argument processor is applied.
%\end{variable}
% 
%\begin{function}{\xparse_process_to_str:n}
%  \begin{syntax}
%    "\xparse_process_to_str:n" \Arg{grabbed argument}
%  \end{syntax}
%  The \cs{xparse_process_to_str:n} processor applies the \LaTeX3
%  \cs{tl_to_str:n} function to the <grabbed argument>. For example
%  \begin{verbatim}
%    \DeclareDocumentCommand \foo { >{\xparse_arg_to_str:n} m } {
%      #1 % Which is now detokenized
%    }
%  \end{verbatim}
%\end{function}
%
%\begin{function}{\xparse_process_comma_split:n}
%  \begin{syntax}
%    "\xparse_process_comma_split:n" \Arg{grabbed argument}
%  \end{syntax}
%  The \cs{xparse_process_comma_split:n} processor splits the 
%  grabbed argument at the first comma, returning the two
%  parts of the result in braces. If no comma is found, the second
%  part of the returned value is empty. This function is intended to
%  aid the processing of co-ordinate pairs. For example, to create
%  a co-ordinate argument which raises an error if not given:
%  \begin{verbatim}
%    \DeclareDocumentCommand \foo 
%      { >{\xparse_process_comma_split:n} d() } {
%        \IfNoValueTF #1 {
%          \ERROR
%        }{
%          \foo_internal:nn #1
%        }
%      }  
%  \end{verbatim}
%  For the input |\foo(1.1,2.2)|, |#1| here would equal |{1.1}{2.2}|,
%  and so \cs{foo_internal:nn} receives exactly the correct number of
%  arguments. A similar function which takes an optional co-ordinate
%  pair, could be created as:
%  \begin{verbatim}
%    \DeclareDocumentCommand \foo 
%      { >{\xparse_process_comma_split:n} D(){0,0} } {
%          \foo_internal:nn #1
%      }  
%  \end{verbatim}
%  This illustrates that the processor function will be applied to the 
%  default value, which therefore includes a comma.
%\end{function}
%
%\subsection{Fully-expandable document commands}
%
% There are \emph{very rare} occasion when it may be useful to create
% fully expandable document commands. To support this, \pkg{xparse}
% can create expandable functions as well as the usual robust
% ones. This imposes a number of restrictions on the nature of the
% arguments accepted by a function, and the code it implements. 
% This facility should only be used when \emph{absolutely necessary};
% if you do not understand when this might be, \emph{do not use these
% functions}!
% 
%\begin{function}{
%  \DeclareExpandableDocumentCommand|
%  \NewExpandableDocumentCommand|
%  \RenewExpandableDocumentCommand|
%  \ProvideExpandableDocumentCommand
%}
%  \begin{syntax}
%    "\DeclareExpandableDocumentCommand" <function> 
%    ~~~~\Arg{arg spec} \Arg{expandable code}
%  \end{syntax}
%  This family of commands are used to create a document-level
%  <function>. The argument specification for the function is
%  given by <arg spec>, and the function will execute <expandable code>.
%  
%  Parsing arguments expandability imposes a number of restrictions on 
%  both the type of arguments that can be read and the error checking 
%  available:
%  \begin{itemize}
%    \item The last argument of the function must be mandatory
%      (type \texttt{l}, \texttt{m} or \texttt{u}).
%    \item All arguments are either short or long: it is not possible
%      to mix short and long argument types.
%    \item The `optional group' argument types \texttt{g} and
%      \texttt{G} are not available.
%    \item It is not possible to differentiate between, for example
%      |\foo[stuff]{argument}| and |\foo{[}]{argument}|. As a
%      result, checking for optional arguments is less robust than 
%      in the standard version.
%  \end{itemize} 
%  \pkg{xparse} will issue an error if an argument specifier is given
%  which does not conform to the first three requirements. The last
%  item is an issue when the function is used, and so is beyond the
%  scope of \pkg{xparse} itself.
%\end{function}  
%  
%\subsection{Variables and constants}
%
%\begin{variable}{\c_xparse_shorthands_prop}
%  Shorthands and replacement text.
%\end{variable}
%
%\begin{variable}{\l_xparse_args_toks}
%  Token register for arguments as they are picked up for passing on to
%  user functions.
%\end{variable}
%
%\begin{variable}{\l_xparse_environment_args_toks}
%  Token register to pass arguments to the end of an environment from
%  the beginning.
%\end{variable}
%
%\begin{variable}{\l_xparse_error_bool}
%  For flagging up errors when making expandable commands.
%\end{variable}
%
%\begin{variable}{\l_xparse_function_tl}
%  Needed to pass along the function name when creating in an expandable
%  manner.
%\end{variable}
%
%\begin{variable}{\l_xparse_last_arg_tl}
%  The last argument type added: must be mandatory for expandable
%  commands.
%\end{variable}
%
%\begin{variable}{\l_xparse_long_bool}
%  Flag used to indicate creation of \cs{long} arguments.
%\end{variable}
%
%\begin{variable}{\l_xparse_m_args_int}
%  Used to enumerate the \texttt{m} arguments with no modifications.
%\end{variable}
%
%\begin{variable}{\l_xparse_m_only_bool}
%  Flag used to indicate that all arguments are of type \texttt{m}.
%\end{variable}
%
%\begin{variable}{
%  \l_xparse_processor_int|
%  \l_xparse_processor_use_int
%}
%  For counting up processors as defined and as used, respectively.
%\end{variable}
%
%\begin{variable}{\l_xparse_signature_toks}
%  For constucting the signature of the functionm defined.
%\end{variable}
%
%\begin{variable}{\l_xparse_tmp_tl}
%  Scratch space.
%\end{variable}
%
%\begin{variable}{\l_xparse_total_args_int}
%  Used to enumerate the total number of arguments.
%\end{variable}
%
%\begin{variable}{\q_xparse_stop}
%  A private delimiting quark.
%\end{variable}
%
%\subsection{Internal functions}
%
%\begin{function}{\xparse_add_arg:n}
%  \begin{syntax}
%    "\xparse_add_arg:n" <grabbed arg>
%  \end{syntax}
%  Adds <grabbed arg> to the output \pkg{xparse} supplies to the
%  defined <code>, applying any post-processing that is needed.
%\end{function}
%
%\begin{function}{\xparse_add_grabber:N}
%  \begin{syntax}
%    "\xparse_add_grabber:N" <grabber type>
%  \end{syntax}
%  Adds appropriate grabber for <grabber type> to the signature
%  being constructed, making it \cs{long} if necessary.
%\end{function}
%
%\begin{function}{
%  \xparse_add_type_+:|
%  \xparse_add_type_>:|
%  \xparse_add_type_d:|
%  \xparse_add_type_D:|
%  \xparse_add_type_g:|
%  \xparse_add_type_G:|
%  \xparse_add_type_l:|
%  \xparse_add_type_m:|
%  \xparse_add_type_t:|
%  \xparse_add_type_u:
%}
%  \begin{syntax}
%    "\xparse_add_type_u:"
%  \end{syntax}
%  Carry out necessary processes to add given <type> of argument to 
%  the signature being constructed.
%\end{function}
%
%\begin{function}{\xparse_check_and_add:N}
%  \begin{syntax}
%    "\xparse_check_and_add:N" <arg spec>
%  \end{syntax}
%  Ensures that <arg spec> is valid, and if so adds it to the signature
%  being constructed.
%\end{function}
%
%\begin{function}{
%  \xparse_declare_cmd:Nnn|
%  \xparse_declare_cmd:cnn
%}
%  \begin{syntax}
%    "\xparse_declare_cmd:Nnn" <function> \Arg{signature}
%    ~~~~\Arg{code}
%  \end{syntax}
%  Declares <function> using <signature> for argument definition and
%  <code> as expansion.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareDocumentCommand}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\xparse_declare_env:nnnn}
%  \begin{syntax}
%    "\xparse_declare_env:nnnn" \Arg{env} \Arg{arg spec}
%    ~~~~\Arg{start code} \Arg{end code}
%  \end{syntax}
%  Declares <env> as an environment taking <arg spec> arguments 
%  at \cs{begin}\{<env>\}. The <start code> is eceutre at the beginning
%  of the environment, and the <end code> at the end. Both parts may
%  use the arguments defined by <arg spec>.
%  \begin{texnote}
%    This is the internal name for \cs{DeclareDocumentEnvironment}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{\xparse_flush_m_args:}
%  \begin{syntax}
%    "\xparse_flush_m_args:" 
%  \end{syntax}
%  Adds an outstanding \texttt{m} arguments to the signature.
%\end{function}
%
%\begin{function}{
%  \xparse_grab_D:w     |
%  \xparse_grab_D_long:w|
%  \xparse_grab_G:w     |
%  \xparse_grab_G_long:w|
%  \xparse_grab_l:w     |
%  \xparse_grab_l_long:w|
%  \xparse_grab_m:w     |
%  \xparse_grab_m_long:w|
%  \xparse_grab_m_1:w   |
%  \xparse_grab_m_2:w   |
%  \xparse_grab_m_3:w   |
%  \xparse_grab_m_4:w   |
%  \xparse_grab_m_5:w   |
%  \xparse_grab_m_6:w   |
%  \xparse_grab_m_7:w   |
%  \xparse_grab_m_8:w   |
%  \xparse_grab_t:w     |
%  \xparse_grab_t_long:w|
%  \xparse_grab_u:w     |
%  \xparse_grab_u_long:w
%}
%  \begin{syntax}
%    "\xparse_grab_D:w" <arg data> "\l_xparse_args_toks"
%  \end{syntax}
%  Argument grabbing functions, which re-arrange other <arg data>
%  so that the argument is read correctly.
%\end{function}
%
%\begin{function}{\xparse_if_no_value:n / (TF) (EXP)}
%  \begin{syntax}
%    "\xparse_if_no_value:nTF" \Arg{arg}
%    ~~~~\Arg{true code} \Arg{false code}
%  \end{syntax}
%  Executes <true code> if <arg> is equal to the special 
%  \cs{NoValue} marker and <false code> otherwise.  
%\end{function}
%
%\begin{function}{
%  \xparse_prepare_signature:n|
%  \xparse_prepare_signature:N
%}
%  \begin{syntax}
%    "\xparse_prepare_signature:n"  \Arg{arg specs}
%  \end{syntax}
%  Parse one or more <arg specs> and convert to an output <signature>.  
%\end{function}
%
%\begin{function}{\xparse_process_arg:n}
%  \begin{syntax}
%    "\xparse_process_arg:n" \Arg{processor}
%  \end{syntax}
%  Sets up code to apply <processor> to next grabbed argument.
%\end{function}
%
%\begin{function}{\xparse_prepare_next:w}
%  \begin{syntax}
%    "\xparse_next:w"
%  \end{syntax}
%  Function to call to loop parsing of <arg spec>, which may need to
%  collect additional information for the previous <type>.
%\end{function}
%
%\subsection{Creating expandable commands}
%
%\begin{function}{
%  \xparse_exp_add_type_d:|
%  \xparse_exp_add_type_D:|
%  \xparse_exp_add_type_l:|
%  \xparse_exp_add_type_m:|
%  \xparse_exp_add_type_t:|
%  \xparse_exp_add_type_u:
%}
%  \begin{syntax}
%    "\xparse_exp_add_type_u:"
%  \end{syntax}
%  Carry out necessary processes to add given <type> of argument for
%  an expandable command.
%\end{function}
%
%\begin{function}{\xparse_exp_check_and_add:N}
%  \begin{syntax}
%    "\xparse_exp_check_and_add:N" <arg spec>
%  \end{syntax}
%  Ensures that <arg spec> is valid, and if so adds it to expandable
%  function being constructed.
%\end{function}
%
%\begin{function}{\xparse_exp_declare_cmd:Nnn}
%  \begin{syntax}
%    "\xparse_exp_declare_cmd:Nnn" <function> \Arg{signature}
%    ~~~~\Arg{code}
%  \end{syntax}
%  Declares <function> using <signature> for argument definition and
%  <code> as expansion, and creating an expandable command.
%  \begin{texnote}
%    This is the internal name for 
%    \cs{DeclareExpandableDocumentCommand}.
%  \end{texnote}
%\end{function}
%
%\begin{function}{
%  \xparse_exp_prepare_function:n|
%  \xparse_exp_prepare_function:N
%}
%  \begin{syntax}
%    "\xparse_exp_prepare_function:n"  \Arg{arg specs}
%  \end{syntax}
%  Parse one or more <arg specs> and convert to an expandable
%  function. 
%\end{function}
%
%\begin{function}{\xparse_exp_set:cpx}
%  \begin{syntax}
%    "\xparse_exp_set:cpx" <csname> <parameters> \Arg{code}
%  \end{syntax}
%  An alias for either \cs{cs_set:cpx} or \cs{cs_set_nopar:cpx},
%  depending on the \cs{long} status of the expandable function.
%\end{function}
%
%\end{documentation}
% 
%\begin{implementation}
%
%\section{\pkg{xparse} implementation}
%
% The usual lead-off: only needed for the package, of course (one day we
% may have a \LaTeX3 kernel).
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
\RequirePackage{expl3}
%</package>
%<*initex|package>
%    \end{macrocode}
%    
%\subsection{Variables and constants}
%
%\begin{macro}{\c_xparse_shorthands_prop}
% Shorthands are stored as a property list: this is set up here as it
% is a constant.
%    \begin{macrocode}
\prop_new:N \c_xparse_shorthands_prop
\prop_put:Nnn \c_xparse_shorthands_prop { o } { d[] }
\prop_put:Nnn \c_xparse_shorthands_prop { O } { D[] }
\prop_put:Nnn \c_xparse_shorthands_prop { s } { t* }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_arg_toks}
% Token registers for single grabbed argument when post-processing.
%    \begin{macrocode}
\toks_new:N \l_xparse_arg_toks
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_args_toks}
% Token registers for grabbed arguments.
%    \begin{macrocode}
\toks_new:N \l_xparse_args_toks
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_environment_args_toks}
% Used to pass arguments to the end of an environment.
%    \begin{macrocode}
\toks_new:N \l_xparse_environment_args_toks
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_error_bool}
% Used to signal an error when creating expandable functions.
%    \begin{macrocode}
\bool_new:N \l_xparse_error_bool
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_function_tl}
% When creating expandable functions, the current function name needs
% to be passed along.
%    \begin{macrocode}
\tl_new:N \l_xparse_function_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_last_arg_tl}
% Used when creating expandable arguments.
%    \begin{macrocode}
\toks_new:N \l_xparse_last_arg_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_long_bool}
% A flag for \cs{long} arguments.
%    \begin{macrocode}
\bool_new:N \l_xparse_long_bool
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_m_args_int}
% The number of simple \texttt{m} arguments is tracked so they can be
% dumped \emph{en masse}.
%    \begin{macrocode}
\int_new:N \l_xparse_m_args_int
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_m_only_bool}
% A flag to indicate that only \texttt{m} arguments have been found.
%    \begin{macrocode}
\bool_new:N \l_xparse_m_only_bool
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_processor_int}
%\begin{macro}{\l_xparse_processor_use_int}
% For keeping a count of post-processors and then using them.
%    \begin{macrocode}
\int_new:N \l_xparse_processor_int
\int_new:N \l_xparse_processor_use_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_xparse_signature_toks}
% Token registers for making signatures.
%    \begin{macrocode}
\toks_new:N \l_xparse_signature_toks
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_tmp_tl}
% A general purpose token list variable.
%    \begin{macrocode}
\tl_new:N \l_xparse_tmp_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_xparse_total_args_int}
% Thje total number of arguments is used to create the internal function
% which has a fixed number of arguments.
%    \begin{macrocode}
\int_new:N \l_xparse_total_args_int
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\q_xparse_stop}
% A private quark.
%    \begin{macrocode}
\quark_new:N \q_xparse_stop
%    \end{macrocode}
%\end{macro}
%    
%\subsection{Internal commands}
%
%\begin{macro}{\xparse_add_arg:n}
%\begin{macro}[aux]{\xparse_add_arg_aux:n}
%\begin{macro}[aux]{\xparse_add_arg_aux:V}
% The argument-storing system provides a single point for interfacing
% with processors. They are done in a loop, couning upward. Notice that
% a set of braces are added back around the result of processing so that
% the internal function will correctly pick up one argument for each
% input argument.
%    \begin{macrocode}
\cs_new:Nn \xparse_add_arg:n {
  \intexpr_compare:nTF { \l_xparse_processor_int = \c_zero } {
    \toks_put_right:Nn \l_xparse_args_toks { {#1} }
  }{
    \xparse_if_no_value:nTF {#1} {
      \int_zero:N \l_xparse_processor_int
      \toks_put_right:Nn \l_xparse_args_toks { {#1} }
    }{
      \int_zero:N \l_xparse_processor_use_int
      \xparse_add_arg_aux:n {#1}
    }
  }
}
\cs_new:Nn \xparse_add_arg_aux:n {
  \int_incr:N \l_xparse_processor_use_int
  \use:c { xparse_processor_ \int_use:N \l_xparse_processor_use_int :n }
    {#1}
  \intexpr_compare:nTF { 
    \l_xparse_processor_use_int = \l_xparse_processor_int 
  } {
    \toks_put_right:No \l_xparse_args_toks {
      \exp_after:wN { \toks_use:N \l_xparse_arg_toks }
    }
    \int_zero:N \l_xparse_processor_int
  }{
    \xparse_add_arg_aux:V \l_xparse_arg_toks
  }  
}
\cs_generate_variant:Nn \xparse_add_arg_aux:n { V }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_add_grabber:N}
% A shortcut to add the appropriate grabber to the signature, possibly
% \cs{long}, and to then clear the flag.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_grabber:N {
  \toks_put_right:Nx \l_xparse_signature_toks {
    \exp_not:c { 
      xparse_grab_ #1 \bool_if:NT \l_xparse_long_bool { _long } :w
    }
  }
  \bool_set_false:N \l_xparse_long_bool
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_+:}
% Making the next argument \cs{long} means setting the flag and
% knocking one back off the totatl argument count. The \texttt{m}
% arguments are recorded here as this has to be done for every case
% where there is then a \cs{long} argument.
%    \begin{macrocode}
\cs_new_nopar:cn { xparse_add_type_+: } {
  \xparse_flush_m_args:
  \bool_set_true:N \l_xparse_long_bool 
  \bool_set_false:N \l_xparse_m_only_bool
  \int_decr:N \l_xparse_total_args_int
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_>:}
%\begin{macro}[aux]{\xparse_add_type_>_aux:}
% Preprocessors are simply added to the signature.
%    \begin{macrocode}
\cs_new_nopar:cn { xparse_add_type_>: } {
  \xparse_flush_m_args:
  \int_decr:N \l_xparse_total_args_int
  \cs_set_eq:Nc \xparse_prepare_next:w { xparse_add_type_>_aux:n }
}
\cs_new:cn { xparse_add_type_>_aux:n } {
  \toks_put_right:Nn \l_xparse_signature_toks {  
    \xparse_process_arg:n {#1}
  }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \xparse_prepare_signature:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_d:}
%\begin{macro}[aux]{\xparse_add_type_d_aux:NN}
% To save on repeated code, \texttt{d} is actually turned into
% the same grabber as is used by \texttt{D}, by putting the
% \cs{NoValue} default in the correct place.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_d: {
  \xparse_flush_m_args:
  \xparse_add_grabber:N D
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_add_type_d_aux:NN
}
\cs_new:Nn \xparse_add_type_d_aux:NN {
  \toks_put_right:Nn \l_xparse_signature_toks { #1#2 { \NoValue } }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \xparse_prepare_signature:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_D:}
%\begin{macro}[aux]{\xparse_add_type_D_aux:NNN}
% The \texttt{D} version is much the same as \texttt{d}, execpt the
% default value has to be picked up.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_D: {
  \xparse_flush_m_args:
  \xparse_add_grabber:N D
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_add_type_D_aux:NNN
}
\cs_new:Nn \xparse_add_type_D_aux:NNN {
  \toks_put_right:Nn \l_xparse_signature_toks { #1#2 {#3} }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \xparse_prepare_signature:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_g:}
% Optional grouped arguments are easy: an alias for \texttt{g} with
% a \cs{NoValue} default.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_g: {
  \xparse_flush_m_args:
  \xparse_add_grabber:N G
  \toks_put_right:Nn \l_xparse_signature_toks { { \NoValue } }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_G:}
%\begin{macro}[aux]{\xparse_add_type_G_aux:n}
% Optional braced arguments with a default just need to find that
% value.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_G: {
  \xparse_flush_m_args:
  \xparse_add_grabber:N G
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_add_type_G_aux:N
}
\cs_new:Nn \xparse_add_type_G_aux:N {
  \toks_put_right:Nn \l_xparse_signature_toks { {#1} }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \xparse_prepare_signature:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_l:}
% Finding \texttt{l} arguments is very simple.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_l: {
  \xparse_flush_m_args:
  \xparse_add_grabber:N l
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_m:}
% The \texttt{m} type is special as only \cs{long} arguments are
% explicitly handled. For non-\cs{long} arguments, the total number
% is counted and dealt with \emph{en masse} later.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_m: {
  \bool_if:NTF \l_xparse_long_bool {
    \bool_set_false:N \l_xparse_long_bool
    \toks_put_right:Nn \l_xparse_signature_toks 
      { \xparse_grab_m_long:w }
  }{
    \intexpr_compare:nTF { \l_xparse_processor_int = \c_zero } {
      \int_incr:N \l_xparse_m_args_int
    }{
      \toks_put_right:Nn \l_xparse_signature_toks { \xparse_grab_m:w }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_t:}
%\begin{macro}[aux]{\xparse_add_type_t_aux:N}
% Setting up a \texttt{t} argument has two steps: add to the signature,
% then set up to collect and store one more token.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_t: {
  \xparse_flush_m_args:
  \xparse_add_grabber:N t
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_add_type_t_aux:N
}
\cs_new:Nn \xparse_add_type_t_aux:N {
  \toks_put_right:Nn \l_xparse_signature_toks { #1 }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \xparse_prepare_signature:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_add_type_u:}
%\begin{macro}[aux]{\xparse_add_type_u_aux:n}
% Setting up a \texttt{u} argument is very similar to a \texttt{t} one,
% with the naming difference that the auxiliary function expects a 
% braced argument.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_add_type_u: {
  \xparse_flush_m_args:
  \xparse_add_grabber:N u
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_add_type_u_aux:n
}
\cs_new_eq:NN \xparse_add_type_u_aux:n \xparse_add_type_G_aux:N
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_check_and_add:N}
% This function checks if the argument type actually exists and gives
% an error if it doesn't.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_check_and_add:N  {
  \cs_if_free:cTF { xparse_add_type_ #1 : } {
    \msg_error:nnx { xparse } { unknown-argument-type } {#1}
    \xparse_add_type_m:
  }{
    \use:c { xparse_add_type_ #1 : }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_declare_cmd:Nnn}
%\begin{macro}{\xparse_declare_cmd:cnn}
%\begin{macro}[aux]{\xparse_declare_cmd_all_m:Nn}
%\begin{macro}[aux]{\xparse_declare_cmd_mixed:Nn}
% First, the signature is set up from the argument specification. There
% is then a check: if only \texttt{m} arguments are needed (which 
% includes functions with no arguments at all) then the definition is
% simple. On the other hand, if the signature is more complex then an 
% internal function actually contains the code with the user function
% as a simple wrapper.
%    \begin{macrocode}
\cs_new:Nn \xparse_declare_cmd:Nnn {
  \xparse_prepare_signature:n {#2}
  \bool_if:NTF \l_xparse_m_only_bool {
    \xparse_declare_cmd_all_m:Nn #1 {#3}
  }{
    \xparse_declare_cmd_mixed:Nn #1 {#3}
  }
}
\cs_generate_variant:Nn \xparse_declare_cmd:Nnn { cnn }
\cs_new:Nn \xparse_declare_cmd_all_m:Nn {
  \cs_generate_from_arg_count:NNnn 
    #1 \cs_set_protected_nopar:Npn \l_xparse_total_args_int {#2}
}
\cs_new:Nn \xparse_declare_cmd_mixed:Nn {
  \cs_set_protected_nopar:Npx #1 {
    \exp_not:n { 
      \int_zero:N \l_xparse_processor_int
      \toks_set:Nn \l_xparse_args_toks 
    } { \exp_not:c { \token_to_str:N #1 } }
    \toks_use:N \l_xparse_signature_toks
    \exp_not:n{ \toks_use:N \l_xparse_args_toks }
  }
  \cs_generate_from_arg_count:cNnn 
    { \token_to_str:N #1 } \cs_set:Npn \l_xparse_total_args_int {#2}
}
%    \end{macrocode} 
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_declare_env:nnnn}
% The idea here is to make sure that the end of the environment has the
% same arguments available as the beginning.
%    \begin{macrocode}
\cs_new:Nn \xparse_declare_env:nnnn {
  \xparse_declare_cmd:cnn { environment_begin_ #1 :w } {#2} {
    \group_begin:
      \toks_set_eq:NN \l_xparse_environment_args_toks 
        \l_xparse_args_toks
      #3
  }
  \cs_set_nopar:cpx { environment_end_ #1 :w } {
      \exp_not:N \exp_last_unbraced:NV 
      \exp_not:c { environment_end_ #1 _aux:N }
      \exp_not:N \l_xparse_environment_args_toks
    \exp_not:N \group_end:
  } 
  \cs_set_nopar:cx { environment_end_ #1 _aux:N } {
    \exp_not:c { environment_end_ #1 _aux :w }
  }
  \cs_generate_from_arg_count:cNnn 
    { environment_end_ #1 _aux :w } \cs_set:Npn
    \l_xparse_total_args_int {#4}
%</initex|package>
%<*package>
  \cs_set_eq:cc {#1} { environment_begin_ #1 :w } 
  \cs_set_eq:cc { end #1 } { environment_end_ #1 :w }
%</package>
%<*initex|package>
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_flush_m_args:}
% As \texttt{m} arguments are simply counted, there is a need to add 
% them to the token register in a block. As this function can only
% be called if something other than \texttt{m} turns up, the flag can 
% be switched here.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_flush_m_args: {
  \cs_if_exist:cT { 
    xparse_grab_m_ \int_use:N \l_xparse_m_args_int :w 
  } {
    \toks_put_right:Nx \l_xparse_signature_toks {
       \exp_not:c { xparse_grab_m_ \int_use:N \l_xparse_m_args_int :w }
    }
  }
  \int_zero:N \l_xparse_m_args_int
  \bool_set_false:N \l_xparse_m_only_bool
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_grab_D:w}
%\begin{macro}{\xparse_grab_D_long:w}
%\begin{macro}[aux]{\xparse_grab_D_aux:NNnnN}
%\begin{macro}[aux]{\xparse_grab_D_aux:w}
% The generic delimited argument grabber.
%    \begin{macrocode}
\cs_new:Npn \xparse_grab_D:w #1#2#3#4 \l_xparse_args_toks {
  \xparse_grab_D_aux:NNnnN #1 #2 {#3} {#4} \cs_set_nopar:Npn
}
\cs_new:Npn \xparse_grab_D_long:w #1#2#3#4 \l_xparse_args_toks {
  \xparse_grab_D_aux:NNnnN #1 #2 {#3} {#4} \cs_set:Npn
}
\cs_set:Nn \xparse_grab_D_aux:NNnnN {
  #5 \xparse_grab_D_aux:w #1 ##1 #2 {
    \xparse_add_arg:n {##1}
    #4 \l_xparse_args_toks
  }
  \peek_charcode:NTF #1 { 
    \xparse_grab_D_aux:w 
  }{
    \xparse_add_arg:n {#3}
    #4 \l_xparse_args_toks
  }
}
\cs_new:Npn \xparse_grab_D_aux:w { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_grab_G:w}
%\begin{macro}{\xparse_grab_G_long:w}
%\begin{macro}[aux]{\xparse_grab_G_aux:nnN}
%\begin{macro}[aux]{\xparse_grab_G_aux:n}
% Optional groups are checed by meaning, so that the same code will 
% work with, for example, Con\TeX{}t-like input.
%    \begin{macrocode}
\cs_new:Npn \xparse_grab_G:w #1#2 \l_xparse_args_toks {
  \xparse_grab_G_aux:nnN {#1} {#2} \cs_set_nopar:Nn
}
\cs_new:Npn \xparse_grab_G_long:w #1#2 \l_xparse_args_toks {
  \xparse_grab_G_aux:nnN {#1} {#2} \cs_set:Nn
}
\cs_set:Nn \xparse_grab_G_aux:nnN {
  #3 \xparse_grab_G_aux:n {
    \xparse_add_arg:n {##1}
    #2 \l_xparse_args_toks
  }
  \peek_meaning:NTF \c_group_begin_token { 
    \xparse_grab_G_aux:n 
  }{
    \xparse_add_arg:n {#1}
    #2 \l_xparse_args_toks
  }
}
\cs_new:Npn \xparse_grab_G_aux:n { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_grab_l:w}
%\begin{macro}{\xparse_grab_l_long:w}
%\begin{macro}[aux]{\xparse_grab_l_aux:nN}
%\begin{macro}[aux]{\xparse_grab_l_aux:w}
% Argument grabbers for mandatory \TeX\ arguments are pretty simple.
%    \begin{macrocode}
\cs_new:Npn \xparse_grab_l:w #1 \l_xparse_args_toks {
  \xparse_grab_l_aux:nN {#1} \cs_set_nopar:Npn
}
\cs_new:Npn \xparse_grab_l_long:w #1 \l_xparse_args_toks { 
  \xparse_grab_l_aux:nN {#1} \cs_set:Npn
}
\cs_new:Nn \xparse_grab_l_aux:nN {
  #2 \xparse_grab_l_aux:w ##1## {
    \xparse_add_arg:n \l_xparse_args_toks {##1}
    #1 \l_xparse_args_toks
  }
  \xparse_grab_l_aux:w
}
\cs_new:Nn \xparse_grab_l_aux:w { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_grab_m:w}
%\begin{macro}{\xparse_grab_m_long:w}
%\begin{macro}[aux]{\xparse_grab_m_aux:n}
% Collecting a single mandatory argument is quite easy.
%    \begin{macrocode}
\cs_new:Npn \xparse_grab_m:w #1 \l_xparse_args_toks {
  \cs_set_nopar:Nn \xparse_grab_m_aux:n {
    \xparse_add_arg:n {##1}
    #1 \l_xparse_args_toks
  }
  \xparse_grab_m_aux:n
}
\cs_new:Npn \xparse_grab_m_long:w #1 \l_xparse_args_toks {
  \cs_set:Nn \xparse_grab_m_aux:n {
    \xparse_add_arg:n {##1}
    #1 \l_xparse_args_toks
  }
  \xparse_grab_m_aux:n
}
\cs_new:Nn \xparse_grab_m_aux:n { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_grab_m_1:w}
%\begin{macro}[aux]{\xparse_grab_m_1_aux:n}
%\begin{macro}{\xparse_grab_m_2:w}
%\begin{macro}[aux]{\xparse_grab_m_2_aux:nn}
%\begin{macro}{\xparse_grab_m_3:w}
%\begin{macro}[aux]{\xparse_grab_m_3_aux:nnn}
%\begin{macro}{\xparse_grab_m_4:w}
%\begin{macro}[aux]{\xparse_grab_m_4_aux:nnnn}
%\begin{macro}{\xparse_grab_m_5:w}
%\begin{macro}[aux]{\xparse_grab_m_5_aux:nnnnn}
%\begin{macro}{\xparse_grab_m_6:w}
%\begin{macro}[aux]{\xparse_grab_m_6_aux:nnnnnn}
%\begin{macro}{\xparse_grab_m_7:w}
%\begin{macro}[aux]{\xparse_grab_m_7_aux:nnnnnnn}
%\begin{macro}{\xparse_grab_m_8:w}
%\begin{macro}[aux]{\xparse_grab_m_8_aux:nnnnnnnn}
% Grabbing 1--8 mandatory arguments. We don't need to worry about 
% nine arguments as this is only possible if everything is 
% mandatory. Each function has an auxiliary so that \cs{par} tokens
% from other arguments still work.
%    \begin{macrocode}
\cs_new:cpn { xparse_grab_m_1:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_1_aux:n } {
    \toks_put_right:Nn \l_xparse_args_toks { {##1} }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_1_aux:n }
}
\cs_new_nopar:cn { xparse_grab_m_1_aux:n } { }
\cs_new:cpn { xparse_grab_m_2:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_2_aux:nn } {
    \toks_put_right:Nn \l_xparse_args_toks { {##1} {##2} }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_2_aux:nn }
}
\cs_new_nopar:cn { xparse_grab_m_2_aux:nn } { }
\cs_new:cpn { xparse_grab_m_3:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_3_aux:nnn } {
    \toks_put_right:Nn \l_xparse_args_toks { {##1} {##2} {##3} }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_3_aux:nnn }
}
\cs_new_nopar:cn { xparse_grab_m_3_aux:nnn } { }
\cs_new:cpn { xparse_grab_m_4:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_4_aux:nnnn } {
    \toks_put_right:Nn \l_xparse_args_toks { {##1} {##2} {##3} {##4} }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_4_aux:nnnn }
}
\cs_new_nopar:cn { xparse_grab_m_4_aux:nnnn } { }
\cs_new:cpn { xparse_grab_m_5:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_5_aux:nnnnn } {
    \toks_put_right:Nn \l_xparse_args_toks { 
      {##1} {##2} {##3} {##4} {##5} 
    }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_5_aux:nnnnn }
}
\cs_new_nopar:cn { xparse_grab_m_5_aux:nnnnn } { }
\cs_new:cpn { xparse_grab_m_6:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_6_aux:nnnnnn } {
    \toks_put_right:Nn \l_xparse_args_toks { 
      {##1} {##2} {##3} {##4} {##5} {##6}
    }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_6_aux:nnnnnn }
}
\cs_new_nopar:cn { xparse_grab_m_6_aux:nnnnnn } { }
\cs_new:cpn { xparse_grab_m_7:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_7_aux:nnnnnnn } {
    \toks_put_right:Nn \l_xparse_args_toks { 
      {##1} {##2} {##3} {##4} {##5} {##6} {##7} 
    }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_7_aux:nnnnnnn }
}
\cs_new_nopar:cn { xparse_grab_m_7_aux:nnnnnnn } { }
\cs_new:cpn { xparse_grab_m_8:w } #1 \l_xparse_args_toks {
  \cs_set_nopar:cn { xparse_grab_m_8_aux:nnnnnnnn } {
    \toks_put_right:Nn \l_xparse_args_toks { 
      {##1} {##2} {##3} {##4} {##5} {##6} {##7} {##8} 
    }
    #1 \l_xparse_args_toks
  }
  \use:c { xparse_grab_m_8_aux:nnnnnnnn }
}
\cs_new_nopar:cn { xparse_grab_m_8_aux:nnnnnnnn } { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_grab_t:w}
%\begin{macro}{\xparse_grab_t_long:w}
%\begin{macro}[aux]{\xparse_grab_t_aux:NnN}
%\begin{macro}[aux]{\xparse_grab_t_aux:}
% Dealing with a token is quite easy. Check the match, remove the 
% token if needed and add a flag to the output.
%    \begin{macrocode}
\cs_new:Npn \xparse_grab_t:w #1#2 \l_xparse_args_toks {
  \xparse_grab_t_aux:NnN #1 {#2} \cs_set_nopar:Nn
}
\cs_new:Npn \xparse_grab_t_long:w #1#2 \l_xparse_args_toks {
  \xparse_grab_t_aux:NnN #1 {#2} \cs_set:Nn
}
\cs_new:Nn \xparse_grab_t_aux:NnN {
  #3 \xparse_grab_t_aux: {
    \peek_charcode_remove:NTF #1 { 
      \xparse_add_arg:n { \BooleanTrue }
      #2 \l_xparse_args_toks
    }{
      \xparse_add_arg:n { \BooleanFalse }
      #2 \l_xparse_args_toks
    }
  }
  \xparse_grab_t_aux:
}
\cs_new:Nn \xparse_grab_t_aux: { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_grab_u:w}
%\begin{macro}{\xparse_grab_u_long:w}
%\begin{macro}[aux]{\xparse_grab_u_aux:NnN}
%\begin{macro}[aux]{\xparse_grab_u_aux:w}
% Grabbing up to a list of tokens is quite easy: define the grabber,
% and then collect.
%    \begin{macrocode}
\cs_new:Npn \xparse_grab_u:w #1#2 \l_xparse_args_toks {
  \xparse_grab_u_aux:NnN {#1} {#2} \cs_set_nopar:Npn
}
\cs_new:Npn \xparse_grab_u_long:w #1#2 \l_xparse_args_toks {
  \xparse_grab_u_aux:NnN {#1} {#2} \cs_set:Npn
}
\cs_new:Nn \xparse_grab_u_aux:NnN {
  #3 \xparse_grab_u_aux:w ##1 #1 {
    \xparse_add_arg:n {##1}
    #2 \l_xparse_args_toks
  }
  \xparse_grab_u_aux:w
}
\cs_new:Nn \xparse_grab_u_aux:w { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[TF]{\xparse_if_no_value:n}
% Tests for \cs{NoValue}.
%    \begin{macrocode}
\prg_new_conditional:Nnn \xparse_if_no_value:n { TF,T,F } {
  \tl_if_eq:nnTF {#1} { \NoValue } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_prepare_signature:n}
% Creating the signature is a case of working through the input and
% turning into the output in \cs{l_xparse_signature_toks}. A track is
% also kept of the total number of arguments. This function sets 
% everything up then hands off to the parser.
%    \begin{macrocode}
\cs_new:Nn \xparse_prepare_signature:n  {
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
  \bool_set_true:N \l_xparse_m_only_bool
  \bool_set_false:N \l_xparse_long_bool
  \int_zero:N \l_xparse_m_args_int
  \int_zero:N \l_xparse_processor_int
  \toks_clear:N \l_xparse_signature_toks
  \int_zero:N \l_xparse_total_args_int
  \xparse_prepare_signature:N #1 \q_nil
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_prepare_signature:N}
%\begin{macro}[aux]{\xparse_prepare_signature_aux:N}
% The main signature-preparation loop is in two parts, to keep the code 
% a little clearer. Most of the checks here is pretty clear, with a key
% point to watch what is next on the stack so that the loop continues
% correctly. 
%    \begin{macrocode}
\cs_new:Nn \xparse_prepare_signature:N {
  \quark_if_nil:NTF #1 {
    \bool_if:NF \l_xparse_m_only_bool {
      \xparse_flush_m_args:
    }
  }{
    \prop_if_in:NnTF \c_xparse_shorthands_prop {#1} {
      \prop_get:NnN \c_xparse_shorthands_prop {#1} \l_xparse_tmp_tl
      \exp_last_unbraced:NV \xparse_prepare_signature:N \l_xparse_tmp_tl
    }{
      \xparse_prepare_signature_aux:N #1
    }
  }
}
\cs_new_nopar:Nn \xparse_prepare_signature_aux:N {
  \int_incr:N \l_xparse_total_args_int
  \xparse_check_and_add:N #1
  \xparse_prepare_next:w
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_prepare_next:w}
% Initially, the next action to take is to find the next symbol. 
% However, that might not always be the case, and in some cases more 
% than one token is absorbed (hence \texttt{:w}).
%    \begin{macrocode}
\cs_new_eq:NN \xparse_prepare_next:w \xparse_prepare_signature:N
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_process_arg:n}
% Processors are saved for use later during the grabbbing process.
%    \begin{macrocode}
\cs_new:Nn \xparse_process_arg:n {
  \int_incr:N \l_xparse_processor_int
  \cs_set:cn { xparse_processor_ \int_use:N \l_xparse_processor_int :n }
    { #1 {##1} }
}
%    \end{macrocode}
%\end{macro}
%
%\subsection{Argument processors}
%
%\begin{macro}{\xparse_process_to_str:n}
% A basic argument processor: as much an example as anything else.
%    \begin{macrocode}
\cs_new:Nn \xparse_process_to_str:n {
  \toks_set:Nx \l_xparse_arg_toks {
    \tl_to_str:n {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_process_comma_split:n}
%\begin{macro}[aux]{\xparse_process_comma_split_aux:w}
% Turns a co-ordinate pair into two separate values.
%    \begin{macrocode}
\cs_new:Nn \xparse_process_comma_split:n {
  \tl_if_in:nnTF {#1} { , } {
    \xparse_process_comma_split_aux:w #1 \q_stop
  }{
    \toks_set:Nn \l_xparse_arg_toks { {#1} { } }
  }
}
\cs_new:Npn \xparse_process_comma_split_aux:w #1 , #2 \q_stop {
  \toks_set:Nn \l_xparse_arg_toks { {#1} {#2} }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsection{Creating expandable functions}
%
%\begin{macro}{\xparse_exp_add_type_d:}
%\begin{macro}[aux]{\xparse_exp_add_type_d_aux:NN}
% As in the standard case, the trick here is to slot in the default
% and treat as type \texttt{D}.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_exp_add_type_d: {
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_exp_add_type_d_aux:NN
}
\cs_new:Nn \xparse_exp_add_type_d_aux:NN {
  \xparse_exp_add_type_D_aux:NNn #1 #2 { \NoValue }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_exp_add_type_D:}
%\begin{macro}[aux]{\xparse_exp_add_type_D_aux:NNn}
% The most complex argument to grab in an expandable manner is the 
% general delimited one. There is a need for an auxiliary function to
% get the ending delimiter.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_exp_add_type_D: {
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_exp_add_type_D_aux:NNn
}
\cs_new:Nn \xparse_exp_add_type_D_aux:NNn {
  \tl_set:Nx \l_xparse_tmpa_tl {
    \exp_after:wN \token_to_str:N \l_xparse_function_tl 
    \int_use:N \l_xparse_total_args_int
  }
  \xparse_exp_set:cpx { \l_xparse_tmpa_tl } ##1 \q_xparse_stop ##2 {
    \exp_not:N \tl_if_head_eq_charcode:nNTF {##2} #1 {
      \exp_not:c { \l_xparse_tmpa_tl aux } 
        ##1 \exp_not:N \q_xparse_stop  #1  
    }{
      \exp_not:c { \l_xparse_tmpa_tl aux } 
        ##1 \exp_not:N \q_xparse_stop  #1 #3 #2 {##2}
    } 
  }
  \xparse_exp_set:cpx { \l_xparse_tmpa_tl aux} 
    ##1 \q_xparse_stop #1 ##2 #2 {
    \exp_not:c {
      \exp_after:wN \token_to_str:N \l_xparse_function_tl 
      \intexpr_eval:n { \l_xparse_total_args_int + 1 }
    } ##1 {##2} \exp_not:N \q_xparse_stop
  }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_exp_prepare_function:N
  \xparse_exp_prepare_function:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_exp_add_type_l:}
% Gathering an \texttt{l} argument is almost the same as grabbing an
% \texttt{m} one.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_exp_add_type_l: {
  \xparse_exp_set:cpx { 
    \exp_after:wN \token_to_str:N \l_xparse_function_tl 
    \int_use:N \l_xparse_total_args_int
  } ##1 \q_xparse_stop ##2## {
    \exp_not:c {
      \exp_after:wN \token_to_str:N \l_xparse_function_tl 
      \intexpr_eval:n { \l_xparse_total_args_int + 1 }
    }
    ##1 {##2} \exp_not:N \q_xparse_stop
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_exp_add_type_m:}
% For an \texttt{m} argument, just set up the chain correctly.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_exp_add_type_m: {
  \int_incr:N \l_xparse_m_args_int
  \xparse_exp_set:cpx { 
    \exp_after:wN \token_to_str:N \l_xparse_function_tl 
    \int_use:N \l_xparse_total_args_int
  } ##1 \q_xparse_stop ##2 {
    \exp_not:c {
      \exp_after:wN \token_to_str:N \l_xparse_function_tl 
      \intexpr_eval:n { \l_xparse_total_args_int + 1 }
    }
    ##1 {##2} \exp_not:N \q_xparse_stop
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_exp_add_type_t:}
%\begin{macro}[aux]{\xparse_exp_add_type_t_aux:N}
% Looking for a single token is relatively easy as there is no need for
% an auxiliary function.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_exp_add_type_t: {
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_exp_add_type_t_aux:N
}
\cs_new:Nn \xparse_exp_add_type_t_aux:N {
  \tl_set:Nx \l_xparse_tmpa_tl {
    \exp_after:wN \token_to_str:N \l_xparse_function_tl 
    \intexpr_eval:n { \l_xparse_total_args_int + 1 }
  }
  \xparse_exp_set:cpx {
    \exp_after:wN \token_to_str:N \l_xparse_function_tl 
    \int_use:N \l_xparse_total_args_int
  } ##1 \q_xparse_stop ##2 {
    \exp_not:N \tl_if_head_eq_charcode:nNTF {##2} #1 {
      \exp_not:c { \l_xparse_tmpa_tl }
      ##1 \exp_not:n { \q_xparse_stop  { \BooleanTrue } }
    }{
      \exp_not:c { \l_xparse_tmpa_tl }
      ##1 \exp_not:n { \q_xparse_stop  { \BooleanFalse } }
    } 
  }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_exp_prepare_function:N
  \xparse_exp_prepare_function:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_exp_add_type_u:}
%\begin{macro}[aux]{\xparse_add_exp_type_u_aux:n} 
% Setting up for a \texttt{u} argument is a two-step process as
% the delimiter is needed. Once it is available, the definition is
% not too bad.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_exp_add_type_u: {
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_exp_add_type_u_aux:n
}
\cs_new:Nn \xparse_exp_add_type_u_aux:n {
  \xparse_exp_set:cpx { 
    \exp_after:wN \token_to_str:N \l_xparse_function_tl 
    \int_use:N \l_xparse_total_args_int
  } ##1 \q_xparse_stop ##2 #1 {
    \exp_not:c {
      \exp_after:wN \token_to_str:N \l_xparse_function_tl 
      \intexpr_eval:n { \l_xparse_total_args_int + 1 }
    }
    ##1 {##2} \exp_not:N \q_xparse_stop
  }
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_exp_prepare_function:N
  \xparse_exp_prepare_function:N
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_exp_check_and_add:N}
% Virtually identical to the normal version.
%    \begin{macrocode}
\cs_new_nopar:Nn \xparse_exp_check_and_add:N  {
  \cs_if_free:cTF { xparse_exp_add_type_ #1 : } {
    \msg_error:nnx { xparse } { unknown-argument-type } {#1}
    \tl_set:Nn \l_xparse_last_arg_tl { m }
    \xparse_exp_add_type_m:
  }{
    \tl_set:Nn \l_xparse_last_arg_tl {#1}
    \use:c { xparse_exp_add_type_ #1 : }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\xparse_exp_declare_cmd:Nnn}
%\begin{macro}[aux]{\xparse_exp_declare_cmd_all_m:Nn}
%\begin{macro}[aux]{\xparse_exp_declare_cmd_mixed:Nn}
%\begin{macro}[aux]{\xparse_exp_declare_cmd_mixed_aux:Nn}
% The overall scheme here is very different from the standard method.
% For each argument, an internal fucntion is created to grab an argument
% and pass along prevous ones. Each `daisy chains' to call the next 
% one in the sequence. Thus at the end of the chain, an extra `argument'
% function is included to unwind the chain and pass data to the the
% internal function containing the actual code. If all of the arguments
% are type \texttt{m}, then the same tick is used as in the standard
% version. The \texttt{x} in the lead-off and mop-up functions makes 
% sure that the braces around the first argument are not lost.
%    \begin{macrocode}
\cs_new:Nn \xparse_exp_declare_cmd:Nnn {
  \tl_set:Nn \l_xparse_function_tl {#1}
  \xparse_exp_prepare_function:n {#2}
  \intexpr_compare:nTF { 
    \l_xparse_total_args_int = \l_xparse_m_args_int 
  } {
    \xparse_exp_declare_cmd_all_m:Nn #1 {#3}
  }{
    \xparse_exp_declare_cmd_mixed:Nn #1 {#3}
  }
}
\cs_new:Nn \xparse_exp_declare_cmd_all_m:Nn {
  \bool_if:NTF \l_xparse_long_bool {
    \cs_generate_from_arg_count:NNnn 
      #1 \cs_set:Npn \l_xparse_total_args_int {#2}
  }{
    \cs_generate_from_arg_count:NNnn 
      #1 \cs_set_nopar:Npn \l_xparse_total_args_int {#2}
  }
}
\cs_new:Nn \xparse_exp_declare_cmd_mixed:Nn {
  \exp_args:NnV \tl_if_in:nnTF { l m u } \l_xparse_last_arg_tl {
    \xparse_exp_declare_cmd_mixed_aux:Nn #1 {#2}
  }{
    \msg_error:nn { xparse } { expandable-ending-optional }
  }
}
\cs_new:Nn \xparse_exp_declare_cmd_mixed_aux:Nn {  
  \cs_set_nopar:Npx #1 {
    \exp_not:c { \token_to_str:N #1 1 } x \exp_not:N \q_xparse_stop
  }
  \cs_set_nopar:cpx { 
    \token_to_str:N #1 \intexpr_eval:n { \l_xparse_total_args_int + 1  }
  } x ##1 \q_xparse_stop {
    \exp_not:c { \token_to_str:N #1 } ##1
  }
  \cs_generate_from_arg_count:cNnn 
    { \token_to_str:N #1 } \cs_set:Npn \l_xparse_total_args_int {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_exp_prepare_function:n}
%\begin{macro}[aux]{\xparse_exp_prepare_function_aux:n}
% A couple of early validation tests. Processors are forbidden, as are
% \texttt{g}, \texttt{l} and \texttt{u} arguments (the later more for
% ease than any technical reason).
%    \begin{macrocode}
\cs_new:Nn \xparse_exp_prepare_function:n  {
  \bool_set_false:N \l_xparse_error_bool
  \tl_if_in:nnT {#1} { > } {
    \msg_error:nnx { xparse } { processor-in-expandable } {#1}
    \bool_set_true:N \l_xparse_error_bool
  }
  \tl_if_in:nnT {#1} { g } {
    \msg_error:nnx { xparse } { grouped-in-expandable } {#1}
    \bool_set_true:N \l_xparse_error_bool
  }
  \tl_if_in:nnT {#1} { G } {
    \msg_error:nnx { xparse } { grouped-in-expandable } {#1}
    \bool_set_true:N \l_xparse_error_bool
  }
  \bool_if:NF \l_xparse_error_bool {
    \xparse_exp_prepare_function_aux:n {#1}
  }
}
\cs_new:Nn \xparse_exp_prepare_function_aux:n  {
  \cs_set_eq:NN \xparse_prepare_next:w \xparse_exp_prepare_function:N
  \cs_set_eq:NN \xparse_exp_set:cpx \cs_set_nopar:cpx
  \bool_set_false:N \l_xparse_long_bool
  \int_zero:N \l_xparse_m_args_int
  \int_zero:N \l_xparse_total_args_int
  \tl_if_in:nnT {#1} { + } {
    \bool_set_true:N \l_xparse_long_bool
    \cs_set_eq:NN \xparse_exp_set:cpx \cs_set:cpx
  }
  \xparse_exp_prepare_function:N #1 \q_nil
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_exp_prepare_function:N}
%\begin{macro}[aux]{\xparse_exp_prepare_function_long:N}
%\begin{macro}[aux]{\xparse_exp_prepare_function_short:N}
%\begin{macro}[aux]{\xparse_exp_prepare_function_aux:N}
% Preparing functions is a case of 
%    \begin{macrocode}
\cs_new:Nn \xparse_exp_prepare_function:N {
  \bool_if:NTF \l_xparse_long_bool {
    \xparse_exp_prepare_function_long:N #1
  }{
    \xparse_exp_prepare_function_short:N #1
  }
}
\cs_new:Nn \xparse_exp_prepare_function_long:N {
  \quark_if_nil:NF #1 {
    \tl_if_eq:nnTF {#1} { + } {
      \xparse_exp_prepare_function_short:N
    }{
      \msg_error:nn { xparse } { inconsistent-long }
    }
  }
}
\cs_new:Nn \xparse_exp_prepare_function_short:N {
  \quark_if_nil:NF #1 {
    \prop_if_in:NnTF \c_xparse_shorthands_prop {#1} {
      \prop_get:NnN \c_xparse_shorthands_prop {#1} \l_xparse_tmp_tl
      \bool_if:NT \l_xparse_long_bool {
        \tl_put_left:Nn \l_xparse_tmp_tl { + }
      }
      \exp_last_unbraced:NV \xparse_exp_prepare_function:N 
        \l_xparse_tmp_tl
    }{
      \xparse_exp_prepare_function_aux:N #1
    }
  }
}
\cs_new_nopar:Nn \xparse_exp_prepare_function_aux:N {
  \int_incr:N \l_xparse_total_args_int
  \xparse_exp_check_and_add:N #1
  \xparse_prepare_next:w
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\xparse_exp_set:cpx}
% A shortcut to save constantly re-testing \cs{l_xparse_long_bool}.
%    \begin{macrocode}
\cs_new_eq:NN \xparse_exp_set:cpx \cs_set_nopar:cpx
%    \end{macrocode}
%\end{macro}
%    
%\subsection{Messages}
%    
% Some error messages.   
%    \begin{macrocode}
\msg_new:nnn { xparse } { command-already-defined } {%
  Command name `\token_to_str:N #1' already defined!%
}
\msg_new:nnnn { xparse } { command-not-yet-defined } {%
  Command `\token_to_str:N #1' not yet defined!%
}{%
  You have used \token_to_str:N \RenewDocumentCommand, or similar\\%
  with a command that was never defined.\\%
  Perhaps you meant \token_to_str:N \NewDocumentCommand.%
}
\msg_new:nnn { xparse } { environment-already-defined } {%
  Environment `#1' already defined!%
}
\msg_new:nnn { xparse } { environment-not-yet-defined } {%
  Environment `#1' not yet defined!%
}
\msg_new:nnnn { xparse } { expandable-ending-optional } {%
  Expandable command signature ends in optional argument.%
}{%
  Expandable functions must have a final mandatory argument.%
}
\msg_new:nnnn { xparse } { grouped-in-expandable } {%
  Optioanl grouped arguments cannot be used with expandable functions.%
}{%
  Argument specification `#1' contains an optional grouped argument:%
  this is only supported for standard robust functions.%
}
\msg_new:nnnn { xparse } { inconsistent-long } {%
  Inconsistent long arguments.%
}{%
  Expandable commands must have all arguments long if any at all.%
}
\msg_new:nnnn { xparse } { processor-in-expandable } {%
  Argument processors cannot be used with expandable functions.%
}{%
  Argument specification `#1' contains a processor function:%
  this is only supported for standard robust functions.%
}
\msg_new:nnn { xparse } { unknown-argument-type } {%
  Unknown argument type `#1' replaced by `m'. Fingers crossed ...%
}
%    \end{macrocode}
%    
%\subsection{User functions}
%
% The user functions are more or less just the internal functions 
% renamed. 
% 
%\begin{macro}{\BooleanFalse}
%\begin{macro}{\BooleanTrue}
% Design-space names for the Boolean values.
%    \begin{macrocode}
\cs_new_eq:NN \BooleanFalse \c_false_bool
\cs_new_eq:NN \BooleanTrue  \c_true_bool
%    \end{macrocode}
%\end{macro}
%\end{macro}
% 
%\begin{macro}{\DeclareDocumentCommand}
%\begin{macro}{\NewDocumentCommand}
%\begin{macro}{\RenewDocumentCommand}
%\begin{macro}{\ProvideDocumentCommand}
% The user macros are pretty simple wrappers around the internal ones.
%    \begin{macrocode}
\cs_new_protected:Npn \DeclareDocumentCommand {
  \xparse_declare_cmd:Nnn 
}
\cs_new_protected:Npn \NewDocumentCommand #1 {
  \cs_if_exist:NTF #1 { 
    \msg_error:nnx { xparse } { command-already-defined } {#1}
    \use_none:nn
  }{
    \xparse_declare_cmd:Nnn #1
  }
}
\cs_new_protected:Npn \RenewDocumentCommand #1 {
  \cs_if_exist:NTF #1 {
    \xparse_declare_cmd:Nnn #1
  }{  
    \msg_error:nnx { xparse } { command-not-yet-defined } {#1}
    \use_none:nn
  }
}
\cs_new_protected:Npn \ProvideDocumentCommand #1 {
  \cs_if_exist:NTF #1 { 
    \use_none:nn
  }{
    \xparse_declare_cmd:Nnn #1
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\DeclareDocumentEnvironment}
%\begin{macro}{\NewDocumentEnvironment}
%\begin{macro}{\RenewDocumentEnvironment}
%\begin{macro}{\ProvideDocumentEnvironment}
% Very similar for environments.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \DeclareDocumentEnvironment {
  \xparse_declare_env:nnnn
}
\cs_new_protected_nopar:Npn \NewDocumentEnvironment #1 {
  \cs_if_exist:cTF { environment_begin_ #1 :w } { 
    \msg_error:nnx { xparse } { environment-already-defined } {#1}
    \use_none:nnn
  }{
    \xparse_declare_env:nnnn {#1}
  }
}
\cs_new_protected_nopar:Npn \RenewDocumentEnvironment #1 {
  \cs_if_exist:cTF { environment_begin_ #1 :w } {
    \xparse_declare_env:nnnn {#1}
  }{  
    \msg_error:nnx { xparse } { environment-not-yet-defined } {#1}
    \use_none:nnn
  }
}
\cs_new_protected_nopar:Npn \ProvideDocumentEnvironment #1 {
  \cs_if_exist:cTF { environment_begin_ #1 :w } { 
    \use_none:nnn
  }{
    \xparse_declare_env:nnnn {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\DeclareExpandableDocumentCommand}
%\begin{macro}{\NewExpandableDocumentCommand}
%\begin{macro}{\RenewExpandableDocumentCommand}
%\begin{macro}{\ProvideExpandableDocumentCommand}
% The expanable versions of the basic functions are essentially the same.
%    \begin{macrocode}
\cs_new_protected:Npn \DeclareExpandableDocumentCommand {
  \xparse_exp_declare_cmd:Nnn 
}
\cs_new_protected:Npn \NewExpandableDocumentCommand #1 {
  \cs_if_exist:NTF #1 { 
    \msg_error:nnx { xparse } { command-already-defined } {#1}
    \use_none:nn
  }{
    \xparse_exp_declare_cmd:Nnn #1
  }
}
\cs_new_protected:Npn \RenewExpandableDocumentCommand #1 {
  \cs_if_exist:NTF #1 {
    \xparse_exp_declare_cmd:Nnn #1
  }{  
    \msg_error:nnx { xparse } { command-not-yet-defined } {#1}
    \use_none:nn
  }
}
\cs_new_protected:Npn \ProvideExpandableDocumentCommand #1 {
  \cs_if_exist:NTF #1 { 
    \use_none:nn
  }{
    \xparse_exp_declare_cmd:Nnn #1
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[TF]{\IfBoolean}
% The logical \meta{true} and \meta{false} statements are just the 
% normal \cs{c_true_bool} and \cs{c_false_bool}, so testing for them is
% done with the \cs{bool_if:NTF} functions from \textsf{l3prg}.
%    \begin{macrocode}
\cs_new_eq:NN \IfBooleanTF \bool_if:NTF
\cs_new_eq:NN \IfBooleanT  \bool_if:NT
\cs_new_eq:NN \IfBooleanF  \bool_if:NF
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[TF]{\IfNoValue}
% Simple re-naming. 
%    \begin{macrocode}
\cs_new_eq:NN \IfNoValueF  \xparse_if_no_value:nF 
\cs_new_eq:NN \IfNoValueT  \xparse_if_no_value:nT 
\cs_new_eq:NN \IfNoValueTF \xparse_if_no_value:nTF 
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\NoValue}
% The marker for no value being give: this can be typeset safely.
% This is coded by hand as making it \cs{protected} ensures that it
% will not turn into anything else by accident.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \NoValue { -NoValue- }
%    \end{macrocode}
%\end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
% 
% \PrintIndex
