% \iffalse
%% File: xparse.dtx (C) Copyright 1999 Frank Mittelbach, Chris Rowley, David Carlisle
%%                  (C) Copyright 2004 Frank Mittelbach, LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3a of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``xbase bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{%
  \def\fileversion{#3}%
  \def\filedate{#4}%
%<package> \ProvidesPackage{#2}[#4 #3 #5 #6]%
}
\next$Id$
          {generic document command parser}
% \fi
%
% \iffalse
%
% Not cleaned up:
%
% \long
% \@typeset@protect
% \@ifnextchar
%
% \fi
%
% \iffalse
%<*driver>
 \documentclass{ltxdoc}
 \usepackage{textcomp}
% \usepackage{ldcdoc}
 \begin{document}
 \catcode`\_=11
 \catcode`\:=11
 \DocInput{xparse.dtx}
 \end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
%
% \title{The \textsf{xparse} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}}
% \author{FMi, CAR, DPC}
% \date{\copyright~\filedate}
%  \maketitle
%
% \begin{abstract}
% The interfaces described in this document are not meant to be final
% but only as a basis for discussion. Building productive applications
% using the current code is discouraged.
% \end{abstract}
%
% \section{Interface}
%
% This package implements high-level interface commands for class file
% writers which allows the separation of formatting commands
% (typically instances of so-called `templates') and their arguments
% from the signature of document-level commands.
%
% This works by declaration commands that provide a general
% specification method for the typical \LaTeX{} syntax, e.g.,
% star-form, optional arguments, and mandatory arguments. A command
% (or environment) declared in this way parses the input according to
% its spec and presents its findings in a normalized way for further
% processing.
%
% \subsection{Argument spec}
%
% An argument specification is a list of letters each representing a
% type of argument, i.e., |m| is a mandatory argument (surrounded by
% braces), |o| an optional argument (surrounded by brackets if
% present), and |s| represents a star (which might be present or
% not).\footnote{Other argument types such as \texttt{c} for picture
% coordinates could be integrated in principle --- the last prototype
% now contains support for\texttt{c}.} Thus the argument
% spec for headings as implemented by |\@startsection| in standard
% \LaTeX{} would be represented by the three letters |som|.
%
% With the new proof of concept implementation there is also
% |O{default}| which acts like |o| which also scans for an optional
% argument but allows to specify a default value if the optional
% argument is not present. I.e., it can be used to turn mandatory
% arguments of a template (that is those that do not check for
% |\NoValue|) into optional ones by supplying a default on the
% document command level.
%
% We also have |C{{x-default}{y-default}}| to allow for optional
% coordinate pairs which is, for example, needed to provide something
% like the picture environment in current \LaTeX.
%
% \subsection{Parsing results}
%
% To normalise the result of parsing the input according to an
% argument specification it is important to uniquely identify all
% arguments found. For this reason each parsing operation initiated by
% one of the argument spec letters will result in an identifiable
% output as follows:
% \begin{description}
% \item[m] will return the parsed argument surrounded by a brace pair,
%   i.e., will normally be the identity;
% \item[o] will return the parsed argument surrounded by a brace pair
%   if present. Otherwise it will return the token |\NoValue|;
% \item[O\textbraceleft default\textbraceright] will return the parsed
%    argument surrounded by a brace pair
%   if present. Otherwise it will return the |{default}| as specified above.
% \item[s] will return either the token |\BooleanTrue| or
%   |\BooleanFalse| depending on whether or not a star was parsed.
% \item[c] will parse the syntax |(|\meta{x}|,|\meta{y}|)|, i.e., a
%   coordinate pair and will return |{{|\meta{x}|}{|\meta{y}|}}| as
%   the result. If no open parentheses is scanned an error is signalled.
% \item[C\textbraceleft\textbraceleft x-default\textbraceright\textbraceleft
%    y-default\textbraceright\textbraceright] behaves like |c|, i.e., parses a
%   coordinate pair if present. If the coordinate pair is missing it
%   returns the default values instead.
% \end{description}
% For example, given the spec |soomO{default}| the input |*[Foo]{Bar}| would be
% parsed as |\BooleanTrue{Foo}\NoValue{Bar}{default}|. In other words
% there will be always exactly the same number of brace groups or
% tokens as the number of letters in the argument spec.
%
% \subsection{Applying the parsing results}
%
% Since the result of the parsing is a well defined number of tokens or
% brace groups it is easy to pass them on in any order to any
% processing function. To this end the tokens or brace groups are
% associated with the standard argument specifiers in \TeX{} macros,
% i.e., |#1|, |#2|, and so forth. This limits the argument
% specification to a maximum number of 9 letters, but for practical
% applications this should be sufficient.
%
% \subsection{The class designer interface}
%
% This package provides two commands for declaring commands
% and environments to be used within the document body.
%
% \DescribeMacro\DeclareDocumentCommand
% The |\DeclareDocumentCommand| declaration takes three arguments. The
% first argument is the name of the command to be declared, the second
% is the argument specification in the syntax described above, and the
% third is the action to be carried out once the arguments are
% parsed. Within the third argument |#1|, |#2|, etc.\ denote the
% result of the parsing, e.g.,
%\begin{verbatim}
%  \DeclareDocumentCommand{\chapter}{som}
%    { \IfBooleanTF {#1}
%        { \typesetnormalchapter {#2}{#3} }
%        { \typesetstarchapter   {#3} }
%    }
%\end{verbatim}
% would be a way to define a |\chapter| command which would
% essentially behave like the current \LaTeX{} command (except that it
% would accept an optional argument even when a |*| was parsed). The
% |\typesetnormalchapter| could test its first argument for being
% |\NoValue| to see if an optional argument was present.
%
% Of course something like the |\IfNoValueTF| test could also be
% placed inside a function that would process all three arguments, thus
% using the templates and their instances as provided by the
% \texttt{template} package such a declaration would probably look
% more like the following example:
%\begin{verbatim}
%  \DeclareDocumentCommand{\chapter}{som}
%    { \UseInstance {head} {A-head-main} {#1} {#2} {#3} }
%\end{verbatim}
%
% Using the |\DeclareDocumentCommand| interface it is easy to modify
% the document-level syntax while still applying the same
% layout-generating functions, e.g., a class that would not support
% optional arguments or star forms for the heading commands could
% define |\chapter| like this:
%\begin{verbatim}
%  \DeclareDocumentCommand{\chapter}{m}
%    { \UseInstance {head} {A-head-main} \BooleanFalse \NoValue {#1} }
%\end{verbatim}
% while a class that would allow for an additional optional argument
% (for whatever reason) could define it like that:
%\begin{verbatim}
%  \DeclareDocumentCommand{\chapter}{somo}
%    { \doSomethingWithTheExtraOptionalArg {#4}
%      \UseInstance {head} {A-head-main} {#1} {#2} {#3} }
%\end{verbatim}
%
% Commands declared in this way are automatically robust (in David's
% implementation).
%
% \DescribeMacro\DeclareDocumentEnvironment
% The |\DeclareDocumentEnvironment| declaration is similar to
% |\DeclareDocumentCommand| except that it takes four arguments: the
% first being the environment name (without a backslash), the second
% again the argument-spec, and the third and forth are the actions
% taken at start end end of the environment. The parsed arguments are
% available to both the start and the finish as |#1|, |#2|,
% etc.\footnote{It is wishful thinking that the args can be made available
% to the end of the environment. In the current implementation this
% was buggy and has been taken out again below.}
%
%
% \subsubsection{Comparing tokens in a quarky way}
%
% Something like |\NoValue| would perhaps be best implemented as a
% ltx3 quark, i.e. a token which expands to itself as this is
% can be easily tested even if hidden inside a macro. The unfortunate
% side effect however is that it will result in a tight loop if it ever
% gets executed by mistake.
%
% \DescribeMacro\NoValue
% For this reason |\NoValue| is defined to expand to the string
% |-NoValue-| which would get typeset if ever executed thus clearly
% indicating the type of error the writer made.
%
% However this makes testing for this token slightly complicated as in
% that case the test
%\begin{verbatim}
%   \def\seen{#1}
%   \def\containsNoValue{\NoValue}
%   \ifx\seen\containsNoValue
%\end{verbatim}
% will be true if |#1| was |\NoValue| but false if if |#1| itself
% contains a macro which contains |\NoValue|; a case that happens
% unfortunately very often in practice.  Using unguarded |\edef| to
% define |\seen| is out of question as |#1| typically is either
% |\NoValue| or arbitrary user input (which is likely to die horribly
% even in a |\protected@edef|.
%
% \DescribeMacro\IfSomethingTF
% \DescribeMacro\IfSomethingT
% \DescribeMacro\IfSomethingF
% Therefore the |\IfSomethingTF| test uses a slower recursive
% procedure: it tests if |#1| and |#2| are equal. If they are testing
% stops and the true-case (argument |#3|) will be executed. If not, it
% expands the first token of |#2| and checks if the resulting
% token-list is identical to |#2| (this would happen if this first
% token is unexpandable or |#2| is empty). In the latter case testing
% terminates and the false-case (argument |#4|) will be
% executed. However if the token-list created this way differs from
% |#2| the macro recurses using this token-list in place of |#2|.
%
% \DescribeMacro\IfNoValueTF
% \DescribeMacro\IfNoValueT
% \DescribeMacro\IfNoValueF
% \DescribeMacro\IfValueTF
% \DescribeMacro\IfValueT
% \DescribeMacro\IfValueF
% The test |\IfNoValueTF| is implemented as an application of
% |\IfSomethingTF|, i.e.,
%\begin{verbatim}
%   \def\IfNoValueTF{\IfSomethingTF\NoValue}
%\end{verbatim}
% where the three arguments (test token, true and false case) are
% picked up by |\IfSomethingTF|. Similar tests for other quark-like
% tokens could be defined similarly. |\IfValueTF| is the same test
% with the true/false case exchanged.
%
%
% \subsection{Some comments on the need for the \texttt{O} specifier}
%
% With |\newcommand| there is the possibility of specifying a default
% for an optional argument which is stored away in a more or less
% efficient manner. For example below is the old definition of
% |\linebreak| as can be found in the \LaTeX2e kernel:
%\begin{verbatim}
%\def\linebreak{\@testopt{\@no@lnbk-}4}
%\def\@no@lnbk #1[#2]{%
%  \ifvmode
%    \@nolnerr
%  \else
%    \@tempskipa\lastskip
%    \unskip
%    \penalty #1\@getpen{#2}%
%    \ifdim\@tempskipa>\z@
%      \hskip\@tempskipa
%      \ignorespaces
%    \fi
%  \fi}
%\end{verbatim}
% Ignoring for the moment that the above is slightly optimised an
% expansion of this code under |\tracingall| will result in about 90
% lines of tracing output.
% If we reimplement this using |\DeclarDocumentCommand\linebreak{o}|
% we have to use |\IfNoValueTF| to find out if an argument was present
% which (because of the somewhat slow expansion of |\IfSomethingTF|)
% results in about twice as much of tracing lines. In contrast using
% |O{4}| as below we end up with 110 lines, which seems roughly the
% price we have to pay for the extra generality available (though this
% could perhaps even be reduced by a better implementation of the
% parsing machine as originally done by David, before i talked him
% into adding support for arguments in the end code of an environment).
%
%\begin{verbatim}
%\DeclareDocumentCommand\linebreak { O{4} }
% {
%  \ifvmode
%    \@nolnerr
%  \else
%    \@tempskipa\lastskip
%    \unskip
% %    \IfNoValueTF{#1}
% %       {\break}
% %       {\penalty -\@getpen{#1}}
%    \penalty -\@getpen{#1}
%    \ifdim\@tempskipa>\z@
%      \hskip\@tempskipa
%      \ignorespaces
%    \fi
%  \fi
% }
%\end{verbatim}
%
% \subsubsection{A boolean data type}
%
% \DescribeMacro\BooleanTrue
% \DescribeMacro\BooleanFalse
% The parsing result for a star etc is presented as the token
% |\BooleanTrue| or |\BooleanFalse| respectively!
%
% \DescribeMacro\IfBooleanTF
% \DescribeMacro\IfBooleanT
% \DescribeMacro\IfBooleanF
% To test for these values the macro |\IfBooleanTF| can be used. It
% expects as its first argument either |\BooleanTrue| or
% |\BooleanFalse| and executes its second or third argument depending
% on this value. |\IfBooleanT| and |\IfBooleanF| are obvious
% shortcuts.
%
% At one point in time i thought that one can represent everything
% using |\NoValue|, e.g., for the star case either return |*| or
% |\NoValue|. However, this slows down processing of commands like
% |\\*| considerably since they would then have to use the slow
% |\IfSomethingTF| internally instead of a fast two-way switch. So now
% this data type is back in.
%
% \subsection{A somewhat complicated example}
%
% This example reimplements the |\makebox| and |\framebox| interface
% of \LaTeX{} both of which are unfortunately quite overloaded
% syntactically. For this reason the example isn't meant to show good
% coding practice but to show the power of the interface even though
% applied in a somewhat bad way.
%
% |\makebox| and |\framebox| support the following different document
% syntax forms:
% \begin{itemize}
% \item
% |\makebox{A}|: only a single mandatory argument.
%
% \item
% |\makebox[20pt]{B}|: one optional argument specify the box width.
%
%
% \item
% |\makebox[30pt][r]{C}|: two optional arguments the second specifying
%    the text position within the box being made (l,c,r being allowed
%    with c being the default).
%
% \item
% |\makebox(20,30){D}|: within picture mode the width is specified not
% as an optional argument in brackets but as a coordinate pair.
%
% \item
% |\makebox(0,0)[lt]{E}|: in that case an optional argument following
% coordinate pair denotes the placement within the box which can have
% different values compared to case C above.
% \end{itemize}
%
% To cater for this overloaded structure we can define |\makebox| to
% be something like the following:
%\begin{verbatim}
%\DeclareDocumentCommand \makebox { C{\NoValue} o O{c} m}
% { \IfNoValueTF{#1}
%     { \ltx@maketextbox{#2}{#3}{#4} }
%     { \ltx@makepicbox #1  {#2}{#4} } }
%\end{verbatim}
% In other words: if we do not see a coordinate pair first (i.e.,
% first argument is |\NoValue| then we expect up to two optional
% arguments (the width of the box or |\NoValue| if not given and the
% placement specifier with a default of |c| if not given) and one
% mandatory one which is the text. In that case we pass argument 2 to
% 4 to an internal function |\ltx@maketextbox| which builds the text
% box.
%
% Otherwise, if the first argument is a coordinate pair we parse an
% optional argument denoting the placement specifier. Since
% \texttt{xparse} doesn't support variant syntax we actually parse for
% another optional argument (which has no meaning in that case and is
% in fact ignored if present) followed by a mandatory one containing
% the box text. In that case we pass the coordinate pair (|#1|), the
% specifier (|#2|), and the text (|#4|) to the function
% |\ltx@makepicbox| which builds the picture box. Note the special
% handling of the coordinatesD: which are passed without surrounding
% braces to |\ltx@makepicbox|: since the coordinate argument looks
% like |{x-val}{y-val}| the receiving function |\ltx@makepicbox| gets
% the |x-val| as argument one and the |y-val| as argument two.
%
% A definition for |\framebox| would look more or less identical
% except that we would need to pass the arguments to slightly
% different internal functions. The alternative is to give the
% internal functions an extra argument that controls whether or not a
% frame is bying built.
%
% \begin{macro}{\ltx@makepicbox}
% So here is a possible implementation of |\ltx@makepicbox| that
% builds a picture box with or without frame. It takes the following
% mandatory arguments:
% \begin{enumerate}
% \item x-part of coordinate
% \item y-part of coordinate
% \item placement specifier, e.g., |lt| or |\NoValue|
% \item text of box
% \item the token |\frame| (if a frame should surround the box) or the
% token |\@firstofone| --- not pretty i agree
% \end{enumerate}
%\begin{verbatim}
%\def\ltx@makepicbox#1#2#3#4#5
%  {
%   #5{
%     \vbox to#2\unitlength
%      {\let\mb@b\vss \let\mb@l\hss\let\mb@r\hss
%       \let\mb@t\vss
%       \IfNoValueF{#3}
%        {
%         \@tfor\reserved@a :=#3\do{
%           \if s\reserved@a
%             \let\mb@l\relax\let\mb@r\relax
%           \else
%             \expandafter\let\csname mb@\reserved@a\endcsname\relax
%           \fi}%
%        }
%       \mb@t
%       \hb@xt@ #1\unitlength{\mb@l #4\mb@r}
%       \mb@b
%       \kern\z@}
%   }
%  }
%\end{verbatim}
% \end{macro}
%
%
%
% \begin{macro}{\ltx@maketextbox}
% For the text case the internal function could  take the following
% mandatory arguments:
% \begin{enumerate}
% \item width of the box or |\NoValue| (denoting to build the box at
% natural width)
% \item placement specifier, e.g., |l|. (No test for |\NoValue| being undertaken)
% \item text of box
% \item the token |\fbox| (if a frame should surround the box) or the
% token |\mbox|
% \end{enumerate}
% The actual code is taken straight from the current \LaTeX{} kernel
% and looks kind of scary.
%\begin{verbatim}
%\def\ltx@maketextbox#1#2#3#4
% {
%  \IfNoValueTF{#1}
%     {#4{#3}}
%     {
%      \leavevmode
%      \@begin@tempboxa\hbox{#3}
%       \setlength\@tempdima{#1}
%       \ifx#4\fbox
%         \setbox\@tempboxa\hb@xt@\@tempdima
%              {\kern\fboxsep\csname bm@#2\endcsname\kern\fboxsep}
%         \@frameb@x{\kern-\fboxrule}
%       \else
%         \hb@xt@\@tempdima{\csname bm@#2\endcsname}
%       \fi
%      \@end@tempboxa
%     }
% }
%\end{verbatim}
% \end{macro}
%
% \begin{macro}{\makebox}
% \begin{macro}{\framebox}
% Given the above internal functions the declarations of |\makebox|
% and |\framebox| would then look like this:
%\begin{verbatim}
%\DeclareDocumentCommand \makebox { C{\NoValue} o O{c} m}
% { \IfNoValueTF{#1}
%     { \ltx@maketextbox{#2}{#3}{#4}\mbox }
%     { \ltx@makepicbox #1  {#2}{#4}\@firstofone } }
%
%\DeclareDocumentCommand \framebox { C{\NoValue} o O{c} m}
% { \IfNoValueTF{#1}
%     { \ltx@maketextbox{#2}{#3}{#4}\fbox }
%     { \ltx@makepicbox #1  {#2}{#4}\frame } }
%\end{verbatim}
% \end{macro}
% \end{macro}
%
%
% \subsection{Open issues}
%
% In this section unresolved issues or ideas to think about and
% perhaps implement are collected. There is no particular order to
% them.
%
% \begin{itemize}
% \item
%   It was suggested to provide a generalised version of the `s' spec
%   to allow parsing for single symbols other than a star. Possible
%   interface could be |S{|\meta{symbol}|}|, e.g. |S{+}| to parse for
%   a plus sign returning |\BooleanTrue| if found and |\BooleanFalse|
%   otherwise.
%
%   Implementation would be straight forward.
%
% \item
%   Furthermore it was suggested to provide a generic extension
%   interface, comparable to |\newcolumntype| in the \texttt{array}
%   package. It is not clear whether or not such a feature could be
%   easily added.
%
% \item
%   Support for parsing verbatim type of arguments was considered (and
%   actually implemented at one stage. E.g.,
%   |g{|\meta{prepare-parsing}|}| where |g| first run
%   \meta{prepare-parsing} (which might involve |catcode|
%   changes)\footnote{urg horror!}, then look at the next token: if
%   that would be a |{| it would scan a brace delimited argument
%   (reverting catcodes of |{| and |}| if needed) otherwise would scan
%   for an argument delimited by that token so that something like
%   |\verb+%\+| would scan |%\| as its argument assuming that the
%   \meta{prepare-parsing} turned |%| and |\| into non-letters.
%
%   All kind of nasty problems lurking especially no proper error
%   checks possible and of course as we all know such commands would
%   then not work inside arguments of other commands.
%
%   Also no way to make the parsing smart by not accepting newlines as
%   part of the code (|\verb| does this right now and this is really
%   helpful as it catches runaways nicely).
%
% \item
%   Do arguments accept |\par| (ie are they |\long| in \TeX{}speak) or
%   should this be configurable (by having a prefix like |P| denoting
%   an argument that potenially accepts more than a single paragraph?
%   Or is it enough to make this a feature of the whole command rather
%   than an individual argument?
%
%   Right now this is not implemented but probably something like this
%   needs to be implemented.
%
% \item
%   There is the open issue of passing the arguments for an
%   environment not only to the begin code but also to the end
%   code. The current implementation provides for both but it is
%   questionable if this feature is really beneficial compared to the
%   overhead it produces.
%
% \item
%   Setting up the boolean and the quark-like data type doesn't belong
%   into this package since it is internal programming and needs to be
%   implemented at the template level.
%
% \end{itemize}
%
% \StopEventually{}
%
% \section{Implementation}
%
% The implementation section currently contains several trial
% implementations and updates. This final version will probably look
% quite differently again.
%
% Set up certain defaults including to ignore white space
% within the body of this package.
%    \begin{macrocode}
%<*package>
% -----START-------
\RequirePackage{ldcsetup}
\RequirePackage{l3tlp,l3toks,l3prg,l3int}
\InternalSyntaxOn
%    \end{macrocode}
%
%
%
% \subsection{The Carlisle implementation for the parsing}
%
% Not implemented in this version is |\DeclareDocumentEnvironment|
% (exercise for the reader).\footnote{Exercise now completed by DPC :-)
%    (required re-implementing argument grabbers to grab to a toks
%     register rather that into a brace group in the input stream.) }
%
% Seemed to need a few toks registers.
%    \begin{macrocode}
\toks_new:N \l_parsers_toks
\toks_new:N \l_arg_spec_toks
\toks_new:N \l_margs_parsers_toks
%    \end{macrocode}
%
%
% \begin{macro}{\DeclareDocumentCommand}
%  Args: |#1| csname,
% |#2| soom argument spec,
% |#3| code
%
% In |#2| currently supported types are:
%     s star,
%     o \oarg{optional},
%     m \marg{mandatory}.\footnote{More added in reimplementation below.}
%
% |#3| is just grabbed so as to not get a space in the argument spec
%    for definition.
%
%    \begin{macrocode}
\def_long:Npn \DeclareDocumentCommand #1 #2 #3{
%    \end{macrocode}
%
% Needed to count no of arguments
%    \begin{macrocode}
   \int_zero:N \l_tmpa_int
%    \end{macrocode}
%
% Builds up list of argument parsers |\xparse_s:w \xparse_xm:w| etc
%    \begin{macrocode}
   \toks_clear:N \l_parsers_toks
%    \end{macrocode}
%
% Builds up |#1#2#3#4| argument spec
%    \begin{macrocode}
   \toks_clear:N \l_arg_spec_toks
%    \end{macrocode}
%
% Builds up list of m-arguments
% occurred since start or since argument of another type.
%    \begin{macrocode}
   \toks_clear:N \l_margs_parsers_toks
%    \end{macrocode}
%
% Start parsing argument spec
%    \begin{macrocode}
   \xparse_parse_sig:n #2 X
%    \end{macrocode}
%
% Define top level command, this just has the wrapper command
% |\xparse_eval_protect:nNN| then the argument grabbers from
% |\l_parsers_toks| then the original
% command name (in case we need to |\protect|) then the internal
% command with the code.
%    \begin{macrocode}
   \def:Npx #1 {
     \exp_not:N \xparse_eval_protect:nNN
       {\toks_use:N\l_parsers_toks}
       \exp_not:c {\token_to_string:N #1}
       \exp_not:N  #1
    }
%    \end{macrocode}
% The |\long| below could be |\relax| if wanted to have a star-non-long
% form of this, cf |\newcommand*|. The argument preamble for
% |\def_long:Npn| comes from |\l_arg_spec_toks|.
%    \begin{macrocode}
   \exp_after:NN \def_long:Npn
          \cs:w \token_to_string:N #1\exp_after:NN \cs_end:
          \toks_use:N\l_arg_spec_toks{#3}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xparse_eval_protect:nNN}
%
% Arguments: |#1| set of argument grabbers,
% |#2| internal command,
% |#3| top level command for |\protect|ing.
%
%    \begin{macrocode}
\def\xparse_eval_protect:nNN#1#2#3{
  \if_meaning:NN \protect \@typeset@protect
    \exp_after:NN \use_arg_i:n
  \else:
    \protect #3
    \exp_after:NN \use_none:n
  \fi:
%    \end{macrocode}
%
% The command+arguments so far are kept in a token register until
% the last moment for ease of processing. So need to  initialise
% that and use it at the end.
%    \begin{macrocode}
  {\toks_set:Nn \l_parsers_toks {#2}
   #1\toks_use:N\l_parsers_toks}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xparse_parse_sig:n}
% Argument: |#1| one of s o m (or X denoting end of parsing).
%    \begin{macrocode}
%<*obsolete>
\def\xparse_parse_sig:n#1{
  \if_meaning:NN #1 X
%    \end{macrocode}
% fini
%    \begin{macrocode}
  \else:
  \if_meaning:NN #1 m
%    \end{macrocode}
%    If doing an m, just stick another |m| in a temporary list that is
%    eventually turned into a collective argument parser.
%    \begin{macrocode}
   \toks_put_right:Nn \l_margs_parsers_toks m
  \else:
%    \end{macrocode}
%
% Otherwise for o and s
% in |\l_parsers_toks| first add any `m' argument parsers saved up
% then add |\xparse_o:w| or |\xparse_s:w|.
%    \begin{macrocode}
  \toks_set:No \l_parsers_toks {%
     \the \exp_after:NN \l_parsers_toks
     \cs:w xparse_
           \toks_use:N\l_margs_parsers_toks
           :w
           \exp_after:NN \cs_end:
     \cs:w xparse_#1:w \cs_end:}
%    \end{macrocode}
%
% Clear list of m's:
%    \begin{macrocode}
   \toks_clear:N \l_margs_parsers_toks
  \fi:
%    \end{macrocode}
%
% Add one to argument count.
%    \begin{macrocode}
  \advance\@tempcnta\@ne
%    \end{macrocode}
%
% Internally all arguments are non delimited args, so add
% |#|\meta{n} to the list in |\l_arg_spec_toks|
%    \begin{macrocode}
  \toks_set:No \l_arg_spec_toks {
     \the \exp_after:NN \l_arg_spec_toks\exp_after:NN ##\the\@tempcnta}
%    \end{macrocode}
%
% Loop:
%    \begin{macrocode}
  \exp_after:NN
  \xparse_parse_sig:n
%    \end{macrocode}
%
%    \begin{macrocode}
  \fi:}
%</obsolete>
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xparse_s:w}
% Argument: |#1| any remaining argument grabbers (+ |\toks_use:N|)
%    \begin{macrocode}
\def_long:Npn \xparse_s:w #1 \l_parsers_toks{
%    \end{macrocode}
%
% put back the rest of the argument grabbers, but add new
% (boolean) argument to list of arguments inside the register.
%    \begin{macrocode}
  \@ifstar
    {\toks_put_right:Nn \l_parsers_toks \c_true %\BooleanTrue
     #1\l_parsers_toks}
    {\toks_put_right:Nn \l_parsers_toks \c_false %\BooleanFalse
     #1\l_parsers_toks}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xparse_o:w}
% Argument: |#1| any remaining argument grabbers (+ |\toks_use:N|).
%    \begin{macrocode}
\def_long:Npn \xparse_o:w #1\l_parsers_toks{
%    \end{macrocode}
%
% Put back the rest of the argument grabbers, but copy
% argument (now with |{}| or |\NoValue| to list of arguments
%  inside toks register.
%
% Before calling |\@ifnextchar| we start a special group that ensures
% that scanning ahead doesn't trigger anything nasty in |\halign|s
% (see pr3040 in the \LaTeX{} bug db).\footnote{However this is most
% certainly not the right approach: a) we would probably need that
% everywhere (right now it is only implemented for o and O) so perhaps
% the whole thing would need to go into \texttt{\textbackslash
% @ifnextchar} to save space and b) it might be better to get rid of
% \& having catcode 4 and instead make it catcode 13.}
%    \begin{macrocode}
   {\if_num:w`}=0\fi:
   \@ifnextchar[
     {\if_num:w`{=\c_zero\fi:}\xparse_o_help:nw{#1}}
     {\if_num:w`{=\c_zero\fi:}
      \toks_put_right:Nn \l_parsers_toks \NoValue
      #1\l_parsers_toks}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xparse_o_help:nw}
%    Helper to remove [].
%    \begin{macrocode}
\def_long:Npn\xparse_o_help:nw#1[#2]{
  \toks_put_right:Nn \l_parsers_toks {{#2}}
  #1\l_parsers_toks}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{A Mittelbach update to the Carlisle implementation
%    supporting O with default for optional arg and c for coordinates
%    --- prove of concept only}
%
%   Only changed and new commands are listed.
%
%
% \begin{macro}{\xparse_parse_sig:n}
%    The big switch that builds up the parser for the document command.
%
%    The complexity of the |\xparse_parse_sig:n| rewrite suggests that
%    there might
%    be better ways to do it, but for a proto-type solution this is
%    fine enough.
%
%    \begin{macrocode}
\def\xparse_parse_sig:n#1{
  \if_meaning:NN #1 X
%    \end{macrocode}
%    Normally we do nothing at this point and don't pick up the
%    trailing mandatory args into |\l_parsers_toks| but if we want to reuse the
%    argument list in an end environment we have to so at this point.
%    \begin{macrocode}
  \else:
    \if_meaning:NN #1 m
%    \end{macrocode}
%    Just record how many m's seen so far
%    \begin{macrocode}
      \toks_put_right:Nn \l_margs_parsers_toks m
    \else:
%    \end{macrocode}
%    If anything other than an |m| is scanned we add to |\l_parsers_toks| and
%    argument grabber that gets all |m|'s in one go rather than argument
%    grabbers that pick up each |m| at a time. Right now this
%    unnecessarily adds |\xparse_x:w| if no |m|'s have been
%    seen.\footnote{fix, see also below}
%    \begin{macrocode}
     \toks_set:No \l_parsers_toks {%
        \the \exp_after:NN \l_parsers_toks
        \cs:w xparse_x
              \toks_use:N\l_margs_parsers_toks
              :w
              \exp_after:NN \cs_end:
         \cs:w xparse_#1:w \cs_end: }
      \toks_clear:N \l_margs_parsers_toks
%    \end{macrocode}
%    In case of |O| and |C| we have to grab the default next.
%    \begin{macrocode}
      \if_meaning:NN #1 O
         \let:NN \xparse_next_sig_or_default:n \xparse_grab_default:n
      \else:
         \if_meaning:NN #1 C
           \let:NN \xparse_next_sig_or_default:n \xparse_grab_default:n
         \fi:
      \fi:
    \fi:
    \int_incr:N \l_tmpa_int
    \toks_set:No \l_arg_spec_toks {
      \the \exp_after:NN \l_arg_spec_toks \exp_after:NN ##\int_use:N \l_tmpa_int}
    \exp_after:NN
    \xparse_next_sig_or_default:n
  \fi:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xparse_next_sig_or_default:n}
%    By default the loop in the |\xparse_parse_sig:n| code above calls itself
%    recursively until the whole spec is processed.
%    \begin{macrocode}
\let:NN \xparse_next_sig_or_default:n\xparse_parse_sig:n
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xparse_grab_default:n}
%    However if we've seen an |O| we need to grab the default value first.
%    \begin{macrocode}
\def_long:Npn \xparse_grab_default:n #1{
  \toks_put_right:Nn \l_parsers_toks {{#1}}
  \let:NN  \xparse_next_sig_or_default:n \xparse_parse_sig:n
  \xparse_parse_sig:n
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xparse_O:w}
%    This command expects the default value (to use if no |[| is
%    parsed) after it.
%    \begin{macrocode}
\def_long:Npn \xparse_O:w #1#2\l_parsers_toks{
   {\if_num:w`}=0\fi:
   \@ifnextchar[
     {\if_num:w`{=\c_zero\fi:}
      \xparse_o_help:nw {#2} }
     {\if_num:w`{=\c_zero\fi:}
      \toks_put_right:Nn \l_parsers_toks{{#1}}
      #2\l_parsers_toks}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xparse_c:w}
%    We look for the `(' and signal an error
%    if not found. By using |\@ifnextchar| this also takes care of any
%    space tokens in front ot the the parentheses.
%    \begin{macrocode}
\def_long:Npn \xparse_c:w #1 \l_parsers_toks {
   \@ifnextchar (
     {\xparse_c_help:nw #1}
     {\PackageError{xparse}{Missing~ coordinate~ argument}
        {A~ value~ of~ (0,0)~ is~ assumed}
      \toks_put_right:Nn\l_parsers_toks{{00}}
      #1\l_parsers_toks}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xparse_c_help:nw}
%    Helper for |\xparse_c:w| and |\xparse_C:w| below to parse a |(x,y)| if we
%    know it is there.
%    \begin{macrocode}
\def_long:Npn \xparse_c_help:nw #1 (#2,#3) {
  \toks_put_right:Nn\l_parsers_toks{{{#2}{#3}}}
  #1\l_parsers_toks}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xparse_C:w}
%    This way we can also directly implement the optional argument case in
%    a natural way.
%    \begin{macrocode}
\def_long:Npn \xparse_C:w #1#2\l_parsers_toks{
   \@ifnextchar (
     {\xparse_c_help:nw #2}
     {\toks_put_right:Nn\l_parsers_toks{{#1}}
      #2\l_parsers_toks}}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\xparse_xm:w}
%    Instead of |\xparse_m:w| we use |\xparse_xm:w| as with the implementation
%    below we might have a need for |\xparse_x:w| (that is no m's pending)
%    and this would result in a name clash. A potentially better
%    implementation (cause faster) would be not to use |\l_margs_parsers_toks|
%    above to record the number of m's seen but a counter register and
%    generate grabber function names containing the number in their
%    name. This way one could better single out the empty case which
%    currently will always result and a |\xparse_x:w| grabber doing
%    nothing.
%    \begin{macrocode}
\def_long:Npn \xparse_xm:w #1 \l_parsers_toks#2{
 \toks_put_right:Nn \l_parsers_toks{{#2}}
 #1\l_parsers_toks}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xparse_xmm:w}
% \begin{macro}{\xparse_xmmm:w}
% \begin{macro}{\xparse_xmmm...:w}
% Arguments: |#1| any remaining argument grabbers (+ |\toks_use:N|),
% |#2#3| argument to be grabbed; and so on. There can be at most 8
% such mandatory arguments in the variations defined below.
%    \begin{macrocode}
\def_long:Npn\xparse_xmm:w#1\l_parsers_toks#2#3{
%    \end{macrocode}
% Put back the rest of the argument grabbers, but copy
%  argument to list of arguments inside the toks register.
% Any `m' at the end will be discarded and the internal
% command will pick up its own arguments.
%    \begin{macrocode}
 \toks_put_right:Nn\l_parsers_toks{{#2}{#3}} #1\l_parsers_toks}
%    \end{macrocode}
%
% And here are the cases for 3 to eight upcoming mandatory args:
%    \begin{macrocode}
\def_long:Npn\xparse_xmmm:w#1\l_parsers_toks#2#3#4{
 \toks_put_right:Nn\l_parsers_toks{{#2}{#3}{#4}}
 #1\l_parsers_toks}
\def_long:Npn\xparse_xmmmm:w#1\l_parsers_toks#2#3#4#5{
 \toks_put_right:Nn\l_parsers_toks{{#2}{#3}{#4}{#5}}
 #1\l_parsers_toks}
\def_long:Npn\xparse_xmmmmm:w#1\l_parsers_toks#2#3#4#5#6{
 \toks_put_right:Nn\l_parsers_toks{{#2}{#3}{#4}{#5}{#6}}
 #1\l_parsers_toks}
\def_long:Npn\xparse_xmmmmmm:w#1\l_parsers_toks#2#3#4#5#6#7{
 \toks_put_right:Nn\l_parsers_toks{{#2}{#3}{#4}{#5}{#6}{#7}}
 #1\l_parsers_toks}
\def_long:Npn\xparse_xmmmmmmm:w#1\l_parsers_toks#2#3#4#5#6#7#8{
 \toks_put_right:Nn\l_parsers_toks{{#2}{#3}{#4}{#5}{#6}{#7}{#8}}
 #1\l_parsers_toks}
\def_long:Npn\xparse_xmmmmmmmm:w#1\l_parsers_toks#2#3#4#5#6#7#8#9{
 \toks_put_right:Nn\l_parsers_toks{{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}}
 #1\l_parsers_toks}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\DeclareDocumentEnvironment}
%    Fixing |\DeclareDocumentEnvironment| to not choke on the spec
%    |m|. Interestingly enough |mm| does work with the old
%    implementation: it simply grabs |\@checkend{name}| whereas the
%    first only grabs |\@checkend| leaving |{name}| around for
%    typesetting :-)
%
%    If we don't make the arguments available in the end code we
%    should most likely revert to David's original code which worked
%    without assigning everything to toks registers (or at least check
%    what is faster!)
%    \begin{macrocode}
\def_long:Npn\DeclareDocumentEnvironment#1#2#3#4{
  \exp_after:NN \DeclareDocumentCommand \cs:w #1\cs_end: {#2}{
%    \end{macrocode}
%     After |\DeclareDocumentCommand| has parsed the arguments the
%     parsing result is available in |\l_parsers_toks| except that trailing
%     |m|'s are picked up directly and their values are therefore not
%     part of this token register. So either we have to slow down
%     everything by individually parsing those as well or this bright
%     idea is not working. For the moment i disabled it again!
%    \begin{macrocode}
    #3}
%    \end{macrocode}
%    In that case the following can be simplified as well:
%    \begin{macrocode}
   \def_long:Npc {end #1}{#4}
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{A different interface (for class design?)}
%
% Combining signature and top-level definition of a command |\foo| as
% in
%\begin{verbatim}
%\DeclareDocumentCommand \foo { m c m }
%{ \typeout{1:#1}
%  \typeout{2:#2}
%  \typeout{3:#3}
%}
%\end{verbatim}
% is fine in certain cases, e.g., if the user wants to declare a few
% commands this way in the preamble of a document. However in a class
% file it probably better to completely separate signature (i.e.,
% argument \#1 and \#2) from top-level implementation (i.e., argument
% \#3).
%
%
%\begin{verbatim}
%\DeclareDocumentCommandInterface \foo {bar} { m c m }
%\end{verbatim}
% The above now declare only the signature of the command |\foo| and
% states that the implementation is to be found under the label |bar|.
%
% A bunch of such statements would then for the first time clearly
% define a document class (i.e., what a document class instance need
% to define to be complient)
%
% An instance would then consist of a lot of declarations of the type
%\begin{verbatim}
%\DeclareDocumentCommandImplementation {bar} {3}
%{ \typeout{1:#1}
%  \typeout{2:#2}
%  \typeout{3:#3}
%}
%\end{verbatim}
% i.e., defining how to format things being referenced as part of the
% signature.
%
%
%
% \begin{macro}{\DeclareDocumentEnvironment}
%    \begin{macrocode}
\def_long:Npn\DeclareDocumentCommandInterface #1 #2 #3{
   \int_zero:N \l_tmpa_int
   \toks_clear:N \l_parsers_toks
   \toks_clear:N \l_arg_spec_toks
   \toks_clear:N \l_margs_parsers_toks
   \xparse_parse_sig:n #3 X
   \def:Npx #1 {
    \exp_not:N  \xparse_eval_protect:nNN
       {\toks_use:N \l_parsers_toks}
       \exp_not:c {impl-#2}
       \exp_not:N #1
    }
%    \end{macrocode}
%    If only the signature is defined but no implementation we typeset
%    the implementation label in angle brackets and give a warning.
%    Probably should by default give an error with a switch to turn it
%    into a warning if desired.
%    \begin{macrocode}
   \exp_after:NN \def_long:Npn \cs:w impl-#2\exp_after:NN \cs_end:
          \toks_use:N \l_arg_spec_toks
          {$\langle$\textit{#2}$\rangle$
           \PackageWarning{xparse}{No~ implementation~
              for~ `#2'\MessageBreak defined}}
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\DeclareDocumentEnvironment}
%    \begin{macrocode}
\def_long:Npn \DeclareDocumentCommandImplementation #1 #2 #3{
   \exp_after:NN \renewcommand \cs:w impl-#1\cs_end: [#2]{#3}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{A Quark-like datatype}
%
% If it turns out that the only quark thingie is going to be
% |\NoValue| then this can be streamlined for speed (and it looks
% like this is the case)!
%
% \begin{macro}{\IfSomethingTF}
% \begin{macro}{\IfSomethingT}
% \begin{macro}{\IfSomethingF}
% Setting up the stage \ldots
%    \begin{macrocode}
\def\IfSomethingTF#1{\def\something@in{#1} \If@SomethingTF}
\def\IfSomethingT#1#2#3{\def\something@in{#1}
                        \If@SomethingTF{#2}{#3}\@empty}
\def\IfSomethingF#1#2#3{\def\something@in{#1}
                        \If@SomethingTF{#2}\@empty{#3}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\If@SomethingTF}
% \ldots and then for the recursive part:
%    \begin{macrocode}
\def\If@SomethingTF#1{
   \def:Npn \something@tmp{#1}
   \if_meaning:NN\something@tmp\something@in
%fini true
     \exp_after:NN \use_arg_ii:nnn
   \else:
       \exp_after:NN \def\exp_after:NN \something@tmpb\exp_after:NN {#1}
       \if_meaning:NN \something@tmp\something@tmpb
%fini false
         \exp_after:NN \exp_after:NN \exp_after:NN \use_arg_iii:nnn
       \else:
%try again expanded
         \exp_after:NN \exp_after:NN \exp_after:NN \use_arg_i:n
       \fi:
   \fi:
   {\exp_after:NN \If@SomethingTF\exp_after:NN {#1}}
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Testing for \texttt{\textbackslash NoValue}}
%
%
% \begin{macro}{\NoValue}
%    \begin{macrocode}
\def\NoValue{-NoValue-}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\NoValueInIt}
%    might be handy sometimes\ldots
%    \begin{macrocode}
\def\NoValueInIt{\NoValue}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\IfNoValueTF}
% \begin{macro}{\IfNoValueT}
% \begin{macro}{\IfNoValueF}
%    \begin{macrocode}
\def\IfNoValueTF{\IfSomethingTF\NoValue}
\def\IfNoValueT {\IfSomethingT \NoValue}
\def\IfNoValueF {\IfSomethingF \NoValue}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\IfValueTF}
% \begin{macro}{\IfValueT}
% \begin{macro}{\IfValueF}
%    \begin{macrocode}
\def\IfValueTF #1 #2 #3 { \IfNoValueTF {#1} {#3} {#2} }
\let:NN  \IfValueT \IfNoValueF
\let:NN  \IfValueF \IfNoValueT
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{A Boolean datatype}
% We just use the one from \textsf{l3prg}.
% \begin{macro}{\BooleanFalse}
% \begin{macro}{\BooleanTrue}
%    \begin{macrocode}
%<*obsolete>
\def\BooleanFalse{TF}
\def\BooleanTrue{TT}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\IfBooleanTF}
% \begin{macro}{\IfBooleanT}
% \begin{macro}{\IfBooleanF}
%    \begin{macrocode}
\def\IfBooleanTF #1 {
   \if#1
       \exp_after:NN \@firstoftwo
   \else
       \exp_after:NN \@secondoftwo
   \fi
}
\def\IfBooleanT #1 #2 {
   \IfBooleanTF {#1} {#2} \@empty
}
\def\IfBooleanF #1 {
   \IfBooleanTF {#1} \@empty
}
%</obsolete>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\IfBooleanTF}
% \begin{macro}{\IfBooleanT}
% \begin{macro}{\IfBooleanF}
%    \begin{macrocode}
\let:NN \IfBooleanTF \prg_logic_test:nTF
\let:NN \IfBooleanT  \prg_logic_test:nT
\let:NN \IfBooleanF  \prg_logic_test:nF
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%    \begin{macrocode}
%</package>
%<*obsolete>
%    \end{macrocode}
%
% \begin{macro}{\xparse_m:w}
% Arguments: |#1| any remaining argument grabbers (+ |\toks_use:N|),
% |#2| argument to be grabbed.
%    \begin{macrocode}
\def_long:Npn\xparse_m:w#1\l_parsers_toks#2{
%    \end{macrocode}
% put back the rest of the argument grabbers, but copy
%  argument to list of arguments inside the toks register.
% Any `m' at the end will be discarded and the internal
% command will pick up its own arguments.
%    \begin{macrocode}
 \toks_put_right:Nn\l_parsers_toks{{#2}}
 #1 \l_parsers_toks}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</obsolete>


%<*perhaps>
\toks_new:N \xparsed@args
%    \end{macrocode}
%
% \begin{macro}{\xparse_xmmmmmmmmm:w}
% If we grab arguments even if they are all mandatory we might have
% even 9 such arguments, thus we also need:
%    \begin{macrocode}
\def_long:Npn\xparse_xmmmmmmmmm:w\toks_use:N\l_parsers_toks#1#2#3#4#5#6#7#8#9{
 \toks_put_right:Nn \l_parsers_toks
     {{#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}}\toks_use:N\l_parsers_toks}
%    \end{macrocode}
% And in that case we also need to provide |\xparse_x:w| as that name will
% be executed if there are no trailing mandatory arguments.
%    \begin{macrocode}
\let:NN \xparse_x:w\relax
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareDocumentEnvironment}
% The implementation here could save a csname or two per environment
% if |\begin| and especially |\end| were modified but that not done here
% so each end code responsible for getting its own arguments.
%
% Arguments: |#1| env name,
% |#2| soom spec,
% |#3| begin code,
% |#4| end code.
%
%    \begin{macrocode}
\def_long:Npn \DeclareDocumentEnvironment #1#2#3#4 {
  \exp_after:NN \DeclareDocumentCommand \cs:w #1 \cs_end: {#2}{
    \xparsed@args\l_parsers_toks
    #3}
  \let:cN {end #1} \@parsed@endenv
  \exp_after:NN \def_long:Npn \cs:w end \token_to_string:N \\#1 \exp_after:NN \cd_end:
    \toks_use:N\l_arg_spec_toks {#4}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@parsed@endenv}
% All end codes are let to this. (Could be merged into |\end|.)
%    \begin{macrocode}
\def\@parsed@endenv{
  \exp_after:NN \@parsed@endenv@\toks_use:N\xparsed@args}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@parsed@endenv@}
% Helper that just replaces the internal name of the begin code
% with that of the end code.
%    \begin{macrocode}
\def\@parsed@endenv@#1{ \use:c{end\token_to_string:N #1} }
%    \end{macrocode}
% \end{macro}
%
%    The above does the fixing by not providing the arguments to the
%    end command. The alternative is to do full parsing and could
%    perhaps look more or less like this:
%    \begin{macrocode}
\def_long:Npn\DeclareDocumentEnvironment#1#2#3#4{
  \let:NN \perhaps@grab@ms\grab@ms
  \exp_after:NN \DeclareDocumentCommand \cs:w #1 \cs_end: {#2}{
%    \end{macrocode}
%    I think we need as a safety measure add a group here or else the
%    code will fail over if people use it without |\begin|\ldots
%    |\end|.
%    Or not? I don't really like it but then i don't want to maintain
%    a private stack here.
%    \begin{macrocode}
    \group_begin:
    \xparsed@args\l_parsers_toks
    #3}
  \let:NN \perhaps@grab@ms\relax
  \let:cN {end #1} \@parsed@endenv
  \exp_after:NN \def_long:Npn \cs:w end \token_to_string:N \\#1 \exp_after:NN \cs_end:
     \toks_use:N \l_arg_spec_toks {#4}
}
%    \end{macrocode}
%    Same as in David's again except that we have the added group now.
%    \begin{macrocode}
\def:Npn \@parsed@endenv{
  \exp_after:NN \@parsed@endenv@\the\xparsed@args\group_end:}
\def:Npn \@parsed@endenv@#1{ \use:c {end\token_to_string:N #1} }
%    \end{macrocode}
% However the above will fail with |\begin{macro}| code of the
% \texttt{doc} package as this code cancels the outer group so it is
% dangerous and for the moment i have not activated it.
%
%    \begin{macrocode}
%</perhaps>
%    \end{macrocode}
%
%
% \subsection{The Mittelbach/Rowley prove-of-concept
%             implementation for the parsing}
%
% \begin{macro}{\DeclareDocumentCommand}
%    \begin{macrocode}
%<*obsolete>
\def\DeclareDocumentCommand #1 #2  {
%  \parse@countargs {#2} % sets \@tempc    % Not implemented yet
  \def\parse@csname{#1}
  \def\parse@spec{#2}
  \afterassignment \declare@dt@
  \toks@
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\declare@dt@}
%    \begin{macrocode}
\def \declare@dt@ {
  \expandafter \edef \parse@csname
    { \noexpand \parse@something
        { \parse@spec }
        { \the\toks@ }
        % { \@tempc }
    }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareDocumentEnvironment}
%    \begin{macrocode}
\long\def\DeclareDocumentEnvironment #1 #2  {
%  \parse@countargs {#2} % sets \@tempc    % Not implemented yet
  \def\parse@csname{#1}
  \def\parse@spec{#2}
  \afterassignment \declare@de@
  \toks@
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\declare@de@}
%    \begin{macrocode}
\def \declare@de@ {
  \expandafter \edef \csname \parse@csname \endcsname
    { \group_begin:
      \noexpand \parse@something
        { \parse@spec }
        { \the\toks@ }
        % { \@tempc }
    }
  \afterassignment \declare@dee@
  \toks@
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\declare@dee@}
%    \begin{macrocode}
\def \declare@dee@ {
  \expandafter \edef \csname end\parse@csname \endcsname
    { \noexpand \parse@apply
        { \the\toks@ }
        \noexpand \parse@results
      \endgroup
    }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\parse@apply}
%    \begin{macrocode}
\def\parse@apply #1 {
      \renewcommand \parse@tempa [\the\parse@cnt] {#1}
      \expandafter \parse@tempa %    #2 implicit
}
\let\parse@tempa\@empty % or \renew... might bulk the first time
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\parse@something}
%    \begin{macrocode}
%% CCC here and elsewhere there are some suggestions for
%      not counting args at run-time
\def \parse@something #1 #2 {  % #3
  \parse@body {#2}
  % \parse@cnt #3
  \parse@cnt \m@ne  % REMOVE
  \parse@args #1x \parse@args {}
}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcount\parse@cnt
\newtoks\parse@body
%    \end{macrocode}
%
%    \begin{macrocode}
\def\parse@args #1 #2\parse@args #3 {
  \advance \parse@cnt \@ne % REMOVE
  \csname parse@#1 \endcsname {#2}{#3}
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \parse@s #1 #2 {
  \@ifstar
      { \parse@args #1 \parse@args { #2 \BooleanTrue } }
      { \parse@args #1 \parse@args { #2 \BooleanFalse } }
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \parse@m #1 #2 #3 {
      \parse@args #1 \parse@args { #2 {#3} }
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \parse@x #1 #2 {
      \def \parse@results {#2}   % for environment
%      \def \parse@tempa {
%        \renewcommand \parse@tempb [\the\parse@cnt]
%      }
%      \expandafter \parse@tempa \expandafter { \the \parse@body }
%      \parse@tempb #2
      \expandafter \parse@apply \expandafter { \the \parse@body }
                            \parse@results % \parse@apply expands this!
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \parse@o #1 #2 {
  \@ifnextchar [
      { \parse@o@ {#1}{#2} }
      { \parse@args #1 \parse@args { #2 \NoValue } }
}
%    \end{macrocode}
%
%    \begin{macrocode}
\def \parse@o@ #1 #2 [#3] {
      \parse@args #1 \parse@args { #2 {#3} }
}
%</obsolete>
%    \end{macrocode}
% \end{macro}
%
%
% \Finale
%
\endinput
