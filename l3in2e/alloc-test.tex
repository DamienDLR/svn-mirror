\documentclass{article}
\usepackage{l3prop,l3prg,l3num}
\CodeStart
\def:Npn \minitraceon{\tracingmacros2~ \tracingassigns2~}
\def:Npn \minitraceoff{\tracingmacros0~ \tracingassigns0~}
%    \begin{macrocode}
% Missing in the int module.
\def_new:Npn \int_to_roman:n #1{\tex_romannumeral:D #1}

%    \end{macrocode}
% Assume $|\g_ins_allocation_num| =42$, $|\g_int_allocation_num| =60$,
% $|\g_box_allocation_num| =50$, and $|\g_toks_allocation_num| =48$. In
% this case we want to define \g_footnote_ins to be a shorthand for
% |\insert61| so that we can have |\count61| etc. Thus we check which
% number is the highest. We know that |\g_ins_allocation_num| is the
% smallest so no need to use that.
% Now check which is the larger of these numbers -- chances are its
% |\g_int_allocation_num|.
%    \begin{macrocode}
\num_new:N \g_ins_allocation_num
\prop_new:N \g_ins_allocation_plist
\num_new:N \g_reserved_insertions_num
%    \end{macrocode}
%  The insertion classes aren't extended in \eTeX{} but they are in
%  Omega. Hence for \eTeX{} we have to reserve the insertions we need
%  whereas we for Omega can simply activate them when needed.
%    \begin{macrocode}
\engine_aleph:TF {}
%    \end{macrocode}
%  For the insertion classes we reserve the first 150 since this array
%  isn't extended in \eTeX. Start with number 11.
%    \begin{macrocode}
{
  \num_set:Nn \g_ins_allocation_num {11}
  \num_set:Nn \g_reserved_insertions_num {150}
}

\engine_aleph:TF {
%    \end{macrocode}
% With Omega we have all the insertions we could possibly want so
% when we encounter a request for an insertion we simply check
% which of the needed register types has the largest number.
%    \begin{macrocode}
  \def_new:Npn \ins_new:N #1 {
    \cs_free:NTF #1
    {
      \num_compare:nNnTF \g_ins_allocation_num < \g_int_allocation_num
        {\num_set:Nn \l_tmpa_num \g_int_allocation_num  }
        {\num_set:Nn \l_tmpa_num   \g_ins_allocation_num  }
      \num_compare:nNnT \l_tmpa_num < \g_box_allocation_num
        {\num_set:Nn \l_tmpa_num   \g_box_allocation_num  }
      \num_compare:nNnT \l_tmpa_num < \g_toks_allocation_num
        {\num_set:Nn \l_tmpa_num   \g_toks_allocation_num }
%    \end{macrocode}
%  Now we have the biggest number stored in |\g_ins_allocation_num|.
%  Then we add~1 and check if we happened to get to insertion 255 which
%  is extremely bad, so we simply add another one to get to 256.
%    \begin{macrocode}
      \num_set:Nn \g_ins_allocation_num {\l_tmpa_num+1}
      \io_put_log:x{\token_to_string:N\g_ins_allocation_num=\num_use:N \g_ins_allocation_num}
      \num_compare:nNnT \g_ins_allocation_num=\c_twohundred_fifty_five
        {\num_gincr:N \g_ins_allocation_num}
      \pref_global:D \tex_chardef:D #1=\g_ins_allocation_num\scan_stop:
%    \end{macrocode}
%  Some message here:
%    \begin{macrocode}
      \io_put_log:x{\token_to_string:N#1=insertion~register~\num_use:N \g_ins_allocation_num}
%    \end{macrocode}
%  We put something like |\lxi {\g_footnote_ins}| in the property list
%  and do the same for \m{toks}, \m{int}, and \m{box}.
%    \begin{macrocode}
      \prop_gput:Ncn \g_ins_allocation_plist
      {alloc_key_ \int_to_roman:n {\num_use:N \g_ins_allocation_num }}{#1}
      \prop_gput:Ncn \g_int_allocation_plist
      {alloc_key_ \int_to_roman:n {\num_use:N \g_ins_allocation_num }}{#1}
      \prop_gput:Ncn \g_box_allocation_plist
      {alloc_key_ \int_to_roman:n {\num_use:N \g_ins_allocation_num }}{#1}
      \prop_gput:Ncn \g_toks_allocation_plist
      {alloc_key_ \int_to_roman:n {\num_use:N \g_ins_allocation_num }}{#1}
    }
    {
      \err_latex_bug:n {The~ register~ `\token_to_string:N #1'~ is~ already~ defined!}
    }
  }
}
%    \end{macrocode}
%  The non-Omega code.
%    \begin{macrocode}
{
  \def_new:Npn \ins_new:N #1 {
    \cs_free:NTF #1
    {
%    \end{macrocode}
%  Now we have the biggest number stored in |\g_ins_allocation_num|.
%  Then we add~1 and check if we happened to get to insertion 255 which
%  is extremely bad, so we simply add another one to get to 256.
%    \begin{macrocode}
      \num_gincr:N \g_ins_allocation_num
      \io_put_log:x{\token_to_string:N\g_ins_allocation_num=\num_use:N \g_ins_allocation_num}
      \num_compare:nNnTF \g_ins_allocation_num=\c_twohundred_fifty_five
      { \err_latex_bug:n {Sorry,~no~ room~ for~ a~ new~ insertion~register~of~type!} }
      {
        \pref_global:D \tex_chardef:D #1=\g_ins_allocation_num\scan_stop:
%    \end{macrocode}
%  Some message here:
%    \begin{macrocode}
        \io_put_log:x{\token_to_string:N#1=insertion~register~\num_use:N \g_ins_allocation_num}
%    \end{macrocode}
%  We put something like |\lxi {\g_footnote_ins}| in the property list.
%    \begin{macrocode}
        \prop_gput:Ncn \g_ins_allocation_plist
          {alloc_key_ \int_to_roman:n {\num_use:N \g_ins_allocation_num }}{#1}
%    \end{macrocode}
%  Now we also lock the register |\count61|, |\toks61| and |\box61| so
%  that we don't overwrite them later on. We still put the name of the
%  insertion in there just so we can easily backtrack if needed.
%    \begin{macrocode}
        \prop_gput:Ncn \g_int_allocation_plist
        {alloc_key_ \int_to_roman:n {\num_use:N \g_ins_allocation_num }}{#1}
        \prop_gput:Ncn \g_box_allocation_plist
        {alloc_key_ \int_to_roman:n {\num_use:N \g_ins_allocation_num }}{#1}
        \prop_gput:Ncn \g_toks_allocation_plist
        {alloc_key_ \int_to_roman:n {\num_use:N \g_ins_allocation_num }}{#1}
      }
    }
    {
      \err_latex_bug:n {The~ register~ `\token_to_string:N #1'~ is~ already~ defined!}
    }
  }
}
%    \end{macrocode}
%  Then there's the question of the \m{int}, \m{box}, and \m{toks}
%  registers. The easiest solution is to simply let them skip all the
%  unused registers and start from 61 next time around. The less easy
%  solution is to make sure the registers keep filling up from the
%  bottom. One way of tackling this is shown below.
%
%  \begin{macro}{\alloc_setup_type:n}
%  Whenever we want to allocate a new type we need two \m{num}s and
%  a property list.
%    \begin{macrocode}
\def_new:Npn \alloc_setup_type:n #1{
  \num_new:c  {g_ #1 _allocation_num}
  \num_new:c  {l_ #1 _allocation_num}
  \prop_new:c {g_ #1 _allocation_plist}
  \prop_new:c {l_ #1 _allocation_plist}
}
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\l_search_free_allocation_bool}
%  A boolean used when we decide if a register is free.
%    \begin{macrocode}
\bool_new:N \l_search_free_allocation_bool
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\alloc_new_aux:NNNNnNn}
%  The generic allocation function. The first four arguments are
%  functions that should be either global or local: |#1| is either
%  |\num_gincr:c| or |\num_incr:c|, |#2| is either |\pref_global:D|
%  or |\scan_stop:|, |#3| should be either |\prop_gput:ccn| or
%  |\prop_put:ccn|, and |#4| either |l| or |g|. The rest are the ones
%  needed every time:  |#5| is the name of the register,
%  |#6| is the type like |int|, |#7| is |\tex_countdef| etc., and
%  |#8| is the maximum number allowed for this type.
%    \begin{macrocode}
\def_new:Npn \alloc_new_aux:NNNNNnNn #1#2#3#4#5#6#7#8 {
  \cs_free:NTF #5
%    \end{macrocode}
%  Before we can define the register we have to check that it hasn't already
%  been taken by an |\ins_new:N|.
%    \begin{macrocode}
  {
    \bool_if:NT \l_local_allocation_bool
    {
      \num_set_eq:cc {l_ #6 _allocation_num}{g_ #6 _allocation_num}
      \prop_set_eq:cc {l_ #6 _allocation_plist}{g_ #6 _allocation_plist}
    }
    \bool_set_true:N \l_search_free_allocation_bool
    \bool_while:NT \l_search_free_allocation_bool
%    \end{macrocode}
%  While the boolean is true we step the allocation counter, then
%  check if this value already exists in the property list. If it
%  does we run the loop again and if not we stop and define the
%  counter.
%    \begin{macrocode}
    {
      \prop_if_in:ccTF {#4_ #6 _allocation_plist}
        { alloc_key_ \int_to_roman:n {\num_use:c {#4 _ #6 _allocation_num} } }
        { \bool_set_false:N \l_search_free_allocation_bool }
        { #1 {#4 _ #6 _allocation_num} }% global or local
    }
%    \end{macrocode}
%  Now we've reached a point where we can safely define the register.
%    \begin{macrocode}
    \num_compare:nNnTF {#8} < {\num_use:c {#4 _ #6 _allocation_num} }
    { \err_latex_bug:n {Sorry,~no~ room~ for~ a~ new~ register~of~type~`#6'!} }
    { #2 #7 #5 = \num_use:c {#4 _ #6 _allocation_num} \scan_stop: % global or local
%    \end{macrocode}
%  Some message for the log/terminal and then put it on the known list.
%    \begin{macrocode}
      \cs_record_meaning:N#5
      \io_put_log:x{\token_to_string:N#5=#6~register~\num_use:c {#4 _ #6 _allocation_num}}
      #3 {#4_ #6 _allocation_plist} % global or local
      { alloc_key_ \int_to_roman:n {\num_use:c {#4 _ #6 _allocation_num}}}{#5}
    }
    \bool_if:NT \l_local_allocation_bool
    {
      \num_set_eq:cc {g_ #6 _allocation_num}{l_ #6 _allocation_num}
      \prop_set_eq:cc {g_ #6 _allocation_plist}{l_ #6 _allocation_plist}
    }
  }
%    \end{macrocode}
%  Issue an error if it's already defined.
%    \begin{macrocode}
  {
    \err_latex_bug:n {The~ register~ `\token_to_string:N #5'~ is~ already~ defined!}
  }
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\alloc_global_new:NnNn}
%  \begin{macro}{\alloc_local_new:NnNn}
%  Simply call the generic function with the right type of
%  functions.
%    \begin{macrocode}
\bool_new:N \l_local_allocation_bool
\def_new:Npn \alloc_global_new:NnNn {
  \alloc_new_aux:NNNNNnNn \num_gincr:c \pref_global:D \prop_gput:ccn g
}
\def_new:Npn \alloc_local_new:NnNn {
  \num_compare:nNnTF \etex_currentgrouplevel:D =\c_zero
  {\alloc_new_aux:NNNNNnNn \num_incr:c \scan_stop: \prop_put:ccn g}
  {
    \bool_set_true:N \l_local_allocation_bool
    \alloc_new_aux:NNNNNnNn \num_incr:c \scan_stop: \prop_put:ccn l
  }
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  We can now define the allocation macros quite easily. The \m{int}
%  uses |\tex_countdef:D|.
%    \begin{macrocode}
\alloc_setup_type:n {int}
\def_new:Npn \int_local_new:N #1 {
  \alloc_local_new:NnNn #1 {int} \tex_countdef:D \c_max_register_int }
\def_new:Npn \int_global_new:N #1 {
  \alloc_global_new:NnNn #1 {int} \tex_countdef:D \c_max_register_int }
%    \end{macrocode}
%  However \TeX{} reserves |\count| registers 0--9, and we also need
%  the constant |\c_minus_one| early on so we better make
%  sure that the first \m{int} register we define is number~11.
%    \begin{macrocode}
\tex_countdef:D \c_minus_one = 10\scan_stop: \c_minus_one=-1\scan_stop:
\num_set:Nn \g_int_allocation_num {11+\g_reserved_insertions_num}
%    \end{macrocode}
%  The \m{box} type uses |\const_new_aux:Nw|.
%    \begin{macrocode}
\alloc_setup_type:n {box}
\num_gset_eq:NN \g_box_allocation_num \g_reserved_insertions_num
\def_new:Npn \box_global_new:N #1 {
  \alloc_global_new:NnNn #1 {box}
    \const_new_aux:Nw \c_max_register_int }
\def_new:Npn \box_local_new:N #1 {
  \alloc_local_new:NnNn #1 {box}
    \const_new_aux:Nw \c_max_register_int }
%    \end{macrocode}
%  We do a little trick to ensure that |\box255| isn't allocated by
%  accident by simply adding it to the list of known allocations.
%    \begin{macrocode}
\prop_gput:Ncn \g_box_allocation_plist
  {alloc_ \int_to_roman:n {255}}{\g_main_vertical_list_box}
%    \end{macrocode}
%  \begin{macro}{\toks_global_new:N}
%  \begin{macro}{\toks_local_new:N}
% Token registers.
%    \begin{macrocode}
\alloc_setup_type:n {toks}
\num_gset_eq:NN \g_toks_allocation_num \g_reserved_insertions_num
\def_new:Npn \toks_global_new:N #1 {
  \alloc_global_new:NnNn #1 {toks}
    \const_new_aux:Nw \c_max_register_int }
\def_new:Npn \toks_local_new:N #1 {
  \alloc_local_new:NnNn #1 {toks}
    \const_new_aux:Nw \c_max_register_int }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \begin{macro}{\skip_global_new:N}
%  \begin{macro}{\skip_local_new:N}
% Skip registers.
%    \begin{macrocode}
\alloc_setup_type:n {skip}
\def_new:Npn \skip_global_new:N #1 {
  \alloc_global_new:NnNn #1 {skip}
    \tex_skipdef:D \c_max_register_int }
\def_new:Npn \skip_local_new:N #1 {
  \alloc_local_new:NnNn #1 {skip}
    \tex_skipdef:D \c_max_register_int }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \begin{macro}{\dim_global_new:N}
%  \begin{macro}{\dim_local_new:N}
% Dimen registers.
%    \begin{macrocode}
\alloc_setup_type:n {dim}
\def_new:Npn \dim_global_new:N #1 {
  \alloc_global_new:NnNn #1 {dim}
    \tex_dimendef:D \c_max_register_int }
\def_new:Npn \dim_local_new:N #1 {
  \alloc_local_new:NnNn #1 {dim}
    \tex_dimendef:D \c_max_register_int }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \begin{macro}{\mark_global_new:N}
%  \begin{macro}{\mark_local_new:N}
% Marks registers.
%    \begin{macrocode}
\alloc_setup_type:n {mark}
\def_new:Npn \mark_global_new:N #1 {
  \alloc_global_new:NnNn #1 {mark}
    \const_new_aux:Nw \c_max_register_int }
\def_new:Npn \mark_local_new:N #1 {
  \alloc_local_new:NnNn #1 {mark}
    \const_new_aux:Nw \c_max_register_int }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \begin{macro}{\muskip_global_new:N}
%  \begin{macro}{\muskip_local_new:N}
% Muskip registers.
%    \begin{macrocode}
\alloc_setup_type:n {muskip}
\def_new:Npn \muskip_global_new:N #1 {
  \alloc_global_new:NnNn #1 {muskip}
    \tex_muskipdef:D \c_max_register_int }
\def_new:Npn \muskip_local_new:N #1 {
  \alloc_local_new:NnNn #1 {muskip}
    \tex_muskipdef:D \c_max_register_int }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \begin{macro}{\iow_global_new:N}
%  \begin{macro}{\iow_local_new:N}
%  \begin{macro}{\ior_global_new:N}
%  \begin{macro}{\ior_local_new:N}
% Reads and writes.
%    \begin{macrocode}
\alloc_setup_type:n {iow}
\def_new:Npn \iow_global_new:N #1 {
  \alloc_global_new:NnNn #1 {iow} \const_new_aux:Nw \c_sixteen }
\def_new:Npn \iow_local_new:N #1 {
  \alloc_local_new:NnNn #1 {iow} \const_new_aux:Nw \c_sixteen }
\alloc_setup_type:n {ior}
\def_new:Npn \ior_global_new:N #1 {
  \alloc_global_new:NnNn #1 {ior} \const_new_aux:Nw \c_sixteen }
\def_new:Npn \ior_local_new:N #1 {
  \alloc_local_new:NnNn #1 {ior} \const_new_aux:Nw \c_sixteen }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \begin{macro}{\hyphen_global_new:N}
%  \begin{macro}{\hyphen_local_new:N}
% Hyphenation patterns.
%    \begin{macrocode}
\alloc_setup_type:n {hyphen}
\def_new:Npn \hyphen_global_new:N #1 {
  \alloc_global_new:NnNn #1 {hyphen}
    \const_new_aux:Nw \c_twohundred_fifty_six }
\def_new:Npn \hyphen_local_new:N #1 {
  \alloc_local_new:NnNn #1 {hyphen}
    \const_new_aux:Nw \c_twohundred_fifty_six }


\int_global_new:N \l_tmpa_int
\int_global_new:N \l_tmpb_int
%\minitraceoff


\ins_new:N \g_footnote_ins
\ins_new:N \g_footnoteA_ins
%\minitraceoff
%\tracingrestores2~
%\tracingassigns2~
{
  %\message{inside~group}
  %\message{local:}
  \int_local_new:N \l_tmpc_int
  %\message{local:}
  \int_local_new:N \l_tmpd_int
  {\message{deeper...}
  %\message{local:}
    \int_local_new:N \l_tmpe_int
    %\message{global:}
    \int_local_new:N \l_tmpf_int
  }
  %\message{local:}
  \int_local_new:N \l_tmpe_int
}
%\tracingassigns2~
%\num_set:Nn \g_int_allocation_num {11+\g_reserved_insertions_num}
%\message{global:}
\int_global_new:N \l_tmpc_int
%\message{global:}
\int_local_new:N \l_tmpd_int
%\tracingrestores0~
%\tracingassigns0~
%\num_set:Nn \g_toks_allocation_num {11}
\toks_global_new:N \l_tmpa_toks
\toks_global_new:N \l_tmpb_toks
\toks_global_new:N \l_tmpc_toks


\CodeStop
\begin{document}

\end{document}
