% \iffalse
%% File: l3expan.dtx Copyright (C) 1990-2008 LaTeX3 project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``expl3 bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{l3names}
%</driver|package>
%\fi
\GetIdInfo$Id$
       {L3 Experimental Argument Expansion module}
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass[full]{l3doc}
\begin{document}
\DocInput{\filename.\filenameext}
\end{document}
%</driver>
% \fi
%
%
% \title{The \textsf{l3expan} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Controlling Expansion of Command Arguments}
% \author{\Team}
% \date{\filedate}
% \maketitle
%
%
% \section{Expansion control}
%
% \subsection{Brief overview}
%
% The functions in this module all have prefix |exp|. 
%
% Not all possible variations are implemented for every base
% function. Instead only those that are used within the \LaTeX3 kernel
% or otherwise seem to be of general interest are implemented.
% Consult the module description to find out which functions are
% actually defined. The next section explains how to define missing
% variants.
% 
%
% \subsection{Defining new variants}
%
% The definition of variant forms for base functions may be necessary
% when writing new functions or when applying a kernel function in a
% situation that we haven't thought of before.
%
% Internally preprocessing of arguments is done with functions from the
% "\exp_" module.  They all look alike, an example would be
% "\exp_args:NNo". This function has three arguments, the first and the
% second are a single tokens  the third argument gets
% expanded once. If "\seq_gpush:No" wouldn't be defined the example
% above could be coded in the following way:
% \begin{verbatim}
%   \exp_args:NNo\seq_gpush:Nn
%      \g_file_name_stack
%      \l_tmpa_tlp
% \end{verbatim}
% In other words, the first argument to "\exp_args:NNo" is the base
% function and the other arguments are preprocessed and then passed to
% this base function. In the example the first argument to the base
% function should be a single token which is left unchanged while the
% second argument is expanded once. From this example we can also see
% how the variants are defined. They just expand into the appropriate
% "\exp_" function followed by the desired base function, e.g.
% \begin{quote}
%   "\def_new:Npn\seq_gpush:No{\exp_args:NNo\seq_gpush:Nn}"
% \end{quote}
% Providing variants in this way in style files is uncritical as the
% "\def_new:Npn" function will silently accept definitions whenever the
% new definition is identical to an already given one. Therefore adding
% such definition to later releases of the kernel will not make such
% style files obsolete.
%
% The |f| type is so special that it deserves an example.
% Let's pretend we want to set "\aaa" equal to the control sequence
% stemming from turning "b \l_tmpa_tlp b" into a control
% sequence. Furthermore we want to store the execution of it in a
% \m{toks} register. In this example we assume "\l_tmpa_tlp" contains
% the text string "lur". The straight forward approach is
% \begin{quote}
% "\toks_set:No \l_tmpa_toks {\let:Nc \aaa {b \l_tmpa_tlp b}}"
% \end{quote}
% Unfortunately this only puts
% "\exp_args:NNc \let:NN \aaa {b \l_tmpa_tlp b}" into "\l_tmpa_toks"
% and not "\let:NwN \aaa = \blurb" as we probably wanted. Using
% "\toks_set:Nx" is not an option as that will die horribly. Instead
% we can do a
% \begin{quote}
% "\toks_set:Nf \l_tmpa_toks {\let:Nc \aaa {b \l_tmpa_tlp b}}"
% \end{quote}
% which puts the desired result in "\l_tmpa_toks". It requires
% "\toks_set:Nf" to be defined as
% \begin{quote}
% "\def:Npn \toks_set:Nf {\exp_args:NNf \toks_set:Nn}"
% \end{quote}
% If you use this type of expansion in conditional processing then
% you should stick to using "TF" type functions only as it does not
% try to finish any "\if... \fi:" itself!
%
%
%
%
%
% The available internal functions for argument expansion come in two
% flavours, some of them are faster then others. Therefore it is usually
% best to follow the following guidelines when defining new functions
% that are supposed to come with variant forms:
% \begin{itemize}
% \item
%   Arguments that might need expansion should come first in the list of
%   arguments to make processing faster.
% \item
%   Arguments that should consist of single tokens should come first.
% \item
%   Arguments that need full expansion (i.e., are denoted with "x")
%   should be avoided if possible as they can not be processed very fast.
% \item 
%   In general "n", "x", and "o" (if not in the last position) will
%   need special processing which is not fast and not expandable,
%   i.e., functions of this type may not work correctly in arguments
%   that are itself subject to "x" expansion. Therefore it is best to
%   use the ``expandable'' functions (i.e., those that contain only
%   "c", "N", "O", "o" or "f" in the last position) whenever possible.
% \end{itemize}
%
%
% When pdf\TeX\ 1.50 arrives, it will contain a primitive for
% performing the equivalent of an "x" expansion after only one
% expansion and most importantly: as an expandable operation.
% \begin{function}{%
%                  \exp_arg:x
% }
% \begin{syntax}
%   " \exp_arg:x" \Arg{arg}
% \end{syntax}
% <arg> is expanded fully using an "x" expansion.
% \end{function}
%
% \subsection{Manipulating the first argument}
%
% \begin{function}{ \exp_args:No / (EXP) }
% \begin{syntax}
%   " \exp_args:No" <funct> <arg1> <arg2> "..."
% \end{syntax}
% The first argument of <funct> (i.e., <arg1>) is expanded once, the
% result is surrounded by braces and passed to <funct>. <funct> may have
% more than one argument---all others are passed unchanged.
% \end{function}
%
% \begin{function}{ \exp_args:Nd / (EXP) }
% \begin{syntax}
%   " \exp_args:Nd" <funct> <arg1> <arg2> "..."
% \end{syntax}
% The first argument of <funct> (i.e., <arg1>) is expanded twice, the
% result is surrounded by braces and passed to <funct>. <funct> may have
% more than one argument---all others are passed unchanged.
% \end{function}
%
% \begin{function}{ \exp_args:Nc / (EXP) }
% \begin{syntax}
%   " \exp_args:Nc" <funct> <arg1> <arg2> "..."
% \end{syntax}
% The first argument of <funct> (i.e., <arg1>) is expanded until only
% characters remain. (An internal error occurs if something else is the
% result of this expansion.) Then the result is turned into a control
% sequence and passed to <funct> as the first argument. <funct> may have
% more than one argument---all others are passed unchanged.
% \end{function}
%
% \begin{function}{ \exp_args:cc / (EXP) }
% \begin{syntax}
%   " \exp_args:cc" \Arg{cs1} \Arg{cs2}
% \end{syntax}
% The control sequence created from <cs2> is passed as an argument to the 
% function created from <cs1>.
% \end{function}
%
% \begin{function}{ \exp_args:NC / (EXP) }
% \begin{syntax}
%   " \exp_args:Nc" <funct> <arg1> <arg2> "..."
% \end{syntax}
% The first argument of <funct> (i.e., <arg1>) is expanded until only
% characters remain. (An internal error occurs if something else is the
% result of this expansion.) Then the result is turned into a control
% sequence which is then expanded once more. The result of this is then
% passed to <funct> as the first argument. <funct> may have more than
% one argument---all others are passed unchanged.
% \end{function}
%
% \begin{function}{ \exp_args:Nx }
% \begin{syntax}
%   " \exp_args:Nx" <funct> <arg1> <arg2> "..."
% \end{syntax}
% The first argument of <funct> (i.e., <arg1>) is fully expanded until
% only unexpandable tokens remain, the result is surrounded by braces
% and passed to <funct>. <funct> may have more than one argument---all
% others are passed unchanged.
% As mentioned before, this type of function is relatively slow.
% \end{function}
%
% \begin{function}{ \exp_args:Nf }
% \begin{syntax}
%   " \exp_args:Nf" <funct> <arg1> <arg2> "..."
% \end{syntax}
% The first argument of <funct> (i.e., <arg1>) undergoes full
% expansion until the first unexpandable token is encountered, the
% result is surrounded by braces and passed to <funct>. <funct> may
% have more than one argument---all others are passed unchanged.
% Beware of its special behavior as explained above.
% \end{function}
%
% \begin{function}{ \exp_args:NE / (EXP) }
% \begin{syntax}
%   " \exp_args:NE" <funct> <arg1> <arg2> "..."
% \end{syntax}
% The first argument of <funct> (i.e., <arg1>) is expanded once, the
% result is \emph{not} surrounded by braces and passed to <funct>.
% \end{function}
%
% \subsection{Manipulating two arguments}
%
% \begin{function}{%
%                  \exp_args:NNx |
%                  \exp_args:Nnx |
%                  \exp_args:Ncx |
%                  \exp_args:Nox |
%                  \exp_args:Nxo |
%                  \exp_args:Nxx |
% }
% \begin{syntax}
%   "\exp_args:Nnx" <funct> <arg1> <arg2> "..."
% \end{syntax}
% The above functions all manipulate the first two arguments of <funct>.
% They are all slow and non-expandable.
% \end{function}
%
% \begin{function}{%
%                  \exp_args:NNo / (EXP) |
%                  \exp_args:NNc / (EXP) |
%                  \exp_args:NNC / (EXP) |
%                  \exp_args:NNE / (EXP) |
%                  \exp_args:NNd / (EXP) |
%                  \exp_args:NNf / (EXP) |
%                  \exp_args:Nno / (EXP) |
%                  \exp_args:Noo / (EXP) |
%                  \exp_args:NOo / (EXP) |
%                  \exp_args:NOc / (EXP) |
%                  \exp_args:Nco / (EXP) |
%                  \exp_args:Ncc / (EXP) |
%                  \exp_args:NcE / (EXP) |
% }
% \begin{syntax}
%   "\exp_args:NNo" <funct> <arg1> <arg2> "..."
% \end{syntax}
% These are the fast and expandable functions for the first two arguments.
% \end{function}
%
% \subsection{Manipulating three arguments}
%
% So far not all possible functions are provided and even the selection
% below may be reduced in the future as far as the non-expandable
% functions are concerned.
%
% \begin{function}{%
%                  \exp_args:Nnnx |
%                  \exp_args:Nnox |
%                  \exp_args:Noox |
%                  \exp_args:Ncnx |
% }
% \begin{syntax}
%   "\exp_args:Nnnx" <funct> <arg1> <arg2> <arg3> "..."
% \end{syntax}
% All the above functions are non-expandable.
% \end{function}
%
% \begin{function}{%
%                  \exp_args:NNNE / (EXP) |
%                  \exp_args:NNNo / (EXP) |
%                  \exp_args:NnnN / (EXP) |
%                  \exp_args:Nnno / (EXP) |
%                  \exp_args:Nnnc / (EXP) |
%                  \exp_args:NNOo / (EXP) |
%                  \exp_args:NOOo / (EXP) |
%                  \exp_args:Nccc / (EXP) |
%                  \exp_args:NcNc / (EXP) |
%                  \exp_args:NcNo / (EXP) |
%                  \exp_args:Ncco / (EXP) |
% }
% \begin{syntax}
%   "\exp_args:NNOo" <funct> <arg1> <arg2> <arg3> "..."
% \end{syntax}
% These are the fast and expandable functions for the first three
% arguments.
% \end{function}
%
% \subsection{Internal functions and variables}
%
% \begin{function}{\exp_after:NN}
% \begin{syntax}
%   "\exp_after:NN" <token1> <token2>
% \end{syntax}
% This will expand <token2> once before processing <token1>. This is
% similar to "\exp_args:No" except that no braces are put around the
% result of expanding <token2>.
% \begin{texnote}
% This is the primitive \tn{expandafter} which was renamed to fit into
% the naming conventions of \LaTeX3.
% \end{texnote}
% \end{function}
%
% \begin{function}{\exp_not:N |
%                  \exp_not:c |
%                  \exp_not:n }
% \begin{syntax}
%   "\exp_not:N" <token>
%   "\exp_not:n" \Arg{token list}
% \end{syntax}
% This function will prohibit the expansion of <token> in situation
% where <token> would otherwise be replaced by it definition, e.g.,
% inside an argument that is handled by the "x" convention.
% \begin{texnote}
% "\exp_not:N" is the primitive \tn{noexpand} renamed and "\exp_not:n"
% is the \eTeX{} primitive \tn{unexpanded}.
% \end{texnote}
% \end{function}
%
%
% \begin{function}{\exp_not:o |
%                  \exp_not:d |
%                  \exp_not:f}
% \begin{syntax}
%   "\exp_not:o" \Arg{token list}
% \end{syntax}
% Same as "\exp_not:n" except <token list> is expanded once for the
% "o" type and twice for the "d" type and the result of this expansion
% is then prohibited from being expanded further.
% \end{function}
% 
% \begin{function}{\exp_not:E}
% \begin{syntax}
%   "\exp_not:E" <token>
% \end{syntax}
% The name of this command is a lie. Perhaps it should be called
% ``"exp_perhaps_once"''. What it actually does is, it expands <token>
% and then issues an "\exp_not:N" to prohibit further expansion of the
% first token in the replacement text of <token>. This means that if
% the replacement text of <token> consists of more than one token all
% further tokens are still subject to full expansion.
% \begin{texnote}
% This command has no equivalent.
% \end{texnote}
% \end{function}
% 
%
% \begin{function}{\exp_stop_f:}
% \begin{syntax}
%   <f expansion> ... "\exp_stop_f:" 
% \end{syntax}
% This function stops an "f" type expansion. An example use is one such as
% \begin{verbatim}
% \tlp_set:Nf \l_tmpa_tlp {
%   \if_case:w \l_tmpa_int 
%   \or:   \use_i_after_orelse:nw{\exp_stop_f: \textbullet}
%   \or:   \use_i_after_orelse:nw{\exp_stop_f: \textendash}
%   \else: \use_i_after_orelse:nw{\exp_stop_f: else-item}
%   \fi:
% }
% \end{verbatim}
% This ensures the expansion in stopped right after finishing the
% conditional but without expanding "\textbullet" etc.
% \begin{texnote}
%   This function is a space token but it is better to distinguish
%   this expansion stopping token from a desired space token when
%   writing code.
% \end{texnote}
% \end{function}
%
%
% \begin{variable}{\l_exp_tlp}
% \begin{syntax}\end{syntax}
% The "\exp_" module has its private variables to temporarily store
% results of the argument expansion. This is done to avoid interference
% with other functions using temporary variables.
% \end{variable}
%
% \StopEventually{}
%
% \subsection{The Implementation}
%
%    We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<package>\ProvidesExplPackage
%<package>  {\filename}{\filedate}{\fileversion}{\filedescription}
%<package>\RequirePackage{l3tlp}
%<*initex|package>
%    \end{macrocode}
%
% \subsubsection{General expansion}
%
% In this section a general mechanism for defining functions to handle
% argument handling is defined.  These general expansion functions are
% expandable unless |x| is used.  (Any version of |x| is going to have
% to use one of the \LaTeX3\ names for |\def:Npx| at some point, and
% so is never going to be expandable.\footnote{However, some
%   primitives have certain characteristics that means that their
%   arguments undergo an \texttt{x} type expansion but the primitive
%   is in fact still expandable. We shall make it very clear when such
%   a function is expandable.})
%
% In a later section some common cases are coded by a more direct
% method, typically using calls to |\exp_after:NN|.
%
% \begin{macro}{\l_exp_tlp}
%    We need a scratch token list pointer.
%    \begin{macrocode}
\tlp_new:Nn\l_exp_tlp{}
%    \end{macrocode}
% \end{macro}
%
% This code uses internal functions with names that start with |\::|
% to perform the expansions. All macros are |long| as this turned out
% to be desirable since the tokens undergoing expansion may be
% arbitrary user input.
%  \begin{macro}{\exp_arg_next:nnn}
%    This is basically the same function as |\Dexp_arg_next:nnn|.
%    \begin{macrocode}
\def_long_new:Npn\exp_arg_next:nnn#1#2#3{
  #2\:::{#3#1}
}
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\::n}
%    This function is used to skip an argument that doesn't need to
%    be expanded.
%    \begin{macrocode}
\def_long_new:Npn\::n#1\:::#2#3{
  #1\:::{#2{#3}}
}
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\::N}
%    This function is used to skip an argument that consists of a
%    single token and doesn't need to be expanded.
%^^A was \let_new:NN\::N\::n (changed to match \;N above.
%    \begin{macrocode}
\def_long_new:Npn\::N#1\:::#2#3{
  #1\:::{#2#3}
}
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\::c}
%    This function is used to skip an argument that is turned into
%    as control sequence without expansion.
%    \begin{macrocode}
\def_long_new:Npn\::c#1\:::#2#3{
  \exp_after:NN\exp_arg_next:nnn\cs:w #3\cs_end:{#1}{#2}
}
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\::o}
%    This function is used to expand an argument once.
%    \begin{macrocode}
\def_long_new:Npn\::o#1\:::#2#3{
  \exp_after:NN\exp_arg_next:nnn\exp_after:NN{\exp_after:NN{#3}}{#1}{#2}
}
%    \end{macrocode}
% \end{macro}
%
%
%  \begin{macro}{\::f}
%  \begin{macro}{\exp_stop_f:}
%    This function is used to expand a token list until the first
%    unexpandable token is found. The underlying "\int_to_roman:w -`0"
%    expands everything in its way to find something terminating the
%    number and thereby expands the function in front of it. This
%    scanning procedure is terminated once the expansion hits
%    something non-expandable or a space. We introduce "\exp_stop_f:"
%    to mark such an end of expansion marker; in case the scanner hits
%    a number, this number also terminates the scanning and is left
%    untouched. In the example shown earlier the scanning was stopped
%    once \TeX{} had fully expanded "\let:Nc \aaa {b \l_tmpa_tlp b}"
%    into "\let:NwN \aaa = \blurb" which then turned out to contain
%    the non-expandable token "\let:NwN".  Since the expansion of
%    "\int_to_roman:w -`0" is \m{null}, we wind up with a fully
%    expanded list, only \TeX{} has not tried to execute any of the
%    non-expandable tokens. This is what differentiates this function
%    from the "x" argument type.
%    \begin{macrocode}
\def_long_new:Npn\::f#1\:::#2#3{
  \exp_after:NN\exp_arg_next:nnn
  \exp_after:NN{\exp_after:NN{\int_to_roman:w -`0 #3}}
  {#1}{#2}
}
\def_new:Npn \exp_stop_f: {~}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%  \begin{macro}{\::x}
%    This function is used to expand an argument fully. If the
%    pdf\TeX\ primitive "\expanded" is present, we use it.
%    \begin{macrocode}
\let_new:NN \exp_arg:x \expanded % Move eventually.
\cs_if_free:NTF\exp_arg:x{
  \def_long_new:Npn\::x#1\:::#2#3{
    % \tlp_set:Nx\l_exp_tlp{{{#3}}}
    \def:Npx \l_exp_tlp{{{#3}}}
    \exp_after:NN\exp_arg_next:nnn\l_exp_tlp{#1}{#2}}
}
{
  \def_long_new:Npn\::x#1\:::#2#3{
    \exp_after:NN\exp_arg_next:nnn
    \exp_after:NN{\exp_arg:x{{#3}}}{#1}{#2}
  }
}
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\:::}
%    Just another name for the identity function.
%    \begin{macrocode}
\def_long_new:Npn\:::#1{#1}
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\::C}
%    This function creates a control sequence out of |#3| and expands
%    that once before passing it on to |\exp_arg_next:nnn|.
%    \begin{macrocode}
\def_long_new:Npn\::C#1\:::#2#3{
  \exp_after:NN\exp_C_aux:nnn\cs:w #3\cs_end:{#1}{#2}}
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\exp_C_aux:nnn}
%    A helper function for |\::C| wich expands its argument before
%    passing it on to |\exp_arg_next:nnn|.
%    \begin{macrocode}
\def_long_new:Npn\exp_C_aux:nnn #1{
  \exp_after:NN
  \exp_arg_next:nnn
  \exp_after:NN
     {
  \exp_after:NN
      {#1}
     }
}
%    \end{macrocode}
% \end{macro}
%
%  Here are some that might not stay but let's see.
%  \begin{macro}{\::E}
%    This function is used to expand an argument once and return it
%    \emph{without} braces. Use this only when you feel pretty
%    comfortable about your input! Actually this is pretty much just
%    generic wrapper for |\exp_after:NN|.
%    \begin{macrocode}
\def_long_new:Npn\::E#1\:::#2#3{
  \exp_after:NN\exp_arg_next:nnn \exp_after:NN{#3}{#1}{#2}
}
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\::e}
%    Same as |\::E| really but conceptually they are different.
%    \begin{macrocode}
\def_long_new:Npn\::e#1\:::#2#3{
  \exp_after:NN\exp_arg_next:nnn \exp_after:NN{#3}{#1}{#2}
}
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\::d}
%    This function is used to expand an argument twice. Mostly useful
%    for |toks| type things.
%    \begin{macrocode}
\def_long_new:Npn\::d#1\:::#2#3{
  \exp_after:NN\exp_after:NN\exp_after:NN\exp_arg_next:nnn
  \exp_after:NN\exp_after:NN\exp_after:NN{
  \exp_after:NN\exp_after:NN\exp_after:NN{#3}}{#1}{#2}
}
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\exp_args:NE,\exp_args:NNE,\exp_args:NNNE,^^A
%    \exp_args:NEE,\exp_args:NcE,\exp_args:Nd,\exp_args:NNd}
% We do most of them by hand here. This also means that we get a name
% for |\exp_after:NN| that fits with the rest of the code.
%    \begin{macrocode}
\let:NN \exp_args:NE \exp_after:NN
\def:Npn \exp_args:NNE #1{\exp_args:NE#1\exp_args:NE}
\def:Npn \exp_args:NNNE #1#2{\exp_args:NE#1\exp_args:NE#2\exp_args:NE}
\def:Npn \exp_args:NEE #1{\exp_args:NE\exp_args:NE\exp_args:NE#1\exp_args:NE}
\def:Npn \exp_args:NcE #1#2{\exp_after:NN #1\cs:w #2\exp_after:NN\cs_end:}
\def:Npn \exp_args:Nd {\::d\:::}
\def:Npn \exp_args:NNd {\::N\::d\:::}
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\exp_args:NC}
%  \begin{macro}{\exp_args:Ncx}
%  \begin{macro}{\exp_args:Ncco}
%  \begin{macro}{\exp_args:Nccx}
%  \begin{macro}{\exp_args:Ncnx}
%  \begin{macro}{\exp_args:NcNc}
%  \begin{macro}{\exp_args:Nf}
%  \begin{macro}{\exp_args:NNf}
%  \begin{macro}{\exp_args:Nfo}
%  \begin{macro}{\exp_args:Nnf}
%  \begin{macro}{\exp_args:NNno}
%  \begin{macro}{\exp_args:NnnN}
%  \begin{macro}{\exp_args:Nnno}
%  \begin{macro}{\exp_args:Nnnx}
%  \begin{macro}{\exp_args:Nno}
%  \begin{macro}{\exp_args:Nnox}
%  \begin{macro}{\exp_args:NNx}
%  \begin{macro}{\exp_args:Nnx}
%  \begin{macro}{\exp_args:Noo}
%  \begin{macro}{\exp_args:Noox}
%  \begin{macro}{\exp_args:Nox}
%  \begin{macro}{\exp_args:Nx}
%  \begin{macro}{\exp_args:Nxx}
%  \begin{macro}{\exp_args:Nxx}
%  \begin{macro}{\exp_args:NNC}
%  \begin{macro}{\exp_args:Nnnc}
%  \begin{macro}{\exp_args:NNnx}
%  \begin{macro}{\exp_args:NNoo}
%  \begin{macro}{\exp_args:NNox}
%    Here are the actual function definitions, using the helper functions
%    above.
%    \begin{macrocode}
%\def:Npn \exp_args:NNNo {\::N\::N\::o\:::}
%\def:Npn \exp_args:NNOo {\::N\::O\::o\:::}
%\def:Npn \exp_args:NNc {\::N\::c\:::}
%\def:Npn \exp_args:NNo {\::N\::o\::\:::}
%\def:Npn \exp_args:NOOo {\::O\::O\::o\:::}
%\def:Npn \exp_args:NOc {\::O\::c\:::}
%\def:Npn \exp_args:NOo {\::O\::o\:::}
%\def:Npn \exp_args:Nc {\::c\:::}
%\def:Npn \exp_args:Ncc {\::c\::c\:::}
%\def:Npn \exp_args:Nccc {\::c\::c\::c\:::}
%\def:Npn \exp_args:Nco {\::c\::o\:::}
%\def:Npn \exp_args:No {\::o\:::}

\def:Npn \exp_args:NC {\::C\:::}
\def:Npn \exp_args:NNC {\::N\::C\:::}
\def:Npn \exp_args:NNf {\::N\::f\:::}
\def:Npn \exp_args:NNno {\::N\::n\::o\:::}
\def:Npn \exp_args:NNnx {\::N\::n\::x\:::}  % new
\def:Npn \exp_args:NNoo {\::N\::o\::o\:::}  % new
\def:Npn \exp_args:NNox {\::N\::o\::x\:::}  % new
\def:Npn \exp_args:NNx {\::N\::x\:::}
\def:Npn \exp_args:NcNc {\::c\::N\::c\:::}
\def:Npn \exp_args:NcNo {\::c\::N\::o\:::}
\def:Npn \exp_args:Ncco {\::c\::c\::o\:::}
\def:Npn \exp_args:Ncco {\::c\::c\::o\:::}
\def:Npn \exp_args:Nccx {\::c\::c\::x\:::}
\def:Npn \exp_args:Ncnx {\::c\::n\::x\:::}
\def:Npn \exp_args:Ncx {\::c\::x\:::}
\def:Npn \exp_args:Nf {\::f\:::}
\def:Npn \exp_args:Nfo{\::f\::o\:::}
\def:Npn \exp_args:Nnf {\::n\::f\:::}
\def:Npn \exp_args:NnnN {\::n\::n\::N\:::}   %% Strange one this one...
\def:Npn \exp_args:Nnnc {\::n\::n\::c\:::}
\def:Npn \exp_args:Nnno {\::n\::n\::o\:::}
\def:Npn \exp_args:Nnnx {\::n\::n\::x\:::}
\def:Npn \exp_args:Nno {\::n\::o\:::}
\def:Npn \exp_args:Nnox {\::n\::o\::x\:::}
\def:Npn \exp_args:Nnx {\::n\::x\:::}
\def:Npn \exp_args:Noo {\::o\::o\:::}
\def:Npn \exp_args:Noox {\::o\::o\::x\:::}
\def:Npn \exp_args:Nox {\::o\::x\:::}
\def:Npn \exp_args:Nx {\::x\:::}
\def:Npn \exp_args:Nxo {\::x\::o\:::}
\def:Npn \exp_args:Nxx {\::x\::x\:::}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
% \subsubsection{Preventing expansion}
%
%
%  \begin{macro}{\exp_not:o}
%  \begin{macro}{\exp_not:d}
%  \begin{macro}{\exp_not:f}
%    \begin{macrocode}
\def_long_new:Npn\exp_not:o#1{\exp_not:n\exp_after:NN{#1}}
\def_long_new:Npn\exp_not:d#1{
  \exp_not:n\exp_after:NN\exp_after:NN\exp_after:NN{#1}
}
\def_long_new:Npn\exp_not:f#1{
  \exp_not:n\exp_after:NN{\int_to_roman:w -`0 #1}
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
% 
%  \begin{macro}{\exp_not:E}
%  \begin{macro}{\exp_not:c}
%    Two helper functions, which we can probably live without it.
%    \begin{macrocode}
\def_new:Npn\exp_not:E{\exp_after:NN\exp_not:N}
\def_long_new:Npn\exp_not:c#1{\exp_after:NN\exp_not:N\cs:w#1\cs_end:}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
% \subsubsection{Single token expansion}
%
% Expansion for arguments that are single tokens is done with the
% functions below. I first thought of using a different module name
% but then I saw that this wouldn't do since I could then never
% determine for, say, |\seq_put:no| whether this means single, or
% general expansion. Therefore I decided to use uppercase `O' for
% single expansion.
%
% One of the most important features of these functions is that they
% are fully expandable and therefore allow to prefix them with
% |\pref_global:D| for example. This together with the fact that the
% above concept is much slower in general means that we should convert
% whenever possible and perhaps remove all remaining occurences by
% hand-encoding in the end.
%
% \begin{macro}{\exp_args:No}
% \begin{macro}{\exp_args:NOo}
% \begin{macro}{\exp_args:NNo}
% \begin{macro}{\exp_args:NNO}
% \begin{macro}{\exp_args:NOOo}
% \begin{macro}{\exp_args:NNOo}
% \begin{macro}{\exp_args:NNNo}
%    This looks somewhat horrible but it runs well with the other
%    syntax. It is important to see that these functions really need
%    single tokens as arguments whenever capital letters are used.
%    \begin{macrocode}
\def_long_new:Npn \exp_args:No #1#2{\exp_after:NN#1\exp_after:NN{#2}}
\def_long_new:Npn \exp_args:NOo #1#2#3{\exp_after:NN\exp_args:No \exp_after:NN#1
  \exp_after:NN#2\exp_after:NN{#3}}
\def_long_new:Npn \exp_args:NOOo #1#2#3#4{\exp_after:NN\exp_args:NOo
  \exp_after:NN#1\exp_after:NN#2\exp_after:NN#3\exp_after:NN{#4}}
\def_long_new:Npn \exp_args:NNo #1#2#3{\exp_after:NN#1\exp_after:NN#2
  \exp_after:NN{#3}}
\def_long_new:Npn \exp_args:NNO #1#2#3 {\exp_after:NN#1
  \exp_after:NN#2 #3}
\def_long_new:Npn \exp_args:NNOo #1#2#3#4{\exp_after:NN\exp_args:NNo
  \exp_after:NN#1\exp_after:NN#2\exp_after:NN#3\exp_after:NN{#4}}
\def_long_new:Npn \exp_args:NNNo #1#2#3#4{\exp_after:NN#1\exp_after:NN#2
  \exp_after:NN#3\exp_after:NN{#4}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\exp_args:Nc}
% \begin{macro}{\exp_args:NNc}
% \begin{macro}{\exp_args:NOc}
% \begin{macro}{\exp_args:Ncc}
% \begin{macro}{\exp_args:Nccc}
%    Here are the functions that turn their argument into csnames but
%    are  expandable.
%    \begin{macrocode}
\def_long_new:Npn \exp_args:Nc #1#2{\exp_after:NN#1\cs:w#2\cs_end:}
\def_long_new:Npn \exp_args:NNc #1#2#3{\exp_after:NN#1\exp_after:NN#2
    \cs:w#3\cs_end:}
\def_long_new:Npn \exp_args:NOc#1#2#3{\exp_after:NN\exp_args:No\exp_after:NN
    #1\exp_after:NN#2\cs:w#3\cs_end:}
\def_long_new:Npn \exp_args:Ncc #1#2#3{\exp_after:NN#1
    \cs:w#2\exp_after:NN\cs_end:\cs:w#3\cs_end:}
\def_long_new:Npn \exp_args:Nccc #1#2#3#4{\exp_after:NN#1
    \cs:w#2\exp_after:NN\cs_end:\cs:w#3\exp_after:NN
      \cs_end:\cs:w #4\cs_end:}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%  \begin{macro}{\exp_args:Nco}
%    If we force that the third argument
%    always has braces, we could implement this function
%    with less tokens and only two arguments.
%    \begin{macrocode}
\def_long_new:Npn \exp_args:Nco #1#2#3{\exp_after:NN#1\cs:w#2\exp_after:NN
     \cs_end:\exp_after:NN{#3}}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\exp_def_form:nnn}
%    This command is a recent addition which was actually added
%    when we wrote the article for TUGboat (while most of the other
%    code goes way back to 1993).
%    \begin{macrocode}
\def:Npn\exp_def_form:nnn#1#2#3{
   \exp_after:NN
   \def:Npn
     \cs:w
        #1:#3
       \exp_after:NN
     \cs_end:
     \exp_after:NN
       {
        \cs:w
           exp_args:N#3
          \exp_after:NN
        \cs_end:
        \cs:w
           #1:#2
        \cs_end:
       }
%    \end{macrocode}
%    We also have to test if |exp_args:N#3| is already defined
%    and if not define it via the
%    |\::| commands using the chars in |#3|
%    \begin{macrocode}
    \cs_if_free:cT
          {exp_args:N#3}
          {\def:cpx {exp_args:N#3}
                    {\exp_args_form_x:w #3 :}
          }
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\exp_args_form_x:w}
%    This command grabs char by char outputting |\::#1| (not expanded
%    further) until we see a |:|. That colon is in fact also turned into
%    |\:::| so that the required structure for |\exp_args...| commands
%    is correctly terminated.
%    \begin{macrocode}
\def_new:Npn\exp_args_form_x:w #1 {
  \exp_not:c{::#1}
  \if_meaning:NN #1 :
  \else:
    \exp_after:NN\exp_args_form_x:w
  \fi:}
%    \end{macrocode}
%  \end{macro}
%
%    Show token usage:
%    \begin{macrocode}
%</initex|package>
%<*showmemory>
\showMemUsage
%</showmemory>
%    \end{macrocode}
%
% \endinput
