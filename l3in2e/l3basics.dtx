% \iffalse
%% File: l3basics.dtx Copyright (C) 1990-1997 LaTeX3 project
%
%<*dtx>
          \ProvidesFile{l3basics.dtx}
%</dtx>
%<package>\NeedsTeXFormat{LaTeX2e}
%<package>\ProvidesPackage{l3basics}
%<driver> \ProvidesFile{l3basics.drv}
% \fi
%         \ProvidesFile{l3basics.dtx}
          [1997/08/04 v1.0b L3 Experimental basic definitions]
%
% \iffalse
%<*driver>
\documentclass{l3doc}

\begin{document}
\DocInput{l3basics.dtx}
\end{document}
%</driver>
% \fi
%
% \GetFileInfo{l3basics.dtx}
% \title{The \textsf{l3basics} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Basic Definitions}
% \author{\Team}
% \date{\filedate}
% \maketitle
%
% Having given all the tex primitives a consistent name, we need to
% give sensible names to the ones we actually want to use.
% These will be defined as needed in the apropriate modules, but
% do a few now, just to get started.\footnote{This renaming gets expensive
% in terms of csname usage, an alternative scheme would be to just use
% the ``tex\ldots D'' name in the cases where no good alternative exists.}
%    \begin{macrocode}
%<*package>
\tex_let:D \let:NwN            \tex_let:D
\let:NwN   \def:Npn            \tex_def:D
\let:NwN   \gdef:Npn           \tex_gdef:D
\let:NwN   \def:Npx            \tex_edef:D
\let:NwN   \gdef:Npx           \tex_xdef:D
\let:NwN   \if:w               \tex_if:D
\let:NwN   \if_num:w           \tex_ifnum:D
\let:NwN   \if_meaning:NN      \tex_ifx:D
\let:NwN   \else:              \tex_else:D
\let:NwN   \fi:                \tex_fi:D
\let:NwN   \io_put_deferred:Nx \tex_write:D
\let:NwN   \token_to_string:N  \tex_string:D
\let:NwN   \cs:w               \tex_csname:D
\let:NwN   \cs_end:            \tex_endcsname:D
\let:NwN   \exp_after:NN       \tex_expandafter:D
\let:NwN   \scan_stop:         \tex_relax:D
%    \end{macrocode}
%
% \section {Defining (new) functions}
%
%    We need some constants now, that should actually all be defined
%    together. We try to avoid using count registers for constants as
%    much as possible.
%
%    \begin{macrocode}
\let:NwN\c_minus_one\m@ne
\tex_chardef:D \c_one     = 1\scan_stop:
\tex_chardef:D \c_sixteen = 16\scan_stop:
\tex_mathchardef:D \c_two_hundred_fifty_six = 256\scan_stop:
%    \end{macrocode}
%
%    We provide two kinds of functions that can be used to define
%    control sequences. On the one hand we have functions that check
%    if their argument doesn't already exist, they are called
%    |\..._new|. The second type of defining functions doesn't check
%    if the argument is already defined.
%
%    Before we can define them, we need some auxiliary macros that
%    allow us to generate error messages. The definitions here are 
%    only temporary, they will be redefined later on.
%
%  \begin{macro}{\io_put_log:x}
%  \begin{macro}{\io_put_term:x}
%    We define a routine to write only to the log file. And a
%    similar one for writing to both the log file and the terminal.
%
%    \begin{macrocode}
\def:Npn \io_put_log:x{
      \tex_immediate:D\io_put_deferred:Nx \c_minus_one }
\def:Npn \io_put_term:x{
      \tex_immediate:D\io_put_deferred:Nx \c_sixteen }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}{\err_latex_bug:n}
%    This will show internal errors.
%    \begin{macrocode}
\def:Npn\err_latex_bug:n#1{
   \io_put_term:x{This~is~a~LaTeX~bug!~Check~coding!}\err_message:D{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\chk_new_cs:N}
%    This command is called by |\def_new:Npn| and |\let_new:NN| etc.\ 
%    to make sure that the argument sequence is not already in use. If
%    it is, an error is signalled.
%    \begin {macrocode}
\def:Npn \chk_new_cs:N #1{
     \if_meaning:NN #1\c_undefined
     \else:
       \if_meaning:NN #1\scan_stop:
       \else:
         \err_latex_bug:n {Command~name~`\token_to_string:N #1'~
                               already~defined!~
                         Current~meaning:\token_to_meaning:N #1
                          }
       \fi:
     \fi:
%<*trace>
     \cs_record_meaning:N#1
%     \io_put_term:x{Defining~\token_to_string:N #1~on~
     \io_put_log:x{Defining~\token_to_string:N #1~on~
                         line~\tex_the:D \tex_inputlineno:D}
%</trace>
   }
%    \end{macrocode}
% \end {macro}
%
%
%  \begin{macro}{\cs_record_meaning:N}
%    This macro will be used later on for tracing purposes. But we
%    need some more modules to define it, so we just give some dummy
%    definition here.
%    \begin{macrocode}
%<*trace>
\def:Npn \cs_record_meaning:N#1{}
%</trace>
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\let:NN}
%  \begin{macro}{\let:cN}
%  \begin{macro}{\let:Nc}
%  \begin{macro}{\let:cc}
%    These macros allow us to copy the definition of a control sequence
%    to another control sequence. Maybe we should implement a few more
%    of these.
%
%    \begin{macrocode}
\tex_long:D\def:Npn \let:NN #1{
%    \end{macrocode}
%    The |=| sign allows us to define funny char tokens like .|=|
%    itself or \verb*= = with this function. For the definition of
%    |\c_space_chartok{~}| to work we need the |~| after the |=|
%
%    \begin{macrocode}
                              \let:NwN #1=~}
\def:Npn\let:cN #1 {\exp_after:NN\let:NwN\cs:w#1\cs_end:=~}
\def:Npn\let:Nc{\exp_args:NNc\let:NN}
\def:Npn\let:cc{\exp_args:Ncc\let:NN}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
% \begin {macro}{\def_new:Npn}
% \begin {macro}{\def_new:Npx}
% \begin {macro}{\let_new:NN}
%    These are like |\def:Npn| and |\let:NN|, but they first check that
%    the argument command is not already in use. You may use
%    |\tex_global:D|, |\tex_long:D|, and |\tex_outer:D| as
%    prefixes.
%     \begin {macrocode}
\def:Npn \def_new:Npn #1{\chk_new_cs:N #1
                         \def:Npn #1}
\def:Npn \def_new:Npx #1{\chk_new_cs:N #1
                         \def:Npx #1}
\def_new:Npn \let_new:NN #1{\chk_new_cs:N #1
                              \let:NN #1}
%    \end{macrocode}
% \end {macro}
% \end {macro}
% \end {macro}
%
% \begin {macro}{\def:cpn}
% \begin {macro}{\def:cpx}
% \begin {macro}{\def_new:cpn}
% \begin {macro}{\def_new:cpx}
%    Like |\def:Npn| and |\def_new:Npn|, except that the first
%    argument consists of the sequence of characters that should be
%    used to form the name of the desired control sequence ( the |c|
%    stands for csname argument, see the expansion module.).
%
%    |\def:cpn|\m{string}\m{rep-text} will turn \m{string} into a
%    csname and then assign \m {rep-text} to it by using |\def:Npn|.
%    This means that there might be a parameter string between the two
%    arguments.
%    \begin {macrocode}
\def_new:Npn \def:cpn #1{\exp_after:NN
                             \def:Npn
                             \cs:w #1\cs_end:}
\def_new:Npn \def:cpx #1{\exp_after:NN
                             \def:Npx
                             \cs:w #1\cs_end:}
\def_new:Npn \def_new:cpn #1{\exp_after:NN
                                  \def_new:Npn
                                  \cs:w #1\cs_end:}
\def_new:Npn \def_new:cpx #1{\exp_after:NN
                                  \def_new:Npx
                                  \cs:w #1\cs_end:}
%    \end{macrocode}
% \end {macro}
% \end {macro}
% \end {macro}
% \end {macro}
%
%
%  \begin{macro}{\def:No}
%    |\def:No| expands its second argument one time before making 
%    the definition.
%    \begin{macrocode}
\def_new:Npn \def:No{\exp_args:NNo\def:Npn}
%    \end{macrocode}
%  \end{macro}
%
% \begin {macro}{\def_long:Npn}
% \begin {macro}{\def_long_new:Npn}
% \begin {macro}{\def_long:cpn}
% \begin {macro}{\def_long:Npx}
%    |\def_long:Npn| stands for |\tex_long:D| |\def:Npn|.
%    |\def_long:Npx| expands its second argument.
%    \begin {macrocode}
\def_new:Npn \def_long:Npn {\tex_long:D\def:Npn}
\def_new:Npn \def_long_new:Npn #1{\chk_new_cs:N #1
                                 \def_long:Npn #1}
\def_new:Npn \def_long:cpn #1{\exp_after:NN
                              \def_long:Npn
                              \cs:w #1\cs_end:}
\def_new:Npn \def_long:Npx {\tex_long:D\def:Npx}
%    \end{macrocode}
% \end {macro}
% \end {macro}
% \end {macro}
% \end {macro}
%
% \begin {macro}{\glet:NN}
% \begin {macro}{\glet_new:NN}
% \begin {macro}{\gdef_new:Npn}
% \begin {macro}{\gdef:cpn}
% \begin {macro}{\gdef:cpx}
% \begin {macro}{\gdef:No}
%  These are global versions of some of the previosly defined functions.
%    \begin {macrocode}
\def_new:Npn \glet:NN {\tex_global:D \let:NN}
\def_new:Npn \glet_new:NN #1{\chk_new_cs:N #1
                               \tex_global:D\let:NN #1}
\def_new:Npn \gdef_new:Npn #1{\chk_new_cs:N #1
                              \gdef:Npn #1}
\def_new:Npn \gdef:cpn {\tex_global:D \def:cpn}
\def_new:Npn \gdef:cpx {\tex_global:D \def:cpx}
\def_new:Npn \gdef:No  {\exp_args:NNo\gdef:Npn}
%    \end{macrocode}
% \end {macro}
% \end {macro}
% \end {macro}
% \end {macro}
% \end {macro}
% \end {macro}

% \begin {macro}{\gdef_long:Npn}
% \begin {macro}{\gdef_long:Npx}
%    |\gdef_long:Npn| stands for |\tex_long:D| |\tex_global:D| |\def:Npn|.
%    |\gdef_long:Npx| expands its second argument.
%    \begin {macrocode}
\def_new:Npn \gdef_long:Npn {\tex_long:D\gdef:Npn}
\def_new:Npn \gdef_long:Npx {\tex_long:D\gdef:Npx}
%    \end{macrocode}
% \end {macro}
% \end {macro}
%
% \begin {macro}{\gfuturelet:NNN}
%    This is a global version of |\let_peek_after:NNN|
%    \begin {macrocode}
\def_new:Npn \gfuturelet:NNN{\tex_global:D \let_peek_after:NNN}
%    \end{macrocode}
% \end {macro}
%
%
%
% \subsection{Freeing memory}
%
% \begin{macro}{\gundefine:N }
%    The following function is used to free the main memory from the
%    definition of some function that isn't in use any longer.
%    \begin{macrocode}
\def_new:Npn \gundefine:N #1{\glet:NN #1\c_undefined}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Gobbling tokens from input}
%
% \begin{macro}{\use_none:n}
% \begin{macro}{\use_none:nn}
% \begin{macro}{\use_none:nnn}
% \begin{macro}{\use_none:nnnn}
%    To gobble tokens from the input we use a standard naming
%    convention: the number of tokens gobbled is given by the number
%    of |n|'s following the |:| in the name.
%    \begin{macrocode}
\def_long_new:Npn \use_none:n #1{}
\def_long_new:Npn \use_none:nn #1#2{}
\def_long_new:Npn \use_none:nnn #1{\use_none:nn}
\def_long_new:Npn \use_none:nnnn
    {\exp_after:NN\use_none:nn \use_none:nn}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \subsection{Selecting tokens}
%
% \begin{macro}{\use:n}
%    This macro grabs its argument and returns it back to the input
%    (with outer braces removed).
%    \begin{macrocode}
\def_long_new:Npn \use:n #1{#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\use:c}
% \begin{macro}{\use:cc}
%    This macro grabs its argument and returns a csname from it.
%    \begin{macrocode}
\def_new:Npn \use:c #1{\cs:w #1\cs_end:}

%    \end{macrocode}
%    THE NAME IS COMPLETELY WRONG!!!!!
%    \begin{macrocode}
\def_new:Npn \use:cc #1#2
  {\cs:w #1\exp_after:NN\cs_end:\cs:w #2\cs_end:}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\use_choice_i:nn}
% \begin{macro}{\use_choice_ii:nn}
%    These macros are needed to provide functions with true and false
%    cases, as introduced by Michael some time ago. By using
%    |\exp_after:NN| |\use_choice_i:nn | |\else:| constructions it
%    is possible to write code where the true or false case is able to
%    access the following tokens from the input stream, which is not
%    possible if the |\c_true| syntax is used.
%    \begin{macrocode}
\def_long_new:Npn \use_choice_i:nn #1#2{#1}
\def_long_new:Npn \use_choice_ii:nn #1#2{#2}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%  \begin{macro}{\use_choice_i:nnn}
%  \begin{macro}{\use_choice_ii:nnn}
%  \begin{macro}{\use_choice_iii:nnn}
%    We also need something for picking up arguments from a longer
%    list.  
%    \begin{macrocode}
\def_long_new:Npn\use_choice_i:nnn#1#2#3{#1}
\def_long_new:Npn\use_choice_ii:nnn#1#2#3{#2}
\def_long_new:Npn\use_choice_iii:nnn#1#2#3{#3}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
% \subsection{Scratch functions}
%
% \begin{macro}{\gtmp:w}
%    This function is for global scratch definitions that are used
%    immediately afterwards. It should be used when we need a function
%    that operates on input, i.e.\ has arguments. If we want to save
%    only some tokens for later use, token-list scratch variables
%    should be used.
%    \begin{macrocode}
\def_new:Npn \gtmp:w {}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tmp:w}
%    This is a local version of the previous function.
%    \begin{macrocode}
\def_new:Npn \tmp:w {}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\use_noop:}
%    I don't think this function belongs here, but one place is as
%    good as any other. I want to use this function when I want to
%    express `no operation'.
%    \begin{macrocode}
\def_new:Npn \use_noop: {}
%</package>
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%<*showmemory>
\showMemUsage
%</showmemory>
%    \end{macrocode}
%    
