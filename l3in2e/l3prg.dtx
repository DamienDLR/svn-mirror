% \iffalse
%% File: l3prg.dtx Copyright (C) 2005 LaTeX3 project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3a of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``expl3 bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%
%<*!initex>
% \fi
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{%^^A}$
  \def\fileversion{#3}%
  \def\filedate{#4}%
%\iffalse
%<*dtx>
%\fi
     \ProvidesFile{#2.dtx}[#4 v#3 #8]%
%\iffalse
%</dtx>
%<package> \ProvidesPackage{#2}[#4 v#3 #8]%
%<driver>  \ProvidesFile{#2.drv}[#4 v#3 #8]%
%\fi
}
%\iffalse
%</!initex>
%\fi
\next$Id$
       {L3 Experimental control structures}
%
% \iffalse
%<*driver>
\documentclass{l3doc}

\begin{document}
\DocInput{l3prg.dtx}
\end{document}
%</driver>
% \fi
%
% \def\next#1: #2.dtx,v #3 #4 #5 #6 #7${^^A}$
%  \def\filename{#2}%
%  \def\fileversion{#3}%
%  \def\filedate{#4}}
% \next$Id$
%
%
% \title{The \textsf{l3prg} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Program control structures}
% \author{\Team}
% \date{\filedate}
% \maketitle
%
%
% \section{Control structures}
%
% \subsection{Choosing modes}
%
% \begin{function}{\mode_vertical:TF|
%                  \mode_vertical:F
%                 }
% \begin{syntax}
%   "\mode_vertical:TF" "{"<true code>"}" "{"<false code>"}"
% \end{syntax}
% Determines if \TeX{} is in vertical mode or not and executes either
% <true code> or <false code> accordingly.
% \end{function}
%
% \begin{function}{\mode_horizontal:TF|
%                  \mode_horizontal:F
%                 }
% \begin{syntax}
%   "\mode_horizontal:TF" "{"<true code>"}" "{"<false code>"}"
% \end{syntax}
% Determines if \TeX{} is in horizontal mode or not and executes either
% <true code> or <false code> accordingly.
% \end{function}
%
%
% \begin{function}{\mode_inner:TF|
%                 }
% \begin{syntax}
%   "\mode_inner:TF" "{"<true code>"}" "{"<false code>"}"
% \end{syntax}
% Determines if \TeX{} is in inner mode or not and executes either
% <true code> or <false code> accordingly.
% \end{function}
%
% \begin{function}{\mode_math:TF|
%                 }
% \begin{syntax}
%   "\mode_math:TF" "{"<true code>"}" "{"<false code>"}"
% \end{syntax}
% Determines if \TeX{} is in math mode or not and executes either
% <true code> or <false code> accordingly.
% \begin{texnote}
% This version will choose the right branch even at the beginning of
% an alignment cell.
% \end{texnote}
% \end{function}
%
%
% \subsubsection{Alignment safe grouping and scanning}
%
% \begin{function}{\scan_align_safe_stop:}
% \begin{syntax}
%   "\scan_align_safe_stop:"
% \end{syntax}
% This function gets \TeX{} on the right track inside an alignment
% cell but without destroying any kerning.
% \end{function}
%
%
% \begin{function}{\group_align_safe_begin:|
%                  \group_align_safe_end:}
% \begin{syntax}
%   "\group_align_safe_begin:" <...> "\group_align_safe_end:"
% \end{syntax}
% Encloses <...> inside a group but is safe inside an alignment cell.
% See the implementation of |\peek_char_generic:NNTF| for an
% application.
% \end{function}
%
%
%
% \subsection{Token lists}
%
%
%  \LaTeX3 incorporates many data types that all have a list-like
%  structure. Therefore it's convenient to have mapping functions able
%  to act on each element or pair of elements in the list.  Usually
%  these functions are found in their respective modules so you'd find
%  "\clist_map_function:NN" (the expandable map function) in the
%  \textsf{l3clist} module. However there are a few types that don't
%  have a module of their own; either because they are very general
%  or because the mapping function is only useful as an intermediate
%  function and these functions can be found in this module.
%
% \subsubsection{Token list mapping}
%
%
%  \begin{function}{%
%                   \tlist_map_function:nN |
%                   \tlist_map_function:NN |
%  }
%  \begin{syntax}
%     "\tlist_map_function:nN" "{"<tlist>"}" <function> \\
%     "\tlist_map_function:NN" <tlist> <function>
%  \end{syntax}
%  Runs through all elements in a |tlist| from left to right and places
%  <function> in front of each element. As this function will also pick
%  up elements in brace groups, the element is returned with braces and
%  hence <function> should be a function with a |:n| suffix even though
%  it may very well only deal with a single token. This function uses a
%  purely expandable loop function and will stay so as long as
%  <function> is expandable too.
%  \end{function}
%
%  \begin{function}{%
%                   \tlist_map_inline:nn |
%                   \tlist_map_inline:Nn |
%  }
%  \begin{syntax}
%     "\tlist_map_inline:nn" "{"<tlist>"}" "{"<inline~function>"}" \\
%     "\tlist_map_inline:Nn" <tlist> "{"<inline~function>"}"
%  \end{syntax}
%  Allows a syntax like "\tlist_map_inline:nn" "{"<tlist>"}"
%  "{\token_to_string:N ##1}". This renders it non-expandable though.
%  Remember to double the "#"s for each level.
%  \end{function}
%
%
%  \begin{function}{%
%                   \tlist_map_variable:nNn |
%                   \tlist_map_variable:NNn |
%                   \tlist_map_variable:cNn |
%  }
%  \begin{syntax}
%     "\tlist_map_variable:nNn" "{"<tlist>"}" <temp> "{"<action>"}" \\
%     "\tlist_map_variable:NNn" <tlist> <temp> "{"<action>"}"
%  \end{syntax}
%  Assigns <temp> to each element on <tlist> and executes <action>.
%  As there is an assignment in this process it is not expandable.
%  \begin{texnote}
%  This is the \LaTeX2{} function \tn{@tfor} but with a more sane syntax.
%  Also it works by tail recursion and so is faster as lists grow longer.
%  \end{texnote}
%  \end{function}
%
%  \begin{function}{%
%                   \tlist_map_break:w |
%  }
%  \begin{syntax}
%     "\tlist_map_break:w"
%  \end{syntax}
%  For breaking out of a loop. You should take note of the ":w" as
%  it's usage must be precise!
%  \end{function}
%
%
%  \begin{function}{%
%                   \tlist_map_inline_function:n |
%  }
%  \begin{syntax}\end{syntax}
%  Internal function used in the "inline" function.
%  \end{function}
%
%  \begin{function}{%
%                   \tlist_map_function_aux:Nn |
%                   \tlist_map_inline_aux:n |
%                   \tlist_map_variable_aux:Nnn |
%  }
%  \begin{syntax}\end{syntax}
%  Internal helper functions for the <tlist> loops.
%  \end{function}
%
%
%  \subsubsection{Heads or tails?}
%
% \begin{function}{%
%                  \tlist_head:n |
%                  \tlist_tail:n |
%                  \tlist_head_iii:n |
%                  \tlist_head_iii:f |
%                  \tlist_head:w |
%                  \tlist_tail:w |
%                  \tlist_head_iii:w
% }
% \begin{syntax}
%   "\tlist_head:n"  "{" <token1><token2>...<token-n> "}" \\
%   "\tlist_tail:n"  "{" <token1><token2>...<token-n> "}"
% \end{syntax}
% These functions return either the head or the tail of a list, thus in
% the above example "\tlist_head:n" would return <token1> and "\tlist_tail:n"
% would return <token2>\dots<token-n>. "\tlist_head_iii:n" returns the first
% three tokens. The ":w" versions require some care as they use a
% delimited argument internally.
% \begin{texnote}
% These are the Lisp functions "car" and "cdr" but with \LaTeX3 names.
% \end{texnote}
% \end{function}
%
%
%
%
% \begin{function}{%
%                  \tlist_if_head_eq:nNTF |
%                  \tlist_if_head_eq:NNTF |
%                  \tlist_if_head_eq:nNT |
%                  \tlist_if_head_eq:nNF |
% }
% \begin{syntax}
%   "\tlist_if_head_eq:nNTF"  "{" <token list> "}" <token> "{"<true>"}""{"<false>"}"\\
% \end{syntax}
% Returns <true> if the first token in <token list> is equal to <token> and
% <false> otherwise.
% \end{function}
%
% \subsubsection{Tests for equality and emptiness}
%
% \begin{function}{%
%                  \tlist_if_empty:nTF |
%                  \tlist_if_empty:nF |
%                  \tlist_if_empty_xpnd:nTF |
%                  \tlist_if_empty_xpnd:nF |
%                  \tlist_if_empty:NTF |
%                  \tlist_if_empty:NF |
% }
% \begin{syntax}
%   "\tlist_if_empty:nTF"  "{" <token list> "}" <token> "{"<true>"}""{"<false>"}"\\
% \end{syntax}
% Returns <true> if the first token in <token list> is equal to <token>
% and <false> otherwise. The |_xpnd| versions are expandable even
% though the token list may consist of arbitrary (non-quark) material.
% The last two are also expandable.
% \end{function}
%
%
% \begin{function}{%
%                  \tlist_if_eq:nnTF |
%                  \tlist_if_eq_alt:nnTF |
%                  \tlist_if_eq_alt:onTF |
% }
% \begin{syntax}
%   "\tlist_if_eq:nnTF"  "{"<token list1>"}""{"<token list2>"}"
%                        "{"<true>"}""{"<false>"}"\\
% \end{syntax}
% Returns <true> if <token list1> is equal to <token list2> and <false>
% otherwise. The |_alt| version try to do a safe expansion using an |f|
% type expansion.
% \end{function}
%
%  \subsection{Peeking ahead at the next token}
%
%  \begin{function}{%
%                   \token_new:N |
%  }
%  \begin{syntax}
%     "\token_new:N" <token>
%  \end{syntax}
%  Define a new token.
%  \end{function}
%
%  \begin{variable}{%
%                   \c_space_char_token |
%                   \c_left_brace_token |
%                   \c_right_brace_token |
%  }
%  \begin{syntax}
%  \end{syntax}
%  Some useful constants. The brace tokens have category codes~1 and~2
%  respectively.
%  \end{variable}
%
%  \begin{variable}{%
%                   \l_peek_token |
%                   \g_peek_token |
%                   \l_peek_search_token |
%  }
%  \begin{syntax}
%  \end{syntax}
%  Some useful variables. Initially they are set to "?".
%  \end{variable}
%
%
%  \begin{function}{%
%                   \peek_after:NN |
%                   \peek_gafter:NN |
%  }
%  \begin{syntax}
%     "\peek_after:NN" <function><token>
%  \end{syntax}
%  Assign <token> to "\l_peek_token" and then run <function> which
%  should perform some sort of test on this token. Leaves <token> in
%  the input stream. "\peek_gafter:NN" does this globally to the token
%  "\g_peek_token".
%  \begin{texnote}
%  This is the primitive \tn{afterassignment} turned into a function.
%  \end{texnote}
%  \end{function}
%
%  \begin{variable}{%
%                   \l_peek_true_branch_tlp |
%                   \l_peek_false_branch_tlp |
%  }
%  \begin{syntax}
%  \end{syntax}
%  These token list pointers are used internally when choosing either
%  the true or false branches of a test.
%  \end{variable}
%
%  \begin{function}{%
%                   \peek_char_generic:NNTF |
%                   \peek_remove_char_generic:NNTF |
%  }
%  \begin{syntax}
%     "\peek_char_generic:NNTF" <token><function> "{"<true>"}""{"<false>"}"
%  \end{syntax}
%  "\peek_char_generic:NNTF" looks ahead and checks if the next token
%  in the input stream is equal to <token>. It uses <function> to make
%  that decision. "\peek_remove_char_generic:NNTF" does the same thing
%  but additionally removes <token> from the input stream if it is
%  found. This does not work if <token> is either "\c_left_brace_token"
%  or "\c_right_brace_token" which ought to be obvious to the
%  programmer who should wish to do such a thing!
%  \end{function}
%
%
%  \begin{function}{%
%                   \peek_remove_spaces: |
%                   \peek_execute_branches: |
%                   \peek_remove_spaces:w |
%  }
%  \begin{syntax}
%  \end{syntax}
%  "\peek_remove_spaces:" continues to remove space tokens and when
%  it encounters something else it executes "\peek_execute_branches:"
%  The function "\peek_remove_spaces:w" is for internal use only.
%  \end{function}
%
%
%  \begin{function}{%
%                   \peek_char:NTF |
%                   \peek_char_spaces:NTF |
%                   \peek_remove_char:NTF |
%                   \peek_remove_char_spaces:NTF |
%  }
%  \begin{syntax}
%     "\peek_char:NNTF" <token>"{"<true>"}""{"<false>"}"
%  \end{syntax}
%  These are all specialized versions of "\peek_char_generic:NNTF" and
%  "\peek_remove_char_generic:NNTF". The "_spaces" versions ignore any
%  space tokens they encounter.
%  \end{function}
%
%
%
%  \begin{function}{%
%                   \peek_macro_or_other:NTF |
%  }
%  \begin{syntax}
%     "\peek_macro_or_other:NTF" <token>"{"<true>"}""{"<false>"}"
%  \end{syntax}
%  A variation which determines if <token> is a macro or something
%  else.
%  \end{function}
%
%
%
%  \subsection{Conditionals and logical operations}
%
%
%  \LaTeX3 has two primary forms of conditional flow processing. The
%  one type deals with the truth value of a test directly as in
%  "\cs_free:NTF" where you test if a control sequence was undefined
%  and then execute either the \m{true} or \m{false} part depending on
%  the result and after exiting the underlying "\if...\fi:" structure.
%  The second type has to do with predicate functions like
%  "\cs_free_p:N" which return either "\c_true" or "\c_false" to be
%  used in testing with "\if:w".
%
%
%  This section describes a boolean data type which is closely
%  connected to both parts as sometimes you want to execute some code
%  depending on the value of a switch (e.g.,~draft/final) and other
%  times you perhaps want to use it as a predicate function in an
%  "\if:w" test. Here \TeX's original concept with "\iffalse" and
%  "\iftrue" is a little difficult to handle so the easiest is simply
%  to let a boolean either be "\c_true" or "\c_false". This also means
%  we get the logical operations And, Or, and Not which can then be
%  used on both the boolean type and predicate functions.
%
%
%  \subsubsection{The boolean data type}
%
%  \begin{function}{%
%                   \bool_new:N |
%                   \bool_set_true:N |
%                   \bool_set_false:N |
%                   \bool_gset_true:N |
%                   \bool_gset_false:N |
%
%  }
%  \begin{syntax}
%     "\bool_new:N" <bool> \\
%     "\bool_gset_false:N" <bool>
%  \end{syntax}
%  Define new and setting of boolean variables. When a boolean is
%  defined it is initialized to <false>. A boolean is actually just
%  either "\c_true" or "\c_false".
%  \end{function}
%
%  \begin{function}{%
%                   \bool_if:NTF |
%                   \bool_if:NT |
%                   \bool_if:NF |
%                   \bool_if_p:N |
%
%  }
%  \begin{syntax}
%     "\bool_if:NTF" <bool> "{"\m{true}"}" "{"\m{false}"}"   \\
%     "\bool_if_p:N" <bool>
%  \end{syntax}
%  Test the truth value of the boolean and execute the \m{true} or
%  \m{false} code. "\bool_if_p:N" is a predicate function for use in
%  "\if:w" tests.
%  \end{function}
%
%  \begin{function}{%
%                   \bool_while:NT |
%                   \bool_while:NF |
%                   \bool_dowhile:NT |
%                   \bool_dowhile:NF |
%
%  }
%  \begin{syntax}
%     "\bool_while:NT" <bool> "{"\m{true}"}"  \\
%     "\bool_while:NF" <bool> "{"\m{false}"}"  \\
%  \end{syntax}
%  The "T" versions execute the \m{true} code as long as the boolean is
%  true and the "F" versions execute the \m{false} code as long as the
%  boolean is false. The "while" functions execute the body after
%  testing the boolean and the "dowhile" functions executes the body
%  first and then tests the boolean.
%  \end{function}
%
%
%  \begin{function}{%
%                   \l_tmpa_bool |
%                   \g_tmpa_bool |
%
%  }
%  \begin{syntax}
%  \end{syntax}
%  Reserved booleans.
%  \end{function}
%
%  \subsubsection{Logical operations}
%
%  Somewhat related to the subject of conditional flow processing is
%  logical operators as these deal with \m{true} and \m{false}
%  statements which is precisely what the predicate functions return.
%
%
%  \begin{function}{%
%                   \prg_logic_test:nTF |
%                   \prg_logic_test:nT |
%                   \prg_logic_test:nF |
%  }
%  \begin{syntax}
%     "\prg_logic_test:nTF" "{"<predicate>"}" "{"\m{true}"}" "{"\m{false}"}" \\
%  \end{syntax}
%  The first argument can either be a predicate function like
%  "\cs_free_p:N \foo" or one of the logic tests below.
%  \end{function}
%
%
%
%
%  \begin{function}{%
%                   \prg_logic_ors_p:n |
%                   \prg_logic_or_p:nn |
%                   \prg_logic_ands_p:n |
%                   \prg_logic_and_p:nn |
%                   \prg_logic_not_p:n |
%  }
%  \begin{syntax}
%     "\prg_logic_ors_p:n" "{"<predicate>,<predicate>,..."}"  \\
%     "\prg_logic_or_p:nn" "{"<predicate>"}" "{"<predicate>"}" \\
%     "\prg_logic_ands_p:n" "{"<predicate>,<predicate>,..."}"  \\
%     "\prg_logic_and_p:nn" "{"<predicate>"}" "{"<predicate>"}" \\
%     "\prg_logic_not_p:n" "{"<predicate>"}"
%  \end{syntax}
%  "\prg_logic_or_p:nn" compares the outcome of two predicate functions
%  (or other logic tests) and if either turns out to be \m{true}
%  returns \m{true} itself. "\prg_logic_and_p:nn" works in a similar way
%  but requires both outcomes to be \m{true} in order for it to return
%  \m{true} itself. "\prg_logic_not_p:n" reverses the truth value of a
%  predicate test or a logic operation. Thus
%  \begin{quote}
%  "\prg_logic_not_p:n {\prg_logic_not_p:n {\c_true}}"
%  \end{quote}
%  ultimately returns \m{true}.
%  The functions "\prg_logic_ors_p:n" and "\prg_logic_ands_p:n" take comma
%  separated lists of predicate functions and return either \m{true} or
%  \m{false}.\footnote{I could have made an interface where you put it
%  in braces but that was just begging for typos.}
%  \end{function}
%
% \StopEventually{}
%
% \section{Implementation}
%
%
%    We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<*initex|package>
%<!initex>\RequirePackage{l3quark,l3toks}\par
%    \end{macrocode}
%
%
%  \subsection{Choosing modes}
%
%  \begin{macro}{\mode_vertical:TF}
%  \begin{macro}{\mode_vertical:T}
%  For testing vertical mode.
%    \begin{macrocode}
\def_new:Npn \mode_vertical:TF {
  \tex_ifvmode:D
    \exp_after:NN \use_arg_i:nn
  \else:
    \exp_after:NN \use_arg_ii:nn
  \fi:}
\def_new:Npn \mode_vertical:T {
  \tex_ifvmode:D
    \exp_after:NN \use_arg_i:n
  \else:
    \exp_after:NN \use_none:n
  \fi:}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\mode_horizontal:TF}
%  \begin{macro}{\mode_horizontal:T}
%  For testing horizontal mode.
%    \begin{macrocode}
\def_new:Npn \mode_horizontal:TF {
  \tex_ifhmode:D
    \exp_after:NN \use_arg_i:nn
  \else:
    \exp_after:NN \use_arg_ii:nn
  \fi:}
\def_new:Npn \mode_horizontal:T {
  \tex_ifhmode:D
    \exp_after:NN \use_arg_i:n
  \else:
    \exp_after:NN \use_none:n
  \fi:}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\mode_inner:TF}
%  For testing inner mode.
%    \begin{macrocode}
\def_new:Npn \mode_inner:TF {
  \tex_ifinner:D
    \exp_after:NN \use_arg_i:nn
  \else:
    \exp_after:NN \use_arg_ii:nn
  \fi:}
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\mode_math:TF}
%  For testing math mode. Uses the kern-save |\scan_stop_safe:|
%    \begin{macrocode}
\def_new:Npn \mode_math:TF {
  \scan_align_safe_stop:
  \tex_ifmmode:D
    \exp_after:NN \use_arg_i:nn
  \else:
    \exp_after:NN \use_arg_ii:nn
  \fi:}
%    \end{macrocode}
%  \end{macro}
%
% \subsubsection{Alignment safe grouping and scanning}
%
%
%  \begin{macro}{\group_align_safe_begin:}
%  \begin{macro}{\group_align_safe_end:}
%  \TeX's alignment structures present many problems. As Knuth says
%  himself in \emph{\TeX: The Program}: ``It's sort of a miracle
%  whenever |\halign| or |\valign| work, [\ldots]'' One problem relates
%  to commands that internally issues a |\cr| but also peek ahead for
%  the next character for use in, say, an optional argument. If the
%  next token happens to be a |&| with category code~4 we will get some
%  sort of weird error message because the underlying
%  |\tex_futurelet:D| will store the token at the end of the alignment
%  template. This could be a |$|$\sb3$ giving a message like
%  |! Misplaced \cr.| or even worse: it could be the |\endtemplate|
%  token causing even more trouble! To solve this we have to open a
%  special group so that \TeX{} still thinks it's on safe ground but at
%  the same time we don't want to introduce any brace group that may
%  find its way to the output. The following functions help with this
%  by using code documented only in Appendix~D of
%  \emph{The \TeX book}\dots
%    \begin{macrocode}
\def_new:Npn \group_align_safe_begin: {\if_false:{\fi:\if_num:w0=`}\fi:}
\def_new:Npn \group_align_safe_end:   {\if_num:w0=`{\fi:\if_false:}\fi:}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\scan_align_safe_stop:}
%  When \TeX{} is in the beginning of an align cell (right after the
%  |\cr|) it is in a somewhat strange mode as it is looking ahead to
%  find an |\tex_omit:D| or |\tex_noalign:D| and hasn't looked at the
%  preamble yet. Thus an |\tex_ifmmode:D| test will always fail unless
%  we insert |\scan_stop:| to stop \TeX's scanning ahead. However we
%  only want to insert |\scan_stop:| if we're certain we won't destroy
%  any kerning! |\scan_align_safe_stop:| inserts it iff a)~we're in the
%  outer part of an alignment cell, b)~the last node wasn't a char node
%  or a ligature node. We make sure to put the |\scan_stop:| after the
%  closing |\fi:| as that may be important in some scanner mechanisms.
%    \begin{macrocode}
\def_new:Npn \scan_align_safe_stop: {
  \num_compare:nNnT \etex_currentgrouptype:D = \c_six
  {
    \num_compare:nNnF \etex_lastnodetype:D = \c_zero
    {
      \num_compare:nNnF \etex_lastnodetype:D = \c_seven
        \scan_stop:
    }
  }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \subsection{Token lists}
%
%  As \LaTeX3 uses a lot of mapping functions on its internal list
%  structures there is little point in adopting the implementation of
%  the \LaTeXe{} macros \tn{@for} and \tn{@tfor} as those two functions
%  have a running time proportional to $n^2$. Instead we make use of
%  tail recursion ensuring a running time proportional to $n$. Although
%  this requires a change in the user interface it also enables us to
%  implement expandable mapping functions.
%
%  Some data types have their own modules and in those cases the
%  corresponding mapping functions have been moved there as that seems
%  more natural. Currently this is the case for the modules
%  \textsf{l3clist}, \textsf{l3prop}, and \textsf{l3seq}.
%
%
%  The contents of a token list is a series of single tokens or
%  something in a brace group.
%
%  \subsubsection{Token list mapping}
%
%  \begin{macro}{\tlist_map_function:nN}
%  \begin{macro}{\tlist_map_function:NN}
%  \begin{macro}{\tlist_map_function_aux:NN}
%  Expandable loop macro for |tlist|s. These have the advantage of not
%  needing to test if the argument is empty, because if it is, the stop
%  marker will be read immediately and the loop terminated.
%    \begin{macrocode}
\def_new:Npn \tlist_map_function:nN #1#2{
  \tlist_map_function_aux:Nn #2 #1 \q_stop
}
\def_new:Npn \tlist_map_function:NN #1#2{
  \exp_after:NN \tlist_map_function_aux:Nn
  \exp_after:NN #2 #1 \q_stop
}
\def_new:Npn \tlist_map_function_aux:Nn #1#2{
  \if_meaning:NN \q_stop #2
  \else:
    #1{#2}
    \exp_after:NN \tlist_map_function_aux:Nn
    \exp_after:NN #1
  \fi:
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\tlist_map_break:w}
%  The break statement.
%    \begin{macrocode}
\def_new:Npn \tlist_map_break:w #1 \q_stop { \fi: }
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\tlist_map_inline:nn}
%  \begin{macro}{\tlist_map_inline:Nn}
%  \begin{macro}{\tlist_map_inline_aux:n}
%  \begin{macro}{\tlist_map_inline_function:n}
%  The inline functions are straight forward by now.
%    \begin{macrocode}
\def_new:Npn \tlist_map_inline:nn #1#2{
  \def:Npn \tlist_map_inline_function:n ##1{#2}
  \tlist_map_inline_aux:N #1 \q_stop
}
\def_new:Npn \tlist_map_inline:Nn #1#2{
  \def:Npn \tlist_map_inline_function:n ##1{#2}
  \exp_after:NN \tlist_map_inline_aux:n #1 \q_stop
}
\def_new:Npn \tlist_map_inline_aux:n #1{
  \if_meaning:NN \q_stop #1
  \else:
    \tlist_map_inline_function:n {#1}
    \exp_after:NN \tlist_map_inline_aux:n
  \fi:
}
\let_new:NN \tlist_map_inline_function:n \use_none:n
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
% \begin{macro}{\tlist_map_variable:nNn}
% \begin{macro}{\tlist_map_variable:NNn}
% \begin{macro}{\tlist_map_variable:cNn}
%    |\tlist_map:NNn| \zz{tlist} \zz{temp} \zz{action} assigns
%    \zz{temp} to each element and executes \zz{action}.
%    \begin{macrocode}
\def_new:Npn \tlist_map_variable:nNn #1#2#3{
  \tlist_if_empty:nF{#1}
  {
    \tlist_map_variable_aux:Nnn #2 {#3} #1 \q_stop
  }
}
\def_new:Npn \tlist_map_variable:NNn {\exp_args:No \tlist_map_variable:nNn}
\def_new:Npn \tlist_map_variable:cNn {\exp_args:Nc \tlist_map_variable:NNn}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\tlist_map_variable_aux:NnN}
%  The general loop. Assign the temp variable |#1| to the current item
%  |#3| and then check if that's the stop marker. If it is, break the
%  loop. If not, execute the action |#2| and continue.
%    \begin{macrocode}
\def_new:Npn \tlist_map_variable_aux:Nnn #1#2#3{
  \tlp_set:Nn #1{#3}
  \if_meaning:NN \q_stop #1
    \exp_after:NN \use_none:nn
  \else:
    #2
    \exp_after:NN \tlist_map_variable_aux:Nnn
  \fi:
  #1{#2}
}
%    \end{macrocode}
% \end{macro}
%
%  \subsubsection{Heads or tails?}
%
%  \begin{macro}{\tlist_head:n}
%  \begin{macro}{\tlist_tail:n}
%  \begin{macro}{\tlist_head_iii:n}
%  \begin{macro}{\tlist_head_iii:f}
%  \begin{macro}{\tlist_head:w}
%  \begin{macro}{\tlist_tail:w}
%  \begin{macro}{\tlist_head_iii:w}
%  These functions pick up either the head or the tail of a list.
%  "\tlist_head_iii:n" returns the first three items on a list.
%    \begin{macrocode}
\def_new:Npn \tlist_head:n #1{\tlist_head:w #1\q_nil}
\def_new:Npn \tlist_tail:n #1{\tlist_tail:w #1\q_nil}
\def_new:Npn \tlist_head_iii:n #1{\tlist_head_iii:w #1\q_nil}
\def_new:Npn \tlist_head_iii:f {\exp_args:Nf \tlist_head_iii:n}
\def_new:Npn \tlist_head:w #1#2\q_nil{#1}
\def_new:Npn \tlist_tail:w #1#2\q_nil{#2}
\def_new:Npn \tlist_head_iii:w #1#2#3#4\q_nil{#1#2#3}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\tlist_if_head_eq:nNTF}
%  \begin{macro}{\tlist_if_head_eq:NNTF}
%  \begin{macro}{\tlist_if_head_eq:nNT}
%  \begin{macro}{\tlist_if_head_eq:nNF}
%  Check if the first token in \m{tlist} equals a specific
%  token.
%    \begin{macrocode}
\def_new:Npn \tlist_if_head_eq:nNTF #1#2{
  \exp_after:NN \if_meaning:NN \tlist_head:w #1\q_nil#2
    \exp_after:NN \use_arg_i:nn
  \else:
    \exp_after:NN \use_arg_ii:nn
  \fi:
}
\def_new:Npn \tlist_if_head_eq:NNTF #1#2{
  \exp_after:NN\exp_after:NN\exp_after:NN \if_meaning:NN
  \exp_after:NN \tlist_head:w #1\q_nil#2
    \exp_after:NN \use_arg_i:nn
  \else:
    \exp_after:NN \use_arg_ii:nn
  \fi:
}
\def_long_new:Npn \tlist_if_head_eq:nNT #1#2{
  \exp_after:NN \if_meaning:NN \tlist_head:w #1\q_nil#2
    \exp_after:NN \use_arg_i:n
  \else:
    \exp_after:NN \use_none:n
  \fi:
}
\def_long_new:Npn \tlist_if_head_eq:nNF #1#2{
  \exp_after:NN \if_meaning:NN \tlist_head:w #1\q_nil#2
    \exp_after:NN \use_none:n
  \else:
    \exp_after:NN \use_arg_i:n
  \fi:
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
% \subsubsection{Tests for equality and emptiness}
%
%
% \begin{macro}{\tlist_if_empty:nTF}
% \begin{macro}{\tlist_if_empty:nF}
% \begin{macro}{\tlist_if_empty_xpnd:nTF}
% \begin{macro}{\tlist_if_empty_xpnd:nF}
% \begin{macro}{\tlist_if_empty:NTF}
% \begin{macro}{\tlist_if_empty:NF}
%    These test whether a token list is empty and act accordingly.
%    \begin{macrocode}
\def_new:Npn \tlist_if_empty:nTF #1{
  \tlp_set:Nn \l_tmpa_tlp {#1} \tlp_if_empty:NTF \l_tmpa_tlp }
\def_new:Npn \tlist_if_empty:nF #1{
  \tlp_set:Nn \l_tmpa_tlp {#1} \tlp_if_empty:NF \l_tmpa_tlp }
%    \end{macrocode}
%    The "xpnd" versions are expandable and work only if "\q_nil" is
%    not the first token in \m{tlist} but since "\q_nil" should never
%    appear, that shouldn't pose a problem. If it is we go into an
%    infinite loop, so I guess you'd notice\dots{} There are more
%    devious methods like having a letter with a strange category code
%    but this should be fine for now.
%    \begin{macrocode}
\def_new:Npn \tlist_if_empty_xpnd:nTF #1{
  \if_meaning:NN \q_nil #1 \q_nil
      \exp_after:NN \use_arg_i:nn \else:
      \exp_after:NN \use_arg_ii:nn \fi:}
\def_new:Npn \tlist_if_empty_xpnd:nF #1{
  \if_meaning:NN \q_nil #1 \q_nil
      \exp_after:NN \use_none:nn \fi: \use_arg_i:n}
%    \end{macrocode}
%    The next two are also expandable.
%    \begin{macrocode}
\def_new:Npn \tlist_if_empty:NTF #1{
  \if_meaning:NN #1 \c_empty_tlp
      \exp_after:NN \use_arg_i:nn \else:
      \exp_after:NN \use_arg_ii:nn \fi:}
\def_new:Npn \tlist_if_empty:NF #1{
  \if_meaning:NN #1 \c_empty_tlp
      \exp_after:NN \use_none:nn \fi: \use_arg_i:n}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%  \begin{macro}{\tlist_if_eq:nnTF}
%  Check if two token lists are equal.
%    \begin{macrocode}
\def_new:Npn \tlist_if_eq:nnTF #1#2{
  \tlp_set:Nn \l_testa_tlp {#1}
  \tlp_set:Nn \l_testb_tlp {#1}
  \tlp_if_eq:NNTF \l_testa_tlp \l_testb_tlp
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\tlist_if_eq_alt:nnTF}
%  \begin{macro}{\tlist_if_eq_alt:onTF}
%  This is a special version of |\tlist_if_eq:nnTF| where we want to
%  check of the token lists expand to the same thing. The problem is
%  that we can't just use the |x| type expansion reliably for something
%  containing user input. Therefore we use a different approach where
%  we check if the first token of |#2| is a command or something else.
%  If it is a command we force an |f| type expansion, otherwise we
%  don't do anything else to it. The reason we don't just execute the
%  |f| expansion immediately is that it will gobble a leading space so
%  user input as \verb*| -NoValue-| would end up as only |-NoValue-|
%  which could easily lead us to the wrong result. By checking if the
%  first token is a command or something else we can avoid such a
%  mistake.
%    \begin{macrocode}
\def_new:Npn \tlist_if_eq_alt:nnTF #1#2{
  \tlp_set:Nn \l_testa_tlp {#1}
%    \end{macrocode}
%  We have to put in some sort of delimiter as we produce the argument
%  ``raw'' because braces won't work of course. Since it is user input
%  a quark is a fine way to delimit it.
%    \begin{macrocode}
  \peek_after:NN \tlist_if_eq_alt_aux:w #2 \q_nil
  \tlp_if_eq:NNTF \l_testa_tlp \l_testb_tlp
}
\def_new:Npn \tlist_if_eq_alt:onTF {\exp_args:No \tlist_if_eq_alt:nnTF}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\tlist_if_eq_alt_aux:w}
%  We peeked ahead to look at the first token of the second token list
%  and now we check if is is a command or something else.
%    \begin{macrocode}
\def_new:Npn \tlist_if_eq_alt_aux:w #1 \q_nil {
  \peek_macro_or_other:NTF \l_peek_token
%    \end{macrocode}
%  If it was a command we force expansion before storing it in the
%  token list pointer, otherwise we just store it unchanged.
%    \begin{macrocode}
    \tlp_set:Nf
    \tlp_set:Nn
  \l_testb_tlp {#1}
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \subsection{Peeking ahead at the next token}
%
%
%  \begin{macro}{\token_new:Nn}
%  Creates a new token.
%    \begin{macrocode}
\def_new:Npn \token_new:Nn #1#2{\glet_new:NN #1#2}
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\c_space_char_token}
%  \begin{macro}{\c_left_brace_token}
%  \begin{macro}{\c_right_brace_token}
%  We define these useful tokens. We have to do it by hand with the
%  brace tokens for obvious reasons.
%    \begin{macrocode}
\token_new:Nn \c_space_char_token {~}
\let_new:NN \c_left_brace_token{
\let_new:NN \c_right_brace_token}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\l_peek_token}
%  \begin{macro}{\g_peek_token}
%  \begin{macro}{\l_peek_search_token}
%  We define some other tokens which will initially be the character
%  |?|.
%    \begin{macrocode}
\token_new:Nn \l_peek_token {?}
\token_new:Nn \g_peek_token {?}
\token_new:Nn \l_peek_search_token {?}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\peek_after:NN}
%  \begin{macro}{\peek_gafter:NN}
%  |\peek_after:NN| takes two argument where the first is a function
%  acting on |\l_peek_token| and the second is the next token in the
%  input stream which |\l_peek_token| is set equal to.
%  |\peek_gafter:NN| does the same globally to |\g_peek_token|.
%    \begin{macrocode}
\def_new:Npn \peek_after:NN {\tex_futurelet:D \l_peek_token }
\def_new:Npn \peek_gafter:NN {
  \pref_global:D \tex_futurelet:D \g_peek_token
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
%  For normal purposes there are four main cases:
%  \begin{enumerate}
%     \item peek at the next token.
%     \item peek at the next non-space token.
%     \item peek at the next token and remove it.
%     \item peek at the next non-space token and remove it.
%  \end{enumerate}

%The only


%
%  The generic function will take four arguments: The token to search
%  for, the function to run on it and the true/false cases.
%
%  The general algorithm is this:
%  \begin{enumerate}
%    \item
%    Store the token to search for in |\l_peek_search_token|.
%    \item
%    Run the \meta{true} and \meta{false} cases through a token
%    register before putting them into |\l_peek_true_tlp| and
%    |\l_peek_false_tlp| respectively as this avoids doubling
%    of hash marks where it's not needed. Also put in a special
%    alignment safe group end.
%    \item
%    Put in an alignment safe group begin.
%    \item
%    Peek ahead and call the function which will act on the next token
%    in the input stream.
%  \end{enumerate}

%  \begin{macro}{\l_peek_true_tlp}
%  \begin{macro}{\l_peek_false_tlp}
%    \begin{macrocode}
\tlp_new:Nn \l_peek_true_tlp {}
\tlp_new:Nn \l_peek_false_tlp {}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}

%  \begin{macro}{\peek_char_generic:NNTF}
%  |#1| is the special token we're looking for, |#2| the function
%  to execute (obey or ignore spaces, etc.), and |#3| and |#4| are
%  the \meta{true} and \meta{false} branches.
%    \begin{macrocode}
\def_long_new:Npn \peek_char_generic:NNTF #1#2#3#4{
%    \end{macrocode}
%  Using |\let:NN| allows us to see a space token as well.
%    \begin{macrocode}
  \let:NN \l_peek_search_token #1
  \toks_set:Nn \l_tmpa_toks {\group_align_safe_end: #3}
  \tlp_set:Nx \l_peek_true_tlp {\toks_use:N \l_tmpa_toks}
  \toks_set:Nn \l_tmpa_toks {\group_align_safe_end: #4}
  \tlp_set:Nx \l_peek_false_tlp {\toks_use:N \l_tmpa_toks}
  \group_align_safe_begin:
    \peek_after:NN #2
}
%    \end{macrocode}
%  \end{macro}

%  \begin{macro}{\peek_remove_spaces:}
%  Most of the functions will want to remove spaces in the input stream
%  so we define a function to do this. Once that task is done we call
%  |\peek_execute_branches:|.
%    \begin{macrocode}
\def_new:Npn \peek_remove_spaces: {
  \if_meaning:NN \l_peek_token \c_space_char_token
    \exp_after:NN \peek_remove_spaces_aux:w
  \else:
    \exp_after:NN \peek_execute_branches:
  \fi:
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\peek_remove_spaces_aux:w}
%  This macro definition looks weird but the deal is that it has to
%  gobble a space token and then search again. We can't implement that
%  directly as the space token would be discarded by \TeX, so we
%  cheat and use |\?| which will not discard a following space.
%  Better ensure the correct category codes just in case.
%    \begin{macrocode}
\group_begin:
  \tex_catcode:D`\?=12\scan_stop:
  \def:Npn \?{\gdef_new:Npn \peek_remove_spaces_aux:w}
  \?~{\peek_after:NN \peek_remove_spaces:}
\group_end:
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\peek_execute_branches:}
%  Execute the correct branch.
%    \begin{macrocode}
\def_new:Npn \peek_execute_branches: {
  \if_meaning:NN \l_peek_token \l_peek_search_token
    \exp_after:NN \l_peek_true_tlp
  \else:
    \exp_after:NN \l_peek_false_tlp
  \fi:
}
%    \end{macrocode}
%  \end{macro}

%  \begin{macro}{\peek_remove_char_generic:NNTF}
%  Same as |\peek_char_generic:NNTF| only this also removes the
%  searched token from the input stream if present. It can't be used
%  for removing an implicit character.
%    \begin{macrocode}
\def_long_new:Npn \peek_remove_char_generic:NNTF #1#2#3{
  \peek_char_generic:NNTF #1#2 {\use_arg_i:nn{#3}}
}
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{\peek_char_spaces:NTF}
%  Here's the normal version. Removes spaces first and then execute
%  the right branch.
%    \begin{macrocode}
\def_new:Npn \peek_char_spaces:NTF #1{
  \peek_char_generic:NNTF #1 \peek_remove_spaces:
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\peek_char:NTF}
%  Here's the version obeying spaces so we simply call the
%  execution of the branches immediately.
%    \begin{macrocode}
\def_new:Npn \peek_char:NTF #1{
  \peek_char_generic:NNTF #1 \peek_execute_branches:
}
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{\peek_remove_char_spaces:NTF}
%  \begin{macro}{\peek_remove_char:NTF}
%  Same as above only here we remove the token instead.
%    \begin{macrocode}
\def_new:Npn \peek_remove_char_spaces:NTF #1{
  \peek_remove_char_generic:NNTF #1 \peek_remove_spaces:
}
\def_new:Npn \peek_remove_char:NTF #1{
  \peek_remove_char_generic:NNTF #1 \peek_execute_branches:
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\peek_macro_or_other:NTF}
%  Check if the the token |#1| is a command or something other. We test
%  against something we know is a command namely |\tex_ifcat:D| itself.
%    \begin{macrocode}
\def_new:Npn \peek_macro_or_other:NTF #1 {
  \tex_ifcat:D \exp_not:N #1 \exp_not:N \tex_ifcat:D
    \exp_after:NN \use_arg_i:nn
  \else:
    \exp_after:NN \use_arg_ii:nn
  \fi:
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%
% \subsection{Booleans}
%  For normal booleans we set them to either "\c_true" or "\c_false"
%  and then use "\if:w" to choose the right branch. The functions
%  return either the TF, T, or F case \emph{after} ending the |\if:w|.
%  We only define the |N| versions here as the |c| versions can easily
%  be constructed with the expansion module.
%
%  \begin{macro}{\bool_new:N}
%  \begin{macro}{\bool_set_true:N}
%  \begin{macro}{\bool_set_false:N}
%  \begin{macro}{\bool_gset_true:N}
%  \begin{macro}{\bool_gset_false:N}
%  Defining and setting a boolean is easy.
%    \begin{macrocode}
\def_new:Npn \bool_new:N #1   { \def_new:Npn #1 { \c_false } }
\def_new:Npn \bool_set_true:N   #1 { \let:NN  #1 \c_true }
\def_new:Npn \bool_set_false:N  #1 { \let:NN  #1 \c_false }
\def_new:Npn \bool_gset_true:N  #1 { \glet:NN #1 \c_true }
\def_new:Npn \bool_gset_false:N #1 { \glet:NN #1 \c_false }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\l_tmpa_bool}
%  \begin{macro}{\g_tmpa_bool}
%  A few booleans just if you need them.
%    \begin{macrocode}
\bool_new:N \l_tmpa_bool
\bool_new:N \g_tmpa_bool
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\bool_if:NTF}
%  \begin{macro}{\bool_if:NT}
%  \begin{macro}{\bool_if:NF}
%  Straight forward here.
%    \begin{macrocode}
\def_new:Npn \bool_if:NTF #1 {
  \if:w #1
    \exp_after:NN \use_arg_i:nn
  \else:
    \exp_after:NN \use_arg_ii:nn
  \fi:
}
\def_new:Npn \bool_if:NT #1 {
  \if:w #1
    \exp_after:NN \use_arg_ii:nn
  \fi:
  \use_none:n
}
\def_new:Npn \bool_if:NF #1 {
  \if:w #1
    \exp_after:NN \use_none:n
  \else:
    \exp_after:NN \use_arg_i:n
  \fi:
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\bool_while:NT}
%  \begin{macro}{\bool_while:NF}
%  A "while" loop where the boolean is tested before executing the
%  statement. The "NT" version executes the "T" part as long as the
%  boolean is true while the "NF" version executes the "F" part as
%  long as the boolean is false.
%\begin{macrocode}
\def_new:Npn \bool_while:NT #1 #2 {
  \bool_if:NT #1 {#2 \bool_while:NT #1 {#2}}
}
\def_new:Npn \bool_while:NF #1 #2 {
  \bool_if:NF #1 {#2 \bool_while:NF #1 {#2}}
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\bool_dowhile:NT}
%  \begin{macro}{\bool_dowhile:NF}
%  A "do-while" loop where the body is performed at least once and the
%  boolean is tested after executing the body. Otherwise identical to
%  the above functions.
%    \begin{macrocode}
\def_new:Npn \bool_dowhile:NT #1 #2 {
  #2 \bool_if:NT #1 {\bool_dowhile:NT #1 {#2}}
}
\def_new:Npn \bool_dowhile:NF #1 #2 {
  #2 \bool_if:NF #1 {\bool_dowhile:NF #1 {#2}}
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\bool_if_p:N}
%  We also make a predicate function for the "bool" data type but since
%  we use "\c_true" and "\c_false" it's rather simple\dots{}
%  Not that there's anything wrong in simplicity -- on the contrary!
%    \begin{macrocode}
\def_new:Npn \bool_if_p:N #1 { #1 }
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\prg_logic_test:nTF}
%  \begin{macro}{\prg_logic_test:nT}
%  \begin{macro}{\prg_logic_test:nF}
%  As the boolean type is actually a predicate function, the next ones
%  are just aliases.
%    \begin{macrocode}
\let_new:NN \prg_logic_test:nTF \bool_if:NTF
\let_new:NN \prg_logic_test:nT  \bool_if:NT
\let_new:NN \prg_logic_test:nF  \bool_if:NF
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\prg_logic_or_p:nn}
%  \begin{macro}{\prg_logic_and_p:nn}
%  \begin{macro}{\prg_logic_not_p:n}
%  The logic operations require a little more work. The idea is to have
%  the end result of the logic "and" and "or" functions return "00" and
%  "01" resp.\ to be used in an "\if:w" test. The arguments of the
%  functions are always something expanding to "\c_true" or "\c_false"
%  which is usually resulting from a predicate function or from another
%  logical operation. All the functions start with a "0" and depending
%  on the results of the tests return either "0" or "1" to the input
%  stream to form a new true or false statement.
%    \begin{macrocode}
\def_new:Npn \prg_logic_or_p:nn #1#2{
%    \end{macrocode}
% Start out with the "0".
%    \begin{macrocode}
  0
%    \end{macrocode}
% Form a number of the input which is one of "0000", "0001", "0100", or
% "0101". If the truth value of both tests are false we get the "0101"
% else we get a number less than that. So we check if the number formed
% is less than $101$.
%    \begin{macrocode}
  \if_num:w #1#2<\c_hundred_one
%    \end{macrocode}
% If it is we put a "0" back into the input stream after closing the
% conditional giving us $"00" = \m{true}$.
%    \begin{macrocode}
    \exp_after:NN 0
  \else:
%    \end{macrocode}
% Else we put in a "1" resulting in $"01" = \m{false}$.
%    \begin{macrocode}
    \exp_after:NN 1
  \fi:
}
%    \end{macrocode}
%  The "and" function is a little different. Again we can have input of
%  the types "0000", "0001", "0100", or "0101". As we require both
%  values to be \m{true} in order to continue we simply check if the
%  number formed by the input is "0" or not and then put the
%  corresponding "0" or "1" back in the input stream as above. We could
%  use "\if_num:w" for this test as well but that'll require us to read
%  the additional "=\c_zero" which runs a little slower than using
%  "\tex_ifcase:D" directly, so we use the latter.
%    \begin{macrocode}
\def_new:Npn \prg_logic_and_p:nn #1#2{
  0
  \tex_ifcase:D #1#2 ~
    \exp_after:NN 0
  \else:
    \exp_after:NN 1
  \fi:
}
%    \end{macrocode}
%  The "not" function checks a single truth value and reverses it. Here
%  we either get a "00" or "01". If the input equals "0" we put a "1"
%  in the input stream, else we put a "0". Again we use "\tex_ifcase:D"
%  because it's slightly faster.
%    \begin{macrocode}
\def_new:Npn \prg_logic_not_p:n #1{
  0
  \tex_ifcase:D #1 ~
    \exp_after:NN 1
  \tex_or:D
    \exp_after:NN 0
  \fi:
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\prg_logic_ors_p:n}
%  \begin{macro}{\prg_logic_ors_aux:w}
%  \begin{macro}{\prg_logic_ands_p:n}
%  \begin{macro}{\prg_logic_ands_aux:w}
%  For longer lists of predicates we can't rely on such structures as
%  above. The "\prg_logic_ands_p:n" would have been easy to program as simply
%  \begin{verbatim}
\def_new:Npn \prg_logic_and_p:n #1 {
  0\tex_ifcase:D #1 ~ \exp_after:NN 0 \else: \exp_after:NN 1 \fi:
}
%  \end{verbatim}
%  but this would fail with a "! Number too big." in case we were
%  testing six predicate functions where the first was false. This
%  would mean we would have to first convert the string from binary
%  into numerical and then check. While challenging and interesting
%  in itself (See \textsf{binhex}) it still imposes a restriction of
%  15 predicate functions\footnote{We would probably never hit that
%  limit but why create a restriction when we can avoid it?} and we
%  haven't dealt with the "or" case either.
%
%  The solution is to use a mapping function similar to the one in the
%  \textsf{l3clist} module.
%
%    \begin{macrocode}
\def_new:Npn \prg_logic_ors_p:n #1{
%    \end{macrocode}
% Start out with the "0" as usual and then call a recursive loop.
%    \begin{macrocode}
  0 \prg_logic_ors_aux:w #1, \q_stop ,
}
%    \end{macrocode}
%    \begin{macrocode}
\def_new:Npn \prg_logic_ors_aux:w #1,{
%    \end{macrocode}
% If we hit the stop marker it means we didn't find a single
% true predicate function so we return "1" to make it all false.
%    \begin{macrocode}
  \if_meaning:NN \q_stop #1
    \exp_after:NN 1
  \else:
%    \end{macrocode}
% If we find a true predicate we return "0" to the input stream and
% break the loop. If not we call this function recursively.
%    \begin{macrocode}
    \tex_ifcase:D #1 ~
      \exp_after:NN 0
      \exp_after:NN \prg_logic_andor_break:w
    \fi:
    \exp_after:NN \prg_logic_ors_aux:w
  \fi:
}
%    \end{macrocode}
%  The "and" function is quite similar. Only here we break the loop
%  if we find a \m{false}.
%    \begin{macrocode}
\def_new:Npn \prg_logic_ands_p:n #1{
%    \end{macrocode}
% Start out with the "0" as usual and then call a recursive loop.
%    \begin{macrocode}
  0 \prg_logic_ands_aux:w #1, \q_stop ,
}
\def_new:Npn \prg_logic_ands_aux:w #1,{
%    \end{macrocode}
% If we hit the stop marker it means we didn't find a single
% false predicate function so we return "0" to make it all true.
%    \begin{macrocode}
  \if_meaning:NN \q_stop #1
    \exp_after:NN 0
  \else:
%    \end{macrocode}
% If we find a false predicate we return "1" to the input stream and
% break the loop. If not we call this function recursively.
%    \begin{macrocode}
    \tex_ifcase:D #1 ~
    \tex_or:D
      \exp_after:NN 1
      \exp_after:NN \prg_logic_andor_break:w
    \fi:
    \exp_after:NN \prg_logic_ands_aux:w
  \fi:
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\prg_logic_andor_break:w}
%    \begin{macrocode}
\def_new:Npn \prg_logic_andor_break:w #1 \q_stop, {\fi:}
%    \end{macrocode}
%  \end{macro}
%
%  That's it (for now).
%    \begin{macrocode}
%</initex|package>
%<*showmemory>
\showMemUsage
%</showmemory>
%    \end{macrocode}
%
% \endinput
%
% $Log$
% Revision 1.8  2005/04/06 21:27:15  morten
% More tlist functions, Moved \engine_aleph:TF to l3basics, new peek-ahead functions, definitions of implicit characters.
%
% Revision 1.7  2005/03/26 21:11:14  morten
% Fix typo in \scan_align_safe_stop:
%
% Revision 1.6  2005/03/22 23:23:30  morten
% Moved \tlist_ functions from l3basics. Added align-safe versions of important functions. Reorganized documentation slightly.
%
% Revision 1.5  2005/03/16 22:36:10  braams
% Added the tweaks necessary to be able to load with initex
%
% Revision 1.4  2005/03/11 21:28:20  braams
% Fixed the use of RCS information; added \StopEventually
%
