% \iffalse
%% File: l3prg.dtx Copyright (C) 2005 Morten H\o gholm, LaTeX3 project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3a of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``expl3 bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%%
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{%
  \def\fileversion{#3}%
  \def\filedate{#4}%
%<package> \ProvidesPackage{#2}[#4 #3 #5 #6]%
}
\next$Id$
       {L3 Experimental control structures}
% \fi
%
% \iffalse
%<*driver>
\documentclass{l3doc}

\begin{document}
\DocInput{l3prg.dtx}
\end{document}
%</driver>
% \fi
%
% \def\next#1: #2.dtx,v #3 #4 #5 #6 #7${
%  \def\filename{#2}%
%  \def\fileversion{#3}%
%  \def\filedate{#4}}
% \next$Id$
%
%
% \title{The \textsf{l3prg} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Program control structures}
% \author{Morten H\o gholm}
% \date{\filedate}
% \maketitle
%
%
% \section{Loop functions}
%
%  Loops are good for many things: Checking a list of punctuation
%  characters to ensure the correct italic correction, normalizing an
%  argument containing possibly active characters and so on.
%
%  In this section we define a number of loop functions in order to
%  assist other modules.
%
%  \subsection{Comma lists}
%
%  First up is the "clist" data type.
%
%  \begin{function}{%
%                   \prg_loop_clist:nN |
%                   \prg_loop_clist:NN |
%  }
%  \begin{syntax}
%     "\prg_loop_clist:nN" "{"<clist>"}" <function> \\
%     "\prg_loop_clist:NN" <clist> <function>
%  \end{syntax}
%  Runs through all elements in a |clist| from left to right and places
%  <function> in front of each element which is surrounded by braces.
%  Thus <function> should be a function with a |:n| suffix. Uses a
%  purely expandable loop function and will stay so as long as
%  <function> is expandable too.
%  \begin{texnote}
%  These are similar to the \tn{@for} function from \LaTeXe{}, only these
%  are faster, expandable, and has meaningful names\dots\ ";-)"
%  \end{texnote}
%  \end{function}
%
%  \begin{function}{%
%                   \prg_loop_clist_inline:nn |
%                   \prg_loop_clist_inline:Nn |
%  }
%  \begin{syntax}
%     "\prg_loop_clist_inline:nn" "{"<clist>"}" "{"<inline~function>"}" \\
%     "\prg_loop_clist_inline:nn" <clist> "{"<inline~function>"}"
%  \end{syntax}
%  Allows a syntax like "\prg_loop_clist_inline:nn" "{"<clist>"}"
%  "{\textbf{#1}}" where "#1" is the element. Very fast.
%  Cannot be nested with other "clist_inline" functions but it's
%  possible to nest it with different types of "inline" functions.
%  \end{function}
%
%
%  \begin{function}{%
%                   \prg_loop_clist_break: |
%  }
%  \begin{syntax}
%     "\prg_loop_clist_break:"
%  \end{syntax}
%  For breaking out of a loop. To be used inside "TF" type functions as
%  in the example here:
%  \begin{verbatim}
%  \def_new:Npn \test_function:n #1 {
%    \int_compare:nNnTF {#1}> 3 {\prg_loop_clist_break:}{``#1''}
%  }
%  \prg_loop_clist:nN {1,2,3,4,5,6,7,8}\test_function:n
%  \end{verbatim}
%  This would return "``1''``2''``3''"
%  \end{function}
%
%  \subsubsection{Internal macros}
%
%  \begin{function}{%
%                   \prg_loop_clist_inline_function:n |
%  }
%  \begin{syntax}\end{syntax}
%  Internal function used in the "inline" function.
%  \end{function}
%
%  \begin{function}{%
%                   \prg_loop_clist_auxi:w |
%                   \prg_loop_clist_auxii:w |
%                   \prg_loop_clist_inline_auxi:w |
%                   \prg_loop_clist_inline_auxii:w |
%  }
%  \begin{syntax}\end{syntax}
%  Internal helper functions for the <clist> loops.
%  \end{function}
%
%
%
%  \subsection{Token lists}
%
%  Here are the corresponding macros for token lists.
%
%  \begin{function}{%
%                   \prg_loop_tlist:nN |
%                   \prg_loop_tlist:NN |
%  }
%  \begin{syntax}
%     "\prg_loop_tlist:nN" "{"<tlist>"}" <function> \\
%     "\prg_loop_tlist:NN" <tlist> <function>
%  \end{syntax}
%  Runs through all elements in a |tlist| from left to right and places
%  <function> in front of each element. Thus <function> should be a
%  function with a |:N| suffix. Uses a purely expandable loop function
%  and will stay so as long as <function> is expandable too. The <tlist>
%  is not supposed to contain brace groups and if still used with these
%  functions it may cause weird errors.
%  \end{function}
%
%  \begin{function}{%
%                   \prg_loop_tlist_inline:nn |
%                   \prg_loop_tlist_inline:Nn |
%  }
%  \begin{syntax}
%     "\prg_loop_tlist_inline:nn" "{"<tlist>"}" "{"<inline~function>"}" \\
%     "\prg_loop_tlist_inline:nn" <tlist> "{"<inline~function>"}"
%  \end{syntax}
%  Allows a syntax like "\prg_loop_tlist_inline:nn" "{"<tlist>"}"
%  "{\token_to_string:N #1}". This renders it non-expandable though.
%  Cannot be nested with other "tlist_inline" functions but it's
%  possible to nest it with a "clist_inline" function.
%  \end{function}
%
%  \begin{function}{%
%                   \prg_loop_tlist_break: |
%  }
%  \begin{syntax}
%     "\prg_loop_tlist_break:"
%  \end{syntax}
%  For breaking out of a loop. Usage is the same as shown in the
%  example for <clist> above.
%  \end{function}
%
%  \subsubsection{Internal macros}
%
%  \begin{function}{%
%                   \prg_loop_tlist_inline_function:N |
%  }
%  \begin{syntax}\end{syntax}
%  Internal function used in the "inline" function.
%  \end{function}
%
%  \begin{function}{%
%                   \prg_loop_tlist_aux:w |
%                   \prg_loop_tlist_inline_aux:w |
%  }
%  \begin{syntax}\end{syntax}
%  Internal helper functions for the <tlist> loops.
%  \end{function}
%
%  \subsection{Property lists}
%
%  Property lists look like "\aaa{aaa}\bbb{bbb}". Here are functions
%  for running through them.
%
%  \begin{function}{%
%                   \prg_loop_plist:NN |
%  }
%  \begin{syntax}
%     "\prg_loop_tlist:NN" <plist> <function>
%  \end{syntax}
%  Runs through all \m{key}"{"\m{info}"}" pairs in a |plist| from
%  left to right and places <function> in front of each pair. Thus
%  <function> should be a function with a |:Nn| suffix. Uses a purely
%  expandable loop function and will stay so as long as <function> is
%  expandable too. For instance you can create an expandable function
%  that checks if a \m{key} is present
%  \end{function}
%
%  \begin{function}{%
%                   \prg_loop_plist_inline:Nn |
%  }
%  \begin{syntax}
%     "\prg_loop_plist_inline:nn" <plist> "{"<inline~function>"}"
%  \end{syntax}
%  "\prg_loop_plist_inline:Nn" <plist> "{\token_to_string:N #1{#2}}"
%  performs the second argument on each pair, so this example would
%  effectively show you the contents of \m{plist}. Although very fast
%  it does render the loop non-expandable.
%  Cannot be nested with other "plist_inline" functions but it's
%  possible to nest it with a different types of "inline" functions.
%  \end{function}
%
%  \begin{function}{%
%                   \prg_loop_plist_break: |
%  }
%  \begin{syntax}
%     "\prg_loop_plist_break:"
%  \end{syntax}
%  For breaking out of a loop. Usage is the same as shown in the
%  example for <clist> above.
%  \end{function}
%
%  \subsubsection{Internal macros}
%
%  \begin{function}{%
%                   \prg_loop_plist_inline_function:N |
%  }
%  \begin{syntax}\end{syntax}
%  Internal function used in the "inline" function.
%  \end{function}
%
%  \begin{function}{%
%                   \prg_loop_plist_aux:w |
%                   \prg_loop_plist_inline_aux:w |
%  }
%  \begin{syntax}\end{syntax}
%  Internal helper functions for the <plist> loops.
%  \end{function}
%
%
%
%  \subsection{Brace lists}
%
%  A brace list is something like "{1}{aaa}{3}{bbb}{-1}{ccc}". Here
%  are functions for running through them.\footnote{I don't know if we
%  really need this type, but here it is just in case.}
%
%  \begin{function}{%
%                   \prg_loop_bracelist:nN |
%                   \prg_loop_bracelist:NN |
%  }
%  \begin{syntax}
%     "\prg_loop_bracelist:NN" <bracelist> <function>
%  \end{syntax}
%  Similar to the loop functions for <tlist> but this type puts braces
%  around the elements, so <function> should have a ":n" suffix.
%  \end{function}
%
%  \begin{function}{%
%                   \prg_loop_bracelist_inline:nn |
%                   \prg_loop_bracelist_inline:Nn |
%  }
%  \begin{syntax}
%     "\prg_loop_bracelist_inline:Nn" <bracelist> "{"<inline~function>"}"
%  \end{syntax}
%  Inline version of the "bracelist" loop function.
%  \end{function}
%
%  \begin{function}{%
%                   \prg_loop_bracelist_break: |
%  }
%  \begin{syntax}
%     "\prg_loop_bracelist_break:"
%  \end{syntax}
%  For breaking out of a loop. Usage is the same as shown in the
%  example for <clist> above.
%  \end{function}
%
%  \subsubsection{Internal macros}
%
%  \begin{function}{%
%                   \prg_loop_bracelist_inline_function:n |
%  }
%  \begin{syntax}\end{syntax}
%  Internal function used in the "inline" function.
%  \end{function}
%
%  \begin{function}{%
%                   \prg_loop_bracelist_aux:w |
%                   \prg_loop_bracelist_inline_aux:w |
%  }
%  \begin{syntax}\end{syntax}
%  Internal helper functions for the <bracelist> loops.
%  \end{function}
%
%
%
%
%  \section{Conditionals and logical operations}
%
%
%  \LaTeX3 has two primary forms of conditional flow processing. The
%  one type deals with the truth value of a test directly as in
%  "\cs_free:NTF" where you test if a control sequence was undefined
%  and then execute either the \m{true} or \m{false} part depending on
%  the result and after exiting the underlying "\if...\fi:" structure.
%  The second type has to do with predicate functions like
%  "\cs_free_p:N" which return either "\c_true" or "\c_false" to be
%  used in testing with "\if:w".
%
%
%  This section describes a boolean data type which is closely
%  connected to both parts as sometimes you want to execute some code
%  depending on the value of a switch (e.g.,~draft/final) and other
%  times you perhaps want to use it as a predicate function in an
%  "\if:w" test. Here \TeX's original concept with "\iffalse" and
%  "\iftrue" is a little difficult to handle so the easiest is simply
%  to let a boolean either be "\c_true" or "\c_false". This also means
%  we get the logical operations And, Or, and Not which can then be
%  used on both the boolean type and predicate functions.
%
%
%  \subsection{The boolean data type}
%
%  \begin{function}{%
%                   \bool_new:N |
%                   \bool_set_true:N |
%                   \bool_set_false:N |
%                   \bool_gset_true:N |
%                   \bool_gset_false:N |
%
%  }
%  \begin{syntax}
%     "\bool_new:N" <bool> \\
%     "\bool_gset_false:N" <bool>
%  \end{syntax}
%  Define new and setting of boolean variables. When a boolean is
%  defined it is initialized to <false>. A boolean is actually just
%  either "\c_true" or "\c_false".
%  \end{function}
%
%  \begin{function}{%
%                   \bool_if:NTF |
%                   \bool_if:NT |
%                   \bool_if:NF |
%                   \bool_if_p:N |
%
%  }
%  \begin{syntax}
%     "\bool_if:NTF" <bool> "{"\m{true}"}" "{"\m{false}"}"   \\
%     "\bool_if_p:N" <bool>
%  \end{syntax}
%  Test the truth value of the boolean and execute the \m{true} or
%  \m{false} code. "\bool_if_p:N" is a predicate function for use in
%  "\if:w" tests.
%  \end{function}
%
%  \begin{function}{%
%                   \bool_while:NT |
%                   \bool_while:NF |
%                   \bool_dowhile:NT |
%                   \bool_dowhile:NF |
%
%  }
%  \begin{syntax}
%     "\bool_while:NT" <bool> "{"\m{true}"}"  \\
%     "\bool_while:NF" <bool> "{"\m{false}"}"  \\
%  \end{syntax}
%  The "T" versions execute the \m{true} code as long as the boolean is
%  true and the "F" versions execute the \m{false} code as long as the
%  boolean is false. The "while" functions execute the body after
%  testing the boolean and the "dowhile" functions executes the body
%  first and then tests the boolean.
%  \end{function}
%
%
%  \subsection{Logical operations}
%
%  Somewhat related to the subject of conditional flow processing is
%  logical operators as these deal with \m{true} and \m{false}
%  statements which is precisely what the predicate functions return.
%
%
%  \begin{function}{%
%                   \prg_logic_test:nTF |
%                   \prg_logic_test:nT |
%                   \prg_logic_test:nF |
%  }
%  \begin{syntax}
%     "\prg_logic_test:nTF" "{"<predicate>"}" "{"\m{true}"}" "{"\m{false}"}" \\
%     "\prg_logic_test:nTF" "{"<logic tests>"}" "{"\m{true}"}" "{"\m{false}"}"
%  \end{syntax}
%  The first argument can either be a predicate function like
%  "\cs_free_p:N \foo" or one of the logic tests below.
%  \end{function}
%
%
%
%
%  \begin{function}{%
%                   \prg_logic_or:nn |
%                   \prg_logic_and:nn |
%                   \prg_logic_not:n |
%  }
%  \begin{syntax}
%     "\prg_logic_or:nn" "{"<predicate func>"}" "{"<predicate func>"}" \\
%     "\prg_logic_and:nn" "{"<predicate func>"}" "{"<predicate func>"}" \\
%     "\prg_logic_not:nn" "{"<predicate func>"}" "{"<predicate func>"}"
%  \end{syntax}
%  "\prg_logic_or:nn" compares the outcome of two predicate functions
%  (or other logic tests) and if either turns out to be \m{true}
%  returns \m{true} itself. "\prg_logic_and:nn" works in a similar way
%  but requires both outcomes to be \m{true} in order for it to return
%  \m{true} itself. "\prg_logic_not:n" reverses the truth value of a
%  predicate test or a logic operation. Thus
%  \begin{quote}
%  "\prg_logic_not:n {\prg_logic_not:n {\c_true}}"
%  \end{quote}
%  ultimately returns \m{true}.
%  \end{function}
%
%
% \section{Implementation}
%
%
%    We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<*package>
\RequirePackage{l3basics,l3quark}\par
%    \end{macrocode}
%
%
%
%
%
%  This module provides a series of loop functions for comma separated
%  lists, token lists, property lists, and other types. They all use
%  tail recursion to work their way through the lists ensuring a
%  running time proportional to $n$. This stands in stark contrast to
%  the loop functions \tn{@for} and \tn{@tfor} from \LaTeXe{} as they both
%  reads to full remainder of the list causing a running time
%  proportional to $n^2$. As there are
%  packages\footnote{\textsf{listings} would be the prime example.} out
%  there using lists consisting of hundreds of elements this is
%  certainly a factor to be reckoned with.\footnote{On a comma
%  separated list with 50 elements, the new functions run a good 8
%  times faster, on a list with 500 elements that number rises to 83.}
%  Also this approach allows us to a)~construct purely expandable loops
%  and b)~define a somewhat cleaner interface than the old loop
%  functions.
%
%  \subsection{Comma separated lists}
%
%  \begin{macro}{\prg_loop_clist:nN}
%  \begin{macro}{\prg_loop_clist:NN}
%  \begin{macro}{\prg_loop_clist_aux:w}
%
%  Expandable loop macro for |clist|s. Performs the action "#2" on each
%  element in the list, so "#2" should be a function taking one
%  argument.
%
%  The only problem we might face with this tail recursion is a proper
%  way to terminate the loop as we might get input like "aaa,bbb,ccc,"
%  where the trailing comma probably means an empty last element. In
%  order to interpret that correctly we have to use two (different)
%  stop markers.
%
%  The ":nN" version takes an expanded "clist" (as is typical for user
%  input or other kinds where the "\clist_..." operations are not
%  sensible). Note that we reverse the order of the function and the
%  list because it's so much easier then. But before we set off we have
%  to check if the list is empty. We can't just use the first element
%  as a reliable test as that may be empty.
%    \begin{macrocode}
\def_new:Npn \prg_loop_clist:nN #1#2{
  \tlist_empty_xpnd:nF {#1}{
    \prg_loop_clist_aux:w #2 #1 , \q_nil , \q_stop ,
  }
}
%    \end{macrocode}
%  The ":NN" version takes an ordinary "clist" and then expands it and
%  never looks back. I assume that people constructing long lists store
%  them in a control sequence.
%    \begin{macrocode}
\def_new:Npn \prg_loop_clist:NN #1#2{
  \tlist_empty:NF #1
  {
    \exp_after:NN \prg_loop_clist_aux:w
    \exp_after:NN #2 #1 , \q_nil , \q_stop ,
  }
}
%    \end{macrocode}
%  The general loop test if we hit the first stop marker and exits if
%  we did. If we didn't, place the function "#1" in front of the
%  element "#2", which is surrounded by braces.
%    \begin{macrocode}
\def_new:Npn \prg_loop_clist_aux:w #1#2,{
  \if_meaning:NN \q_nil #2
    \prg_loop_clist_break:
  \else:
    #1{#2}
    \exp_after:NN \prg_loop_clist_aux:w
    \exp_after:NN #1
  \fi:
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\prg_loop_clist_break:}
%  The break statement is easy: Just gobble everything op to the last
%  of the two stop markers "\q_stop" waiting at the end and close the
%  "\if_..." we're in.
%    \begin{macrocode}
\def_new:Npn \prg_loop_clist_break: #1 \q_stop, { \fi: }
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\prg_loop_clist_inline:nn}
%  \begin{macro}{\prg_loop_clist_inline:Nn}
%  \begin{macro}{\prg_loop_clist_inline_aux:w}
%  \begin{macro}{\prg_loop_clist_inline_function:n}
%  The inline versions are even faster because they only handle one
%  argument when doing the actual loop. The catch is they can't be
%  nested though. If you want nesting, use the expandable version
%  instead.
%    \begin{macrocode}
\def_new:Npn \prg_loop_clist_inline:nn #1{
  \def:Npn \l_testa_tlp {#1}
  \prg_loop_clist_inline:Nn \l_testa_tlp
}
\def_new:Npn \prg_loop_clist_inline:Nn #1#2{
  \tlist_empty:NF #1
  {
    \def:Npn \prg_loop_clist_inline_function:n ##1{#2}
    \exp_after:NN \prg_loop_clist_inline_aux:w #1 , \q_nil , \q_stop ,
  }
}
%    \end{macrocode}
%  Helper functions once again. Otherwise similar to the expandable
%  versions.
%    \begin{macrocode}
\def_new:Npn \prg_loop_clist_inline_aux:w #1,{
  \if_meaning:NN \q_nil #1
    \prg_loop_clist_break:
  \else:
    \prg_loop_clist_inline_function:n {#1}
    \exp_after:NN \prg_loop_clist_inline_aux:w
  \fi:
}
\def_new:Npn \prg_loop_clist_inline_function:n #1 {}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \subsection{Token lists}
%  The contents of a token list is a series of single tokens, so no
%  brace groups allowed. The brace group supported type is available
%  under the names "\prg_loop_bracedlist:XX"
%
%  \begin{macro}{\prg_loop_tlist:nN}
%  \begin{macro}{\prg_loop_tlist:NN}
%  \begin{macro}{\prg_loop_tlist_aux:w}
%  Expandable loop macro for |tlist|s. These have the advantage of not
%  needing to test if the argument is empty, because if it is, the stop
%  marker will be read immediately and the loop terminated. This is the
%  "N" type where we expect a single token in the stream. Although it
%  will also pick up a brace group "{..}" this is not intended and don't
%  come asking for help if it doesn't work as you expected.
%    \begin{macrocode}
\def_new:Npn \prg_loop_tlist:nN #1#2{
  \prg_loop_tlist_aux:w #2 #1 \q_stop
}
\def_new:Npn \prg_loop_tlist:NN #1#2{
  \exp_after:NN \prg_loop_tlist_aux:w
  \exp_after:NN #2 #1 \q_stop
}
\def_new:Npn \prg_loop_tlist_aux:w #1#2{
  \if_meaning:NN \q_stop #2
  \else:
    #1#2
    \exp_after:NN \prg_loop_tlist_aux:w
    \exp_after:NN #1
  \fi:
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\prg_loop_tlist_break:}
%  The break statement.
%    \begin{macrocode}
\def_new:Npn \prg_loop_tlist_break: #1 \q_stop { \fi: }
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\prg_loop_tlist_inline:nn}
%  \begin{macro}{\prg_loop_tlist_inline:Nn}
%  \begin{macro}{\prg_loop_tlist_inline_aux:w}
%  \begin{macro}{\prg_loop_tlist_inline_function:N}
%  The inline functions are straight forward by now.
%    \begin{macrocode}
\def_new:Npn \prg_loop_tlist_inline:nn #1#2{
  \def:Npn \prg_loop_tlist_inline_function:N ##1{#2}
  \prg_loop_tlist_inline_aux:w #1 \q_stop
}
\def_new:Npn \prg_loop_tlist_inline:Nn #1#2{
  \def:Npn \prg_loop_tlist_inline_function:N ##1{#2}
  \exp_after:NN \prg_loop_tlist_inline_aux:w #1 \q_stop
}
\def_new:Npn \prg_loop_tlist_inline_aux:w #1#2{
  \if_meaning:NN \q_stop #2
  \else:
    \prg_loop_tlist_inline_function:N #2
    \exp_after:NN \prg_loop_tlist_aux:w
  \fi:
}
\def_new:Npn \prg_loop_tlist_inline_function:N #1 {}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%  \subsection{Braced lists}
%  The contents of a brace list is something like "{aa}{bb}{}{ddd}". I
%  don't know if this will be useful at all but at least it's here if
%  anyone needs it.\footnote{I have an idea of making a function type
%  that makes \tn{ifcase} easier to use by taking an
%  input like \texttt{\bslash
%    prg_case_choose:nn^^A
%    \{}\m{number}\texttt{\}\{\{1\}\{one\}^^A
%    \{3\}\{three\}\{-1\}\{other\}\}^^A
%    } and then picking the right one.}
%
%
%  \begin{macro}{\prg_loop_bracelist:nN}
%  \begin{macro}{\prg_loop_bracelist:NN}
%  \begin{macro}{\prg_loop_bracelist_aux:w}
%  Pretty much the same as for |tlist|s except this type puts the
%  braces back in when processing the list elements.
%    \begin{macrocode}
\def_new:Npn \prg_loop_bracelist:nN #1#2{
  \prg_loop_bracelist_aux:w #2 #1 \q_stop
}
\def_new:Npn \prg_loop_bracelist:NN #1#2{
  \exp_after:NN \prg_loop_bracelist_aux:w
  \exp_after:NN #2 #1 \q_stop
}
\def_new:Npn \prg_loop_bracelist_aux:w #1#2{
  \if_meaning:NN \q_stop #2
  \else:
    #1{#2}
    \exp_after:NN \prg_loop_bracelist_aux:w
    \exp_after:NN #1
  \fi:
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\prg_loop_bracelist_break:}
%  The break statement.
%    \begin{macrocode}
\def_new:Npn \prg_loop_bracelist_break: #1 \q_stop { \fi: }
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\prg_loop_bracelist_inline:nn}
%  \begin{macro}{\prg_loop_bracelist_inline:Nn}
%  \begin{macro}{\prg_loop_bracelist_inline_aux:w}
%  \begin{macro}{\prg_loop_bracelist_inline_function:n}
%  The inline functions are straight forward by now.
%    \begin{macrocode}
\def_new:Npn \prg_loop_bracelist_inline:nn #1#2{
  \def:Npn \prg_loop_bracelist_inline_function:n ##1{#2}
  \prg_loop_bracelist_inline_aux:w #1 \q_stop
}
\def_new:Npn \prg_loop_bracelist_inline:Nn #1#2{
  \def:Npn \prg_loop_bracelist_inline_function:N ##1{#2}
  \exp_after:NN \prg_loop_bracelist_inline_aux:w #1 \q_stop
}
\def_new:Npn \prg_loop_bracelist_inline_aux:w #1#2{
  \if_meaning:NN \q_stop #2
  \else:
    \prg_loop_bracelist_inline_function:n {#2}
    \exp_after:NN \prg_loop_bracelist_aux:w
  \fi:
}
\def_new:Npn \prg_loop_bracelist_inline_function:N #1 {}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \subsection{Property lists}
%
%  \begin{macro}{\prg_loop_plist:NN}
%  \begin{macro}{\prg_loop_plist_aux:w}
%  Expandable loop macro for |plist|s. No need to test if it's empty
%  as it'll exit on the first loop anyway. That's also faster.
%    \begin{macrocode}
\def_new:Npn \prg_loop_plist:NN #1#2{
    \exp_after:NN \prg_loop_plist_aux:w
    \exp_after:NN #2 #1 \q_nil \q_stop
}
\def_new:Npn \prg_loop_plist_aux:w #1#2#3{
  \if_meaning:NN \q_nil #2
  \else:
    #1#2{#3}
    \exp_after:NN \prg_loop_plist_aux:w
    \exp_after:NN #1
  \fi:
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\prg_loop_plist_break:}
%  The break statement. Strangely familiar\dots
%    \begin{macrocode}
\def_new:Npn \prg_loop_plist_break: #1 \q_stop { \fi: }
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\prg_loop_plist_inline:Nn}
%  \begin{macro}{\prg_loop_plist_inline_aux:w}
%  \begin{macro}{\prg_loop_plist_inline_function:Nn}
%  The inline functions are straight forward by now. It takes longer
%  to test if the list is empty than to run it on an empty list so
%  we don't waste time doing that.
%    \begin{macrocode}
\def_new:Npn \prg_loop_plist_inline:Nn #1#2 {
    \def:Npn \prg_loop_plist_inline_function:Nn ##1##2{#2}
    \exp_after:NN \prg_loop_plist_inline_aux:w #1 \q_nil \q_stop
}
\def_new:Npn \prg_loop_plist_inline_aux:w #1#2{
  \if_meaning:NN \q_nil #1
  \else:
    \prg_loop_plist_inline_function:Nn #1{#2}
    \exp_after:NN \prg_loop_plist_inline_aux:w
  \fi:
}
\def_new:Npn \prg_loop_plist_inline_function:Nn #1#2 {}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%
% \subsection{Booleans}
%  For normal booleans we set them to either "\c_true" or "\c_false"
%  and then use "\if:w" to choose the right branch. The functions
%  return either the TF, T, or F case \emph{after} ending the |\if:w|.
%  We only define the |N| versions here as the |c| versions can easily
%  be constructed with the expansion module.
%
%\begin{macro}{\bool_new:N}
%\begin{macro}{\bool_set_true:N}
%\begin{macro}{\bool_set_false:N}
%\begin{macro}{\bool_gset_true:N}
%\begin{macro}{\bool_gset_false:N}
%  Defining and setting a boolean is easy.
%    \begin{macrocode}
\def_new:Npn \bool_new:N #1   { \def_new:Npn #1 { \c_false } }
\def_new:Npn \bool_set_true:N   #1 { \let:NN  #1 \c_true }
\def_new:Npn \bool_set_false:N  #1 { \let:NN  #1 \c_false }
\def_new:Npn \bool_gset_true:N  #1 { \glet:NN #1 \c_true }
\def_new:Npn \bool_gset_false:N #1 { \glet:NN #1 \c_false }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\bool_if:NTF}
%\begin{macro}{\bool_if:NT}
%\begin{macro}{\bool_if:NF}
%  Straight forward here.
%    \begin{macrocode}
\def_new:Npn \bool_if:NTF #1 {
  \if:w #1
    \exp_after:NN \use_choice_i:nn
  \else:
    \exp_after:NN \use_choice_ii:nn
  \fi:
}
\def_new:Npn \bool_if:NT #1 {
  \if:w #1
    \exp_after:NN \use_choice_ii:nn
  \fi:
  \use_none:n
}
\def_new:Npn \bool_if:NF #1 {
  \if:w #1
    \exp_after:NN \use_none:n
  \else:
    \exp_after:NN \use:n
  \fi:
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\bool_while:NT}
%\begin{macro}{\bool_while:NF}
%  A "while" loop where the boolean is tested before executing the
%  statement. The "NT" version executes the "T" part as long as the
%  boolean is true while the "NF" version executes the "F" part as
%  long as the boolean is false.
%\begin{macrocode}
\def_new:Npn \bool_while:NT #1 #2 {
  \bool_if:NT #1 {#2 \bool_while:NT #1 {#2}}
}
\def_new:Npn \bool_while:NF #1 #2 {
  \bool_if:NF #1 {#2 \bool_while:NF #1 {#2}}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\bool_dowhile:NT}
%\begin{macro}{\bool_dowhile:NF}
%  A "do-while" loop where the body is performed at least once and the
%  boolean is tested after executing the body. Otherwise identical to
%  the above functions.
%\begin{macrocode}
\def_new:Npn \bool_dowhile:NT #1 #2 {
  #2 \bool_if:NT #1 {\bool_dowhile:NT #1 {#2}}
}
\def_new:Npn \bool_dowhile:NF #1 #2 {
  #2 \bool_if:NF #1 {\bool_dowhile:NF #1 {#2}}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\bool_if_p:N}
%  We also make a predicate function for the "bool" data type but since
%  we use "\c_true" and "\c_false" it's rather simple\dots
%    \begin{macrocode}
\def_new:Npn \bool_if_p:N #1 { #1 }
%    \end{macrocode}
%\end{macro}
%
%
%  \begin{macro}{\prg_logic_test:nTF}
%  \begin{macro}{\prg_logic_test:nT}
%  \begin{macro}{\prg_logic_test:nF}
%  As the boolean type is actually a predicate function this is just
%  a few aliases.
%    \begin{macrocode}
\let_new:NN \prg_logic_test:nTF \bool_if:NTF
\let_new:NN \prg_logic_test:nT  \bool_if:NT
\let_new:NN \prg_logic_test:nF  \bool_if:NF
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\prg_logic_or:nn}
%  \begin{macro}{\prg_logic_and:nn}
%  \begin{macro}{\prg_logic_not:n}
%  The logic operations require a little more work. The idea is to have
%  the end result of the logic "and" and "or" functions return "00" and
%  "01" resp.\ to be used in an "\if:w" test. The arguments of the
%  functions are always something expanding to "\c_true" or "\c_false"
%  which is usually resulting from a predicate function or from another
%  logical operation. All the functions start with a "0" and depending
%  on the results of the tests return either "0" or "1" to the input
%  stream to form a new true or false statement.
%    \begin{macrocode}
\def_new:Npn \prg_logic_or:nn #1#2{
%    \end{macrocode}
% Start out with the "0".
%    \begin{macrocode}
  0
%    \end{macrocode}
% Form a number of the input which is one of "0000", "0001", "0100", or
% "0101". If the truth value of both tests are false we get the "0101"
% else we get a number less than that. So we check if the number formed
% is less than $101$.
%    \begin{macrocode}
  \if_num:w #1#2<\c_hundred_one
%    \end{macrocode}
% If it is we put a "0" back into the input stream after closing the
% conditional giving us $"00" = \m{true}$.
%    \begin{macrocode}
    \exp_after:NN 0
  \else:
%    \end{macrocode}
% Else we put in a "1" resulting in $"01" = \m{false}$.
%    \begin{macrocode}
    \exp_after:NN 1
  \fi:
}
%    \end{macrocode}
%  The "and" function is a little different. Again we can have input of
%  the types "0000", "0001", "0100", or "0101". As we require both
%  values to be \m{true} in order to continue we simply check if the
%  number formed by the input is "0" or not and then put the
%  corresponding "0" or "1" back in the input stream as above. We could
%  use "\if_num:w" for this test as well but that'll require us to read
%  the additional "=\c_zero" which runs a little slower than using
%  "\tex_ifcase:D" directly, so we use the latter.
%    \begin{macrocode}
\def_new:Npn \prg_logic_and:nn #1#2{
  0
  \tex_ifcase:D #1#2 ~
    \exp_after:NN 0
  \else:
    \exp_after:NN 1
  \fi:
}
%    \end{macrocode}
%  The "not" function checks a single truth value and reverses it. Here
%  we either get a "00" or "01". If the input equals "0" we put a "1"
%  in the input stream, else we put a "0". Again we use "\tex_ifcase:D"
%  because it's slightly faster.
%    \begin{macrocode}
\def_new:Npn \prg_logic_not:n #1{
  0
  \tex_ifcase:D #1 ~
    \exp_after:NN 1
  \tex_or:D
    \exp_after:NN 0
  \fi:
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  That's it (for now).
%    \begin{macrocode}
%</package>
%<*showmemory>
\showMemUsage
%</showmemory>
%    \end{macrocode}
