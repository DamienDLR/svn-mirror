% \iffalse
%% File: l3num.dtx Copyright (C) 2005 Frank Mittelbach, LaTeX3 project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3a of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``expl3 bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%
%<*!initex>
% \fi
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{%^^A}$
  \def\fileversion{#3}%
  \def\filedate{#4}%
%\iffalse
%<*dtx>
%\fi
     \ProvidesFile{#2.dtx}[#4 v#3 #8]%
%\iffalse
%</dtx>
%<package> \ProvidesPackage{#2}[#4 v#3 #8]%
%<driver>  \ProvidesFile{#2.drv}[#4 v#3 #8]%
% \fi
}
%\iffalse
%</!initex>
%\fi
\next$Id$
       {L3 Experimental token numbers}
%
% \iffalse
%<*driver>
\documentclass{l3doc}

\begin{document}
\DocInput{l3num.dtx}
\end{document}
%</driver>
% \fi
%
% \def\next#1: #2.dtx,v #3 #4 #5 #6 #7${%^^A$
%  \def\filename{#2}%
%  \def\fileversion{#3}%
%  \def\filedate{#4}}
% \next$Id$
%
%
% \title{The \textsf{l3num} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Integer in macros}
% \author{Frank Mittelbach}
% \date{\filedate}
% \maketitle
%
% \section{Macro Counters}
%
% Instead of using counter registers for manipulation of
% integer values it is sometimes useful to keep such values in
% macros. For this \LaTeX3 offers the  type ``num''.
%
% One reason is the limited number of registers inside
% \TeX{}. However, when
% using e\TeX{} this is no longer an issue. It remains to be seen if
% there are other compelling reasons to keep this module.
%
% It turns out there might be.
%
% \subsection{Functions}
%
% \begin{function}{%
%                  \num_new:N |
%                  \num_new:c |
% }
% \begin{syntax}
%    "\num_new:N"   <num>
% \end{syntax}
% Defines <num> to be a new variable of type "num" (initialized to
% zero). There is no way to
% define constant counters with these functions.
% \end{function}
%
% \begin{function}{%
%                  \num_incr:N |
%                  \num_incr:c |
%                  \num_gincr:N |
%                  \num_gincr:c
% }
% \begin{syntax}
%   "\num_incr:N"   <num>
% \end{syntax}
% Increments <num> by one. For global variables the global versions
% should be used.
% \end{function}
%
% \begin{function}{%
%                  \num_decr:N |
%                  \num_decr:c |
%                  \num_gdecr:N |
%                  \num_gdecr:c |
% }
% \begin{syntax}
%   "\num_decr:N"   <num>
% \end{syntax}
% Decrements <num> by one. For global variables the global versions
% should be used.
% \end{function}
%
% \begin{function}{%
%                  \num_zero:N |
%                  \num_zero:c |
%                  \num_gzero:N |
%                  \num_gzero:c |
% }
% \begin{syntax}
%   "\num_zero:N"   <num>
% \end{syntax}
% Resets <num> to zero. For global variables the global versions
% should be used.
% \end{function}
%
% \begin{function}{%
%                  \num_set:Nn |
%                  \num_set:cn |
%                  \num_gset:Nn |
%                  \num_gset:cn |
% }
% \begin{syntax}
%   "\num_set:Nn"   <num> "{" <integer> "}"
% \end{syntax}
% These functions will set the <num> register to the <integer> value.
% \end{function}
%
% \begin{function}{%
%                  \num_gset_eq:NN |
%                  \num_gset_eq:cN |
%                  \num_gset_eq:Nc |
%                  \num_gset_eq:cc |
% }
% \begin{syntax}
%   "\num_gset_eq:NN"   <num1> <num2>
% \end{syntax}
% These functions will set the <num1> register equal to <num2>.
% \end{function}
%
% \begin{function}{%
%                  \num_add:Nn |
%                  \num_gadd:Nn |
% }
% \begin{syntax}
%   "\num_add:Nn"   <num> "{" <integer> "}"
% \end{syntax}
% These functions will add to the <num> register the value <integer>.  If
% the second argument is a <num> register too, the surrounding braces
% can be left out.
%
% \end{function}
%
%
% \begin{function}{%
%                  \num_use:N |
%                  \num_use:c |
% }
% \begin{syntax}
%   "\num_use:N"   <num>
% \end{syntax}
% This function returns the integer value kept in <num> in a way
% suitable for further processing.
% \begin{texnote}
% Since these <num>s are implemented as macros, the function
% "\num_use:N" is effetively a noop and mainly there for consistency
% with similar functions in other modules.
% \end{texnote}
% \end{function}
%
%
% \begin{function}{%
%                  \num_eval:n |
% }
% \begin{syntax}
%   "\num_eval:n"   "{" <integer-expr> "}"
% \end{syntax}
% Evaluates the integer expression allowing normal mathematical
% operators like |+-/*|.
% \begin{texnote}
% This is |\etex_numexpr:D| turned into a function.
% \end{texnote}
% \end{function}
%
% \begin{function}{%
%                  \num_compare:nNnTF |
%                  \num_compare:nNnT |
%                  \num_compare:nNnF |
% }
% \begin{syntax}
%   "\num_compare:nNnTF"   "{"<num~expr>"}" <rel> "{"<num~expr>"}"
%                          "{"<true>"}" "{"<false>"}"
% \end{syntax}
% These functions test two \m{num} expressions against each other. They
% are both evaluated by "\num_eval:n".
% \end{function}
%
% \begin{function}{%
%                  \num_compare_p:nNn |
% }
% \begin{syntax}
%   "\num_compare_p:nNn"   "{"<num~expr>"}" <rel> "{"<num~expr>"}"
% \end{syntax}
% A predicate version of the above functions.
% \end{function}
%
%
% \subsection{Formatting a counter value}
%
%
% \subsection{Variable and constants}
%
% \begin{function}{%
%                  \const_new:Nn |
% }
% \begin{syntax}
%   "\const_new:Nn"  "\c_"<value> "{" <value> "}"
% \end{syntax}
% Defines a constant with <value>. If the constant is negative
% or very large it requires an <int> register.
% \end{function}
%
% \begin{variable}{%
%                  \c_minus_one |
%                  \c_zero |
%                  \c_one |
%                  \c_two |
%                  \c_three |
%                  \c_four |
%                  \c_six |
%                  \c_seven |
%                  \c_sixteen |
%                  \c_hundred_one |
%                  \c_twohundred_fifty_five |
%                  \c_twohundred_fifty_six |
%                  \c_thousand |
%                  \c_ten_thousand |
%                  \c_twenty_thousand |
% }
% Set of constants denoting useful values.
% \begin{texnote}
% Most of these constants have been available under \LaTeX2 under names
% like \tn{tw@}, \tn{thr@@} etc.
% \end{texnote}
% \end{variable}
%
% \begin{variable}{%
%                  \l_tmpa_num |
%                  \l_tmpb_num |
%                  \l_tmpc_num |
%                  \g_tmpa_num |
%                  \g_tmpb_num |
% }
% Scratch register for immediate use. They are not used by conditionals
% or predicate functions.
% \end{variable}
%
% \StopEventually{}
%
% \section{Implementation}
%
%
%    We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<package&!check>\RequirePackage{l3prg}\par
%<package&check>\RequirePackage{l3chk}\par
%<*initex|package>
%    \end{macrocode}
%
% Functions that support \LaTeX's user accessible counters should be
% added here, too. But first the internal counters.
%
% \begin{macro}{\num_incr:N}
% \begin{macro}{\num_decr:N}
% \begin{macro}{\num_gincr:N}
% \begin{macro}{\num_gdecr:N}
%    Incrementing and decrementing of integer registers is done with
%    the following functions.
%    \begin{macrocode}
\def:Npn \num_incr:N #1{\num_add:Nn#1 1}
\def:Npn \num_decr:N #1{\num_add:Nn#1 {-1}}
\def:Npn \num_gincr:N #1{\num_gadd:Nn#1 1}
\def:Npn \num_gdecr:N #1{\num_gadd:Nn#1 {-1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\num_incr:c}
% \begin{macro}{\num_decr:c}
% \begin{macro}{\num_gincr:c}
% \begin{macro}{\num_gdecr:c}
%    We also need \ldots
%    \begin{macrocode}
\def_new:Npn \num_incr:c {\exp_args:Nc \num_incr:N}
\def_new:Npn \num_decr:c {\exp_args:Nc \num_decr:N}
\def_new:Npn \num_gincr:c {\exp_args:Nc \num_gincr:N}
\def_new:Npn \num_gdecr:c {\exp_args:Nc \num_gdecr:N}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\num_zero:N}
% \begin{macro}{\num_zero:c}
% \begin{macro}{\num_gzero:N}
% \begin{macro}{\num_gzero:c}
%    We also need \ldots
%    \begin{macrocode}
\def_new:Npn \num_zero:N #1 {\num_set:Nn #1 0}
\def_new:Npn \num_gzero:N #1 {\num_gset:Nn #1 0}
\def_new:Npn \num_zero:c {\exp_args:Nc \num_zero:N}
\def_new:Npn \num_gzero:c {\exp_args:Nc \num_gzero:N}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\num_new:N}
% \begin{macro}{\num_new:c}
%    Allocate a new \m{num} variable and initialize it with zero.
%    \begin{macrocode}
\def_new:Npn \num_new:N #1{\tlp_new:Nn #1{0}}
\def_new:Npn \num_new:c {\exp_args:Nc \num_new:N}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\num_eval:n}
% This function enables us to do all the operations without the aid of
% an \m{int} register.
%    \begin{macrocode}
\def_new:Npn \num_eval:n #1{\etex_numexpr:D #1\scan_stop:}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\num_set:Nn}
% \begin{macro}{\num_set:cn}
% \begin{macro}{\num_gset:Nn}
% \begin{macro}{\num_gset:cn}
% Assigning values to \m{num} registers.
%    \begin{macrocode}
\def_new:Npn \num_set:Nn #1#2{
  \tlp_set:No #1{ \tex_number:D \num_eval:n {#2} }
}
\def_new:Npn \num_gset:Nn {\pref_global:D \num_set:Nn}
\def_new:Npn \num_set:cn {\exp_args:Nc \num_set:Nn }
\def_new:Npn \num_gset:cn {\exp_args:Nc \num_gset:Nn }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\num_set_eq:NN}
% \begin{macro}{\num_set_eq:cN}
% \begin{macro}{\num_set_eq:Nc}
% \begin{macro}{\num_set_eq:cc}
% Setting \m{num} registers equal to each other.
%    \begin{macrocode}
\let_new:NN \num_set_eq:NN \tlp_set_eq:NN
\def_new:Npn \num_set_eq:cN {\exp_args:Nc \num_set_eq:NN}
\def_new:Npn \num_set_eq:Nc {\exp_args:NNc \num_set_eq:NN}
\def_new:Npn \num_set_eq:cc {\exp_args:Ncc \num_set_eq:NN}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\num_gset_eq:NN}
% \begin{macro}{\num_gset_eq:cN}
% \begin{macro}{\num_gset_eq:Nc}
% \begin{macro}{\num_gset_eq:cc}
% Setting \m{num} registers equal to each other.
%    \begin{macrocode}
\let_new:NN \num_gset_eq:NN \tlp_gset_eq:NN
\def_new:Npn \num_gset_eq:cN {\exp_args:Nc \num_gset_eq:NN}
\def_new:Npn \num_gset_eq:Nc {\exp_args:NNc \num_gset_eq:NN}
\def_new:Npn \num_gset_eq:cc {\exp_args:Ncc \num_gset_eq:NN}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\num_add:Nn}
% \begin{macro}{\num_gadd:Nn}
% Adding is easily done as the second argument goes through
% |\num_eval:n|.
%    \begin{macrocode}
\def_new:Npn \num_add:Nn #1#2 {\num_set:Nn #1{#1+#2}}
\def_new:Npn \num_gadd:Nn {\pref_global:D \num_add:Nn}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\num_use:N}
% \begin{macro}{\num_use:c}
%    Here is how num macros are accessed:
%    \begin{macrocode}
\let_new:NN\num_use:N \use_arg_i:n
\let_new:NN\num_use:c \use:c
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\num_compare:nNnTF}
% \begin{macro}{\num_compare:nNnT}
% \begin{macro}{\num_compare:nNnF}
% Simple comparison tests.
%    \begin{macrocode}
\def_new:Npn \num_compare:nNnTF #1#2#3{
  \if_num:w \num_eval:n {#1}#2\num_eval:n {#3}
    \exp_after:NN \use_arg_i:nn
  \else:
    \exp_after:NN \use_arg_ii:nn
  \fi:
}
\def_new:Npn \num_compare:nNnT #1#2#3{
  \if_num:w \num_eval:n {#1}#2\num_eval:n {#3}
    \exp_after:NN \use_arg_ii:nn
  \fi:
  \use_none:n
}
\def_new:Npn \num_compare:nNnF #1#2#3{
  \if_num:w \num_eval:n {#1}#2\num_eval:n {#3}
    \exp_after:NN \use_none:n
  \else:
    \exp_after:NN \use_arg_i:n
  \fi:
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\num_compare_p:nNn}
% A predicate function.
%    \begin{macrocode}
\def_new:Npn \num_compare_p:nNn #1#2#3{
  \if_num:w \num_eval:n {#1}#2\num_eval:n {#3}
    \c_true
  \else:
    \c_false
  \fi:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_tmpa_num}
% \begin{macro}{\l_tmpb_num}
% \begin{macro}{\l_tmpc_num}
% \begin{macro}{\g_tmpa_num}
% \begin{macro}{\g_tmpb_num}
%    We provide an number local and two global \m{num}s, maybe we
%    need more or less.
%    \begin{macrocode}
\num_new:N \l_tmpa_num
\num_new:N \l_tmpb_num
\num_new:N \l_tmpc_num
\num_new:N \g_tmpa_num
\num_new:N \g_tmpb_num
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%  \subsection{Defining constants}
%  As stated, most constants can be defined as |\tex_chardef:D| or
%  |\tex_mathchardef:D| but that's engine dependent. Omega/Aleph
%  allows |\tex_chardef:D|s up to 65535 which is also the maximum
%  number of registers of all types.
%  \begin{macro}{\const_new:Nn}
%  \begin{macro}{\c_max_register_int}
%  \begin{macro}{\const_new_aux:Nw}
%    \begin{macrocode}
%    \begin{macrocode}
\engine_aleph:TF
{
  \let_new:NN \const_new_aux:Nw \tex_chardef:D
  \const_new_aux:Nw \c_max_register_int = 65535 \scan_stop:
}
{
  \let_new:NN \const_new_aux:Nw \tex_mathchardef:D
  \const_new_aux:Nw \c_max_register_int = 32767 \scan_stop:
}
\def_new:Npn \const_new:Nn #1#2 {
  \num_compare:nNnTF  {#2} > \c_minus_one
  {
    \num_compare:nNnTF {#2}<\c_max_register_int
    {\chk_new_cs:N #1 \const_new_aux:Nw #1 = #2 \scan_stop: }
    {\int_new:N #1 \int_set:Nn #1{#2}}
  }
  {\int_new:N #1 \int_set:Nn #1{#2}}
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}{\c_minus_one}
% \begin{macro}{\c_zero}
% \begin{macro}{\c_one}
% \begin{macro}{\c_two}
% \begin{macro}{\c_three}
% \begin{macro}{\c_four}
% \begin{macro}{\c_six}
% \begin{macro}{\c_seven}
% \begin{macro}{\c_sixteen}
% \begin{macro}{\c_thirty_two}
% \begin{macro}{\c_hundred_one}
% \begin{macro}{\c_twohundred_fifty_five}
% \begin{macro}{\c_twohundred_fifty_six}
% \begin{macro}{\c_thousand}
% \begin{macro}{\c_ten_thousand}
% \begin{macro}{\c_ten_thousand_one}
% \begin{macro}{\c_ten_thousand_two}
% \begin{macro}{\c_ten_thousand_three}
% \begin{macro}{\c_ten_thousand_four}
% \begin{macro}{\c_twenty_thousand}
%    And the usual constants, others are still missing. Please, make
%    every constant a real constant at least for the moment. We can
%    easily convert things in the end when we have found what
%    constants are used in critical places and what not.
%    \begin{macrocode}
 %% \tex_countdef:D \c_minus_one = 10 \scan_stop:
 %% \c_minus_one = -1 \scan_stop:        %% in l3basics
 %% \tex_chardef:D \c_sixteen    = 16\scan_stop: %% in l3basics
\const_new:Nn \c_zero {0}
\const_new:Nn \c_one {1}
\const_new:Nn \c_two {2}
\const_new:Nn \c_three {3}
\const_new:Nn \c_four  {4}
\const_new:Nn \c_six   {6}
\const_new:Nn \c_seven {7}
\const_new:Nn \c_thirty_two {32}
%    \end{macrocode}
% The next one may seem a little odd (obviously!) but is useful when
% dealing with logical operators.
%    \begin{macrocode}
\const_new:Nn \c_hundred_one          {101}
\const_new:Nn \c_twohundred_fifty_five {255}
\const_new:Nn \c_twohundred_fifty_six {256}
\const_new:Nn \c_thousand             {1000}
\const_new:Nn \c_ten_thousand         {10000}
\const_new:Nn \c_ten_thousand_one     {10001}
\const_new:Nn \c_ten_thousand_two     {10002}
\const_new:Nn \c_ten_thousand_three   {10003}
\const_new:Nn \c_ten_thousand_four    {10004}
\const_new:Nn \c_twenty_thousand      {20000}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}

%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \endinput
%
% $Log$
% Revision 1.8  2005/03/26 21:06:35  morten
% Update documentation
%
% Revision 1.7  2005/03/22 23:21:32  morten
% Now independent of l3int and can be used as a very primitive module.
%
% Revision 1.6  2005/03/16 22:36:20  braams
% Added the tweaks necessary to be able to load with initex
%
% Revision 1.5  2005/03/11 21:39:47  braams
% Fixed the use of RCS information; added \StopEventually
%
