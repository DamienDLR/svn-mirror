% \iffalse
%% File: l3fp.dtx Copyright (C) 2010 LaTeX3 project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``expl3 bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%<*driver|package>
\RequirePackage{l3names}
%</driver|package>
%\fi
\GetIdInfo$Id$
  {L3 Experimental floating-point operations}
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{l3fp.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{l3fp} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Key--value support}
% \author{\Team}
% \date{\filedate}
% \maketitle
%
%\begin{documentation}
%
%\section{Floating point variables}
%
% Floating point numbers are stored in the \texttt{fp} floating
% point variable type. This has a standard range of functions for
% variable management.
%
%\begin{function}{ 
%  \fp_new:N  |
%  \fp_new:c  |
%}
%  \begin{syntax}
%    \cs{fp_new:N} \meta{floating point}
%  \end{syntax}
%  Creates a new \meta{floating point} or raises an error if the
%  name is already taken. The declaration global. The 
%  \meta{floating point} will initially be set to \( 0.0 \).
%\end{function}
%
%\begin{function}{ 
%  \fp_set_eq:NN |
%  \fp_set_eq:cN |
%  \fp_set_eq:Nc |
%  \fp_set_eq:cc |
%}
%  \begin{syntax}
%    \cs{fp_set_eq:NN} \meta{fp1} \meta{fp2}
%  \end{syntax}
%  Sets the value of \meta{floating point1} equal to that of
%  \meta{floating point2}. This assignment is restricted to the 
%  current \TeX\ group level.
%\end{function}
%
%\begin{function}{ 
%  \fp_gset_eq:NN |
%  \fp_gset_eq:cN |
%  \fp_gset_eq:Nc |
%  \fp_gset_eq:cc |
%}
%  \begin{syntax}
%    \cs{tl_gset_eq:NN} \meta{tl var1} \meta{tl var2}
%  \end{syntax}
%  Sets the value of \meta{floating point1} equal to that of
%  \meta{floating point2}. This assignment is global and so is
%  not limited by the current \TeX\ group level.
%\end{function}
%
%\begin{function}{ 
%  \fp_zero:N  |
%  \fp_zero:c  |
%}
%  \begin{syntax}
%    \cs{fp_zero:N} \meta{floating point}
%  \end{syntax}
%  Sets the \meta{floating point} to \( 0.0 \) within the current scope.
%\end{function}
%
%\begin{function}{ 
%  \fp_gzero:N  |
%  \fp_gzero:c  |
%}
%  \begin{syntax}
%    \cs{fp_gzero:N} \meta{floating point}
%  \end{syntax}
%  Sets the \meta{floating point} to \( 0.0 \) globally.
%\end{function}
%
%\begin{function}{ 
%  \fp_set:Nn |
%  \fp_set:cn |
%}
%  \begin{syntax}
%    \cs{fp_set:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Sets the \meta{floating point} variable to \meta{value} within
%  the scope of the current \TeX\ group.
%\end{function}
%
%\begin{function}{ 
%  \fp_gset:Nn |
%  \fp_gset:cn |
%}
%  \begin{syntax}
%    \cs{fp_gset:Nn} \meta{floating poin} \Arg{value}
%  \end{syntax}
%  Sets the \meta{floating point} variable to \meta{value} globally.
%\end{function} 
%
%\begin{function}{ 
%  \fp_set_from_dim:Nn |
%  \fp_set_from_dim:cn |
%}
%  \begin{syntax}
%    \cs{fp_set_from_dim:Nn} \meta{floating point} \Arg{dimexpr}
%  \end{syntax}
%  Sets the \meta{floating point} variable to the distance represented
%  by the \meta{dimension expression} in the units points. This means
%  that distances given in other units are first converted to points
%  before being assigned to the \meta{floating point}. The assignment
%  is local.
%\end{function}
%
%\begin{function}{ 
%  \fp_gset_from_dim:Nn |
%  \fp_gset_from_dim:cn |
%}
%  \begin{syntax}
%    \cs{fp_gset_from_dim:Nn} \meta{floating point} \Arg{dimexpr}
%  \end{syntax}
%  Sets the \meta{floating point} variable to the distance represented
%  by the \meta{dimension expression} in the units points. This means
%  that distances given in other units are first converted to points
%  before being assigned to the \meta{floating point}. The assignment
%  is global.
%\end{function}
%
%\begin{function}{
%  \fp_show:N |
%  \fp_show:c |
%}
%  \begin{syntax}
%    \cs{fp_show:N} \meta{floating point}
%  \end{syntax}
%  Displays the content of the \meta{floating point} on the
%  terminal.
%\end{function}
%
%\subsection{Arithmetic}
%
%\begin{function}{
%  \fp_add:Nn |
%  \fp_add:cn |
%}
%  \begin{syntax}
%    \cs{fp_add:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Adds the \meta{value} to the \meta{floating point}, making the
%  assignment within the current \TeX\ group level.
%\end{function}
%
%\begin{function}{
%  \fp_gadd:Nn |
%  \fp_gadd:cn |
%}
%  \begin{syntax}
%    \cs{fp_gadd:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Adds the \meta{value} to the \meta{floating point}, making the
%  assignment globally.
%\end{function}
%
%\begin{function}{
%  \fp_sub:Nn |
%  \fp_sub:cn |
%}
%  \begin{syntax}
%    \cs{fp_sub:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Subtracts the \meta{value} from the \meta{floating point}, making the
%  assignment within the current \TeX\ group level.
%\end{function}
%
%\begin{function}{
%  \fp_gsub:Nn |
%  \fp_gsub:cn |
%}
%  \begin{syntax}
%    \cs{fp_gsub:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Subtracts the \meta{value} from the \meta{floating point}, making the
%  assignment globally.
%\end{function}
%
%\end{documentation}
%
%\begin{implementation}
%
%\section{Implementation}
% 
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%    
%\subsection{General variables}
%    
%\begin{macro}{\l_fp_input_a_integer_int}
%\begin{macro}{\l_fp_input_a_decimal_int}
%\begin{macro}{\l_fp_input_b_integer_int}
%\begin{macro}{\l_fp_input_b_decimal_int}
% Storage for the input, divided into integer and decimal parts.
%    \begin{macrocode}
\int_new:N \l_fp_input_a_integer_int
\int_new:N \l_fp_input_a_decimal_int
\int_new:N \l_fp_input_b_integer_int
\int_new:N \l_fp_input_b_decimal_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_fp_input_a_sign_int}
%\begin{macro}{\l_fp_input_b_sign_int}
% The sign of each item in the input is stored as an \texttt{int} as
% this allows some faster manipulation than would otherwise be possible.
%    \begin{macrocode}
\int_new:N \l_fp_input_a_sign_int
\int_new:N \l_fp_input_b_sign_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_fp_output_sign_int}
%\begin{macro}{\l_fp_output_integer_int}
%\begin{macro}{\l_fp_output_decimal_int}
% Output is stored in the same way as input.
%    \begin{macrocode}
\int_new:N \l_fp_output_sign_int
\int_new:N \l_fp_output_integer_int
\int_new:N \l_fp_output_decimal_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_fp_output_sign_tl}
% There are some places where the output sign has to be built without
% using \TeX.
%    \begin{macrocode}
\tl_new:N \l_fp_output_sign_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_fp_tmp_int}
% A scratch \texttt{int}: used only where the value is not carried
% forward.
%    \begin{macrocode}
\int_new:N \l_fp_tmp_int
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_fp_tmp_tl}
% The usual scratch token list.
%    \begin{macrocode}
\tl_new:N \l_fp_tmp_tl
%    \end{macrocode}
%\end{macro}
%
%\subsection{Operations for \texttt{fp} variables}
%
%\begin{macro}{\fp_new:N}
%\begin{macro}{\fp_new:c}
% Floating points always have a value, and of course this has to be
% initialised globally.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_new:N #1 {
  \tl_new:N #1
  \tl_gset:Nn #1 { 0.0 }
}
\cs_generate_variant:Nn \fp_new:N { c }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\fp_zero:N}
%\begin{macro}{\fp_zero:c}
%\begin{macro}{\fp_gzero:N}
%\begin{macro}{\fp_gzero:c}
% Zeroing floating points is pretty obvious.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_zero:N #1 {
  \tl_set:Nn #1 { 0.0 }
}
\cs_new_protected_nopar:Npn \fp_gzero:N #1 {
  \tl_gset:Nn #1 { 0.0 }
}
\cs_generate_variant:Nn \fp_zero:N { c }
\cs_generate_variant:Nn \fp_gzero:N { c }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\fp_set:Nn}
%\begin{macro}{\fp_set:cn}
%\begin{macro}{\fp_gset:Nn}
%\begin{macro}{\fp_gset:cn} 
%\begin{macro}[aux]{\fp_set_aux:NNn} 
% To trap any input errors, a very simple version of the parser is run
% here. This will pick up any invalid characters at this stage, saving
% issues later. The splitting approach is the same as the more 
% advanced function later.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_set:Nn {
  \fp_set_aux:NNn \tl_set:Nn 
}
\cs_new_protected_nopar:Npn \fp_gset:Nn {
  \fp_set_aux:NNn \tl_gset:Nn 
}
\cs_new_protected_nopar:Npn \fp_set_aux:NNn #1#2#3 {
  \group_begin:
    \fp_split:Nn a {#3}
    \int_add:Nn \l_fp_input_a_decimal_int { 1000000000 }
    \tex_multiply:D \l_fp_input_a_integer_int \l_fp_input_a_sign_int
    \tl_set:Nx \l_fp_tmp_tl
      {
        \int_use:N \l_fp_input_a_integer_int
        .
        \tex_expandafter:D \use_none:n 
          \tex_the:D \l_fp_output_decimal_int
      }
  \tex_expandafter:D \group_end: \tex_expandafter:D 
  #1 \tex_expandafter:D #2 \tex_expandafter:D { \l_fp_tmp_tl }
}
\cs_generate_variant:Nn \fp_set:Nn  { c }
\cs_generate_variant:Nn \fp_gset:Nn { c }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\fp_set_from_dim:Nn}
%\begin{macro}{\fp_set_from_dim:cn}
%\begin{macro}{\fp_gset_from_dim:Nn}
%\begin{macro}{\fp_gset_from_dim:cn} 
%\begin{macro}[aux]{\fp_set_from_dim_aux:NNn} 
%\begin{macro}[aux]{\fp_set_from_dim_aux:w} 
%\begin{macro}{\l_fp_tmp_dim}
% Here, dimensions are converted to floating points \emph{via} a
% temporary variable. This ensures that they always convert as points.
% Things are coded for speed, hence the awkward \cs{tex_expandafter:D}
% chain.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_set_from_dim:Nn {
  \fp_set_from_dim_aux:NNn \tl_set:Nx 
}
\cs_new_protected_nopar:Npn \fp_gset_from_dim:Nn {
  \fp_set_from_dim_aux:NNn \tl_gset:Nx 
}
\cs_new_protected_nopar:Npn \fp_set_from_dim_aux:NNn #1#2#3 {
  \group_begin:
    \l_fp_tmp_dim \etex_dimexpr:D #3 \scan_stop:    
  \tex_expandafter:D \group_end: \tex_expandafter:D
  #1 \tex_expandafter:D #2 \tex_expandafter:D 
    { 
      \tex_expandafter:D \fp_set_from_dim_aux:w 
        \tex_the:D \l_fp_tmp_dim \q_stop 
    }
}
\cs_set_protected_nopar:Npx \fp_set_from_dim_aux:w {
  \cs_set_nopar:Npn \exp_not:N \fp_set_from_dim_aux:w 
    ##1 \tl_to_str:n { pt } \exp_not:N \q_stop {##1}
}
\fp_set_from_dim_aux:w
\cs_generate_variant:Nn \fp_set_from_dim:Nn  { c }
\cs_generate_variant:Nn \fp_gset_from_dim:Nn { c }
\dim_new:N \l_fp_tmp_dim
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\fp_set_eq:NN}
%\begin{macro}{\fp_set_eq:cN}
%\begin{macro}{\fp_set_eq:Nc}
%\begin{macro}{\fp_set_eq:cc}
%\begin{macro}{\fp_gset_eq:NN}
%\begin{macro}{\fp_gset_eq:cN}
%\begin{macro}{\fp_gset_eq:Nc}
%\begin{macro}{\fp_gset_eq:cc}
% Pretty simple, really.
%    \begin{macrocode}
\cs_new_eq:NN \fp_set_eq:NN  \tl_set_eq:NN
\cs_new_eq:NN \fp_set_eq:cN  \tl_set_eq:cN
\cs_new_eq:NN \fp_set_eq:Nc  \tl_set_eq:Nc
\cs_new_eq:NN \fp_set_eq:cc  \tl_set_eq:cc
\cs_new_eq:NN \fp_gset_eq:NN \tl_gset_eq:NN
\cs_new_eq:NN \fp_gset_eq:cN \tl_gset_eq:cN
\cs_new_eq:NN \fp_gset_eq:Nc \tl_gset_eq:Nc
\cs_new_eq:NN \fp_gset_eq:cc \tl_gset_eq:cc
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\fp_show:N}
%\begin{macro}{\fp_show:c}
% Simple showing of the underlying variable.
%    \begin{macrocode}
\cs_new_eq:NN \fp_show:N \tl_show:N
\cs_new_eq:NN \fp_show:c \tl_show:c
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\fp_use:N}
%\begin{macro}{\fp_use:c}
% These are token lists, so this is easy.
%    \begin{macrocode}
\cs_new_eq:NN \fp_use:N \tl_use:N
\cs_new_eq:NN \fp_use:c \tl_use:c
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsection{Internal utilities}
%
%\begin{macro}{\fp_split:Nn}
%\begin{macro}[aux]{\fp_split_aux:w}
%\begin{macro}[aux]{\fp_split_decimal:w}
%\begin{macro}[aux]{\fp_split_decimal_aux:w}
% The aim here is to use as much of \TeX's mechanism as possible to pick
% up the numerical input without any mistakes. In particular, negative
% numbers have to be filtered out first in case the integer part is
% \( 0 \) (in which case \TeX\ would drop the "-" sign). After that 
% case is dealt with, the next step is to pick up the integer
% part. The auxiliary \cs{fp_split_aux:w} can then be triggered by
% the decimal sign (as \TeX\ will assign the integer part when it 
% reaches this). There is then some clearing up to make sure that the
% decimal part is zero-filled on the right as appropriate.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_split:Nn #1#2 {
  \tl_set:Nx \l_fp_tmp_tl {#2}
  \tex_ifnum:D \pdf_strcmp:D 
    { \tex_expandafter:D \tl_head:w \l_fp_tmp_tl ? \q_stop } { - } 
      = 0 \scan_stop:
    \tl_set:Nx \l_fp_tmp_tl
      { 
        \tex_expandafter:D 
          \tl_tail:w \l_fp_tmp_tl \prg_do_nothing: \q_stop 
      }
    \use:c { l_fp_input_ #1 _sign_int } -1 \scan_stop:  
  \tex_else:D 
    \use:c { l_fp_input_ #1 _sign_int } 1 \scan_stop:
  \tex_fi:D    
  \tex_afterassignment:D \fp_split_aux:w 
  \use:c { l_fp_input_ #1 _integer_int } 
    \etex_numexpr:D 0 \l_fp_tmp_tl . . \q_stop #1
}
\cs_new_protected_nopar:Npn \fp_split_aux:w #1 . #2 . #3 \q_stop {
  \l_fp_tmp_int 0 #2 \scan_stop:
  \tex_expandafter:D \fp_split_decimal:w 
    \tex_the:D \l_fp_tmp_int 00000000 \q_stop
}
\cs_new_protected_nopar:Npn \fp_split_decimal:w #1#2#3#4#5#6#7#8#9 {
  \fp_split_decimal_aux:w {#1#2#3#4#5#6#7#8#9}
}
\cs_new_protected_nopar:Npn \fp_split_decimal_aux:w #1#2 \q_stop #3 {
  \use:c { l_fp_input_ #3 _decimal_int } #1 \scan_stop:
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%  
%\begin{macro}{\fp_add:Nn}
%\begin{macro}{\fp_add:cn}
%\begin{macro}{\fp_gadd:Nn}
%\begin{macro}{\fp_gadd:cn}
%\begin{macro}{\fp_add:Nnn}
%\begin{macro}{\fp_add:cnn}
%\begin{macro}{\fp_gadd:Nnn}
%\begin{macro}{\fp_gadd:cnn}
% The various addition functions are simply different ways to call the
% single master function below. This pattern is repeated for the
% other arithmetic functions.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_add:Nn #1 {
  \fp_add:NNnn \tl_set:Nn #1 #1
}
\cs_new_protected_nopar:Npn \fp_gadd:Nn #1 {
  \fp_add:NNnn \tl_gset:Nn #1 #1
}
\cs_new_protected_nopar:Npn \fp_add:Nnn {
  \fp_add:NNnn \tl_set:Nn
}
\cs_new_protected_nopar:Npn \fp_gadd:Nnn {
  \fp_add:NNnn \tl_gset:Nn
}
\cs_generate_variant:Nn \fp_add:Nn   { c }
\cs_generate_variant:Nn \fp_gadd:Nn  { c }
\cs_generate_variant:Nn \fp_add:Nnn  { c }
\cs_generate_variant:Nn \fp_gadd:Nnn { c }
%    \end{macrocode}
%\end{macro} 
%\end{macro}
%\end{macro} 
%\end{macro} 
%\end{macro} 
%\end{macro} 
%\end{macro} 
%\end{macro} 
%
%\begin{macro}{\fp_add:NNnn}
%\begin{macro}[aux]{\fp_add_core:}
% The strategy for addition is as follows. After splitting the input
% into parts, the sign on the input is used to set up the integer and
% decimal parts appropriately. There is then some very simple addition
% before correcting for a negative decimal part. The decimal part
% is then padded so that it will come out correctly when printed.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_add:NNnn #1#2#3#4 {
  \group_begin:
    \fp_split:Nn a {#3}
    \fp_split:Nn b {#4}
    \fp_add_core:
  \tex_expandafter:D \group_end: \tex_expandafter:D
  #1 \tex_expandafter:D #2 \tex_expandafter:D { \l_fp_tmp_tl }
}
\cs_new_protected_nopar:Npn \fp_add_core: {
  \tex_ifnum:D \l_fp_input_a_sign_int < 0 \scan_stop:
    \l_fp_input_a_integer_int -\l_fp_input_a_integer_int
    \l_fp_input_a_decimal_int -\l_fp_input_a_decimal_int
  \tex_fi:D
  \tex_ifnum:D \l_fp_input_b_sign_int < 0 \scan_stop:
    \l_fp_input_b_integer_int -\l_fp_input_b_integer_int
    \l_fp_input_b_decimal_int -\l_fp_input_b_decimal_int
  \tex_fi:D
  \l_fp_output_integer_int \l_fp_input_a_integer_int
  \tex_advance:D \l_fp_output_integer_int \l_fp_input_b_integer_int
  \l_fp_output_decimal_int \l_fp_input_a_decimal_int
  \tex_advance:D \l_fp_output_decimal_int \l_fp_input_b_decimal_int
  \tex_ifnum:D \l_fp_output_integer_int = 0 \scan_stop:
    \tex_ifnum:D \l_fp_output_decimal_int < 0 \scan_stop:
      \tl_set:Nn \l_fp_output_sign_tl { - }
    \tex_else:D
      \tl_clear:N \l_fp_output_sign_tl
    \tex_fi:D
  \tex_else:D
    \tl_clear:N \l_fp_output_sign_tl
  \tex_fi:D
  \tex_ifnum:D \l_fp_output_decimal_int < 0 \scan_stop:
    \l_fp_output_decimal_int -\l_fp_output_decimal_int \scan_stop:
  \tex_fi:D
  \tex_ifnum:D \l_fp_output_decimal_int > 999999999 \scan_stop:
    \tex_ifnum:D \l_fp_input_b_sign_int > 0
      \tex_advance:D \l_fp_output_integer_int 1 \scan_stop:
    \tex_else:D
      \tex_advance:D \l_fp_output_integer_int -1 \scan_stop:
    \tex_fi:D
  \tex_else:D
    \int_add:Nn \l_fp_output_decimal_int { 1000000000 }
  \tex_fi:D
  \tl_set:Nx \l_fp_tmp_tl
    {
      \l_fp_output_sign_tl
      \int_use:N \l_fp_output_integer_int
      .
      \tex_expandafter:D \use_none:n 
        \tex_the:D \l_fp_output_decimal_int
    }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\fp_sub:Nn}
%\begin{macro}{\fp_sub:cn}
%\begin{macro}{\fp_gsub:Nn}
%\begin{macro}{\fp_gsub:cn}
%\begin{macro}{\fp_sub:Nnn}
%\begin{macro}{\fp_sub:cnn}
%\begin{macro}{\fp_gsub:Nnn}
%\begin{macro}{\fp_gsub:cnn}
% Subtraction is essentially the same as addition, but with the sign
% of the second component reversed. Thus the core of the two function 
% groups is the same, with just a little set up here.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_sub:Nn #1 {
  \fp_sub:NNnn \tl_set:Nn #1 #1
}
\cs_new_protected_nopar:Npn \fp_gsub:Nn #1 {
  \fp_sub:NNnn \tl_gset:Nn #1 #1
}
\cs_new_protected_nopar:Npn \fp_sub:Nnn {
  \fp_sub:NNnn \tl_set:Nn
}
\cs_new_protected_nopar:Npn \fp_gsub:Nnn {
  \fp_sub:NNnn \tl_gset:Nn
}
\cs_generate_variant:Nn \fp_sub:Nn   { c }
\cs_generate_variant:Nn \fp_gsub:Nn  { c }
\cs_generate_variant:Nn \fp_sub:Nnn  { c }
\cs_generate_variant:Nn \fp_gsub:Nnn { c }
\cs_new_protected_nopar:Npn \fp_sub:NNnn #1#2#3#4 {
  \group_begin:
    \fp_split:Nn a {#3}
    \fp_split:Nn b {#4}
    \tex_multiply:D \l_fp_input_b_sign_int -1 \scan_stop:
    \fp_add_core:
  \tex_expandafter:D \group_end: \tex_expandafter:D
  #1 \tex_expandafter:D #2 \tex_expandafter:D { \l_fp_tmp_tl }
}
%    \end{macrocode}
%\end{macro} 
%\end{macro}
%\end{macro} 
%\end{macro} 
%\end{macro} 
%\end{macro} 
%\end{macro} 
%\end{macro} 
% 
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
%\end{implementation}
%
%\PrintChanges
%
%\PrintIndex