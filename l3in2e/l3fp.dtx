% \iffalse
%% File: l3fp.dtx Copyright (C) 2010-2011 LaTeX3 project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``expl3 bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%<*driver|package>
\RequirePackage{l3names}
%</driver|package>
%\fi
\GetIdInfo$Id$
  {L3 Experimental floating-point operations}
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass[full,checktest]{l3doc}
\begin{document}
  \DocInput{l3fp.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{l3fp} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Floating point arithmetic}
% \author{\Team}
% \date{\filedate}
% \maketitle
%
%\begin{documentation}
%
%\section{Floating point numbers}
%
% A floating point number is one which is stored as a mantissa and
% a separate exponent. This module implements arithmetic using radix 
% \( 10 \) floating point numbers. This means that the mantissa should
% be a real number in the range \( 1 \le \expandafter\mathopen\string| 
% x \expandafter\mathclose\string| < 10 \), with the 
% exponent given as an integer between \( -99 \) and \( 99 \). In the
% input, the exponent part is represented starting with an \texttt{e}.
% As this is a low-level module, error-checking is minimal. Numbers 
% which are too large for the floating point unit to handle will result
% in errors, either from \TeX\ or from \LaTeX. The \LaTeX\ code does not 
% check that the input will not overflow, hence the possibility of a 
% \TeX\ error. On the other hand, numbers which are too small will be 
% dropped, which will mean that extra decimal digits will simply be 
% lost.
% 
% When parsing numbers, any missing parts will be interpreted as 
% zero. So for example
%\begin{verbatim}
%  \fp_set:Nn \l_my_fp { }
%  \fp_set:Nn \l_my_fp { . }
%  \fp_set:Nn \l_my_fp { - }
%\end{verbatim} 
% will all be interpreted as zero values without raising an error.
% 
% Operations which give an undefined result (such as division by
% \( 0 \)) will not lead to errors. Instead special marker values are 
% returned, which can be tested for using fr example 
% \cs{fp_if_undefined:N(TF)}. In this way it is possible to work with
% asymptotic functions without first checking the input. If these
% special values are carried forward in calculations they will be
% treated as \( 0 \).
% 
% Floating point numbers are stored in the \texttt{fp} floating point 
% variable type. This has a standard range of functions for
% variable management.
% 
%\subsection{Constants}
%
%\begin{variable}{ \c_e_fp }
% The value of the base of natural numbers, \( \mathrm{e} \).
%\end{variable}
%
%\begin{variable}{ \c_one_fp }
% A floating point variable with permanent value \( 1 \): used for 
% speeding up some comparisons.
%\end{variable}
%
%\begin{variable}{ \c_pi_fp }
% The value of \( \pi \).
%\end{variable}
%
%\begin{variable}{ \c_undefined_fp }
% A special marker floating point variable representing the result of
% an operation which does not give a defined result (such as division
% by \( 0 \)).
%\end{variable}
% 
%\begin{variable}{ \c_zero_fp }
% A permanently zero floating point variable.
%\end{variable}
% 
%\subsection{Floating-point variables}
% 
%\begin{function}{ 
%  \fp_new:N |
%  \fp_new:c |
%}
%  \begin{syntax}
%    \cs{fp_new:N} \meta{floating point variable}
%  \end{syntax}
%  Creates a new \meta{floating point variable} or raises an error if
%  the name is already taken. The declaration global. The 
%  \meta{floating point} will initially be set to  "+0.000000000e0"
%  (the zero floating point).
%\end{function}
%
%\begin{function}{ 
%  \fp_const:Nn |
%  \fp_const:cn |
%}
%  \begin{syntax}
%    \cs{fp_const:Nn} \meta{floating point variable} \Arg{value}
%  \end{syntax}
%  Creates a new constant \meta{floating point variable} or raises an 
%  error  if the name is already taken. The value of the 
%  \meta{floating point variable} will be set globally to the 
%  \meta{value}.
%\end{function}
%
%\begin{function}{ 
%  \fp_set_eq:NN |
%  \fp_set_eq:cN |
%  \fp_set_eq:Nc |
%  \fp_set_eq:cc |
%}
%  \begin{syntax}
%    \cs{fp_set_eq:NN} \meta{fp var1} \meta{fp var2}
%  \end{syntax}
%  Sets the value of \meta{floating point variable1} equal to that of
%  \meta{floating point variable2}. This assignment is restricted to the 
%  current \TeX\ group level.
%\end{function}
%
%\begin{function}{ 
%  \fp_gset_eq:NN |
%  \fp_gset_eq:cN |
%  \fp_gset_eq:Nc |
%  \fp_gset_eq:cc |
%}
%  \begin{syntax}
%    \cs{fp_gset_eq:NN} \meta{fp var1} \meta{fp var2}
%  \end{syntax}
%  Sets the value of \meta{floating point variable1} equal to that of
%  \meta{floating point variable2}. This assignment is global and so is
%  not limited by the current \TeX\ group level.
%\end{function}
%
%\begin{function}{ 
%  \fp_zero:N  |
%  \fp_zero:c  |
%}
%  \begin{syntax}
%    \cs{fp_zero:N} \meta{floating point variable}
%  \end{syntax}
%  Sets the \meta{floating point variable} to "+0.000000000e0" within 
%  the current scope.
%\end{function}
%
%\begin{function}{ 
%  \fp_gzero:N  |
%  \fp_gzero:c  |
%}
%  \begin{syntax}
%    \cs{fp_gzero:N} \meta{floating point variable}
%  \end{syntax}
%  Sets the \meta{floating point variable} to "+0.000000000e0" globally.
%\end{function}
%
%\begin{function}{ 
%  \fp_set:Nn |
%  \fp_set:cn |
%}
%  \begin{syntax}
%    \cs{fp_set:Nn} \meta{floating point variable} \Arg{value}
%  \end{syntax}
%  Sets the \meta{floating point variable} variable to \meta{value} 
%  within the scope of the current \TeX\ group.
%\end{function}
%
%\begin{function}{ 
%  \fp_gset:Nn |
%  \fp_gset:cn |
%}
%  \begin{syntax}
%    \cs{fp_gset:Nn} \meta{floating point variable} \Arg{value}
%  \end{syntax}
%  Sets the \meta{floating point variable} variable to \meta{value} 
%  globally.
%\end{function} 
%
%\begin{function}{ 
%  \fp_set_from_dim:Nn |
%  \fp_set_from_dim:cn |
%}
%  \begin{syntax}
%    \cs{fp_set_from_dim:Nn} \meta{floating point variable} \Arg{dimexpr}
%  \end{syntax}
%  Sets the \meta{floating point variable} to the distance represented
%  by the \meta{dimension expression} in the units points. This means
%  that distances given in other units are first converted to points
%  before being assigned to the \meta{floating point variable}. The 
%  assignment is local.
%\end{function}
%
%\begin{function}{ 
%  \fp_gset_from_dim:Nn |
%  \fp_gset_from_dim:cn |
%}
%  \begin{syntax}
%    \cs{fp_gset_from_dim:Nn} \meta{floating point variable} \Arg{dimexpr}
%  \end{syntax}
%  Sets the \meta{floating point variable} to the distance represented
%  by the \meta{dimension expression} in the units points. This means
%  that distances given in other units are first converted to points
%  before being assigned to the \meta{floating point variable}. The 
%  assignment is global.
%\end{function}
%
%\begin{function}{
%  \fp_use:N / (EXP) |
%  \fp_use:c / (EXP) |
%}
%  \begin{syntax}
%    \cs{fp_use:N} \meta{floating point variable}
%  \end{syntax}
%  Inserts the value of the \meta{floating point variable} into the
%  input stream. The value will be given as a real number without any
%  exponent part, and will always include a decimal point. For example,
%  \begin{verbatim}
%    \fp_new:Nn \test
%    \fp_set:Nn \test { 1.234 e 5 }
%    \fp_use:N \test
%  \end{verbatim}
%  will insert `\texttt{12345.00000}' into the input stream.
%  As illustrated, a floating point will always be inserted with ten
%  significant digits given. Very large and very small values will 
%  include additional zeros for place value.
%\end{function}
%
%\begin{function}{
%  \fp_show:N |
%  \fp_show:c |
%}
%  \begin{syntax}
%    \cs{fp_show:N} \meta{floating point variable}
%  \end{syntax}
%  Displays the content of the \meta{floating point variable} on the
%  terminal.
%\end{function}
%
%\subsection{Conversion to other formats}
%
% It is useful to be able to convert floating point variables to 
% other forms. These functions are expandable, so that the material
% can be used in a variety of contexts. The \cs{fp_use:N} function 
% should also be consulted in this context, as it will insert the
% value of the floating point variable as a real number.
% 
%\begin{function}{
%  \fp_to_dim:N / (EXP) |
%  \fp_to_dim:c / (EXP) |
%}
%  \begin{syntax}
%    \cs{fp_to_dim:N} \meta{floating point variable}
%  \end{syntax}
%  Inserts the value of the \meta{floating point variable}
%  into the input stream converted into a dimension in points.
%\end{function}
%
%\begin{function}{
%  \fp_to_int:N / (EXP) |
%  \fp_to_int:c / (EXP) |
%}
%  \begin{syntax}
%    \cs{fp_to_int:N} \meta{floating point variable}
%  \end{syntax}
%  Inserts the integer value of the \meta{floating point variable}
%  into the input stream. The decimal part of the number will not be
%  included, but will be used to round the integer.
%\end{function}
%
%\begin{function}{
%  \fp_to_tl:N / (EXP) |
%  \fp_to_tl:c / (EXP) |
%}
%  \begin{syntax}
%    \cs{fp_to_tl:N} \meta{floating point variable}
%  \end{syntax}
%  Inserts a representation of the \meta{floating point variable} into
%  the input stream as a token list. The representation follows the
%  conventions of a pocket calculator:
%  \begin{center}
%    \ttfamily
%    \begin{tabular}{r@{.}lr@{.}l}
%      \toprule
%        \multicolumn{2}{l}{\rmfamily{Floating point value}} & 
%        \multicolumn{2}{l}{\rmfamily{Representation}} \\
%      \midrule
%         1 & 234000000000e0  &  1 & 234    \\
%        -1 & 234000000000e0  & -1 & 234    \\
%         1 & 234000000000e3  &  \multicolumn{2}{l}{1234} \\
%         1 & 234000000000e13 &  \multicolumn{2}{l}{1234e13} \\
%         1 & 234000000000e-1 & 0 & 1234   \\
%         1 & 234000000000e-2 & 0 & 01234  \\
%         1 & 234000000000e-3 & 1 & 234e-3 \\
%      \bottomrule
%    \end{tabular}
%  \end{center}
%  Notice that trailing zeros are removed in this process, and that 
%  numbers which do not require a decimal part do \emph{not} include
%  a decimal marker.
%\end{function}
%
%\subsection{Rounding floating point values}
%
% The module can round floating point values to either decimal places
% or significant figures using the usual method in which exact halves
% are rounded up.
%
%\begin{function}{
%  \fp_round_figures:Nn |
%  \fp_round_figures:cn |
%}
%  \begin{syntax}
%    \cs{fp_round_figures:Nn} \meta{floating point variable} \Arg{target}
%  \end{syntax}
%  Rounds the \meta{floating point variable} to the \meta{target} number
%  of significant figures (an integer expression). The rounding is 
%  carried out locally.
%\end{function}
%
%\begin{function}{
%  \fp_ground_figures:Nn |
%  \fp_ground_figures:cn |
%}
%  \begin{syntax}
%    \cs{fp_ground_figures:Nn} \meta{floating point variable} \Arg{target}
%  \end{syntax}
%  Rounds the \meta{floating point variable} to the \meta{target} number
%  of significant figures (an integer expression). The rounding is 
%  carried out globally.
%\end{function}
%
%\begin{function}{
%  \fp_round_places:Nn |
%  \fp_round_places:cn |
%}
%  \begin{syntax}
%    \cs{fp_round_places:Nn} \meta{floating point variable} \Arg{target}
%  \end{syntax}
%  Rounds the \meta{floating point variable} to the \meta{target} number
%  of decimal places (an integer expression). The rounding is 
%  carried out locally.
%\end{function}
%
%\begin{function}{
%  \fp_ground_places:Nn |
%  \fp_ground_places:cn |
%}
%  \begin{syntax}
%    \cs{fp_ground_places:Nn} \meta{floating point variable} \Arg{target}
%  \end{syntax}
%  Rounds the \meta{floating point variable} to the \meta{target} number
%  of decimal places (an integer expression). The rounding is 
%  carried out globally.
%\end{function}
%
%\subsection{Tests on floating-point values}
%
%\begin{function}{ 
%  \fp_if_undefined_p:N / (EXP)      |
%  \fp_if_undefined:N   / (EXP) (TF) |
%}
%  \begin{syntax}
%    \cs{fp_if_undefined_p:N} \meta{fixed-point}
%    \cs{fp_if_undefined:NTF} \meta{fixed-point} 
%    ~~\Arg{true code} \Arg{false code}
%  \end{syntax}
%  Tests if \meta{floating point} is undefined (\emph{i.e}.~equal to the
%  special \cs{c_undefined_fp} variable). The branching versions then
%  leave either \meta{true code} or \meta{false code} in the input 
%  stream, as appropriate to the truth of the test and the variant of 
%  the function chosen. The logical truth of the test is left in the 
%  input stream by the predicate version. 
%\end{function}
%
%\begin{function}{ 
%  \fp_if_zero_p:N / (EXP)      |
%  \fp_if_zero:N   / (EXP) (TF) |
%}
%  \begin{syntax}
%    \cs{fp_if_zero_p:N} \meta{fixed-point}
%    \cs{fp_if_zero:NTF} \meta{fixed-point} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Tests if \meta{floating point} is equal to zero (\emph{i.e}.~equal to 
%  the special \cs{c_zero_fp} variable). The branching versions then 
%  leave either \meta{true code} or \meta{false code} in the input 
%  stream, as appropriate to the truth of the test and the variant of 
%  the function chosen. The logical truth of the test is left in the 
%  input stream by the predicate version. 
%\end{function}
%
%\begin{function}{ \fp_compare:nNn / (TF) }
%  \begin{syntax}
%    \cs{fp_compare:nNnTF} 
%    ~~\Arg{floating point1} \meta{relation} \Arg{floating point2}
%    ~~\Arg{true code} \Arg{false code}
%  \end{syntax}
%  This function compared the two \meta{floating point} values, which
%  may be stored as \texttt{fp} variables, using the \meta{relation}:
%  \begin{center}
%    \begin{tabular}{ll}
%      Equal                 & "=" \\
%      Greater than          & ">" \\
%      Less than             & "<" \\
%    \end{tabular}
%  \end{center}
%  Either \meta{true code} or \meta{false code} is then left in the 
%  input stream, as appropriate to the truth of the test and the variant
%  of the function chosen. The tests treat undefined floating points as
%  zero as the comparison is intended for real numbers only.
%\end{function}
%
%\subsection{Unary operations}
%
% The unary operations alter the value stored within an \texttt{fp}
% variable.
%
%\begin{function}{
%  \fp_abs:N |
%  \fp_abs:c |
%}
%  \begin{syntax}
%    \cs{fp_abs:N} \meta{floating point variable} 
%  \end{syntax}
%  Converts the \meta{floating point variable} to its absolute value, 
%  assigning the result within the current \TeX\ group.
%\end{function}
%
%\begin{function}{
%  \fp_gabs:N |
%  \fp_gabs:c |
%}
%  \begin{syntax}
%    \cs{fp_gabs:N} \meta{floating point variable} 
%  \end{syntax}
%  Converts the \meta{floating point variable} to its absolute value, 
%  assigning the result globally.
%\end{function}
%
%\begin{function}{
%  \fp_neg:N |
%  \fp_neg:c |
%}
%  \begin{syntax}
%    \cs{fp_neg:N} \meta{floating point variable} 
%  \end{syntax}
%  Reverse the sign of the \meta{floating point variable}, assigning the 
%  result within the current \TeX\ group.
%\end{function}
%
%\begin{function}{
%  \fp_gneg:N |
%  \fp_gneg:c |
%}
%  \begin{syntax}
%    \cs{fp_gneg:N} \meta{floating point variable} 
%  \end{syntax}
%  Reverse the sign of the \meta{floating point variable}, assigning the 
%  result globally.
%\end{function}
%
%\subsection{Arithmetic operations}
%
% Binary arithmetic operations act on the value stored in an 
% \texttt{fp}, so for example
%\begin{verbatim}
%  \fp_set:Nn \l_my_fp { 1.234 }
%  \fp_sub:Nn \l_my_fp { 5.678 }
%\end{verbatim}
% sets \cs{l_my_fp} to the result of \( 1.234 - 5.678 \) 
% (\emph{i.e}.~\( -4.444 \)).
%
%\begin{function}{
%  \fp_add:Nn |
%  \fp_add:cn |
%}
%  \begin{syntax}
%    \cs{fp_add:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Adds the \meta{value} to the \meta{floating point}, making the
%  assignment within the current \TeX\ group level.
%\end{function}
%
%\begin{function}{
%  \fp_gadd:Nn |
%  \fp_gadd:cn |
%}
%  \begin{syntax}
%    \cs{fp_gadd:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Adds the \meta{value} to the \meta{floating point}, making the
%  assignment globally.
%\end{function}
%
%\begin{function}{
%  \fp_sub:Nn |
%  \fp_sub:cn |
%}
%  \begin{syntax}
%    \cs{fp_sub:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Subtracts the \meta{value} from the \meta{floating point}, making the
%  assignment within the current \TeX\ group level.
%\end{function}
%
%\begin{function}{
%  \fp_gsub:Nn |
%  \fp_gsub:cn |
%}
%  \begin{syntax}
%    \cs{fp_gsub:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Subtracts the \meta{value} from the \meta{floating point}, making the
%  assignment globally.
%\end{function}
%
%\begin{function}{
%  \fp_mul:Nn |
%  \fp_mul:cn |
%}
%  \begin{syntax}
%    \cs{fp_mul:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Multiples the \meta{floating point} by the \meta{value}, making the
%  assignment within the current \TeX\ group level.
%\end{function}
%
%\begin{function}{
%  \fp_gmul:Nn |
%  \fp_gmul:cn |
%}
%  \begin{syntax}
%    \cs{fp_gmul:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Multiples the \meta{floating point} by the \meta{value}, making the
%  assignment globally.
%\end{function}
%
%\begin{function}{
%  \fp_div:Nn |
%  \fp_div:cn |
%}
%  \begin{syntax}
%    \cs{fp_div:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Divides the \meta{floating point} by the \meta{value}, making the
%  assignment within the current \TeX\ group level. If the \meta{value}
%  is zero, the \meta{floating point} will be set to 
%  \cs{c_undefined_fp}.The assignment is local.
%\end{function}
%
%\begin{function}{
%  \fp_gdiv:Nn |
%  \fp_gdiv:cn |
%}
%  \begin{syntax}
%    \cs{fp_gdiv:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Divides the \meta{floating point} by the \meta{value}, making the
%  assignment globally. If the \meta{value} is zero, the 
%  \meta{floating point} will be set to \cs{c_undefined_fp}.
%  The assignment is global.
%\end{function}
%
%\subsection{Power operations}
%
%\begin{function}{
%  \fp_pow:Nn |
%  \fp_pow:cn |
%}
%  \begin{syntax}
%    \cs{fp_pow:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Raises the \meta{floating point} to the given \meta{value}, which
%  should be a positive real number or a negative integer. 
%  Mathematically invalid operations such as \( 0^{0} \) will give
%  set the \meta{floating point} to  to \cs{c_undefined_fp}. The
%  assignment is local.
%\end{function}
%
%\begin{function}{
%  \fp_gpow:Nn |
%  \fp_gpow:cn |
%}
%  \begin{syntax}
%    \cs{fp_gpow:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Raises the \meta{floating point} to the given \meta{value}, which
%  should be a positive real number or a negative integer. 
%  Mathematically invalid operations such as \( 0^{0} \) will give
%  set the \meta{floating point} to  to \cs{c_undefined_fp}. The
%  assignment is global.
%\end{function}
%
%\subsection{Exponential and logarithm functions}
%
%\begin{function}{
%  \fp_exp:Nn |
%  \fp_exp:cn |
%}
%  \begin{syntax}
%    \cs{fp_exp:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Calculates the exponential of the \meta{value} and assigns this
%  to the \meta{floating point}. The assignment is local.
%\end{function}
%
%\begin{function}{
%  \fp_gexp:Nn |
%  \fp_gexp:cn |
%}
%  \begin{syntax}
%    \cs{fp_gexp:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Calculates the exponential of the \meta{value} and assigns this
%  to the \meta{floating point}. The assignment is global.
%\end{function}
%
%\begin{function}{
%  \fp_ln:Nn |
%  \fp_ln:cn |
%}
%  \begin{syntax}
%    \cs{fp_ln:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Calculates the natural logarithm of the \meta{value} and assigns
%  this to the \meta{floating point}. The assignment is local.
%\end{function}
%
%\begin{function}{
%  \fp_gln:Nn |
%  \fp_gln:cn |
%}
%  \begin{syntax}
%    \cs{fp_gln:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Calculates the natural logarithm of the \meta{value} and assigns 
%  this to the \meta{floating point}. The assignment is global.
%\end{function}
%
%\subsection{Trigonometric functions}
%
% The trigonometric functions all work in radians. They accept a maximum
% input value of \( 100\,000\,000 \), as there are issues with range 
% reduction and very large input values.
% 
%\begin{function}{
%  \fp_sin:Nn |
%  \fp_sin:cn |
%}
%  \begin{syntax}
%    \cs{fp_sin:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Assigns the sine of the \meta{value} to the \meta{floating point}.
%  The \meta{value} should be given in radians. The assignment is 
%  local.
%\end{function}
%
%\begin{function}{
%  \fp_gsin:Nn |
%  \fp_gsin:cn |
%}
%  \begin{syntax}
%    \cs{fp_gsin:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Assigns the sine of the \meta{value} to the \meta{floating point}.
%  The \meta{value} should be given in radians. The assignment is 
%  global.
%\end{function}
%
%\begin{function}{
%  \fp_cos:Nn |
%  \fp_cos:cn |
%}
%  \begin{syntax}
%    \cs{fp_cos:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Assigns the cosine of the \meta{value} to the \meta{floating point}.
%  The \meta{value} should be given in radians. The assignment is 
%  local.
%\end{function}
%
%\begin{function}{
%  \fp_gcos:Nn |
%  \fp_gcos:cn |
%}
%  \begin{syntax}
%    \cs{fp_gcos:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Assigns the cosine of the \meta{value} to the \meta{floating point}.
%  The \meta{value} should be given in radians. The assignment is 
%  global.
%\end{function}
%
%\begin{function}{
%  \fp_tan:Nn |
%  \fp_tan:cn |
%}
%  \begin{syntax}
%    \cs{fp_tan:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Assigns the tangent of the \meta{value} to the \meta{floating point}.
%  The \meta{value} should be given in radians. The assignment is 
%  local. 
%\end{function}
%
%\begin{function}{
%  \fp_gtan:Nn |
%  \fp_gtan:cn |
%}
%  \begin{syntax}
%    \cs{fp_gtan:Nn} \meta{floating point} \Arg{value}
%  \end{syntax}
%  Assigns the tangent of the \meta{value} to the \meta{floating point}.
%  The \meta{value} should be given in radians. The assignment is 
%  global.
%\end{function}
%
%\subsection{Notes on the floating point unit}
%
% As calculation of the elemental transcendental functions is
% computationally expensive compared to storage of results, after
% calculating a trigonometric function, exponent, \emph{etc}.~the module
% stored the result for reuse. Thus the performance of the module for
% repeated operations, most probably trigonometric functions, should be
% much higher than if the values were re-calculated every time they
% were needed.
%
% Anyone with experience of programming floating point calculations will
% know that this is a complex area. The aim of the unit is to be 
% accurate enough for the likely applications in a typesetting context. 
% The arithmetic operations are therefore intended to provide ten digit
% accuracy with the last digit accurate to \( \pm 1 \). The elemental 
% transcendental functions may not provide such high accuracy in every 
% case, although the design aim has been to provide \( 10 \) digit
% accuracy for cases likely to be relevant in typesetting situations.
% A good overview of the challenges in this area can be found in
% J.-M.~Muller, \emph{Elementary functions: algorithms and 
% implementation}, 2nd edition, Birkh{\"a}uer Boston, New York, USA,
% 2006.
% 
% The internal representation of numbers is tuned to the needs of the
% underlying \TeX\ system. This means that the format is somewhat
% different from that used in, for example, computer floating point
% units. Programming in \TeX\ makes it most convenient to use a 
% radix \( 10 \) system, using \TeX\ \texttt{count} registers for
% storage and taking advantage where possible of delimited arguments.
%  
%\end{documentation}
%
%\begin{implementation}
%
%\section{Implementation}
%
% \TestFiles{m3fp003.lvt}
% 
%    We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
\package_check_loaded_expl:
%</package>
%<*initex|package>
%    \end{macrocode}
%    
%\subsection{Constants}
%
%\begin{macro}[aux]{\c_forty_four}
%\begin{macro}[aux]{\c_one_hundred}
%\begin{macro}[aux]{\c_one_thousand}
%\begin{macro}[aux]{\c_one_million}
%\begin{macro}[aux]{\c_one_hundred_million}
%\begin{macro}[aux]{\c_five_hundred_million}
%\begin{macro}[aux]{\c_one_thousand_million}
% There is some speed to gain by moving numbers into fixed positions.
%    \begin{macrocode}
\int_const:Nn \c_forty_four { 44 }
\int_const:Nn \c_one_hundred { 100 }
\int_const:Nn \c_one_thousand { 1000 }
\int_const:Nn \c_one_million { 1 000 000 }
\int_const:Nn \c_one_hundred_million { 100 000 000 }
\int_const:Nn \c_five_hundred_million { 500 000 000 }
\int_const:Nn \c_one_thousand_million { 1 000 000 000 }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[aux]{\c_fp_pi_by_four_decimal_int}
%\begin{macro}[aux]{\c_fp_pi_by_four_extended_int}
%\begin{macro}[aux]{\c_fp_pi_decimal_int}
%\begin{macro}[aux]{\c_fp_pi_extended_int}
%\begin{macro}[aux]{\c_fp_two_pi_decimal_int}
%\begin{macro}[aux]{\c_fp_two_pi_extended_int}
% Parts of \( \pi \) for trigonometric range reduction, implemented
% as \texttt{int} variables for speed.
%    \begin{macrocode}
\int_new:N  \c_fp_pi_by_four_decimal_int
\int_set:Nn \c_fp_pi_by_four_decimal_int { 785 398 158 }
\int_new:N  \c_fp_pi_by_four_extended_int
\int_set:Nn \c_fp_pi_by_four_extended_int { 897 448 310 }
\int_new:N  \c_fp_pi_decimal_int
\int_set:Nn \c_fp_pi_decimal_int { 141 592 653 }
\int_new:N  \c_fp_pi_extended_int
\int_set:Nn \c_fp_pi_extended_int { 589 793 238 }
\int_new:N  \c_fp_two_pi_decimal_int
\int_set:Nn \c_fp_two_pi_decimal_int { 283 185 307 }
\int_new:N  \c_fp_two_pi_extended_int
\int_set:Nn \c_fp_two_pi_extended_int { 179 586 477 }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\c_e_fp}
% The value \( \mathrm{e} \) as a `machine number'.
%    \begin{macrocode}
\tl_new:N \c_e_fp
\tl_set:Nn \c_e_fp { + 2.718281828 e 0 }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\c_one_fp}
% The constant value \( 1 \): used for fast comparisons.
%    \begin{macrocode}
\tl_new:N \c_one_fp 
\tl_set:Nn \c_one_fp { + 1.000000000 e 0 }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\c_pi_fp}
% The value \( \pi \) as a `machine number'.
%    \begin{macrocode}
\tl_new:N \c_pi_fp
\tl_set:Nn \c_pi_fp { + 3.141592654 e 0 }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\c_undefined_fp}
% A marker for undefined values.
%    \begin{macrocode}
\tl_new:N \c_undefined_fp
\tl_set:Nn \c_undefined_fp { X 0.000000000 e 0 }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\c_zero_fp}
% The constant zero value.
%    \begin{macrocode}
\tl_new:N \c_zero_fp
\tl_set:Nn \c_zero_fp { + 0.000000000 e 0 }
%    \end{macrocode}
%\end{macro}
%
%\subsection{Variables}
%
%\begin{macro}[aux]{\l_fp_arg_tl}
% A token list to store the formalised representation of the input
% for transcendental functions.
%    \begin{macrocode}
\tl_new:N \l_fp_arg_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_count_int}
% A counter for things like the number of divisions possible.
%    \begin{macrocode}
\int_new:N \l_fp_count_int 
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_div_offset_int}
% When carrying out division, an offset is used for the results to 
% get the decimal part correct.
%    \begin{macrocode}
\int_new:N \l_fp_div_offset_int
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_exp_integer_int}
%\begin{macro}[aux]{\l_fp_exp_decimal_int}
%\begin{macro}[aux]{\l_fp_exp_extended_int}
%\begin{macro}[aux]{\l_fp_exp_exponent_int}
% Used for the calculation of exponent values.
%    \begin{macrocode}
\int_new:N \l_fp_exp_integer_int
\int_new:N \l_fp_exp_decimal_int
\int_new:N \l_fp_exp_extended_int
\int_new:N \l_fp_exp_exponent_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_input_a_sign_int}
%\begin{macro}[aux]{\l_fp_input_a_integer_int}
%\begin{macro}[aux]{\l_fp_input_a_decimal_int}
%\begin{macro}[aux]{\l_fp_input_a_exponent_int}
%\begin{macro}[aux]{\l_fp_input_b_sign_int}
%\begin{macro}[aux]{\l_fp_input_b_integer_int}
%\begin{macro}[aux]{\l_fp_input_b_decimal_int}
%\begin{macro}[aux]{\l_fp_input_b_exponent_int}
% Storage for the input: two storage areas as there are at most two
% inputs.
%    \begin{macrocode}
\int_new:N \l_fp_input_a_sign_int
\int_new:N \l_fp_input_a_integer_int
\int_new:N \l_fp_input_a_decimal_int
\int_new:N \l_fp_input_a_exponent_int
\int_new:N \l_fp_input_b_sign_int
\int_new:N \l_fp_input_b_integer_int
\int_new:N \l_fp_input_b_decimal_int
\int_new:N \l_fp_input_b_exponent_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_input_a_extended_int}
%\begin{macro}[aux]{\l_fp_input_b_extended_int}
% For internal use, `extended' floating point numbers are 
% needed.
%    \begin{macrocode}
\int_new:N \l_fp_input_a_extended_int
\int_new:N \l_fp_input_b_extended_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_mul_a_i_int}
%\begin{macro}[aux]{\l_fp_mul_a_ii_int}
%\begin{macro}[aux]{\l_fp_mul_a_iii_int}
%\begin{macro}[aux]{\l_fp_mul_a_iv_int}
%\begin{macro}[aux]{\l_fp_mul_a_v_int}
%\begin{macro}[aux]{\l_fp_mul_a_vi_int}
%\begin{macro}[aux]{\l_fp_mul_b_i_int}
%\begin{macro}[aux]{\l_fp_mul_b_ii_int}
%\begin{macro}[aux]{\l_fp_mul_b_iii_int}
%\begin{macro}[aux]{\l_fp_mul_b_iv_int}
%\begin{macro}[aux]{\l_fp_mul_b_v_int}
%\begin{macro}[aux]{\l_fp_mul_b_vi_int}
% Multiplication requires that the decimal part is split into parts
% so that there are no overflows. 
%    \begin{macrocode}
\int_new:N \l_fp_mul_a_i_int
\int_new:N \l_fp_mul_a_ii_int
\int_new:N \l_fp_mul_a_iii_int
\int_new:N \l_fp_mul_a_iv_int
\int_new:N \l_fp_mul_a_v_int
\int_new:N \l_fp_mul_a_vi_int
\int_new:N \l_fp_mul_b_i_int
\int_new:N \l_fp_mul_b_ii_int
\int_new:N \l_fp_mul_b_iii_int
\int_new:N \l_fp_mul_b_iv_int
\int_new:N \l_fp_mul_b_v_int
\int_new:N \l_fp_mul_b_vi_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_mul_output_int}
%\begin{macro}[aux]{\l_fp_mul_output_tl}
% Space for multiplication results.
%    \begin{macrocode}
\int_new:N \l_fp_mul_output_int
\tl_new:N  \l_fp_mul_output_tl
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_output_sign_int}
%\begin{macro}[aux]{\l_fp_output_integer_int}
%\begin{macro}[aux]{\l_fp_output_decimal_int}
%\begin{macro}[aux]{\l_fp_output_exponent_int}
% Output is stored in the same way as input.
%    \begin{macrocode}
\int_new:N \l_fp_output_sign_int
\int_new:N \l_fp_output_integer_int
\int_new:N \l_fp_output_decimal_int
\int_new:N \l_fp_output_exponent_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_output_extended_int}
% Again, for calculations an extended part.
%    \begin{macrocode}
\int_new:N \l_fp_output_extended_int
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_round_carry_bool}
% To indicate that a digit needs to be carried forward.
%    \begin{macrocode}
\bool_new:N \l_fp_round_carry_bool
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_round_decimal_tl}
% A temporary store when rounding, to build up the decimal part without
% needing to do any maths.
%    \begin{macrocode}
\tl_new:N \l_fp_round_decimal_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_round_position_int}
%\begin{macro}[aux]{\l_fp_round_target_int}
% Used to check the position for rounding.
%    \begin{macrocode}
\int_new:N \l_fp_round_position_int
\int_new:N \l_fp_round_target_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_sign_tl}
% There are places where the sign needs to be set up `early',
% so that the registers can be re-used.
%    \begin{macrocode}
\tl_new:N \l_fp_sign_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_split_sign_int}
% When splitting the input it is fastest to use a fixed name for the 
% sign part, and to transfer it after the split is complete.
%    \begin{macrocode}
\int_new:N \l_fp_split_sign_int
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_tmp_int}
% A scratch \texttt{int}: used only where the value is not carried
% forward.
%    \begin{macrocode}
\int_new:N \l_fp_tmp_int
%    \end{macrocode}
%\end{macro}
%    
%\begin{macro}[aux]{\l_fp_tmp_tl}
% A scratch token list variable for expanding material.
%    \begin{macrocode}
\tl_new:N \l_fp_tmp_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_trig_octant_int}
% To track which octant the trigonometric input is in.
%    \begin{macrocode}
\int_new:N \l_fp_trig_octant_int
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[aux]{\l_fp_trig_sign_int}
%\begin{macro}[aux]{\l_fp_trig_decimal_int}
%\begin{macro}[aux]{\l_fp_trig_extended_int}
% Used for the calculation of trigonometric values.
%    \begin{macrocode}
\int_new:N \l_fp_trig_sign_int
\int_new:N \l_fp_trig_decimal_int
\int_new:N \l_fp_trig_extended_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\subsection{Parsing numbers}
%
%\begin{macro}{\fp_read:N}
%\begin{macro}[aux]{\fp_read_aux:w}
% Reading a stored value is made easier as the format is designed to
% match the delimited function. This is always used to read the first
% value (register "a").
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_read:N #1 {
  \tex_expandafter:D \fp_read_aux:w #1 \q_stop
}
\cs_new_protected_nopar:Npn \fp_read_aux:w #1#2 . #3 e #4 \q_stop {
  \tex_if:D #1 -
    \l_fp_input_a_sign_int \c_minus_one
  \tex_else:D
    \l_fp_input_a_sign_int \c_one
  \tex_fi:D
  \l_fp_input_a_integer_int  #2 \scan_stop:
  \l_fp_input_a_decimal_int  #3 \scan_stop:
  \l_fp_input_a_exponent_int #4 \scan_stop:
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%    
%\begin{macro}{\fp_split:Nn}
%\begin{macro}[aux]{\fp_split_sign:}
%\begin{macro}[aux]{\fp_split_exponent:}
%\begin{macro}[aux]{\fp_split_aux_i:w}
%\begin{macro}[aux]{\fp_split_aux_ii:w}
%\begin{macro}[aux]{\fp_split_aux_iii:w}
%\begin{macro}[aux]{\fp_split_decimal:w}
%\begin{macro}[aux]{\fp_split_decimal_aux:w}
% The aim here is to use as much of \TeX's mechanism as possible to pick
% up the numerical input without any mistakes. In particular, negative
% numbers have to be filtered out first in case the integer part is
% \( 0 \) (in which case \TeX\ would drop the "-" sign). That process
% has to be done in a loop for cases where the sign is repeated. 
% Finding an exponent is relatively easy, after which the next phase is 
% to find the integer part, which will terminate with a ".", and trigger 
% the decimal-finding code. The later will allow the decimal to be too 
% long, truncating the result.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_split:Nn #1#2 {
  \tl_set:Nx \l_fp_tmp_tl {#2}
  \tl_set_rescan:Nno \l_fp_tmp_tl { \char_make_ignore:n { 32 } }
    { \l_fp_tmp_tl }
  \l_fp_split_sign_int \c_one
  \fp_split_sign:
  \use:c { l_fp_input_ #1 _sign_int } \l_fp_split_sign_int
  \tex_expandafter:D \fp_split_exponent:w \l_fp_tmp_tl e e \q_stop #1
}
\cs_new_protected_nopar:Npn \fp_split_sign: {
  \tex_ifnum:D \pdf_strcmp:D 
    { \tex_expandafter:D \tl_head:w \l_fp_tmp_tl ? \q_stop } { - } 
      = \c_zero
    \tl_set:Nx \l_fp_tmp_tl
      { 
        \tex_expandafter:D 
          \tl_tail:w \l_fp_tmp_tl \prg_do_nothing: \q_stop 
      }
    \l_fp_split_sign_int -\l_fp_split_sign_int 
    \tex_expandafter:D \fp_split_sign:
  \tex_else:D 
    \tex_ifnum:D \pdf_strcmp:D 
      { \tex_expandafter:D \tl_head:w \l_fp_tmp_tl ? \q_stop } { + } 
        = \c_zero
      \tl_set:Nx \l_fp_tmp_tl
        { 
          \tex_expandafter:D 
            \tl_tail:w \l_fp_tmp_tl \prg_do_nothing: \q_stop 
        }
      \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
        \fp_split_sign:  
     \tex_fi:D   
  \tex_fi:D  
}
\cs_new_protected_nopar:Npn 
  \fp_split_exponent:w #1 e #2 e #3 \q_stop #4 {
  \use:c { l_fp_input_ #4 _exponent_int } 
    \etex_numexpr:D 0 #2 \scan_stop:
  \tex_afterassignment:D \fp_split_aux_i:w 
  \use:c { l_fp_input_ #4 _integer_int } 
    \etex_numexpr:D 0 #1 . . \q_stop #4 
}
\cs_new_protected_nopar:Npn \fp_split_aux_i:w #1 . #2 . #3 \q_stop {
  \fp_split_aux_ii:w #2 000000000 \q_stop
}
\cs_new_protected_nopar:Npn \fp_split_aux_ii:w #1#2#3#4#5#6#7#8#9 {
  \fp_split_aux_iii:w {#1#2#3#4#5#6#7#8#9}
}
\cs_new_protected_nopar:Npn \fp_split_aux_iii:w #1#2 \q_stop {
  \l_fp_tmp_int 1 #1 \scan_stop:
  \tex_expandafter:D \fp_split_decimal:w 
    \int_use:N \l_fp_tmp_int 000000000 \q_stop
}
\cs_new_protected_nopar:Npn \fp_split_decimal:w #1#2#3#4#5#6#7#8#9 {
  \fp_split_decimal_aux:w {#2#3#4#5#6#7#8#9}
}
\cs_new_protected_nopar:Npn \fp_split_decimal_aux:w #1#2#3 \q_stop #4 {
  \use:c { l_fp_input_ #4 _decimal_int } #1#2 \scan_stop:
  \tex_ifnum:D
    \etex_numexpr:D 
      \use:c { l_fp_input_ #4 _integer_int } +
      \use:c { l_fp_input_ #4 _decimal_int }
    \scan_stop:
      = \c_zero 
    \use:c { l_fp_input_ #4 _sign_int } \c_one  
  \tex_fi:D  
  \tex_ifnum:D 
    \use:c { l_fp_input_ #4 _integer_int } < \c_one_thousand_million
  \tex_else:D
    \tex_expandafter:D \fp_overflow_msg:
  \tex_fi:D  
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\fp_standardise:NNNN}
%\begin{macro}[aux]{\fp_standardise_aux:NNNN}
%\begin{macro}[aux]{\fp_standardise_aux:}
%\begin{macro}[aux]{\fp_standardise_aux:w}
% The idea here is to shift the input into a known exponent range. This
% is done using \TeX\ tokens where possible, as this is faster than
% arithmetic.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_standardise:NNNN #1#2#3#4 {
  \tex_ifnum:D 
    \etex_numexpr:D #2 + #3 = \c_zero
    #1 \c_one
    #4 \c_zero
    \tex_expandafter:D \use_none:nnnn
  \tex_else:D
    \tex_expandafter:D \fp_standardise_aux:NNNN
  \tex_fi:D
  #1#2#3#4
}
\cs_new_protected_nopar:Npn \fp_standardise_aux:NNNN #1#2#3#4 {
  \cs_set_protected_nopar:Npn \fp_standardise_aux:
    {
      \tex_ifnum:D #2 = \c_zero
        \tex_advance:D #3 \c_one_thousand_million
        \tex_expandafter:D \fp_standardise_aux:w
          \int_use:N #3 \q_stop
         \tex_expandafter:D \fp_standardise_aux:
       \tex_fi:D
    }
  \cs_set_protected_nopar:Npn 
    \fp_standardise_aux:w ##1##2##3##4##5##6##7##8##9 \q_stop
    {
      #2 ##2 \scan_stop:
      #3 ##3##4##5##6##7##8##9 0 \scan_stop:
      \tex_advance:D #4 \c_minus_one 
    }
  \fp_standardise_aux:
  \cs_set_protected_nopar:Npn \fp_standardise_aux:
    {
      \tex_ifnum:D #2 > \c_nine
        \tex_advance:D #2 \c_one_thousand_million
        \tex_expandafter:D \use_i:nn \tex_expandafter:D 
          \fp_standardise_aux:w \int_use:N #2
         \tex_expandafter:D \fp_standardise_aux:
       \tex_fi:D
    } 
  \cs_set_protected_nopar:Npn 
    \fp_standardise_aux:w ##1##2##3##4##5##6##7##8##9
    {
      #2 ##1##2##3##4##5##6##7##8 \scan_stop:
      \tex_advance:D #3 \c_one_thousand_million
      \tex_divide:D #3 \c_ten
      \tl_set:Nx \l_fp_tmp_tl
        {
          ##9
          \tex_expandafter:D \use_none:n \int_use:N #3
        }
      #3 \l_fp_tmp_tl \scan_stop:  
      \tex_advance:D #4 \c_one 
    }
  \fp_standardise_aux:
  \tex_ifnum:D #4 < \c_one_hundred
    \tex_ifnum:D #4 > -\c_one_hundred
    \tex_else:D
      #1 \c_one
      #2 \c_zero
      #3 \c_zero
      #4 \c_zero
    \tex_fi:D
  \tex_else:D
    \tex_expandafter:D \fp_overflow_msg:
  \tex_fi:D  
}
\cs_new_protected_nopar:Npn \fp_standardise_aux: { }
\cs_new_protected_nopar:Npn \fp_standardise_aux:w { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\subsection{Internal utilities}
%
%\begin{macro}{\fp_level_input_exponents:}
%\begin{macro}[aux]{\fp_level_input_exponents_a:}
%\begin{macro}[aux]{\fp_level_input_exponents_a:NNNNNNNNN}
%\begin{macro}[aux]{\fp_level_input_exponents_b:}
%\begin{macro}[aux]{\fp_level_input_exponents_b:NNNNNNNNN}
% The routines here are similar to those used to standardise the 
% exponent. However, the aim here is different: the two exponents need
% to end up the same.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_level_input_exponents: {
  \tex_ifnum:D \l_fp_input_a_exponent_int > \l_fp_input_b_exponent_int
    \tex_expandafter:D \fp_level_input_exponents_a:
  \tex_else:D
    \tex_expandafter:D \fp_level_input_exponents_b:
  \tex_fi:D
}
\cs_new_protected_nopar:Npn \fp_level_input_exponents_a: {
  \tex_ifnum:D \l_fp_input_a_exponent_int > \l_fp_input_b_exponent_int
    \tex_advance:D \l_fp_input_b_integer_int \c_one_thousand_million
    \tex_expandafter:D \use_i:nn \tex_expandafter:D
      \fp_level_input_exponents_a:NNNNNNNNN 
        \int_use:N \l_fp_input_b_integer_int
    \tex_expandafter:D \fp_level_input_exponents_a:
  \tex_fi:D
}
\cs_new_protected_nopar:Npn 
  \fp_level_input_exponents_a:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  \l_fp_input_b_integer_int #1#2#3#4#5#6#7#8 \scan_stop:
  \tex_advance:D \l_fp_input_b_decimal_int \c_one_thousand_million
  \tex_divide:D \l_fp_input_b_decimal_int \c_ten
  \tl_set:Nx \l_fp_tmp_tl
    {
      #9 
      \tex_expandafter:D \use_none:n 
        \int_use:N \l_fp_input_b_decimal_int
    }
  \l_fp_input_b_decimal_int \l_fp_tmp_tl \scan_stop:  
  \tex_advance:D \l_fp_input_b_exponent_int \c_one
}
\cs_new_protected_nopar:Npn \fp_level_input_exponents_b: {
  \tex_ifnum:D \l_fp_input_b_exponent_int > \l_fp_input_a_exponent_int
    \tex_advance:D \l_fp_input_a_integer_int \c_one_thousand_million
    \tex_expandafter:D \use_i:nn \tex_expandafter:D
      \fp_level_input_exponents_b:NNNNNNNNN 
        \int_use:N \l_fp_input_a_integer_int
    \tex_expandafter:D \fp_level_input_exponents_b:
  \tex_fi:D
}
\cs_new_protected_nopar:Npn 
  \fp_level_input_exponents_b:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  \l_fp_input_a_integer_int #1#2#3#4#5#6#7#8 \scan_stop:
  \tex_advance:D \l_fp_input_a_decimal_int \c_one_thousand_million
  \tex_divide:D \l_fp_input_a_decimal_int \c_ten
  \tl_set:Nx \l_fp_tmp_tl
    {
      #9 
      \tex_expandafter:D \use_none:n 
        \int_use:N \l_fp_input_a_decimal_int
    }
  \l_fp_input_a_decimal_int \l_fp_tmp_tl \scan_stop:  
  \tex_advance:D \l_fp_input_a_exponent_int \c_one
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[aux]{\fp_tmp:w}
% Used for output of results, cutting down on \cs{tex_expandafter:D}.
% This is just a place holder definition.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_tmp:w #1#2 { }
%    \end{macrocode}
%\end{macro}
%
%\subsection{Operations for \texttt{fp} variables}
%
% The format of \texttt{fp} variables is tightly defined, so that 
% they can be read quickly by the internal code. The format is a single
% sign token, a single number, the decimal point, nine decimal numbers,
% an "e" and finally the exponent. This final part may vary in length.
% When stored, floating points will always be stored with a value in
% the integer position unless the number is zero.
%
%\begin{macro}{\fp_new:N, \fp_new:c}
%\UnitTested
% Fixed-points always have a value, and of course this has to be
% initialised globally.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_new:N #1 {
  \tl_new:N #1
  \tl_gset_eq:NN #1 \c_zero_fp
}
\cs_generate_variant:Nn \fp_new:N { c }
%    \end{macrocode}
%\end{macro}
%
%
%\begin{macro}{\fp_const:Nn, \fp_const:cn}
% A simple wrapper.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_const:Nn #1#2 {
  \cs_if_free:NTF #1
    {
      \fp_new:N #1
      \fp_gset:Nn #1 {#2} 
    }
    { 
      \msg_kernel_error:nx { variable-already-defined } 
        { \token_to_str:N #1 }
    }
}
\cs_generate_variant:Nn \fp_const:Nn { c }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\fp_zero:N,  \fp_zero:c  }
%\UnitTested
%\begin{macro}{\fp_gzero:N, \fp_gzero:c }
%\UnitTested
% Zeroing fixed-points is pretty obvious.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_zero:N #1 {
  \tl_set_eq:NN #1 \c_zero_fp
}
\cs_new_protected_nopar:Npn \fp_gzero:N #1 {
  \tl_gset_eq:NN #1 \c_zero_fp
}
\cs_generate_variant:Nn \fp_zero:N { c }
\cs_generate_variant:Nn \fp_gzero:N { c }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\fp_set:Nn,  \fp_set:cn}
%\UnitTested
%\begin{macro}{\fp_gset:Nn, \fp_gset:cn} 
%\UnitTested
%\begin{macro}[aux]{\fp_set_aux:NNn} 
% To trap any input errors, a very simple version of the parser is run
% here. This will pick up any invalid characters at this stage, saving
% issues later. The splitting approach is the same as the more 
% advanced function later.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_set:Nn {
  \fp_set_aux:NNn \tl_set:Nn 
}
\cs_new_protected_nopar:Npn \fp_gset:Nn {
  \fp_set_aux:NNn \tl_gset:Nn 
}
\cs_new_protected_nopar:Npn \fp_set_aux:NNn #1#2#3 {
  \group_begin:
    \fp_split:Nn a {#3}
    \fp_standardise:NNNN
      \l_fp_input_a_sign_int
      \l_fp_input_a_integer_int
      \l_fp_input_a_decimal_int
      \l_fp_input_a_exponent_int
    \tex_advance:D \l_fp_input_a_decimal_int \c_one_thousand_million
    \cs_set_protected_nopar:Npx \fp_tmp:w
      {
        \group_end:
        #1 \exp_not:N #2
          {
            \tex_ifnum:D \l_fp_input_a_sign_int < \c_zero
              -
            \tex_else:D
              +  
            \tex_fi:D  
            \int_use:N \l_fp_input_a_integer_int
            .
            \tex_expandafter:D \use_none:n 
              \int_use:N \l_fp_input_a_decimal_int
            e
            \int_use:N \l_fp_input_a_exponent_int
          }
      }
  \fp_tmp:w
}
\cs_generate_variant:Nn \fp_set:Nn  { c }
\cs_generate_variant:Nn \fp_gset:Nn { c }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%\begin{macro}{\fp_set_from_dim:Nn,  \fp_set_from_dim:cn}
%\UnitTested
%\begin{macro}{\fp_gset_from_dim:Nn, \fp_gset_from_dim:cn} 
%\UnitTested
%\begin{macro}[aux]{\fp_set_from_dim_aux:NNn} 
%\begin{macro}[aux]{\fp_set_from_dim_aux:w} 
%\begin{macro}[aux]{\l_fp_tmp_dim}
%\begin{macro}[aux]{\l_fp_tmp_skip}
% Here, dimensions are converted to fixed-points \emph{via} a
% temporary variable. This ensures that they always convert as points.
% The code is then essentially the same as for \cs{fp_set:Nn}, but with
% the dimension passed so that it will be striped of the "pt" on the
% way through. The passage through a skip is used to remove any rubber
% part.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_set_from_dim:Nn {
  \fp_set_from_dim_aux:NNn \tl_set:Nx 
}
\cs_new_protected_nopar:Npn \fp_gset_from_dim:Nn {
  \fp_set_from_dim_aux:NNn \tl_gset:Nx 
}
\cs_new_protected_nopar:Npn \fp_set_from_dim_aux:NNn #1#2#3 {
  \group_begin:
    \l_fp_tmp_skip \etex_glueexpr:D #3 \scan_stop:
    \l_fp_tmp_dim \l_fp_tmp_skip 
    \fp_split:Nn a 
      { 
        \tex_expandafter:D \fp_set_from_dim_aux:w 
          \dim_use:N \l_fp_tmp_dim  
      }
    \fp_standardise:NNNN
      \l_fp_input_a_sign_int
      \l_fp_input_a_integer_int
      \l_fp_input_a_decimal_int
      \l_fp_input_a_exponent_int 
    \tex_advance:D \l_fp_input_a_decimal_int \c_one_thousand_million
    \cs_set_protected_nopar:Npx \fp_tmp:w
      {
        \group_end:
        #1 \exp_not:N #2
          {
            \tex_ifnum:D \l_fp_input_a_sign_int < \c_zero
              -
            \tex_else:D
              +  
            \tex_fi:D  
            \int_use:N \l_fp_input_a_integer_int
            .
            \tex_expandafter:D \use_none:n 
              \int_use:N \l_fp_input_a_decimal_int
            e
            \int_use:N \l_fp_input_a_exponent_int
          }
      }
  \fp_tmp:w
}
\cs_set_protected_nopar:Npx \fp_set_from_dim_aux:w {
  \cs_set_nopar:Npn \exp_not:N \fp_set_from_dim_aux:w 
    ##1 \tl_to_str:n { pt } {##1}
}
\fp_set_from_dim_aux:w
\cs_generate_variant:Nn \fp_set_from_dim:Nn  { c }
\cs_generate_variant:Nn \fp_gset_from_dim:Nn { c }
\dim_new:N \l_fp_tmp_dim
\skip_new:N \l_fp_tmp_skip
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%
%\begin{macro}{\fp_set_eq:NN, \fp_set_eq:cN,
%              \fp_set_eq:Nc, \fp_set_eq:cc}
%\UnitTested
%\begin{macro}{\fp_gset_eq:NN, \fp_gset_eq:cN,
%              \fp_gset_eq:Nc, \fp_gset_eq:cc}
%\UnitTested
% Pretty simple, really.
%    \begin{macrocode}
\cs_new_eq:NN \fp_set_eq:NN  \tl_set_eq:NN
\cs_new_eq:NN \fp_set_eq:cN  \tl_set_eq:cN
\cs_new_eq:NN \fp_set_eq:Nc  \tl_set_eq:Nc
\cs_new_eq:NN \fp_set_eq:cc  \tl_set_eq:cc
\cs_new_eq:NN \fp_gset_eq:NN \tl_gset_eq:NN
\cs_new_eq:NN \fp_gset_eq:cN \tl_gset_eq:cN
\cs_new_eq:NN \fp_gset_eq:Nc \tl_gset_eq:Nc
\cs_new_eq:NN \fp_gset_eq:cc \tl_gset_eq:cc
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%
%
%\begin{macro}{\fp_show:N, \fp_show:c}
%\UnitTested
% Simple showing of the underlying variable.
%    \begin{macrocode}
\cs_new_eq:NN \fp_show:N \tl_show:N
\cs_new_eq:NN \fp_show:c \tl_show:c
%    \end{macrocode}
%\end{macro}
%
%
%
%\begin{macro}{\fp_use:N, \fp_use:c}
% \UnitTested
%\begin{macro}[aux]{\fp_use_aux:w}
%\begin{macro}[aux]{\fp_use_none:w}
%\begin{macro}[aux]{\fp_use_small:w}
%\begin{macro}[aux]{\fp_use_large:w}
%\begin{macro}[aux]{\fp_use_large_aux_i:w}
%\begin{macro}[aux]{\fp_use_large_aux_1:w}
%\begin{macro}[aux]{\fp_use_large_aux_2:w}
%\begin{macro}[aux]{\fp_use_large_aux_3:w}
%\begin{macro}[aux]{\fp_use_large_aux_4:w}
%\begin{macro}[aux]{\fp_use_large_aux_5:w}
%\begin{macro}[aux]{\fp_use_large_aux_6:w}
%\begin{macro}[aux]{\fp_use_large_aux_7:w}
%\begin{macro}[aux]{\fp_use_large_aux_8:w}
%\begin{macro}[aux]{\fp_use_large_aux_i:w}
%\begin{macro}[aux]{\fp_use_large_aux_ii:w}
% The idea of the \cs{fp_use:N} function to convert the stored
% value into something suitable for \TeX\ to use as a number in an
% expandable manner. The first step is to deal with the sign, then
% work out how big the input is.
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_use:N #1 {
  \tex_expandafter:D \fp_use_aux:w #1 \q_stop
}
\cs_generate_variant:Nn \fp_use:N { c }
\cs_new_nopar:Npn \fp_use_aux:w #1#2 e #3 \q_stop {
  \tex_if:D #1 -
    -
  \tex_fi:D
  \tex_ifnum:D #3 > \c_zero
    \tex_expandafter:D \fp_use_large:w
  \tex_else:D
    \tex_ifnum:D #3 < \c_zero
      \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
        \fp_use_small:w
    \tex_else:D
      \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
        \fp_use_none:w
    \tex_fi:D
  \tex_fi:D
  #2 e #3 \q_stop
}
%    \end{macrocode}
% When the exponent is zero, the input is simply returned as output.   
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_use_none:w #1 e #2 \q_stop {#1}
%    \end{macrocode}
% For small numbers (less than \( 1 \)) the correct number of zeros
% have to be inserted, but the decimal point is easy.
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_use_small:w #1 . #2 e #3 \q_stop {
  0 .
  \prg_replicate:nn { -#3 - 1 } { 0 }
  #1#2
}
%    \end{macrocode}
% Life is more complex for large numbers. The decimal point needs to
% be shuffled, with potentially some zero-filling for very large values.
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_use_large:w #1 . #2 e #3 \q_stop {
  \tex_ifnum:D #3 < \c_ten
    \tex_expandafter:D \fp_use_large_aux_i:w
  \tex_else:D
    \tex_expandafter:D \fp_use_large_aux_ii:w
  \tex_fi:D
  #1#2 e #3 \q_stop
}
\cs_new_nopar:Npn \fp_use_large_aux_i:w #1#2 e #3 \q_stop {
  #1
  \use:c { fp_use_large_aux_ #3 :w } #2 \q_stop
}
\cs_new_nopar:cpn { fp_use_large_aux_1:w } #1#2 \q_stop { #1 . #2 }
\cs_new_nopar:cpn { fp_use_large_aux_2:w } #1#2#3 \q_stop { 
  #1#2 . #3 
}
\cs_new_nopar:cpn { fp_use_large_aux_3:w } #1#2#3#4 \q_stop { 
  #1#2#3 . #4
}
\cs_new_nopar:cpn { fp_use_large_aux_4:w } #1#2#3#4#5 \q_stop { 
  #1#2#3#4 . #5
}
\cs_new_nopar:cpn { fp_use_large_aux_5:w } #1#2#3#4#5#6 \q_stop { 
  #1#2#3#4#5 . #6
}
\cs_new_nopar:cpn { fp_use_large_aux_6:w } #1#2#3#4#5#6#7 \q_stop { 
  #1#2#3#4#5#6 . #7
}
\cs_new_nopar:cpn { fp_use_large_aux_7:w } #1#2#3#4#5#6#7#8 \q_stop { 
  #1#2#3#4#6#7 . #8
}
\cs_new_nopar:cpn { fp_use_large_aux_8:w } #1#2#3#4#5#6#7#8#9 \q_stop {
  #1#2#3#4#5#6#7#8 . #9
}
\cs_new_nopar:cpn { fp_use_large_aux_9:w } #1 \q_stop { #1 . }
\cs_new_nopar:Npn \fp_use_large_aux_ii:w #1 e #2 \q_stop {
  #1
  \prg_replicate:nn { #2 - 9 } { 0 }
  .
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\subsection{Transferring to other types}
%
% The \cs{fp_use:N} function converts a floating point variable to
% a form that can be used by \TeX. Here, the functions are slightly
% different, as some information may be discarded.
% 
%\begin{macro}{\fp_to_dim:N, \fp_to_dim:c}
% A very simple wrapper.
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_to_dim:N #1 { \fp_use:N #1 pt }
\cs_generate_variant:Nn \fp_to_dim:N { c }
%    \end{macrocode}
%\end{macro}
%
% 
%\begin{macro}{\fp_to_int:N, \fp_to_int:c}
%\UnitTested
%\begin{macro}[aux]{\fp_to_int_aux:w}
%\begin{macro}[aux]{\fp_to_int_none:w}
%\begin{macro}[aux]{\fp_to_int_small:w}
%\begin{macro}[aux]{\fp_to_int_large:w}
%\begin{macro}[aux]{\fp_to_int_large_aux_i:w}
%\begin{macro}[aux]{\fp_to_int_large_aux_1:w}
%\begin{macro}[aux]{\fp_to_int_large_aux_2:w}
%\begin{macro}[aux]{\fp_to_int_large_aux_3:w}
%\begin{macro}[aux]{\fp_to_int_large_aux_4:w}
%\begin{macro}[aux]{\fp_to_int_large_aux_5:w}
%\begin{macro}[aux]{\fp_to_int_large_aux_6:w}
%\begin{macro}[aux]{\fp_to_int_large_aux_7:w}
%\begin{macro}[aux]{\fp_to_int_large_aux_8:w}
%\begin{macro}[aux]{\fp_to_int_large_aux_i:w}
%\begin{macro}[aux]{\fp_to_int_large_aux:nnn}
%\begin{macro}[aux]{\fp_to_int_large_aux_ii:w}
% Converting to integers in an expandable manner is very similar to 
% simply using floating point variables, particularly in the lead-off.
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_to_int:N #1 {
  \tex_expandafter:D \fp_to_int_aux:w #1 \q_stop
}
\cs_generate_variant:Nn \fp_to_int:N { c }
\cs_new_nopar:Npn \fp_to_int_aux:w #1#2 e #3 \q_stop {
  \tex_if:D #1 -
    -
  \tex_fi:D
  \tex_ifnum:D #3 < \c_zero
    \tex_expandafter:D \fp_to_int_small:w
  \tex_else:D
    \tex_expandafter:D \fp_to_int_large:w
  \tex_fi:D
  #2 e #3 \q_stop
}
%    \end{macrocode}
% For small numbers, if the decimal part is greater than a half then
% there is rounding up to do.
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_to_int_small:w #1 . #2 e #3 \q_stop {
  \tex_ifnum:D #3 > \c_one
  \tex_else:D
    \tex_ifnum:D #1 < \c_five
      0
    \tex_else:D
      1
    \tex_fi:D
  \tex_fi:D
}
%    \end{macrocode}
% For large numbers, the idea is to split off the part for rounding,
% do the rounding and fill if needed.
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_to_int_large:w #1 . #2 e #3 \q_stop {
  \tex_ifnum:D #3 < \c_ten
    \tex_expandafter:D \fp_to_int_large_aux_i:w
  \tex_else:D
    \tex_expandafter:D \fp_to_int_large_aux_ii:w
  \tex_fi:D
  #1#2 e #3 \q_stop
}
\cs_new_nopar:Npn \fp_to_int_large_aux_i:w #1#2 e #3 \q_stop {
  \use:c { fp_to_int_large_aux_ #3 :w } #2 \q_stop {#1}
}
\cs_new_nopar:cpn { fp_to_int_large_aux_1:w } #1#2 \q_stop { 
  \fp_to_int_large_aux:nnn { #2 0 } {#1} 
}
\cs_new_nopar:cpn { fp_to_int_large_aux_2:w } #1#2#3 \q_stop { 
  \fp_to_int_large_aux:nnn { #3 00 } {#1#2} 
}
\cs_new_nopar:cpn { fp_to_int_large_aux_3:w } #1#2#3#4 \q_stop { 
  \fp_to_int_large_aux:nnn { #4 000 } {#1#2#3} 
}
\cs_new_nopar:cpn { fp_to_int_large_aux_4:w } #1#2#3#4#5 \q_stop { 
  \fp_to_int_large_aux:nnn { #5 0000 } {#1#2#3#4} 
}
\cs_new_nopar:cpn { fp_to_int_large_aux_5:w } #1#2#3#4#5#6 \q_stop { 
  \fp_to_int_large_aux:nnn { #6 00000 } {#1#2#3#4#5} 
}
\cs_new_nopar:cpn { fp_to_int_large_aux_6:w } #1#2#3#4#5#6#7 \q_stop {
  \fp_to_int_large_aux:nnn { #7 000000 } {#1#2#3#4#5#6} 
}
\cs_new_nopar:cpn 
  { fp_to_int_large_aux_7:w } #1#2#3#4#5#6#7#8 \q_stop { 
  \fp_to_int_large_aux:nnn { #8 0000000 } {#1#2#3#4#5#6#7} 
}
\cs_new_nopar:cpn 
  { fp_to_int_large_aux_8:w } #1#2#3#4#5#6#7#8#9 \q_stop {
  \fp_to_int_large_aux:nnn { #9 00000000 } {#1#2#3#4#5#6#7#8} 
}
\cs_new_nopar:cpn { fp_to_int_large_aux_9:w } #1 \q_stop {#1}
\cs_new_nopar:Npn \fp_to_int_large_aux:nnn #1#2#3 {
  \tex_ifnum:D #1 < \c_five_hundred_million
    #3#2
  \tex_else:D
    \tex_number:D \etex_numexpr:D #3#2 + 1 \scan_stop:
  \tex_fi:D
}
\cs_new_nopar:Npn \fp_to_int_large_aux_ii:w #1 e #2 \q_stop {
  #1
  \prg_replicate:nn { #2 - 9 } { 0 }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%
%
%\begin{macro}{\fp_to_tl:N, \fp_to_tl:c}
%\UnitTested
%\begin{macro}[aux]{\fp_to_tl_aux:w}
%\begin{macro}[aux]{\fp_to_tl_large:w}
%\begin{macro}[aux]{\fp_to_tl_large_aux_i:w}
%\begin{macro}[aux]{\fp_to_tl_large_aux_ii:w}
%\begin{macro}[aux]{\fp_to_tl_large_0:w}
%\begin{macro}[aux]{\fp_to_tl_large_1:w}
%\begin{macro}[aux]{\fp_to_tl_large_2:w}
%\begin{macro}[aux]{\fp_to_tl_large_3:w}
%\begin{macro}[aux]{\fp_to_tl_large_4:w}
%\begin{macro}[aux]{\fp_to_tl_large_5:w}
%\begin{macro}[aux]{\fp_to_tl_large_6:w}
%\begin{macro}[aux]{\fp_to_tl_large_7:w}
%\begin{macro}[aux]{\fp_to_tl_large_8:w}
%\begin{macro}[aux]{\fp_to_tl_large_8_aux:w}
%\begin{macro}[aux]{\fp_to_tl_large_9:w}
%\begin{macro}[aux]{\fp_to_tl_small:w}
%\begin{macro}[aux]{\fp_to_tl_small_one:w}
%\begin{macro}[aux]{\fp_to_tl_small_two:w}
%\begin{macro}[aux]{\fp_to_tl_small_aux:w}
%\begin{macro}[aux]{\fp_to_tl_large_zeros:NNNNNNNNN}
%\begin{macro}[aux]{\fp_to_tl_small_zeros:NNNNNNNNN}
%\begin{macro}[aux]{\fp_use_iix_ix:NNNNNNNNN}
%\begin{macro}[aux]{\fp_use_ix:NNNNNNNNN}
%\begin{macro}[aux]{\fp_use_i_to_vii:NNNNNNNNN}
%\begin{macro}[aux]{\fp_use_i_to_iix:NNNNNNNNN}
% Converting to integers in an expandable manner is very similar to 
% simply using floating point variables, particularly in the lead-off.
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_to_tl:N #1 {
  \tex_expandafter:D \fp_to_tl_aux:w #1 \q_stop
}
\cs_generate_variant:Nn \fp_to_tl:N { c }
\cs_new_nopar:Npn \fp_to_tl_aux:w #1#2 e #3 \q_stop {
  \tex_if:D #1 -
    -
  \tex_fi:D
  \tex_ifnum:D #3 < \c_zero
    \tex_expandafter:D \fp_to_tl_small:w
  \tex_else:D
    \tex_expandafter:D \fp_to_tl_large:w
  \tex_fi:D
  #2 e #3 \q_stop
}
%    \end{macrocode}
% For `large' numbers (exponent \( \ge 0 \)) there are two
% cases. For very large exponents (\( \ge 10 \)) life is easy: apart
% from dropping extra zeros there is no work to do. On the other hand, 
% for intermediate exponent values the decimal needs to be moved, then
% zeros can be dropped.
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_to_tl_large:w #1 e #2 \q_stop {
  \tex_ifnum:D #2 < \c_ten
    \tex_expandafter:D \fp_to_tl_large_aux_i:w
  \tex_else:D
    \tex_expandafter:D \fp_to_tl_large_aux_ii:w
  \tex_fi:D
  #1 e #2 \q_stop
}
\cs_new_nopar:Npn \fp_to_tl_large_aux_i:w #1 e #2 \q_stop {
  \use:c { fp_to_tl_large_ #2 :w } #1 \q_stop
}
\cs_new_nopar:Npn \fp_to_tl_large_aux_ii:w #1 . #2 e #3 \q_stop {
  #1
  \fp_to_tl_large_zeros:NNNNNNNNN #2
  e #3
}
\cs_new_nopar:cpn { fp_to_tl_large_0:w } #1 . #2 \q_stop {
  #1
  \fp_to_tl_large_zeros:NNNNNNNNN #2
}
\cs_new_nopar:cpn { fp_to_tl_large_1:w } #1 . #2#3 \q_stop {
  #1#2
  \fp_to_tl_large_zeros:NNNNNNNNN #3 0
}
\cs_new_nopar:cpn { fp_to_tl_large_2:w } #1 . #2#3#4 \q_stop {
  #1#2#3
  \fp_to_tl_large_zeros:NNNNNNNNN #4 00
}
\cs_new_nopar:cpn { fp_to_tl_large_3:w } #1 . #2#3#4#5 \q_stop {
  #1#2#3#4
  \fp_to_tl_large_zeros:NNNNNNNNN #5 000
}
\cs_new_nopar:cpn { fp_to_tl_large_4:w } #1 . #2#3#4#5#6 \q_stop {
  #1#2#3#4#5
  \fp_to_tl_large_zeros:NNNNNNNNN #6 0000
}
\cs_new_nopar:cpn { fp_to_tl_large_5:w } #1 . #2#3#4#5#6#7 \q_stop {
  #1#2#3#4#5#6
  \fp_to_tl_large_zeros:NNNNNNNNN #7 00000
}
\cs_new_nopar:cpn { fp_to_tl_large_6:w } #1 . #2#3#4#5#6#7#8 \q_stop {
  #1#2#3#4#5#6#7
  \fp_to_tl_large_zeros:NNNNNNNNN #8 000000
}
\cs_new_nopar:cpn { fp_to_tl_large_7:w } #1 . #2#3#4#5#6#7#8#9 \q_stop {
  #1#2#3#4#5#6#7#8
  \fp_to_tl_large_zeros:NNNNNNNNN #9 0000000
}
\cs_new_nopar:cpn { fp_to_tl_large_8:w } #1 . {
  #1
  \use:c { fp_to_tl_large_8_aux:w }
}
\cs_new_nopar:cpn 
  { fp_to_tl_large_8_aux:w } #1#2#3#4#5#6#7#8#9 \q_stop {
  #1#2#3#4#5#6#7#8
  \fp_to_tl_large_zeros:NNNNNNNNN #9 00000000
}
\cs_new_nopar:cpn { fp_to_tl_large_9:w } #1 . #2 \q_stop {#1#2}
%    \end{macrocode}
% Dealing with small numbers is a bit more complex as there has to be
% rounding. This makes life rather awkward, as there need to be a series
% of tests and calculations, as things cannot be stored in an
% expandable system.   
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_to_tl_small:w #1 e #2 \q_stop {
  \tex_ifnum:D #2 = \c_minus_one
    \tex_expandafter:D \fp_to_tl_small_one:w
  \tex_else:D
    \tex_ifnum:D #2 = -\c_two
      \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
        \fp_to_tl_small_two:w
    \tex_else:D  
      \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
        \fp_to_tl_small_aux:w
    \tex_fi:D
  \tex_fi:D
  #1 e #2 \q_stop
}
\cs_new_nopar:Npn \fp_to_tl_small_one:w #1 . #2 e #3 \q_stop {
  \tex_ifnum:D \fp_use_ix:NNNNNNNNN #2 > \c_four
    \tex_ifnum:D 
      \etex_numexpr:D #1 \fp_use_i_to_iix:NNNNNNNNN #2 + 1 
        < \c_one_thousand_million
      0.
      \tex_expandafter:D \fp_to_tl_small_zeros:NNNNNNNNN
        \tex_number:D 
          \etex_numexpr:D 
            #1 \fp_use_i_to_iix:NNNNNNNNN #2 + 1 
          \scan_stop:
    \tex_else:D
      1  
    \tex_fi:D
  \tex_else:D
    0. #1
    \fp_to_tl_small_zeros:NNNNNNNNN #2
  \tex_fi:D
}
\cs_new_nopar:Npn \fp_to_tl_small_two:w #1 . #2 e #3 \q_stop {
  \tex_ifnum:D \fp_use_iix_ix:NNNNNNNNN #2 > \c_forty_four
    \tex_ifnum:D 
      \etex_numexpr:D #1 \fp_use_i_to_vii:NNNNNNNNN #2 0 + \c_ten
        < \c_one_thousand_million
      0.0 
      \tex_expandafter:D \fp_to_tl_small_zeros:NNNNNNNNN
        \tex_number:D 
          \etex_numexpr:D 
            #1 \fp_use_i_to_vii:NNNNNNNNN #2 0 + \c_ten
          \scan_stop:
    \tex_else:D
      0.1  
    \tex_fi:D
  \tex_else:D
    0.0
    #1
    \fp_to_tl_small_zeros:NNNNNNNNN #2
  \tex_fi:D
}
\cs_new_nopar:Npn \fp_to_tl_small_aux:w #1 . #2 e #3 \q_stop {
  #1
  \fp_to_tl_large_zeros:NNNNNNNNN #2
  e #3
}
%    \end{macrocode}
% Rather than a complex recursion, the tests for finding trailing zeros
% are written out long-hand.  The difference between the two is only the
% need for a decimal marker.
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_to_tl_large_zeros:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  \tex_ifnum:D #9 = \c_zero
    \tex_ifnum:D #8 = \c_zero
      \tex_ifnum:D #7 = \c_zero
        \tex_ifnum:D #6 = \c_zero
          \tex_ifnum:D #5 = \c_zero
            \tex_ifnum:D #4 = \c_zero
              \tex_ifnum:D #3 = \c_zero
                \tex_ifnum:D #2 = \c_zero
                  \tex_ifnum:D #1 = \c_zero
                  \tex_else:D
                    . #1
                  \tex_fi:D
                \tex_else:D
                  . #1#2    
                \tex_fi:D
              \tex_else:D
                . #1#2#3 
              \tex_fi:D  
            \tex_else:D
              . #1#2#3#4
            \tex_fi:D
          \tex_else:D
            . #1#2#3#4#5
          \tex_fi:D     
        \tex_else:D
          . #1#2#3#4#5#6
        \tex_fi:D
      \tex_else:D
        . #1#2#3#4#5#6#7
      \tex_fi:D
    \tex_else:D
       . #1#2#3#4#5#6#7#8
    \tex_fi:D
  \tex_else:D
    . #1#2#3#4#5#6#7#8#9
  \tex_fi:D
}
\cs_new_nopar:Npn \fp_to_tl_small_zeros:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  \tex_ifnum:D #9 = \c_zero
    \tex_ifnum:D #8 = \c_zero
      \tex_ifnum:D #7 = \c_zero
        \tex_ifnum:D #6 = \c_zero
          \tex_ifnum:D #5 = \c_zero
            \tex_ifnum:D #4 = \c_zero
              \tex_ifnum:D #3 = \c_zero
                \tex_ifnum:D #2 = \c_zero
                  \tex_ifnum:D #1 = \c_zero
                  \tex_else:D
                    #1
                  \tex_fi:D
                \tex_else:D
                  #1#2    
                \tex_fi:D
              \tex_else:D
                #1#2#3 
              \tex_fi:D  
            \tex_else:D
              #1#2#3#4
            \tex_fi:D
          \tex_else:D
            #1#2#3#4#5
          \tex_fi:D     
        \tex_else:D
          #1#2#3#4#5#6
        \tex_fi:D
      \tex_else:D
        #1#2#3#4#5#6#7
      \tex_fi:D
    \tex_else:D
       #1#2#3#4#5#6#7#8
    \tex_fi:D
  \tex_else:D
    #1#2#3#4#5#6#7#8#9
  \tex_fi:D
}
%    \end{macrocode}
% Some quick `return a few' functions.   
%    \begin{macrocode}
\cs_new_nopar:Npn \fp_use_iix_ix:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {#8#9}
\cs_new_nopar:Npn \fp_use_ix:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {#9}
\cs_new_nopar:Npn \fp_use_i_to_vii:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  #1#2#3#4#5#6#7
}
\cs_new_nopar:Npn \fp_use_i_to_iix:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  #1#2#3#4#5#6#7#8
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\subsection{Rounding numbers}
%
% The results may well need to be rounded. A couple of related functions
% to do this for a stored value.
% 
% 
%\begin{macro}{\fp_round_figures:Nn,  \fp_round_figures:cn}
%\UnitTested
%\begin{macro}{\fp_ground_figures:Nn, \fp_ground_figures:cn}
%\UnitTested
%\begin{macro}[aux]{\fp_round_figures_aux:NNn} 
% Rounding to figures needs only an adjustment to the target by one
% (as the target is in decimal places).
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_round_figures:Nn {
  \fp_round_figures_aux:NNn \tl_set:Nn
}
\cs_generate_variant:Nn \fp_round_figures:Nn { c }
\cs_new_protected_nopar:Npn \fp_ground_figures:Nn {
  \fp_round_figures_aux:NNn \tl_gset:Nn
}
\cs_generate_variant:Nn \fp_ground_figures:Nn { c }
\cs_new_protected_nopar:Npn \fp_round_figures_aux:NNn #1#2#3 {
  \group_begin:
    \fp_read:N #2
    \int_set:Nn \l_fp_round_target_int { #3 - 1 }
    \tex_ifnum:D \l_fp_round_target_int < \c_ten
      \tex_expandafter:D \fp_round:
    \tex_fi:D
    \tex_advance:D \l_fp_input_a_decimal_int \c_one_thousand_million
    \cs_set_protected_nopar:Npx \fp_tmp:w
      {
        \group_end:
        #1 \exp_not:N #2
          {
            \tex_ifnum:D \l_fp_input_a_sign_int < \c_zero
              -
            \tex_else:D
              +  
            \tex_fi:D  
            \int_use:N \l_fp_input_a_integer_int
            .
            \tex_expandafter:D \use_none:n 
              \int_use:N \l_fp_input_a_decimal_int
            e
            \int_use:N \l_fp_input_a_exponent_int
          }
      }
  \fp_tmp:w
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%\begin{macro}{\fp_round_places:Nn,  \fp_round_places:cn}
%\UnitTested
%\begin{macro}{\fp_ground_places:Nn, \fp_ground_places:cn}
%\UnitTested
%\begin{macro}[aux]{\fp_round_places_aux:NNn} 
% Rounding to places needs an adjustment for the exponent value, which
% will mean that everything should be correct.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_round_places:Nn {
  \fp_round_places_aux:NNn \tl_set:Nn
}
\cs_generate_variant:Nn \fp_round_places:Nn { c }
\cs_new_protected_nopar:Npn \fp_ground_places:Nn {
  \fp_round_places_aux:NNn \tl_gset:Nn
}
\cs_generate_variant:Nn \fp_ground_places:Nn { c }
\cs_new_protected_nopar:Npn \fp_round_places_aux:NNn #1#2#3 {
  \group_begin:
    \fp_read:N #2
    \int_set:Nn \l_fp_round_target_int 
      { #3 + \l_fp_input_a_exponent_int }
    \tex_ifnum:D \l_fp_round_target_int < \c_ten
      \tex_expandafter:D \fp_round:
    \tex_fi:D
    \tex_advance:D \l_fp_input_a_decimal_int \c_one_thousand_million
    \cs_set_protected_nopar:Npx \fp_tmp:w
      {
        \group_end:
        #1 \exp_not:N #2
          {
            \tex_ifnum:D \l_fp_input_a_sign_int < \c_zero
              -
            \tex_else:D
              +  
            \tex_fi:D  
            \int_use:N \l_fp_input_a_integer_int
            .
            \tex_expandafter:D \use_none:n 
              \int_use:N \l_fp_input_a_decimal_int
            e
            \int_use:N \l_fp_input_a_exponent_int
          }
      }
  \fp_tmp:w
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}  
%
%
%
%\begin{macro}{\fp_round:}
%\begin{macro}[aux]{\fp_round_aux:NNNNNNNNN}
%\begin{macro}{\fp_round_loop:N}
% The rounding approach is the same for decimal places and significant
% figures. There are always nine decimal digits to round, so the code
% can be written to account for this. The basic logic is simply to 
% find the rounding, track any carry digit and move along. At the end
% of the loop there is a possible shuffle if the integer part has 
% become \( 10 \).
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_round: {
  \bool_set_false:N \l_fp_round_carry_bool
  \l_fp_round_position_int \c_eight
  \tl_clear:N \l_fp_round_decimal_tl
  \tex_advance:D \l_fp_input_a_decimal_int \c_one_thousand_million
  \tex_expandafter:D \use_i:nn \tex_expandafter:D 
    \fp_round_aux:NNNNNNNNN \int_use:N \l_fp_input_a_decimal_int
}
\cs_new_protected_nopar:Npn \fp_round_aux:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  \fp_round_loop:N #9#8#7#6#5#4#3#2#1
  \bool_if:NT \l_fp_round_carry_bool
    { \tex_advance:D \l_fp_input_a_integer_int \c_one }
  \l_fp_input_a_decimal_int \l_fp_round_decimal_tl \scan_stop:
  \tex_ifnum:D \l_fp_input_a_integer_int < \c_ten
  \tex_else:D
    \l_fp_input_a_integer_int \c_one
    \tex_divide:D \l_fp_input_a_decimal_int \c_ten
    \tex_advance:D \l_fp_input_a_exponent_int \c_one
  \tex_fi:D
}
\cs_new_protected_nopar:Npn \fp_round_loop:N #1 {
  \tex_ifnum:D \l_fp_round_position_int < \l_fp_round_target_int
    \bool_if:NTF \l_fp_round_carry_bool
      { \l_fp_tmp_int \etex_numexpr:D #1 + \c_one \scan_stop: }
      { \l_fp_tmp_int \etex_numexpr:D #1 \scan_stop: }
    \tex_ifnum:D \l_fp_tmp_int = \c_ten
      \l_fp_tmp_int \c_zero
    \tex_else:D 
      \bool_set_false:N \l_fp_round_carry_bool  
    \tex_fi:D  
    \tl_set:Nx \l_fp_round_decimal_tl
      { \int_use:N \l_fp_tmp_int \l_fp_round_decimal_tl }    
  \tex_else:D
    \tl_set:Nx \l_fp_round_decimal_tl { 0 \l_fp_round_decimal_tl }
    \tex_ifnum:D \l_fp_round_position_int = \l_fp_round_target_int
      \tex_ifnum:D #1 > \c_four
        \bool_set_true:N \l_fp_round_carry_bool 
      \tex_fi:D
    \tex_fi:D  
  \tex_fi:D  
  \tex_advance:D \l_fp_round_position_int \c_minus_one
  \tex_ifnum:D \l_fp_round_position_int > \c_minus_one
    \tex_expandafter:D \fp_round_loop:N
  \tex_fi:D
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%
%\subsection{Unary functions}
%
%\begin{macro}{\fp_abs:N,  \fp_abs:c}
%\UnitTested
%\begin{macro}{\fp_gabs:N, \fp_gabs:c}
%\UnitTested
%\begin{macro}[aux]{\fp_abs_aux:NN}
% Setting the absolute value is easy: read the value, ignore the sign,
% return the result.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_abs:N {
  \fp_abs_aux:NN \tl_set:Nn 
}
\cs_new_protected_nopar:Npn \fp_gabs:N {
  \fp_abs_aux:NN \tl_gset:Nn 
}
\cs_generate_variant:Nn \fp_abs:N  { c }
\cs_generate_variant:Nn \fp_gabs:N { c }
\cs_new_protected_nopar:Npn \fp_abs_aux:NN #1#2 {
  \group_begin:
    \fp_read:N #2
    \tex_advance:D \l_fp_input_a_decimal_int \c_one_thousand_million
    \cs_set_protected_nopar:Npx \fp_tmp:w
      {
        \group_end:
        #1 \exp_not:N #2
          {
            +
            \int_use:N \l_fp_input_a_integer_int
            .
            \tex_expandafter:D \use_none:n 
              \int_use:N \l_fp_input_a_decimal_int
            e
            \int_use:N \l_fp_input_a_exponent_int
          }
      }
  \fp_tmp:w
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%
%\begin{macro}{\fp_neg:N,  \fp_neg:c}
%\UnitTested
%\begin{macro}{\fp_gneg:N, \fp_gneg:c}
%\UnitTested
%\begin{macro}[aux]{\fp_neg:NN}
% Just a bit more complex: read the input, reverse the sign and 
% output the result.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_neg:N {
  \fp_neg_aux:NN \tl_set:Nn 
}
\cs_new_protected_nopar:Npn \fp_gneg:N {
  \fp_neg_aux:NN \tl_gset:Nn 
}
\cs_generate_variant:Nn \fp_neg:N  { c }
\cs_generate_variant:Nn \fp_gneg:N { c }
\cs_new_protected_nopar:Npn \fp_neg_aux:NN #1#2 {
  \group_begin:
    \fp_read:N #2
    \tex_advance:D \l_fp_input_a_decimal_int \c_one_thousand_million
    \tl_set:Nx \l_fp_tmp_tl
      {
        \tex_ifnum:D \l_fp_input_a_sign_int < \c_zero
          +
        \tex_else:D
          -
        \tex_fi:D  
        \int_use:N \l_fp_input_a_integer_int
        .
        \tex_expandafter:D \use_none:n 
          \int_use:N \l_fp_input_a_decimal_int
        e
        \int_use:N \l_fp_input_a_exponent_int
      }
  \tex_expandafter:D \group_end: \tex_expandafter:D
  #1 \tex_expandafter:D #2 \tex_expandafter:D { \l_fp_tmp_tl }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%\subsection{Basic arithmetic}
%  
%\begin{macro}{\fp_add:Nn, \fp_add:cn}
%\UnitTested
%\begin{macro}{\fp_gadd:Nn,\fp_gadd:cn}
%\UnitTested
%\begin{macro}[aux]{\fp_add_aux:NNn}
%\begin{macro}[aux]{\fp_add_core:}
%\begin{macro}[aux]{\fp_add_sum:}
%\begin{macro}[aux]{\fp_add_difference:}
% The various addition functions are simply different ways to call the
% single master function below. This pattern is repeated for the
% other arithmetic functions.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_add:Nn {
  \fp_add_aux:NNn \tl_set:Nn 
}
\cs_new_protected_nopar:Npn \fp_gadd:Nn {
  \fp_add_aux:NNn \tl_gset:Nn 
}
\cs_generate_variant:Nn \fp_add:Nn   { c }
\cs_generate_variant:Nn \fp_gadd:Nn  { c }
%    \end{macrocode}
% Addition takes place using one of two paths. If the signs of the 
% two parts are the same, they are simply combined. On the other
% hand, if the signs are different the calculation finds this
% difference.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_add_aux:NNn #1#2#3 {
  \group_begin:
    \fp_read:N #2
    \fp_split:Nn b {#3}
    \fp_standardise:NNNN
      \l_fp_input_b_sign_int
      \l_fp_input_b_integer_int
      \l_fp_input_b_decimal_int
      \l_fp_input_b_exponent_int
    \fp_add_core:
  \fp_tmp:w #1#2
}
\cs_new_protected_nopar:Npn \fp_add_core: {  
  \fp_level_input_exponents:
  \tex_ifnum:D 
    \etex_numexpr:D
      \l_fp_input_a_sign_int * \l_fp_input_b_sign_int
    \scan_stop:
      > \c_zero
    \tex_expandafter:D \fp_add_sum:  
  \tex_else:D
    \tex_expandafter:D \fp_add_difference:     
  \tex_fi:D
  \l_fp_output_exponent_int \l_fp_input_a_exponent_int
  \fp_standardise:NNNN
    \l_fp_output_sign_int
    \l_fp_output_integer_int
    \l_fp_output_decimal_int
    \l_fp_output_exponent_int
  \cs_set_protected_nopar:Npx \fp_tmp:w ##1##2
    {
      \group_end:
      ##1 ##2 
        {
          \tex_ifnum:D \l_fp_output_sign_int < \c_zero
            -
          \tex_else:D
            +
          \tex_fi:D  
          \int_use:N \l_fp_output_integer_int
          .
          \tex_expandafter:D \use_none:n 
            \tex_number:D \etex_numexpr:D
               \l_fp_output_decimal_int + \c_one_thousand_million
          e
          \int_use:N \l_fp_output_exponent_int
        } 
    }
}
%    \end{macrocode}
% Finding the sum of two numbers is trivially easy.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_add_sum: {
  \l_fp_output_sign_int \l_fp_input_a_sign_int
  \l_fp_output_integer_int
    \etex_numexpr:D
      \l_fp_input_a_integer_int + \l_fp_input_b_integer_int
    \scan_stop:
  \l_fp_output_decimal_int
    \etex_numexpr:D
      \l_fp_input_a_decimal_int + \l_fp_input_b_decimal_int
    \scan_stop:
  \tex_ifnum:D \l_fp_output_decimal_int < \c_one_thousand_million
  \tex_else:D
    \tex_advance:D \l_fp_output_integer_int \c_one
    \tex_advance:D \l_fp_output_decimal_int -\c_one_thousand_million
  \tex_fi:D  
}
%    \end{macrocode}
% When the signs of the two parts of the input are different, the 
% absolute difference is worked out first. There is then a calculation
% to see which way around everything has worked out, so that the final
% sign is correct. The difference might also give a zero result with
% a negative sign, which is reversed as zero is regarded as positive.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_add_difference: {
  \l_fp_output_integer_int
    \etex_numexpr:D
      \l_fp_input_a_integer_int - \l_fp_input_b_integer_int
    \scan_stop:
  \l_fp_output_decimal_int
    \etex_numexpr:D
      \l_fp_input_a_decimal_int - \l_fp_input_b_decimal_int
    \scan_stop:
  \tex_ifnum:D \l_fp_output_decimal_int < \c_zero
    \tex_advance:D \l_fp_output_integer_int \c_minus_one
    \tex_advance:D \l_fp_output_decimal_int \c_one_thousand_million
  \tex_fi:D
  \tex_ifnum:D \l_fp_output_integer_int < \c_zero
    \l_fp_output_sign_int \l_fp_input_b_sign_int 
    \tex_ifnum:D \l_fp_output_decimal_int = \c_zero
      \l_fp_output_integer_int -\l_fp_output_integer_int
    \tex_else:D
      \l_fp_output_decimal_int 
        \etex_numexpr:D
          \c_one_thousand_million - \l_fp_output_decimal_int 
        \scan_stop:
      \l_fp_output_integer_int
         \etex_numexpr:D
           - \l_fp_output_integer_int - \c_one
         \scan_stop:
    \tex_fi:D
  \tex_else:D
    \l_fp_output_sign_int \l_fp_input_a_sign_int  
  \tex_fi:D   
}
%    \end{macrocode}
%\end{macro}
%\end{macro} 
%\end{macro} 
%\end{macro}
%\end{macro} 
%\end{macro}
%
%
%
%
%\begin{macro}{\fp_sub:Nn, \fp_sub:cn}
%\UnitTested
%\begin{macro}{\fp_gsub:Nn,\fp_gsub:cn}
%\UnitTested
%\begin{macro}[aux]{\fp_sub_aux:NNn}
% Subtraction is essentially the same as addition, but with the sign
% of the second component reversed. Thus the core of the two function 
% groups is the same, with just a little set up here.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_sub:Nn {
  \fp_sub_aux:NNn \tl_set:Nn
}
\cs_new_protected_nopar:Npn \fp_gsub:Nn {
  \fp_sub_aux:NNn \tl_gset:Nn
}
\cs_generate_variant:Nn \fp_sub:Nn   { c }
\cs_generate_variant:Nn \fp_gsub:Nn  { c }
\cs_new_protected_nopar:Npn \fp_sub_aux:NNn #1#2#3 {
  \group_begin:
    \fp_read:N #2
    \fp_split:Nn b {#3}
    \fp_standardise:NNNN
      \l_fp_input_b_sign_int
      \l_fp_input_b_integer_int
      \l_fp_input_b_decimal_int
      \l_fp_input_b_exponent_int
    \tex_multiply:D \l_fp_input_b_sign_int \c_minus_one
    \fp_add_core:
  \fp_tmp:w #1#2
}
%    \end{macrocode}
%\end{macro}
%\end{macro} 
%\end{macro}
%
%
%
%
%
%\begin{macro}{\fp_mul:Nn, \fp_mul:cn}
%\UnitTested
%\begin{macro}{\fp_gmul:Nn,\fp_gmul:cn}
%\UnitTested
%\begin{macro}[aux]{\fp_mul_aux:NNn}
%\begin{macro}[aux]{\fp_mul_internal:}
%\begin{macro}[aux]{\fp_mul_split:NNNN}
%\begin{macro}[aux]{\fp_mul_split:w}
%\begin{macro}[aux]{\fp_mul_end_level:}
%\begin{macro}[aux]{\fp_mul_end_level:NNNNNNNNN}
% The pattern is much the same for multiplication.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_mul:Nn {
  \fp_mul_aux:NNn \tl_set:Nn 
}
\cs_new_protected_nopar:Npn \fp_gmul:Nn {
  \fp_mul_aux:NNn \tl_gset:Nn 
}
\cs_generate_variant:Nn \fp_mul:Nn  { c }
\cs_generate_variant:Nn \fp_gmul:Nn { c }
%    \end{macrocode}
% The approach to multiplication is as follows. First, the two numbers
% are split into blocks of three digits. These are then multiplied 
% together to find products for each group of three output digits. This 
% is al written out in full for speed reasons. Between each block of
% three digits in the output, there is a carry step. The very lowest
% digits are not calculated, while
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_mul_aux:NNn #1#2#3 {
  \group_begin:
    \fp_read:N #2
    \fp_split:Nn b {#3}
    \fp_standardise:NNNN
      \l_fp_input_b_sign_int
      \l_fp_input_b_integer_int
      \l_fp_input_b_decimal_int
      \l_fp_input_b_exponent_int
    \fp_mul_internal:
    \l_fp_output_exponent_int
      \etex_numexpr:D 
        \l_fp_input_a_exponent_int + \l_fp_input_b_exponent_int
      \scan_stop:  
    \fp_standardise:NNNN
      \l_fp_output_sign_int
      \l_fp_output_integer_int
      \l_fp_output_decimal_int
      \l_fp_output_exponent_int
    \cs_set_protected_nopar:Npx \fp_tmp:w
      {
        \group_end:
        #1 \exp_not:N #2
          {
            \tex_ifnum:D 
              \etex_numexpr:D 
                \l_fp_input_a_sign_int * \l_fp_input_b_sign_int
                < \c_zero
              \tex_ifnum:D
                \etex_numexpr:D 
                  \l_fp_output_integer_int + \l_fp_output_decimal_int
                  = \c_zero
                +    
              \tex_else:D    
                -
              \tex_fi:D
            \tex_else:D
              +
           \tex_fi:D
            \int_use:N \l_fp_output_integer_int
            .
            \tex_expandafter:D \use_none:n 
              \tex_number:D \etex_numexpr:D
                 \l_fp_output_decimal_int + \c_one_thousand_million
            e
            \int_use:N \l_fp_output_exponent_int
          }
      }
  \fp_tmp:w
}
%    \end{macrocode}
% Done separately so that the internal use is a bit easier.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_mul_internal: {
  \fp_mul_split:NNNN \l_fp_input_a_decimal_int
    \l_fp_mul_a_i_int \l_fp_mul_a_ii_int \l_fp_mul_a_iii_int
  \fp_mul_split:NNNN \l_fp_input_b_decimal_int
    \l_fp_mul_b_i_int \l_fp_mul_b_ii_int \l_fp_mul_b_iii_int
  \l_fp_mul_output_int \c_zero
  \tl_clear:N \l_fp_mul_output_tl
  \fp_mul_product:NN \l_fp_mul_a_i_int         \l_fp_mul_b_iii_int
  \fp_mul_product:NN \l_fp_mul_a_ii_int        \l_fp_mul_b_ii_int
  \fp_mul_product:NN \l_fp_mul_a_iii_int       \l_fp_mul_b_i_int
  \tex_divide:D \l_fp_mul_output_int \c_one_thousand
  \fp_mul_product:NN \l_fp_input_a_integer_int \l_fp_mul_b_iii_int
  \fp_mul_product:NN \l_fp_mul_a_i_int         \l_fp_mul_b_ii_int
  \fp_mul_product:NN \l_fp_mul_a_ii_int        \l_fp_mul_b_i_int
  \fp_mul_product:NN \l_fp_mul_a_iii_int       \l_fp_input_b_integer_int
  \fp_mul_end_level:
  \fp_mul_product:NN \l_fp_input_a_integer_int \l_fp_mul_b_ii_int
  \fp_mul_product:NN \l_fp_mul_a_i_int         \l_fp_mul_b_i_int
  \fp_mul_product:NN \l_fp_mul_a_ii_int        \l_fp_input_b_integer_int
  \fp_mul_end_level:
  \fp_mul_product:NN \l_fp_input_a_integer_int \l_fp_mul_b_i_int
  \fp_mul_product:NN \l_fp_mul_a_i_int         \l_fp_input_b_integer_int
  \fp_mul_end_level:
  \l_fp_output_decimal_int 0 \l_fp_mul_output_tl \scan_stop:
  \tl_clear:N \l_fp_mul_output_tl
  \fp_mul_product:NN \l_fp_input_a_integer_int \l_fp_input_b_integer_int
  \fp_mul_end_level:
  \l_fp_output_integer_int 0 \l_fp_mul_output_tl \scan_stop:
}
%    \end{macrocode}
% The split works by making a \( 10 \) digit number, from which 
% the first digit can then be dropped using a delimited argument. The
% groups of three digits are then assigned to the various parts of
% the input: notice that "##9" contains the last two digits of the
% smallest part of the input.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_mul_split:NNNN #1#2#3#4 {
  \tex_advance:D #1 \c_one_thousand_million
  \cs_set_protected_nopar:Npn \fp_mul_split_aux:w
    ##1##2##3##4##5##6##7##8##9 \q_stop {
      #2 ##2##3##4 \scan_stop:
      #3 ##5##6##7 \scan_stop:
      #4 ##8##9    \scan_stop:
    }
  \tex_expandafter:D \fp_mul_split_aux:w \int_use:N #1 \q_stop  
  \tex_advance:D #1 -\c_one_thousand_million  
}
\cs_new_protected_nopar:Npn \fp_mul_product:NN #1#2 {
  \l_fp_mul_output_int
    \etex_numexpr:D \l_fp_mul_output_int + #1 * #2 \scan_stop:
}
%    \end{macrocode}
% At the end of each output group of three, there is a transfer of
% information so that there is no danger of an overflow. This is done by
% expansion to keep the number of calculations down.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_mul_end_level: {
  \tex_advance:D \l_fp_mul_output_int \c_one_thousand_million
  \tex_expandafter:D \use_i:nn \tex_expandafter:D 
    \fp_mul_end_level:NNNNNNNNN \int_use:N \l_fp_mul_output_int
}
\cs_new_protected_nopar:Npn \fp_mul_end_level:NNNNNNNNN 
  #1#2#3#4#5#6#7#8#9 {
  \tl_set:Nx \l_fp_mul_output_tl { #7#8#9 \l_fp_mul_output_tl }
  \l_fp_mul_output_int #1#2#3#4#5#6 \scan_stop:
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro} 
%\end{macro} 
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%
%
%\begin{macro}{\fp_div:Nn, \fp_div:cn}
%\UnitTested
%\begin{macro}{\fp_gdiv:Nn,\fp_gdiv:cn}
%\UnitTested
%\begin{macro}[aux]{\fp_div_aux:NNn}
%\begin{macro}{\fp_div_internal:}
%\begin{macro}[aux]{\fp_div_loop:}
%\begin{macro}[aux]{\fp_div_divide:}
%\begin{macro}[aux]{\fp_div_divide_aux:}
%\begin{macro}[aux]{\fp_div_store:}
%\begin{macro}[aux]{\fp_div_store_integer:}
%\begin{macro}[aux]{\fp_div_store_decimal:}
% The pattern is much the same for multiplication.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_div:Nn {
  \fp_div_aux:NNn \tl_set:Nn 
}
\cs_new_protected_nopar:Npn \fp_gdiv:Nn {
  \fp_div_aux:NNn \tl_gset:Nn 
}
\cs_generate_variant:Nn \fp_div:Nn  { c }
\cs_generate_variant:Nn \fp_gdiv:Nn { c }
%    \end{macrocode}
% Division proper starts with a couple of tests. If the denominator is
% zero then a error is issued. On the other hand, if the numerator is
% zero then the result must be \( 0.0 \) and can be given with no
% further work. 
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_div_aux:NNn #1#2#3 {
  \group_begin:
    \fp_read:N #2
    \fp_split:Nn b {#3}
    \fp_standardise:NNNN
      \l_fp_input_b_sign_int
      \l_fp_input_b_integer_int
      \l_fp_input_b_decimal_int
      \l_fp_input_b_exponent_int
    \tex_ifnum:D
      \etex_numexpr:D 
        \l_fp_input_b_integer_int + \l_fp_input_b_decimal_int
        = \c_zero
      \cs_set_protected_nopar:Npx \fp_tmp:w ##1##2 
        { 
          \group_end:
          #1 \exp_not:N #2 { \c_undefined_fp } 
        } 
    \tex_else:D  
      \tex_ifnum:D
        \etex_numexpr:D 
          \l_fp_input_a_integer_int + \l_fp_input_a_decimal_int
          = \c_zero
        \cs_set_protected_nopar:Npx \fp_tmp:w ##1##2 
          { 
            \group_end:
            #1 \exp_not:N #2 { \c_zero_fp } 
          } 
      \tex_else:D  
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
          \fp_div_internal:  
      \tex_fi:D   
    \tex_fi:D 
  \fp_tmp:w #1#2  
}
%    \end{macrocode} 
% The main division algorithm works by finding how many times "b" can
% be removed from "a", storing the result and doing the subtraction.
% Input "a" is then multiplied by \( 10 \), and the process is repeated.
% The looping ends either when there is nothing left of "a" 
% (\emph{i.e.}~an exact result) or when the code reaches the ninth 
% decimal place. Most of the process takes place in the loop function
% below.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_div_internal: {
  \l_fp_output_integer_int \c_zero
  \l_fp_output_decimal_int \c_zero
  \cs_set_eq:NN \fp_div_store: \fp_div_store_integer:
  \l_fp_div_offset_int \c_one_hundred_million
  \fp_div_loop:
  \l_fp_output_exponent_int  
    \etex_numexpr:D 
      \l_fp_input_a_exponent_int - \l_fp_input_b_exponent_int 
    \scan_stop:
  \fp_standardise:NNNN
    \l_fp_output_sign_int
    \l_fp_output_integer_int
    \l_fp_output_decimal_int
    \l_fp_output_exponent_int
  \cs_set_protected_nopar:Npx \fp_tmp:w ##1##2 
    {
      \group_end:
      ##1 ##2
        {
          \tex_ifnum:D 
            \etex_numexpr:D 
              \l_fp_input_a_sign_int * \l_fp_input_b_sign_int
              < \c_zero
            \tex_ifnum:D
              \etex_numexpr:D 
                \l_fp_output_integer_int + \l_fp_output_decimal_int
                = \c_zero
              +    
            \tex_else:D    
              -
            \tex_fi:D
          \tex_else:D
            +
          \tex_fi:D
          \int_use:N \l_fp_output_integer_int
          .
          \tex_expandafter:D \use_none:n 
            \tex_number:D \etex_numexpr:D
               \l_fp_output_decimal_int + \c_one_thousand_million
             \scan_stop:  
          e
          \int_use:N \l_fp_output_exponent_int
        }  
    }
}
%    \end{macrocode}
% The main loop implements the approach described above. The storing
% function is done as a function so that the integer and decimal parts
% can be done separately but rapidly.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_div_loop: {
  \l_fp_count_int \c_zero
  \fp_div_divide: 
  \fp_div_store:
  \tex_multiply:D \l_fp_input_a_integer_int \c_ten
  \tex_advance:D \l_fp_input_a_decimal_int \c_one_thousand_million
  \tex_expandafter:D \fp_div_loop_step:w 
    \int_use:N \l_fp_input_a_decimal_int \q_stop
  \tex_ifnum:D
    \etex_numexpr:D
      \l_fp_input_a_integer_int + \l_fp_input_a_decimal_int
      > \c_zero
      \tex_ifnum:D \l_fp_div_offset_int > \c_zero 
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
          \fp_div_loop:
      \tex_fi:D 
  \tex_fi:D      
}
%    \end{macrocode}
% Checking to see if the numerator can be divides needs quite an
% involved check. Either the integer part has to be bigger for the
% numerator or, if it is not smaller then the decimal part of the
% numerator must not be smaller than that of the denominator. Once
% the test is right the rest is much as elsewhere.  
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_div_divide: {
  \tex_ifnum:D \l_fp_input_a_integer_int > \l_fp_input_b_integer_int
    \tex_expandafter:D \fp_div_divide_aux:
  \tex_else:D 
    \tex_ifnum:D \l_fp_input_a_integer_int < \l_fp_input_b_integer_int 
    \tex_else:D
      \tex_ifnum:D 
        \l_fp_input_a_decimal_int < \l_fp_input_b_decimal_int
      \tex_else:D
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \tex_expandafter:D \fp_div_divide_aux:
      \tex_fi:D  
    \tex_fi:D
  \tex_fi:D
}
\cs_new_protected_nopar:Npn \fp_div_divide_aux: {
  \tex_advance:D \l_fp_count_int \c_one
  \tex_advance:D \l_fp_input_a_integer_int -\l_fp_input_b_integer_int
  \tex_advance:D \l_fp_input_a_decimal_int -\l_fp_input_b_decimal_int
  \tex_ifnum:D \l_fp_input_a_decimal_int < \c_zero
    \tex_advance:D \l_fp_input_a_integer_int \c_minus_one
    \tex_advance:D \l_fp_input_a_decimal_int \c_one_thousand_million
  \tex_fi:D
  \fp_div_divide:
}
%    \end{macrocode}
% Storing the number of each division is done differently for the
% integer and decimal. The integer is easy and a one-off, while the
% decimal also needs to account for the position of the digit to store. 
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_div_store: { }
\cs_new_protected_nopar:Npn \fp_div_store_integer: {
  \l_fp_output_integer_int \l_fp_count_int
  \cs_set_eq:NN \fp_div_store: \fp_div_store_decimal:  
}
\cs_new_protected_nopar:Npn \fp_div_store_decimal: {
  \l_fp_output_decimal_int
    \etex_numexpr:D
      \l_fp_output_decimal_int + 
      \l_fp_count_int * \l_fp_div_offset_int
    \scan_stop:
  \tex_divide:D \l_fp_div_offset_int \c_ten
}
\cs_new_protected_nopar:Npn 
  \fp_div_loop_step:w #1#2#3#4#5#6#7#8#9 \q_stop {
  \l_fp_input_a_integer_int 
    \etex_numexpr:D
      #2 + \l_fp_input_a_integer_int 
    \scan_stop:
  \l_fp_input_a_decimal_int #3#4#5#6#7#8#9 0 \scan_stop:
}
%    \end{macrocode}
%\end{macro}
%\end{macro} 
%\end{macro} 
%\end{macro}
%\end{macro} 
%\end{macro} 
%\end{macro} 
%\end{macro}
%\end{macro} 
%\end{macro}
%
%
%
%
%
%\subsection{Arithmetic for internal use}
%
% For the more complex functions, it is only possible to deliver
% reliable \( 10 \) digit accuracy if the internal calculations are 
% carried out to a higher degree of precision. This is done using a
% second set of functions so that the `user' versions are not
% slowed down. These versions are also focussed on the needs of internal
% calculations. No error checking, sign checking or exponent levelling
% is done. For addition and subtraction, the arguments are:
% \begin{itemize}
%   \item Integer part of input "a".
%   \item Decimal part of input "a".
%   \item Additional decimal part of input "a".
%   \item Integer part of input "b".
%   \item Decimal part of input "b".
%   \item Additional decimal part of input "b".
%   \item Integer part of output.
%   \item Decimal part of output.
%   \item Additional decimal part of output.
% \end{itemize}
% The situation for multiplication and division is a little different as
% they only deal with the decimal part.
% 
%\begin{macro}{\fp_add:NNNNNNNNN}
% The internal sum is always exactly that: it is always a sum and there
% is no sign check.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_add:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  #7 \etex_numexpr:D #1 + #4 \scan_stop:
  #8 \etex_numexpr:D #2 + #5 \scan_stop:
  #9 \etex_numexpr:D #3 + #6 \scan_stop:
  \tex_ifnum:D #9 < \c_one_thousand_million
  \tex_else:D
    \tex_advance:D #8 \c_one
    \tex_advance:D #9 -\c_one_thousand_million
  \tex_fi:D 
  \tex_ifnum:D #8 < \c_one_thousand_million
  \tex_else:D
    \tex_advance:D #7 \c_one
    \tex_advance:D #8 -\c_one_thousand_million
  \tex_fi:D  
}
%    \end{macrocode}
%\end{macro} 
%
%\begin{macro}{\fp_sub:NNNNNNNNN}
% Internal subtraction is needed only when the first number is bigger 
% than the second, so there is no need to worry about the sign. This is 
% a good job as there are no arguments left. The flipping flag is
% used in the rare case where a sign change is possible.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_sub:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  #7 \etex_numexpr:D #1 - #4 \scan_stop:
  #8 \etex_numexpr:D #2 - #5 \scan_stop:
  #9 \etex_numexpr:D #3 - #6 \scan_stop:
  \tex_ifnum:D #9 < \c_zero
    \tex_advance:D #8 \c_minus_one
    \tex_advance:D #9 \c_one_thousand_million
  \tex_fi:D
  \tex_ifnum:D #8 < \c_zero
    \tex_advance:D #7 \c_minus_one
    \tex_advance:D #8 \c_one_thousand_million
  \tex_fi:D
  \tex_ifnum:D #7 < \c_zero
    \tex_ifnum:D \etex_numexpr:D #8 + #9 = \c_zero
      #7 -#7
    \tex_else:D
      \tex_advance:D #7 \c_one
      #8 \etex_numexpr:D \c_one_thousand_million - #8 \scan_stop:
      #9 \etex_numexpr:D \c_one_thousand_million - #9 \scan_stop:
    \tex_fi:D 
  \tex_fi:D 
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\fp_mul:NNNNNN}
% Decimal-part only multiplication but with higher accuracy than the
% user version.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_mul:NNNNNN #1#2#3#4#5#6 {
  \fp_mul_split:NNNN #1
    \l_fp_mul_a_i_int \l_fp_mul_a_ii_int \l_fp_mul_a_iii_int
  \fp_mul_split:NNNN #2
    \l_fp_mul_a_iv_int \l_fp_mul_a_v_int \l_fp_mul_a_vi_int
  \fp_mul_split:NNNN #3
    \l_fp_mul_b_i_int \l_fp_mul_b_ii_int \l_fp_mul_b_iii_int
  \fp_mul_split:NNNN #4
    \l_fp_mul_b_iv_int \l_fp_mul_b_v_int \l_fp_mul_b_vi_int
  \l_fp_mul_output_int \c_zero
  \tl_clear:N \l_fp_mul_output_tl
  \fp_mul_product:NN \l_fp_mul_a_i_int         \l_fp_mul_b_vi_int
  \fp_mul_product:NN \l_fp_mul_a_ii_int        \l_fp_mul_b_v_int
  \fp_mul_product:NN \l_fp_mul_a_iii_int       \l_fp_mul_b_iv_int
  \fp_mul_product:NN \l_fp_mul_a_iv_int        \l_fp_mul_b_iii_int
  \fp_mul_product:NN \l_fp_mul_a_v_int         \l_fp_mul_b_ii_int
  \fp_mul_product:NN \l_fp_mul_a_vi_int        \l_fp_mul_b_i_int
  \tex_divide:D \l_fp_mul_output_int \c_one_thousand
  \fp_mul_product:NN \l_fp_mul_a_i_int        \l_fp_mul_b_v_int
  \fp_mul_product:NN \l_fp_mul_a_ii_int       \l_fp_mul_b_iv_int
  \fp_mul_product:NN \l_fp_mul_a_iii_int      \l_fp_mul_b_iii_int
  \fp_mul_product:NN \l_fp_mul_a_iv_int       \l_fp_mul_b_ii_int
  \fp_mul_product:NN \l_fp_mul_a_v_int        \l_fp_mul_b_i_int
  \fp_mul_end_level:
  \fp_mul_product:NN \l_fp_mul_a_i_int        \l_fp_mul_b_iv_int
  \fp_mul_product:NN \l_fp_mul_a_ii_int       \l_fp_mul_b_iii_int
  \fp_mul_product:NN \l_fp_mul_a_iii_int      \l_fp_mul_b_ii_int
  \fp_mul_product:NN \l_fp_mul_a_iv_int       \l_fp_mul_b_i_int
  \fp_mul_end_level:
  \fp_mul_product:NN \l_fp_mul_a_i_int        \l_fp_mul_b_iii_int
  \fp_mul_product:NN \l_fp_mul_a_ii_int       \l_fp_mul_b_ii_int
  \fp_mul_product:NN \l_fp_mul_a_iii_int      \l_fp_mul_b_i_int
  \fp_mul_end_level:
  #6 0 \l_fp_mul_output_tl \scan_stop:
  \tl_clear:N \l_fp_mul_output_tl
  \fp_mul_product:NN \l_fp_mul_a_i_int        \l_fp_mul_b_ii_int
  \fp_mul_product:NN \l_fp_mul_a_ii_int       \l_fp_mul_b_i_int
  \fp_mul_end_level:
  \fp_mul_product:NN \l_fp_mul_a_i_int        \l_fp_mul_b_i_int
  \fp_mul_end_level:
  \fp_mul_end_level:
  #5 0 \l_fp_mul_output_tl \scan_stop:
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\fp_mul:NNNNNNNNN}
% For internal multiplication where the integer does need to be
% retained. This means of course that this code is quite slow, and so
% is only used when necessary.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_mul:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  \fp_mul_split:NNNN #2
    \l_fp_mul_a_i_int \l_fp_mul_a_ii_int \l_fp_mul_a_iii_int
  \fp_mul_split:NNNN #3
    \l_fp_mul_a_iv_int \l_fp_mul_a_v_int \l_fp_mul_a_vi_int
  \fp_mul_split:NNNN #5
    \l_fp_mul_b_i_int \l_fp_mul_b_ii_int \l_fp_mul_b_iii_int
  \fp_mul_split:NNNN #6
    \l_fp_mul_b_iv_int \l_fp_mul_b_v_int \l_fp_mul_b_vi_int
  \l_fp_mul_output_int \c_zero
  \tl_clear:N \l_fp_mul_output_tl
  \fp_mul_product:NN \l_fp_mul_a_i_int         \l_fp_mul_b_vi_int
  \fp_mul_product:NN \l_fp_mul_a_ii_int        \l_fp_mul_b_v_int
  \fp_mul_product:NN \l_fp_mul_a_iii_int       \l_fp_mul_b_iv_int
  \fp_mul_product:NN \l_fp_mul_a_iv_int        \l_fp_mul_b_iii_int
  \fp_mul_product:NN \l_fp_mul_a_v_int         \l_fp_mul_b_ii_int
  \fp_mul_product:NN \l_fp_mul_a_vi_int        \l_fp_mul_b_i_int
  \tex_divide:D \l_fp_mul_output_int \c_one_thousand
  \fp_mul_product:NN #1                       \l_fp_mul_b_vi_int
  \fp_mul_product:NN \l_fp_mul_a_i_int        \l_fp_mul_b_v_int
  \fp_mul_product:NN \l_fp_mul_a_ii_int       \l_fp_mul_b_iv_int
  \fp_mul_product:NN \l_fp_mul_a_iii_int      \l_fp_mul_b_iii_int
  \fp_mul_product:NN \l_fp_mul_a_iv_int       \l_fp_mul_b_ii_int
  \fp_mul_product:NN \l_fp_mul_a_v_int        \l_fp_mul_b_i_int
  \fp_mul_product:NN \l_fp_mul_a_vi_int       #4
  \fp_mul_end_level:
  \fp_mul_product:NN #1                       \l_fp_mul_b_v_int
  \fp_mul_product:NN \l_fp_mul_a_i_int        \l_fp_mul_b_iv_int
  \fp_mul_product:NN \l_fp_mul_a_ii_int       \l_fp_mul_b_iii_int
  \fp_mul_product:NN \l_fp_mul_a_iii_int      \l_fp_mul_b_ii_int
  \fp_mul_product:NN \l_fp_mul_a_iv_int       \l_fp_mul_b_i_int
  \fp_mul_product:NN \l_fp_mul_a_v_int        #4
  \fp_mul_end_level:
  \fp_mul_product:NN #1                       \l_fp_mul_b_iv_int
  \fp_mul_product:NN \l_fp_mul_a_i_int        \l_fp_mul_b_iii_int
  \fp_mul_product:NN \l_fp_mul_a_ii_int       \l_fp_mul_b_ii_int
  \fp_mul_product:NN \l_fp_mul_a_iii_int      \l_fp_mul_b_i_int
  \fp_mul_product:NN \l_fp_mul_a_iv_int       #4
  \fp_mul_end_level:
  #9 0 \l_fp_mul_output_tl \scan_stop:
  \tl_clear:N \l_fp_mul_output_tl
  \fp_mul_product:NN #1                       \l_fp_mul_b_iii_int
  \fp_mul_product:NN \l_fp_mul_a_i_int        \l_fp_mul_b_ii_int
  \fp_mul_product:NN \l_fp_mul_a_ii_int       \l_fp_mul_b_i_int
  \fp_mul_product:NN \l_fp_mul_a_iii_int      #4
  \fp_mul_end_level:
  \fp_mul_product:NN #1                       \l_fp_mul_b_ii_int
  \fp_mul_product:NN \l_fp_mul_a_i_int        \l_fp_mul_b_i_int
  \fp_mul_product:NN \l_fp_mul_a_ii_int       #4
  \fp_mul_end_level:
  \fp_mul_product:NN #1                       \l_fp_mul_b_i_int
  \fp_mul_product:NN \l_fp_mul_a_i_int        #4
  \fp_mul_end_level:
  #8 0 \l_fp_mul_output_tl \scan_stop:
  \tl_clear:N \l_fp_mul_output_tl
  \fp_mul_product:NN #1 #4
  \fp_mul_end_level:
  #7 0 \l_fp_mul_output_tl \scan_stop:
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\fp_div_integer:NNNNN}
% Here, division is always by an integer, and so it is possible to 
% use \TeX's native calculations rather than doing it in macros.
% The idea here is to divide the decimal part, find any remainder, 
% then do the real division of the two parts before adding in what 
% is needed for the remainder.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_div_integer:NNNNN #1#2#3#4#5 {
  \l_fp_tmp_int #1
  \tex_divide:D \l_fp_tmp_int #3
  \l_fp_tmp_int \etex_numexpr:D #1 - \l_fp_tmp_int * #3 \scan_stop:
  #4 #1
  \tex_divide:D #4 #3
  #5 #2
  \tex_divide:D #5 #3
  \tex_multiply:D \l_fp_tmp_int \c_one_thousand
  \tex_divide:D \l_fp_tmp_int #3
  #5 \etex_numexpr:D #5 + \l_fp_tmp_int * \c_one_million \scan_stop:
  \tex_ifnum:D #5 > \c_one_thousand_million
    \tex_advance:D #4 \c_one
    \tex_advancd:D #5 -\c_one_thousand_million
  \tex_fi:D
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\fp_extended_normalise:}
%\begin{macro}[aux]{\fp_extended_normalise_aux_i:}
%\begin{macro}[aux]{\fp_extended_normalise_aux_i:w}
%\begin{macro}[aux]{\fp_extended_normalise_aux_ii:w}
%\begin{macro}[aux]{\fp_extended_normalise_aux_ii:}
%\begin{macro}[aux]{\fp_extended_normalise_aux:NNNNNNNNN}
% The `extended' integers for internal use are mainly used in
% fixed-point mode. This comes up in a few places, so a generalised
% utility is made available to carry out the change. This function
% simply calls the two loops to shift the input to the point of 
% having a zero exponent.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_extended_normalise: {
  \fp_extended_normalise_aux_i:
  \fp_extended_normalise_aux_ii:
}
\cs_new_protected_nopar:Npn \fp_extended_normalise_aux_i: {
  \tex_ifnum:D \l_fp_input_a_exponent_int > \c_zero
    \tex_multiply:D \l_fp_input_a_integer_int \c_ten
    \tex_advance:D \l_fp_input_a_decimal_int \c_one_thousand_million
    \tex_expandafter:D \fp_extended_normalise_aux_i:w
      \int_use:N \l_fp_input_a_decimal_int \q_stop
     \tex_expandafter:D \fp_extended_normalise_aux_i:
   \tex_fi:D
}
\cs_new_protected_nopar:Npn 
  \fp_extended_normalise_aux_i:w #1#2#3#4#5#6#7#8#9 \q_stop {
  \l_fp_input_a_integer_int
    \etex_numexpr:D \l_fp_input_a_integer_int + #2 \scan_stop:
  \l_fp_input_a_decimal_int #3#4#5#6#7#8#9 0 \scan_stop:
  \tex_advance:D \l_fp_input_a_extended_int \c_one_thousand_million
  \tex_expandafter:D \fp_extended_normalise_aux_ii:w
      \int_use:N \l_fp_input_a_extended_int \q_stop
}
\cs_new_protected_nopar:Npn 
  \fp_extended_normalise_aux_ii:w #1#2#3#4#5#6#7#8#9 \q_stop {
  \l_fp_input_a_decimal_int
    \etex_numexpr:D \l_fp_input_a_decimal_int + #2 \scan_stop:
  \l_fp_input_a_extended_int #3#4#5#6#7#8#9 0 \scan_stop:
  \tex_advance:D \l_fp_input_a_exponent_int \c_minus_one
}
\cs_new_protected_nopar:Npn \fp_extended_normalise_aux_ii: {
  \tex_ifnum:D \l_fp_input_a_exponent_int < \c_zero
    \tex_advance:D \l_fp_input_a_decimal_int \c_one_thousand_million
    \tex_expandafter:D \use_i:nn \tex_expandafter:D 
      \fp_extended_normalise_ii_aux:NNNNNNNNN
      \int_use:N \l_fp_input_a_decimal_int
     \tex_expandafter:D \fp_extended_normalise_aux_ii:
   \tex_fi:D
}
\cs_new_protected_nopar:Npn 
  \fp_extended_normalise_ii_aux:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  \tex_ifnum:D \l_fp_input_a_integer_int = \c_zero
    \l_fp_input_a_decimal_int #1#2#3#4#5#6#7#8 \scan_stop:
  \tex_else:D
    \tl_set:Nx \l_fp_tmp_tl
      {
        \int_use:N \l_fp_input_a_integer_int 
        #1#2#3#4#5#6#7#8
      }
    \l_fp_input_a_integer_int \c_zero
    \l_fp_input_a_decimal_int \l_fp_tmp_tl \scan_stop:
  \tex_fi:D
  \tex_divide:D \l_fp_input_a_extended_int \c_ten
  \tl_set:Nx \l_fp_tmp_tl 
    {
      #9
      \int_use:N \l_fp_input_a_extended_int 
    }
  \l_fp_input_a_extended_int \l_fp_tmp_tl \scan_stop:
  \tex_advance:D \l_fp_input_a_exponent_int \c_one
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\fp_extended_normalise_output:}
%\begin{macro}[aux]{\fp_extended_normalise_output_aux_i:NNNNNNNNN}
%\begin{macro}[aux]{\fp_extended_normalise_output_aux_ii:NNNNNNNNN}
%\begin{macro}[aux]{\fp_extended_normalise_output_aux:N}
% At some stages in working out extended output, it is possible for the
% value to need shifting to keep the integer part in range. This only 
% ever happens such that the integer needs to be made smaller.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_extended_normalise_output: {
  \tex_ifnum:D \l_fp_output_integer_int > \c_nine
    \tex_advance:D \l_fp_output_integer_int \c_one_thousand_million
    \tex_expandafter:D \use_i:nn \tex_expandafter:D 
      \fp_extended_normalise_output_aux_i:NNNNNNNNN
      \int_use:N \l_fp_output_integer_int
    \tex_expandafter:D \fp_extended_normalise_output:
  \tex_fi:D
} 
\cs_new_protected_nopar:Npn 
  \fp_extended_normalise_output_aux_i:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  \l_fp_output_integer_int #1#2#3#4#5#6#7#8 \scan_stop:
  \tex_advance:D \l_fp_output_decimal_int \c_one_thousand_million
  \tl_set:Nx \l_fp_tmp_tl
    { 
      #9
      \tex_expandafter:D \use_none:n
      \int_use:N \l_fp_output_decimal_int
    }
  \tex_expandafter:D \fp_extended_normalise_output_aux_ii:NNNNNNNNN
    \l_fp_tmp_tl
}
\cs_new_protected_nopar:Npn 
  \fp_extended_normalise_output_aux_ii:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  \l_fp_output_decimal_int #1#2#3#4#5#6#7#8#9 \scan_stop:
  \fp_extended_normalise_output_aux:N
}
\cs_new_protected_nopar:Npn \fp_extended_normalise_output_aux:N #1 {
  \tex_advance:D \l_fp_output_extended_int \c_one_thousand_million
  \tex_divide:D \l_fp_output_extended_int \c_ten
  \tl_set:Nx \l_fp_tmp_tl
    {
      #1
      \tex_expandafter:D \use_none:n 
        \int_use:N \l_fp_output_extended_int
    }
  \l_fp_output_extended_int \l_fp_tmp_tl \scan_stop:
  \tex_advance:D \l_fp_output_exponent_int \c_one
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
% 
%\subsection{Trigonometric functions}
%
%\begin{macro}{\fp_trig_normalise:}
%\begin{macro}[aux]{\fp_trig_normalise_aux:}
%\begin{macro}[aux]{\fp_trig_sub:NNN}
% For normalisation, the code essentially switches to fixed-point 
% arithmetic. There is a shift of the exponent, then repeated 
% subtractions. The end result is a number in the range 
% \( -\pi < x \le \pi \).
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_trig_normalise: {
  \tex_ifnum:D \l_fp_input_a_exponent_int < \c_ten
    \l_fp_input_a_extended_int \c_zero
    \fp_extended_normalise:
    \fp_trig_normalise_aux:
    \tex_ifnum:D \l_fp_input_a_integer_int < \c_zero
      \l_fp_input_a_sign_int -\l_fp_input_a_sign_int
      \l_fp_input_a_integer_int -\l_fp_input_a_integer_int
    \tex_fi:D
     \tex_expandafter:D \fp_trig_octant:
  \tex_else:D
    \l_fp_input_a_sign_int    \c_one
    \l_fp_output_integer_int  \c_zero
    \l_fp_output_decimal_int  \c_zero
    \l_fp_output_exponent_int \c_zero
    \tex_expandafter:D \fp_trig_overflow_msg:
  \tex_fi:D
}
\cs_new_protected_nopar:Npn \fp_trig_normalise_aux: {
  \tex_ifnum:D \l_fp_input_a_integer_int > \c_three
    \fp_trig_sub:NNN
      \c_six \c_fp_two_pi_decimal_int \c_fp_two_pi_extended_int
    \tex_expandafter:D \fp_trig_normalise_aux:    
  \tex_else:D
    \tex_ifnum:D \l_fp_input_a_integer_int > \c_two
      \tex_ifnum:D \l_fp_input_a_decimal_int > \c_fp_pi_decimal_int
        \fp_trig_sub:NNN
          \c_six \c_fp_two_pi_decimal_int \c_fp_two_pi_extended_int 
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \tex_expandafter:D \fp_trig_normalise_aux:
        \tex_fi:D  
    \tex_fi:D
  \tex_fi:D
}
%    \end{macrocode}
% Here, there may be a sign change but there will never be any
% variation in the input. So a dedicated function can be used.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_trig_sub:NNN #1#2#3 {
  \l_fp_input_a_integer_int
    \etex_numexpr:D \l_fp_input_a_integer_int - #1 \scan_stop:
  \l_fp_input_a_decimal_int
    \etex_numexpr:D \l_fp_input_a_decimal_int - #2 \scan_stop:
  \l_fp_input_a_extended_int
    \etex_numexpr:D \l_fp_input_a_extended_int - #3 \scan_stop:
  \tex_ifnum:D \l_fp_input_a_extended_int < \c_zero
    \tex_advance:D \l_fp_input_a_decimal_int \c_minus_one
    \tex_advance:D \l_fp_input_a_extended_int \c_one_thousand_million
  \tex_fi:D
  \tex_ifnum:D \l_fp_input_a_decimal_int < \c_zero
    \tex_advance:D \l_fp_input_a_integer_int \c_minus_one
    \tex_advance:D \l_fp_input_a_decimal_int \c_one_thousand_million
  \tex_fi:D
  \tex_ifnum:D \l_fp_input_a_integer_int < \c_zero
    \l_fp_input_a_sign_int -\l_fp_input_a_sign_int
    \tex_ifnum:D
      \etex_numexpr:D 
        \l_fp_input_a_decimal_int + \l_fp_input_a_extended_int
      = \c_zero
      \l_fp_input_a_integer_int -\l_fp_input_a_integer_int
    \tex_else:D
      \l_fp_input_a_integer_int
         \etex_numexpr:D
           - \l_fp_input_a_integer_int - \c_one
         \scan_stop:
      \l_fp_input_a_decimal_int
        \etex_numexpr:D
          \c_one_thousand_million - \l_fp_input_a_decimal_int
        \scan_stop:
      \l_fp_input_a_extended_int
        \etex_numexpr:D
          \c_one_thousand_million - \l_fp_input_a_extended_int
        \scan_stop:
    \tex_fi:D
  \tex_fi:D   
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\fp_trig_octant:}
%\begin{macro}[aux]{\fp_trig_octant_aux:}
% Here, the input is further reduced into the range 
% \( 0 \le x < \pi / 4 \). This is pretty simple: check if 
% \( \pi / 4 \) can be taken off and if it can do it and loop. The
% check at the end is to `mop up' values which are so close to
% \( \pi / 4 \) that they should be treated as such.  The test for
% an even octant is needed as the `remainder' needed is from
% the nearest \( \pi / 2 \).
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_trig_octant: {
  \l_fp_trig_octant_int \c_one
  \fp_trig_octant_aux:
  \tex_ifnum:D \l_fp_input_a_decimal_int < \c_ten
    \l_fp_input_a_decimal_int  \c_zero
    \l_fp_input_a_extended_int \c_zero
  \tex_fi:D
  \tex_ifodd:D \l_fp_trig_octant_int
  \tex_else:D
    \fp_sub:NNNNNNNNN
      \c_zero \c_fp_pi_by_four_decimal_int \c_fp_pi_by_four_extended_int
      \l_fp_input_a_integer_int \l_fp_input_a_decimal_int 
        \l_fp_input_a_extended_int
      \l_fp_input_a_integer_int \l_fp_input_a_decimal_int 
        \l_fp_input_a_extended_int
  \tex_fi:D
}
\cs_new_protected_nopar:Npn \fp_trig_octant_aux: {
  \tex_ifnum:D \l_fp_input_a_integer_int > \c_zero
    \fp_sub:NNNNNNNNN
      \l_fp_input_a_integer_int \l_fp_input_a_decimal_int 
        \l_fp_input_a_extended_int
      \c_zero \c_fp_pi_by_four_decimal_int \c_fp_pi_by_four_extended_int
      \l_fp_input_a_integer_int \l_fp_input_a_decimal_int 
        \l_fp_input_a_extended_int
    \tex_advance:D \l_fp_trig_octant_int \c_one  
    \tex_expandafter:D \fp_trig_octant_aux: 
  \tex_else:D
    \tex_ifnum:D 
      \l_fp_input_a_decimal_int > \c_fp_pi_by_four_decimal_int
      \fp_sub:NNNNNNNNN
        \l_fp_input_a_integer_int \l_fp_input_a_decimal_int 
          \l_fp_input_a_extended_int
        \c_zero \c_fp_pi_by_four_decimal_int 
          \c_fp_pi_by_four_extended_int
        \l_fp_input_a_integer_int \l_fp_input_a_decimal_int 
          \l_fp_input_a_extended_int
      \tex_advance:D \l_fp_trig_octant_int \c_one      
      \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
        \fp_trig_octant_aux:   
    \tex_fi:D  
  \tex_fi:D
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%
%
%
%
%
%\begin{macro}{\fp_sin:Nn, \fp_sin:cn}
%\UnitTested
%\begin{macro}{\fp_gsin:Nn,\fp_gsin:cn}
%\UnitTested
%\begin{macro}[aux]{\fp_sin_aux:NNn}
%\begin{macro}[aux]{\fp_sin_aux_i:}
%\begin{macro}[aux]{\fp_sin_aux_ii:}
% Calculating the sine starts off in the usual way. There is a check
% to see if the value has already been worked out before proceeding
% further.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_sin:Nn {
  \fp_sin_aux:NNn \tl_set:Nn
}
\cs_new_protected_nopar:Npn \fp_gsin:Nn {
  \fp_sin_aux:NNn \tl_gset:Nn
}
\cs_generate_variant:Nn \fp_sin:Nn   { c }
\cs_generate_variant:Nn \fp_gsin:Nn  { c }
%    \end{macrocode}
% The internal routine for sines does a check to see if the value is 
% already known. This saves a lot of repetition when doing rotations. 
% For very small values it is best to simply return the input as the 
% sine: the cut-off is \( 1 \times 10^{-5} \). 
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_sin_aux:NNn #1#2#3 {
  \group_begin:
    \fp_split:Nn a {#3}
    \fp_standardise:NNNN
      \l_fp_input_a_sign_int
      \l_fp_input_a_integer_int
      \l_fp_input_a_decimal_int
      \l_fp_input_a_exponent_int  
    \tl_set:Nx \l_fp_arg_tl
      {
        \tex_ifnum:D \l_fp_input_a_sign_int < \c_zero
          -
        \tex_else:D
          +
        \tex_fi:D
        \int_use:N \l_fp_input_a_integer_int
        .
        \tex_expandafter:D \use_none:n 
          \tex_number:D \etex_numexpr:D 
            \l_fp_input_a_decimal_int + \c_one_thousand_million  
        e
        \int_use:N \l_fp_input_a_exponent_int
      }
    \tex_ifnum:D \l_fp_input_a_exponent_int < -\c_five
      \cs_set_protected_nopar:Npx \fp_tmp:w 
      {
        \group_end:
        #1 \exp_not:N #2 { \l_fp_arg_tl }
      }
    \tex_else:D
      \etex_ifcsname:D 
        c_fp_sin ( \l_fp_arg_tl ) _fp 
      \tex_endcsname:D
      \tex_else:D
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
          \fp_sin_aux_i:  
      \tex_fi:D  
      \cs_set_protected_nopar:Npx \fp_tmp:w 
        {
          \group_end:
          #1 \exp_not:N #2 
            { \use:c { c_fp_sin ( \l_fp_arg_tl ) _fp } }
        }
    \tex_fi:D  
  \fp_tmp:w 
}
%    \end{macrocode}
% The internals for sine first normalise the input into an octant, then
% choose the correct set up for the Taylor series. The sign for the sine
% function is easy, so there is no worry about it. So the only thing to
% do is to get the output standardised.   
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_sin_aux_i: {
  \fp_trig_normalise:
  \fp_sin_aux_ii:
  \tex_ifnum:D \l_fp_output_integer_int = \c_one
    \l_fp_output_exponent_int \c_zero
  \tex_else:D
    \l_fp_output_integer_int \l_fp_output_decimal_int
    \l_fp_output_decimal_int \l_fp_output_extended_int
    \l_fp_output_exponent_int -\c_nine
  \tex_fi:D
  \fp_standardise:NNNN
    \l_fp_input_a_sign_int
    \l_fp_output_integer_int
    \l_fp_output_decimal_int
    \l_fp_output_exponent_int
  \tl_new:c { c_fp_sin ( \l_fp_arg_tl ) _fp }
  \tl_gset:cx { c_fp_sin ( \l_fp_arg_tl ) _fp }
    {
      \tex_ifnum:D \l_fp_input_a_sign_int > \c_zero
        +
      \tex_else:D
        -
      \tex_fi:D    
      \int_use:N \l_fp_output_integer_int
      .
      \tex_expandafter:D \use_none:n 
        \tex_number:D \etex_numexpr:D
           \l_fp_output_decimal_int + \c_one_thousand_million
         \scan_stop:  
      e
      \int_use:N \l_fp_output_exponent_int    
    }
}
\cs_new_protected_nopar:Npn \fp_sin_aux_ii: {
  \tex_ifcase:D \l_fp_trig_octant_int
  \tex_or:D
    \tex_expandafter:D \fp_trig_calc_sin:
  \tex_or:D
    \tex_expandafter:D \fp_trig_calc_cos:
  \tex_or:D
    \tex_expandafter:D \fp_trig_calc_cos:
  \tex_or:D
    \tex_expandafter:D \fp_trig_calc_sin:
  \tex_fi:D
}
%    \end{macrocode}
%\end{macro} 
%\end{macro} 
%\end{macro}
%\end{macro} 
%\end{macro}
%
%
%
%
%
%\begin{macro}{\fp_cos:Nn, \fp_cos:cn}
%\UnitTested
%\begin{macro}{\fp_gcos:Nn,\fp_gcos:cn}
%\UnitTested
%\begin{macro}[aux]{\fp_cos_aux:NNn}
%\begin{macro}[aux]{\fp_cos_aux_i:}
%\begin{macro}[aux]{\fp_cos_aux_ii:}
% Cosine is almost identical, but there is no short cut code here.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_cos:Nn {
  \fp_cos_aux:NNn \tl_set:Nn
}
\cs_new_protected_nopar:Npn \fp_gcos:Nn {
  \fp_cos_aux:NNn \tl_gset:Nn
}
\cs_generate_variant:Nn \fp_cos:Nn   { c }
\cs_generate_variant:Nn \fp_gcos:Nn  { c }
\cs_new_protected_nopar:Npn \fp_cos_aux:NNn #1#2#3 {
  \group_begin:
    \fp_split:Nn a {#3}
    \fp_standardise:NNNN
      \l_fp_input_a_sign_int
      \l_fp_input_a_integer_int
      \l_fp_input_a_decimal_int
      \l_fp_input_a_exponent_int
    \tl_set:Nx \l_fp_arg_tl
      {
        \tex_ifnum:D \l_fp_input_a_sign_int < \c_zero
          -
        \tex_else:D
          +
        \tex_fi:D
        \int_use:N \l_fp_input_a_integer_int
        .
      \tex_expandafter:D \use_none:n 
        \tex_number:D \etex_numexpr:D
           \l_fp_input_a_decimal_int + \c_one_thousand_million
        e
        \int_use:N \l_fp_input_a_exponent_int
      }
    \etex_ifcsname:D c_fp_cos ( \l_fp_arg_tl ) _fp \tex_endcsname:D
    \tex_else:D
      \tex_expandafter:D \fp_cos_aux_i:  
    \tex_fi:D  
    \cs_set_protected_nopar:Npx \fp_tmp:w 
      {
        \group_end:
        #1 \exp_not:N #2 
          { \use:c { c_fp_cos ( \l_fp_arg_tl ) _fp } }
      }
  \fp_tmp:w 
}
%    \end{macrocode}
% Almost the same as for sine: just a bit of correction for the sign
% of the output.   
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_cos_aux_i: {
  \fp_trig_normalise:
  \fp_cos_aux_ii:
  \tex_ifnum:D \l_fp_output_integer_int = \c_one
    \l_fp_output_exponent_int \c_zero
  \tex_else:D
    \l_fp_output_integer_int \l_fp_output_decimal_int
    \l_fp_output_decimal_int \l_fp_output_extended_int
    \l_fp_output_exponent_int -\c_nine
  \tex_fi:D
  \fp_standardise:NNNN
    \l_fp_input_a_sign_int
    \l_fp_output_integer_int
    \l_fp_output_decimal_int
    \l_fp_output_exponent_int
  \tl_new:c { c_fp_cos ( \l_fp_arg_tl ) _fp }
  \tl_gset:cx { c_fp_cos ( \l_fp_arg_tl ) _fp }
    {
      \tex_ifnum:D \l_fp_input_a_sign_int > \c_zero
        +
      \tex_else:D
        -
      \tex_fi:D    
      \int_use:N \l_fp_output_integer_int
      .
      \tex_expandafter:D \use_none:n 
        \tex_number:D \etex_numexpr:D
           \l_fp_output_decimal_int + \c_one_thousand_million
         \scan_stop:  
      e
      \int_use:N \l_fp_output_exponent_int    
    }
}
\cs_new_protected_nopar:Npn \fp_cos_aux_ii: {
  \tex_ifcase:D \l_fp_trig_octant_int
  \tex_or:D
    \tex_expandafter:D \fp_trig_calc_cos:
  \tex_or:D
    \tex_expandafter:D \fp_trig_calc_sin:
  \tex_or:D
    \tex_expandafter:D \fp_trig_calc_sin:
  \tex_or:D
    \tex_expandafter:D \fp_trig_calc_cos:
  \tex_fi:D
  \tex_ifnum:D \l_fp_input_a_sign_int > \c_zero
    \tex_ifnum:D \l_fp_trig_octant_int > \c_two
      \l_fp_input_a_sign_int \c_minus_one
    \tex_fi:D
  \tex_else:D
    \tex_ifnum:D \l_fp_trig_octant_int > \c_two
    \tex_else:D
      \l_fp_input_a_sign_int \c_one
    \tex_fi:D
  \tex_fi:D
}
%    \end{macrocode}
%\end{macro} 
%\end{macro} 
%\end{macro}
%\end{macro} 
%\end{macro}
%
%
%
%
%
%\begin{macro}{\fp_trig_calc_cos:}
%\begin{macro}{\fp_trig_calc_sin:}
%\begin{macro}[aux]{\fp_trig_calc_Taylor:}
% These functions actually do the calculation for sine and cosine.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_trig_calc_cos: {
  \tex_ifnum:D \l_fp_input_a_decimal_int = \c_zero
    \l_fp_output_integer_int \c_one
    \l_fp_output_decimal_int \c_zero
  \tex_else:D  
    \l_fp_trig_sign_int \c_minus_one
    \fp_mul:NNNNNN
      \l_fp_input_a_decimal_int \l_fp_input_a_extended_int
      \l_fp_input_a_decimal_int \l_fp_input_a_extended_int
      \l_fp_trig_decimal_int \l_fp_trig_extended_int
    \fp_div_integer:NNNNN
      \l_fp_trig_decimal_int \l_fp_trig_extended_int
      \c_two
      \l_fp_trig_decimal_int \l_fp_trig_extended_int
    \l_fp_count_int \c_three
    \tex_ifnum:D \l_fp_trig_extended_int = \c_zero
      \tex_ifnum:D \l_fp_trig_decimal_int = \c_zero
        \l_fp_output_integer_int \c_one
        \l_fp_output_decimal_int \c_zero
        \l_fp_output_extended_int \c_zero
      \tex_else:D
        \l_fp_output_integer_int \c_zero
        \l_fp_output_decimal_int \c_one_thousand_million
        \l_fp_output_extended_int \c_zero
      \tex_fi:D
    \tex_else:D
      \l_fp_output_integer_int \c_zero
      \l_fp_output_decimal_int 999999999 \scan_stop:
      \l_fp_output_extended_int \c_one_thousand_million
    \tex_fi:D
    \tex_advance:D \l_fp_output_extended_int -\l_fp_trig_extended_int
    \tex_advance:D \l_fp_output_decimal_int -\l_fp_trig_decimal_int
    \tex_expandafter:D \fp_trig_calc_Taylor:
  \tex_fi:D
}
\cs_new_protected_nopar:Npn \fp_trig_calc_sin: {
  \l_fp_output_integer_int \c_zero
  \tex_ifnum:D \l_fp_input_a_decimal_int = \c_zero
    \l_fp_output_decimal_int \c_zero
  \tex_else:D  
    \l_fp_output_decimal_int \l_fp_input_a_decimal_int
    \l_fp_output_extended_int \l_fp_input_a_extended_int
    \l_fp_trig_sign_int \c_one
    \l_fp_trig_decimal_int \l_fp_input_a_decimal_int
    \l_fp_trig_extended_int \l_fp_input_a_extended_int
    \l_fp_count_int \c_two
    \tex_expandafter:D \fp_trig_calc_Taylor:
  \tex_fi:D
}
%    \end{macrocode}
% This implements a Taylor series calculation for the trigonometric
% functions. Lots of shuffling about as \TeX\ is not exactly a natural
% choice for this sort of thing.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_trig_calc_Taylor: {
  \l_fp_trig_sign_int -\l_fp_trig_sign_int
  \fp_mul:NNNNNN
    \l_fp_trig_decimal_int \l_fp_trig_extended_int
    \l_fp_input_a_decimal_int \l_fp_input_a_extended_int
    \l_fp_trig_decimal_int \l_fp_trig_extended_int
  \fp_mul:NNNNNN
    \l_fp_trig_decimal_int \l_fp_trig_extended_int
    \l_fp_input_a_decimal_int \l_fp_input_a_extended_int
    \l_fp_trig_decimal_int \l_fp_trig_extended_int
  \fp_div_integer:NNNNN
    \l_fp_trig_decimal_int \l_fp_trig_extended_int
    \l_fp_count_int
    \l_fp_trig_decimal_int \l_fp_trig_extended_int
  \tex_advance:D \l_fp_count_int \c_one
  \fp_div_integer:NNNNN
    \l_fp_trig_decimal_int \l_fp_trig_extended_int
    \l_fp_count_int
    \l_fp_trig_decimal_int \l_fp_trig_extended_int
  \tex_advance:D \l_fp_count_int \c_one
  \tex_ifnum:D \l_fp_trig_decimal_int > \c_zero
    \tex_ifnum:D \l_fp_trig_sign_int > \c_zero
      \tex_advance:D \l_fp_output_decimal_int \l_fp_trig_decimal_int
      \tex_advance:D \l_fp_output_extended_int 
        \l_fp_trig_extended_int
      \tex_ifnum:D \l_fp_output_extended_int < \c_one_thousand_million
      \tex_else:D
        \tex_advance:D \l_fp_output_decimal_int \c_one
        \tex_advance:D \l_fp_output_extended_int 
          -\c_one_thousand_million
      \tex_fi:D
      \tex_ifnum:D \l_fp_output_decimal_int < \c_one_thousand_million
      \tex_else:D
        \tex_advance:D \l_fp_output_integer_int \c_one
        \tex_advance:D \l_fp_output_decimal_int 
          -\c_one_thousand_million
      \tex_fi:D
    \tex_else:D
      \tex_advance:D \l_fp_output_decimal_int -\l_fp_trig_decimal_int
      \tex_advance:D \l_fp_output_extended_int 
        -\l_fp_input_a_extended_int
      \tex_ifnum:D \l_fp_output_extended_int < \c_zero
        \tex_advance:D \l_fp_output_decimal_int \c_minus_one
        \tex_advance:D \l_fp_output_extended_int \c_one_thousand_million
      \tex_fi:D 
      \tex_ifnum:D \l_fp_output_decimal_int < \c_zero
        \tex_advance:D \l_fp_output_integer_int \c_minus_one
        \tex_advance:D \l_fp_output_decimal_int \c_one_thousand_million
      \tex_fi:D   
    \tex_fi:D
    \tex_expandafter:D \fp_trig_calc_Taylor:
  \tex_fi:D
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%
%\begin{macro}{\fp_tan:Nn, \fp_tan:cn}
%\UnitTested
%\begin{macro}{\fp_gtan:Nn,\fp_gtan:cn}
%\UnitTested
%\begin{macro}[aux]{\fp_tan_aux:NNn}
%\begin{macro}[aux]{\fp_tan_aux_i:}
%\begin{macro}[aux]{\fp_tan_aux_ii:}
%\begin{macro}[aux]{\fp_tan_aux_iii:}
%\begin{macro}[aux]{\fp_tan_aux_iv:}
% As might be expected, tangents are calculated from the sine and cosine
% by division. So there is a bit of set up, the two subsidiary pieces
% of work are done and then a division takes place. For small numbers,
% the same approach is used as for sines, with the input value simply
% returned as is.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_tan:Nn {
  \fp_tan_aux:NNn \tl_set:Nn
}
\cs_new_protected_nopar:Npn \fp_gtan:Nn {
  \fp_tan_aux:NNn \tl_gset:Nn
}
\cs_generate_variant:Nn \fp_tan:Nn   { c }
\cs_generate_variant:Nn \fp_gtan:Nn  { c }
\cs_new_protected_nopar:Npn \fp_tan_aux:NNn #1#2#3 {
  \group_begin:
    \fp_split:Nn a {#3}
    \fp_standardise:NNNN
      \l_fp_input_a_sign_int
      \l_fp_input_a_integer_int
      \l_fp_input_a_decimal_int
      \l_fp_input_a_exponent_int
    \tl_set:Nx \l_fp_arg_tl
      {
        \tex_ifnum:D \l_fp_input_a_sign_int < \c_zero
          -
        \tex_else:D
          +
        \tex_fi:D
        \int_use:N \l_fp_input_a_integer_int
        .
        \tex_expandafter:D \use_none:n 
          \tex_number:D \etex_numexpr:D 
            \l_fp_input_a_decimal_int + \c_one_thousand_million  
        e
        \int_use:N \l_fp_input_a_exponent_int
      }
    \tex_ifnum:D \l_fp_input_a_exponent_int < -\c_five
      \cs_set_protected_nopar:Npx \fp_tmp:w 
      {
        \group_end:
        #1 \exp_not:N #2 { \l_fp_arg_tl }
      }
    \tex_else:D
      \etex_ifcsname:D 
        c_fp_tan ( \l_fp_arg_tl ) _fp 
      \tex_endcsname:D
      \tex_else:D
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
          \fp_tan_aux_i:  
      \tex_fi:D  
      \cs_set_protected_nopar:Npx \fp_tmp:w 
        {
          \group_end:
          #1 \exp_not:N #2 
            { \use:c { c_fp_tan ( \l_fp_arg_tl ) _fp } }
        }
    \tex_fi:D 
  \fp_tmp:w 
}
%    \end{macrocode}
% The business of the calculation does not check for stored sines or
% cosines as there would then be an overhead to reading them back in.
% There is also no need to worry about `small' sine values as
% these will have been dealt with earlier. There is a two-step lead off
% so that undefined division is not even attempted.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_tan_aux_i: {
  \tex_ifnum:D \l_fp_input_a_exponent_int < \c_ten
    \tex_expandafter:D \fp_tan_aux_ii:
  \tex_else:D
    \cs_new_eq:cN { c_fp_tan ( \l_fp_arg_tl ) _fp } 
      \c_zero_fp
    \tex_expandafter:D \fp_trig_overflow_msg:
  \tex_fi:D  
}
\cs_new_protected_nopar:Npn \fp_tan_aux_ii: {
  \fp_trig_normalise:
  \tex_ifnum:D \l_fp_input_a_sign_int > \c_zero
    \tex_ifnum:D \l_fp_trig_octant_int > \c_two
      \l_fp_output_sign_int \c_minus_one
    \tex_else:D
      \l_fp_output_sign_int \c_one  
    \tex_fi:D
  \tex_else:D
    \tex_ifnum:D \l_fp_trig_octant_int > \c_two
      \l_fp_output_sign_int \c_one
    \tex_else:D
      \l_fp_output_sign_int \c_minus_one  
    \tex_fi:D
  \tex_fi:D
  \fp_cos_aux_ii:
  \tex_ifnum:D \l_fp_input_a_decimal_int = \c_zero
    \tex_ifnum:D \l_fp_input_a_integer_int = \c_zero
      \cs_new_eq:cN { c_fp_tan ( \l_fp_arg_tl ) _fp } 
        \c_undefined_fp
    \tex_else:D
      \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
        \fp_tan_aux_iii:
    \tex_fi:D
  \tex_else:D
    \tex_expandafter:D \fp_tan_aux_iii:
  \tex_fi:D
}
%    \end{macrocode}
% The division is done here using the same code as the standard division
% unit, shifting the digits in the calculated sine and cosine to 
% maintain accuracy.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_tan_aux_iii: {
  \l_fp_input_b_integer_int \l_fp_output_decimal_int
  \l_fp_input_b_decimal_int \l_fp_output_extended_int
  \l_fp_input_b_exponent_int -\c_nine
  \fp_standardise:NNNN
    \l_fp_input_b_sign_int
    \l_fp_input_b_integer_int
    \l_fp_input_b_decimal_int
    \l_fp_input_b_exponent_int
  \fp_sin_aux_ii:
  \l_fp_input_a_integer_int \l_fp_output_decimal_int
  \l_fp_input_a_decimal_int \l_fp_output_extended_int
  \l_fp_input_a_exponent_int -\c_nine
  \fp_standardise:NNNN
    \l_fp_input_a_sign_int
    \l_fp_input_a_integer_int
    \l_fp_input_a_decimal_int
    \l_fp_input_a_exponent_int
  \tex_ifnum:D \l_fp_input_a_decimal_int = \c_zero
    \tex_ifnum:D \l_fp_input_a_integer_int = \c_zero
      \cs_new_eq:cN { c_fp_tan ( \l_fp_arg_tl ) _fp } 
        \c_zero_fp
    \tex_else:D
      \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
        \fp_tan_aux_iv:
    \tex_fi:D
  \tex_else:D
    \tex_expandafter:D \fp_tan_aux_iv:
  \tex_fi:D
}
 \cs_new_protected_nopar:Npn \fp_tan_aux_iv: { 
  \l_fp_output_integer_int \c_zero
  \l_fp_output_decimal_int \c_zero
  \cs_set_eq:NN \fp_div_store: \fp_div_store_integer:
  \l_fp_div_offset_int \c_one_hundred_million
  \fp_div_loop:
  \l_fp_output_exponent_int  
    \etex_numexpr:D 
      \l_fp_input_a_exponent_int - \l_fp_input_b_exponent_int 
    \scan_stop:
  \fp_standardise:NNNN
    \l_fp_output_sign_int
    \l_fp_output_integer_int
    \l_fp_output_decimal_int
    \l_fp_output_exponent_int
  \tl_new:c { c_fp_tan ( \l_fp_arg_tl ) _fp }
  \tl_gset:cx { c_fp_tan ( \l_fp_arg_tl ) _fp }
    {
      \tex_ifnum:D \l_fp_output_sign_int > \c_zero
        +
      \tex_else:D
        -
      \tex_fi:D    
      \int_use:N \l_fp_output_integer_int
      .
      \tex_expandafter:D \use_none:n 
        \tex_number:D \etex_numexpr:D
           \l_fp_output_decimal_int + \c_one_thousand_million
         \scan_stop:  
      e
      \int_use:N \l_fp_output_exponent_int    
    }
}
%    \end{macrocode}
%\end{macro} 
%\end{macro} 
%\end{macro} 
%\end{macro}
%\end{macro} 
%\end{macro} 
%\end{macro}
%
%
%
%
%
%
%\subsection{Exponent and logarithm functions}
%
%\begin{macro}[aux]{\c_fp_exp_1_tl}
%\begin{macro}[aux]{\c_fp_exp_2_tl}
%\begin{macro}[aux]{\c_fp_exp_3_tl}
%\begin{macro}[aux]{\c_fp_exp_4_tl}
%\begin{macro}[aux]{\c_fp_exp_5_tl}
%\begin{macro}[aux]{\c_fp_exp_6_tl}
%\begin{macro}[aux]{\c_fp_exp_7_tl}
%\begin{macro}[aux]{\c_fp_exp_8_tl}
%\begin{macro}[aux]{\c_fp_exp_9_tl}
%\begin{macro}[aux]{\c_fp_exp_10_tl}
%\begin{macro}[aux]{\c_fp_exp_20_tl}
%\begin{macro}[aux]{\c_fp_exp_30_tl}
%\begin{macro}[aux]{\c_fp_exp_40_tl}
%\begin{macro}[aux]{\c_fp_exp_50_tl}
%\begin{macro}[aux]{\c_fp_exp_60_tl}
%\begin{macro}[aux]{\c_fp_exp_70_tl}
%\begin{macro}[aux]{\c_fp_exp_80_tl}
%\begin{macro}[aux]{\c_fp_exp_90_tl}
%\begin{macro}[aux]{\c_fp_exp_100_tl}
%\begin{macro}[aux]{\c_fp_exp_200_tl}
% Calculation of exponentials requires a number of precomputed values:
% first the positive integers.
%    \begin{macrocode}
\tl_new:c { c_fp_exp_1_tl }
\tl_set:cn { c_fp_exp_1_tl }
  { { 2 } { 718281828 } { 459045235 } { 0 } }
\tl_new:c { c_fp_exp_2_tl }
\tl_set:cn { c_fp_exp_2_tl }
  { { 7 } { 389056098 } { 930650227 } { 0 } }
\tl_new:c { c_fp_exp_3_tl }
\tl_set:cn { c_fp_exp_3_tl }
  { { 2 } { 008553692 } { 318766774 } { 1 } }
\tl_new:c { c_fp_exp_4_tl }
\tl_set:cn { c_fp_exp_4_tl }
  { { 5 } { 459815003 } { 314423908 } { 1 } }
\tl_new:c { c_fp_exp_5_tl }
\tl_set:cn { c_fp_exp_5_tl }
  { { 1 } { 484131591 } { 025766034 } { 2 } }
\tl_new:c { c_fp_exp_6_tl }
\tl_set:cn { c_fp_exp_6_tl }
  { { 4 } { 034287934 } { 927351226 } { 2 } }
\tl_new:c { c_fp_exp_7_tl }
\tl_set:cn { c_fp_exp_7_tl }
  { { 1 } { 096633158 } { 428458599 } { 3 } }
\tl_new:c { c_fp_exp_8_tl }
\tl_set:cn { c_fp_exp_8_tl }
  { { 2 } { 980957987 } { 041728275 } { 3 } }
\tl_new:c { c_fp_exp_9_tl }
\tl_set:cn { c_fp_exp_9_tl }
  { { 8 } { 103083927 } { 575384008 } { 3 } }
\tl_new:c { c_fp_exp_10_tl }
\tl_set:cn { c_fp_exp_10_tl }
  { { 2 } { 202646579 } { 480671652 } { 4 } }
\tl_new:c { c_fp_exp_20_tl }
\tl_set:cn { c_fp_exp_20_tl }
  { { 4 } { 851651954 } { 097902280 } { 8 } }
\tl_new:c { c_fp_exp_30_tl }
\tl_set:cn { c_fp_exp_30_tl }
  { { 1 } { 068647458 } { 152446215 } { 13 } }
\tl_new:c { c_fp_exp_40_tl }
\tl_set:cn { c_fp_exp_40_tl }
  { { 2 } { 353852668 } { 370199854 } { 17 } }
\tl_new:c { c_fp_exp_50_tl }
\tl_set:cn { c_fp_exp_50_tl }
  { { 5 } { 184705528 } { 587072464 } { 21 } }
\tl_new:c { c_fp_exp_60_tl }
\tl_set:cn { c_fp_exp_60_tl }
  { { 1 } { 142007389 } { 815684284 } { 26 } }
\tl_new:c { c_fp_exp_70_tl }
\tl_set:cn { c_fp_exp_70_tl }
  { { 2 } { 515438670 } { 919167006 } { 30 } }
\tl_new:c { c_fp_exp_80_tl }
\tl_set:cn { c_fp_exp_80_tl }
  { { 5 } { 540622384 } { 393510053 } { 34 } }
\tl_new:c { c_fp_exp_90_tl }
\tl_set:cn { c_fp_exp_90_tl }
  { { 1 } { 220403294 } { 317840802 } { 39 } }
\tl_new:c { c_fp_exp_100_tl }
\tl_set:cn { c_fp_exp_100_tl }
  { { 2 } { 688117141 } { 816135448 } { 43 } }
\tl_new:c { c_fp_exp_200_tl }
\tl_set:cn { c_fp_exp_200_tl }
  { { 7 } { 225973768 } { 125749258 } { 86 } }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%
%\begin{macro}[aux]{\c_fp_exp_-1_tl}
%\begin{macro}[aux]{\c_fp_exp_-2_tl}
%\begin{macro}[aux]{\c_fp_exp_-3_tl}
%\begin{macro}[aux]{\c_fp_exp_-4_tl}
%\begin{macro}[aux]{\c_fp_exp_-5_tl}
%\begin{macro}[aux]{\c_fp_exp_-6_tl}
%\begin{macro}[aux]{\c_fp_exp_-7_tl}
%\begin{macro}[aux]{\c_fp_exp_-8_tl}
%\begin{macro}[aux]{\c_fp_exp_-9_tl}
%\begin{macro}[aux]{\c_fp_exp_-10_tl}
%\begin{macro}[aux]{\c_fp_exp_-20_tl}
%\begin{macro}[aux]{\c_fp_exp_-30_tl}
%\begin{macro}[aux]{\c_fp_exp_-40_tl}
%\begin{macro}[aux]{\c_fp_exp_-50_tl}
%\begin{macro}[aux]{\c_fp_exp_-60_tl}
%\begin{macro}[aux]{\c_fp_exp_-70_tl}
%\begin{macro}[aux]{\c_fp_exp_-80_tl}
%\begin{macro}[aux]{\c_fp_exp_-90_tl}
%\begin{macro}[aux]{\c_fp_exp_-100_tl}
%\begin{macro}[aux]{\c_fp_exp_-200_tl}
% Now the negative integers.
%    \begin{macrocode}
\tl_new:c { c_fp_exp_-1_tl }
\tl_set:cn { c_fp_exp_-1_tl }
  { { 3 } { 678794411 } { 71442322 } { -1 } }
\tl_new:c { c_fp_exp_-2_tl }
\tl_set:cn { c_fp_exp_-2_tl }
  { { 1 } { 353352832 } { 366132692 } { -1 } }
\tl_new:c { c_fp_exp_-3_tl }
\tl_set:cn { c_fp_exp_-3_tl }
  { { 4 } { 978706836 } { 786394298 } { -2 } }
\tl_new:c { c_fp_exp_-4_tl }
\tl_set:cn { c_fp_exp_-4_tl }
  { { 1 } { 831563888 } { 873418029 } { -2 } }
\tl_new:c { c_fp_exp_-5_tl }
\tl_set:cn { c_fp_exp_-5_tl }
  { { 6 } { 737946999 } { 085467097 } { -3 } }
\tl_new:c { c_fp_exp_-6_tl }
\tl_set:cn { c_fp_exp_-6_tl }
  { { 2 } { 478752176 } { 666358423 } { -3 } }
\tl_new:c { c_fp_exp_-7_tl }
\tl_set:cn { c_fp_exp_-7_tl }
  { { 9 } { 118819655 } { 545162080 } { -4 } }
\tl_new:c { c_fp_exp_-8_tl }
\tl_set:cn { c_fp_exp_-8_tl }
  { { 3 } { 354626279 } { 025118388 } { -4 } }
\tl_new:c { c_fp_exp_-9_tl }
\tl_set:cn { c_fp_exp_-9_tl }
  { { 1 } { 234098040 } { 866795495 } { -4 } }
\tl_new:c { c_fp_exp_-10_tl }
\tl_set:cn { c_fp_exp_-10_tl }
  { { 4 } { 539992976 } { 248451536 } { -5 } }
\tl_new:c { c_fp_exp_-20_tl }
\tl_set:cn { c_fp_exp_-20_tl }
  { { 2 } { 061153622 } { 438557828 } { -9 } }
\tl_new:c { c_fp_exp_-30_tl }
\tl_set:cn { c_fp_exp_-30_tl }
  { { 9 } { 357622968 } { 840174605 } { -14 } }
\tl_new:c { c_fp_exp_-40_tl }
\tl_set:cn { c_fp_exp_-40_tl }
  { { 4 } { 248354255 } { 291588995 } { -18 } }
\tl_new:c { c_fp_exp_-50_tl }
\tl_set:cn { c_fp_exp_-50_tl }
  { { 1 } { 928749847 } { 963917783 } { -22 } }
\tl_new:c { c_fp_exp_-60_tl }
\tl_set:cn { c_fp_exp_-60_tl }
  { { 8 } { 756510762 } { 696520338 } { -27 } }
\tl_new:c { c_fp_exp_-70_tl }
\tl_set:cn { c_fp_exp_-70_tl }
  { { 3 } { 975449735 } { 908646808 } { -31 } }
\tl_new:c { c_fp_exp_-80_tl }
\tl_set:cn { c_fp_exp_-80_tl }
  { { 1 } { 804851387 } { 845415172 } { -35 } }
\tl_new:c { c_fp_exp_-90_tl }
\tl_set:cn { c_fp_exp_-90_tl }
  { { 8 } { 194012623 } { 990515430 } { -40 } }
\tl_new:c { c_fp_exp_-100_tl }
\tl_set:cn { c_fp_exp_-100_tl }
  { { 3 } { 720075976 } { 020835963 } { -44 } }
\tl_new:c { c_fp_exp_-200_tl }
\tl_set:cn { c_fp_exp_-200_tl }
  { { 1 } { 383896526 } { 736737530 } { -87 } }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%
%
%
%
%\begin{macro}{\fp_exp:Nn, \fp_exp:cn}
%\UnitTested
%\begin{macro}{\fp_gexp:Nn,\fp_gexp:cn}
%\UnitTested
%\begin{macro}[aux]{\fp_exp_aux:NNn}
%\begin{macro}[aux]{\fp_exp_internal:}
%\begin{macro}[aux]{\fp_exp_aux:}
%\begin{macro}[aux]{\fp_exp_integer:}
%\begin{macro}[aux]{\fp_exp_integer_tens:}
%\begin{macro}[aux]{\fp_exp_integer_units:}
%\begin{macro}[aux]{\fp_exp_integer_const:n}
%\begin{macro}[aux]{\fp_exp_integer_const:nnnn}
%\begin{macro}[aux]{\fp_exp_decimal:}
%\begin{macro}[aux]{\fp_exp_Taylor:}
%\begin{macro}[aux]{\fp_exp_const:Nx}
%\begin{macro}[aux]{\fp_exp_const:cx}
% The calculation of an exponent starts off starts in much the same
% way as the trigonometric functions: normalise the input, look for
% a pre-defined value and if one is not found hand off to the real
% workhorse function. The test for a definition of the result is used
% so that overflows do not result in any outcome being defined.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_exp:Nn {
  \fp_exp_aux:NNn \tl_set:Nn
}
\cs_new_protected_nopar:Npn \fp_gexp:Nn {
  \fp_exp_aux:NNn \tl_gset:Nn
}
\cs_generate_variant:Nn \fp_exp:Nn  { c }
\cs_generate_variant:Nn \fp_gexp:Nn { c }
\cs_new_protected_nopar:Npn \fp_exp_aux:NNn #1#2#3 {
  \group_begin:
    \fp_split:Nn a {#3}
    \fp_standardise:NNNN
      \l_fp_input_a_sign_int
      \l_fp_input_a_integer_int
      \l_fp_input_a_decimal_int
      \l_fp_input_a_exponent_int
    \l_fp_input_a_extended_int \c_zero
    \tl_set:Nx \l_fp_arg_tl
      {
        \tex_ifnum:D \l_fp_input_a_sign_int < \c_zero
          -
        \tex_else:D
          +
        \tex_fi:D
        \int_use:N \l_fp_input_a_integer_int
        .
        \tex_expandafter:D \use_none:n 
          \tex_number:D \etex_numexpr:D
             \l_fp_input_a_decimal_int + \c_one_thousand_million
        e
        \int_use:N \l_fp_input_a_exponent_int
      }
    \etex_ifcsname:D c_fp_exp ( \l_fp_arg_tl ) _fp \tex_endcsname:D
    \tex_else:D
      \tex_expandafter:D \fp_exp_internal:  
    \tex_fi:D  
    \cs_set_protected_nopar:Npx \fp_tmp:w 
      {
        \group_end:
        #1 \exp_not:N #2 
          { 
            \etex_ifcsname:D c_fp_exp ( \l_fp_arg_tl ) _fp 
              \tex_endcsname:D
              \use:c { c_fp_exp ( \l_fp_arg_tl ) _fp } 
            \tex_else:D
              \c_zero_fp
            \tex_fi:D  
          }
      }
  \fp_tmp:w 
}
%    \end{macrocode}
% The first real step is to convert the input into a fixed-point
% representation for further calculation: anything which is dropped
% here as too small would not influence the output in any case. There
% are a couple of overflow tests: the maximum 
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_exp_internal: {
  \tex_ifnum:D \l_fp_input_a_exponent_int < \c_three
    \fp_extended_normalise:
    \tex_ifnum:D \l_fp_input_a_sign_int > \c_zero
      \tex_ifnum:D \l_fp_input_a_integer_int < 230 \scan_stop:
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
          \tex_expandafter:D \fp_exp_aux:
      \tex_else:D
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
          \tex_expandafter:D \fp_exp_overflow_msg:
        \tex_fi:D
    \tex_else:D
      \tex_ifnum:D \l_fp_input_a_integer_int < 230 \scan_stop:
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
          \tex_expandafter:D  \fp_exp_aux: 
      \tex_else:D
        \fp_exp_const:cx { c_fp_exp ( \l_fp_arg_tl ) _fp } 
          { \c_zero_fp }
      \tex_fi:D    
    \tex_fi:D      
  \tex_else:D
    \tex_expandafter:D \fp_exp_overflow_msg:
  \tex_fi:D
}
%    \end{macrocode}
% The main algorithm makes use of the fact that 
% \[ 
%   \mathrm{e}^{nmp.q} = 
%     \mathrm{e}^{n} 
%     \mathrm{e}^{m}
%     \mathrm{e}^{p}
%     \mathrm{e}^{0.q}
% \]
% and that there is a Taylor series that can be used to calculate
% \( \mathrm{e}^{0.q} \). Thus the approach needed is in three parts.
% First, the exponent of the integer part of the input is found
% using the pre-calculated constants. Second, the Taylor series is
% used to find the exponent for the decimal part of the input. Finally,
% the two parts are multiplied together to give the result. As the
% normalisation code will already have dealt with any overflowing
% values, there are no further checks needed.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_exp_aux: {
  \tex_ifnum:D \l_fp_input_a_integer_int > \c_zero 
    \tex_expandafter:D \fp_exp_integer:
  \tex_else:D
    \l_fp_output_integer_int  \c_one
    \l_fp_output_decimal_int  \c_zero
    \l_fp_output_extended_int \c_zero
    \l_fp_output_exponent_int \c_zero
    \tex_expandafter:D \fp_exp_decimal:
  \tex_fi:D
}
%    \end{macrocode}
% The integer part calculation starts with the hundreds. This is
% set up such that very large negative numbers can short-cut the entire
% procedure and simply return zero. In other cases, the code either
% recovers the exponent of the hundreds value or sets the appropriate
% storage to one (so that multiplication works correctly).
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_exp_integer: {
  \tex_ifnum:D \l_fp_input_a_integer_int < \c_one_hundred
    \l_fp_exp_integer_int  \c_one
    \l_fp_exp_decimal_int  \c_zero
    \l_fp_exp_extended_int \c_zero
    \l_fp_exp_exponent_int \c_zero
    \tex_expandafter:D \fp_exp_integer_tens:
  \tex_else:D
    \tl_set:Nx \l_fp_tmp_tl
      { 
        \tex_expandafter:D \use_i:nnn
          \int_use:N \l_fp_input_a_integer_int 
      }
    \l_fp_input_a_integer_int 
      \etex_numexpr:D
        \l_fp_input_a_integer_int - \l_fp_tmp_tl 00
      \scan_stop:
    \tex_ifnum:D \l_fp_input_a_sign_int < \c_zero 
      \tex_ifnum:D \l_fp_output_integer_int > 200 \scan_stop:
        \fp_exp_const:cx { c_fp_exp ( \l_fp_arg_tl ) _fp } 
          { \c_zero_fp }
      \tex_else:D
        \fp_exp_integer_const:n { - \l_fp_tmp_tl 00 }
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
          \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
          \tex_expandafter:D \fp_exp_integer_tens:  
      \tex_fi:D
    \tex_else:D  
      \fp_exp_integer_const:n { \l_fp_tmp_tl 00 }
      \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D 
        \tex_expandafter:D \fp_exp_integer_tens:  
    \tex_fi:D  
  \tex_fi:D
}
%    \end{macrocode}
% The tens and units parts are handled in a similar way, with a
% multiplication step to build up the final value. That also includes a
% correction step to avoid an overflow of the integer part.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_exp_integer_tens: {
  \l_fp_output_integer_int  \l_fp_exp_integer_int
  \l_fp_output_decimal_int  \l_fp_exp_decimal_int
  \l_fp_output_extended_int \l_fp_exp_extended_int
  \l_fp_output_exponent_int \l_fp_exp_exponent_int
  \tex_ifnum:D \l_fp_input_a_integer_int > \c_nine
    \tl_set:Nx \l_fp_tmp_tl
      { 
        \tex_expandafter:D \use_i:nn 
          \int_use:N \l_fp_input_a_integer_int 
      }
    \l_fp_input_a_integer_int 
      \etex_numexpr:D
        \l_fp_input_a_integer_int - \l_fp_tmp_tl 0
      \scan_stop:
    \tex_ifnum:D \l_fp_input_a_sign_int > \c_zero
      \fp_exp_integer_const:n { \l_fp_tmp_tl 0 }
    \tex_else:D
      \fp_exp_integer_const:n { - \l_fp_tmp_tl 0 }
    \tex_fi:D
    \fp_mul:NNNNNNNNN
      \l_fp_exp_integer_int \l_fp_exp_decimal_int \l_fp_exp_extended_int
      \l_fp_output_integer_int \l_fp_output_decimal_int 
        \l_fp_output_extended_int
      \l_fp_output_integer_int \l_fp_output_decimal_int 
        \l_fp_output_extended_int
    \tex_advance:D \l_fp_output_exponent_int \l_fp_exp_exponent_int
    \fp_extended_normalise_output:
  \tex_fi:D
  \fp_exp_integer_units: 
}
\cs_new_protected_nopar:Npn \fp_exp_integer_units: {
  \tex_ifnum:D \l_fp_input_a_integer_int > \c_zero
    \tex_ifnum:D \l_fp_input_a_sign_int > \c_zero
      \fp_exp_integer_const:n { \int_use:N \l_fp_input_a_integer_int }
    \tex_else:D
      \fp_exp_integer_const:n 
        { - \int_use:N \l_fp_input_a_integer_int }
    \tex_fi:D
    \fp_mul:NNNNNNNNN
      \l_fp_exp_integer_int \l_fp_exp_decimal_int \l_fp_exp_extended_int
      \l_fp_output_integer_int \l_fp_output_decimal_int 
        \l_fp_output_extended_int
      \l_fp_output_integer_int \l_fp_output_decimal_int 
        \l_fp_output_extended_int  
    \tex_advance:D \l_fp_output_exponent_int \l_fp_exp_exponent_int
    \fp_extended_normalise_output:
  \tex_fi:D
  \fp_exp_decimal:
}
%    \end{macrocode}
% Recovery of the stored constant values into the separate registers
% is done with a simple expansion then assignment.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_exp_integer_const:n #1 {
  \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
    \fp_exp_integer_const:nnnn 
    \tex_csname:D c_fp_exp_ #1 _tl \tex_endcsname:D
}
\cs_new_protected_nopar:Npn \fp_exp_integer_const:nnnn #1#2#3#4 {
  \l_fp_exp_integer_int  #1 \scan_stop:
  \l_fp_exp_decimal_int  #2 \scan_stop:
  \l_fp_exp_extended_int #3 \scan_stop:
  \l_fp_exp_exponent_int #4 \scan_stop:
}
%    \end{macrocode}
% Finding the exponential for the decimal part of the number requires
% a Taylor series calculation. The set up is done here with the loop
% itself a separate function. Once the decimal part is available this
% is multiplied by the integer part already worked out to give
% the final result.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_exp_decimal: {
  \tex_ifnum:D \l_fp_input_a_decimal_int > \c_zero
    \tex_ifnum:D \l_fp_input_a_sign_int > \c_zero
      \l_fp_exp_integer_int  \c_one
      \l_fp_exp_decimal_int  \l_fp_input_a_decimal_int
      \l_fp_exp_extended_int \l_fp_input_a_extended_int
    \tex_else:D  
      \l_fp_exp_integer_int \c_zero
      \tex_ifnum:D \l_fp_exp_extended_int = \c_zero
        \l_fp_exp_decimal_int  
          \etex_numexpr:D 
            \c_one_thousand_million - \l_fp_input_a_decimal_int
          \scan_stop:
        \l_fp_exp_extended_int \c_zero
      \tex_else:D
        \l_fp_exp_decimal_int  
          \etex_numexpr:D 
            999999999 - \l_fp_input_a_decimal_int
          \scan_stop:
        \l_fp_exp_extended_int  
          \etex_numexpr:D 
            \c_one_thousand_million - \l_fp_input_a_extended_int
          \scan_stop:
      \tex_fi:D
    \tex_fi:D  
    \l_fp_input_b_sign_int     \l_fp_input_a_sign_int
    \l_fp_input_b_decimal_int  \l_fp_input_a_decimal_int
    \l_fp_input_b_extended_int \l_fp_input_a_extended_int
    \l_fp_count_int \c_one
    \fp_exp_Taylor:
    \fp_mul:NNNNNNNNN
      \l_fp_exp_integer_int \l_fp_exp_decimal_int \l_fp_exp_extended_int
      \l_fp_output_integer_int \l_fp_output_decimal_int 
        \l_fp_output_extended_int
      \l_fp_output_integer_int \l_fp_output_decimal_int 
        \l_fp_output_extended_int 
  \tex_fi:D
  \tex_ifnum:D \l_fp_output_extended_int < \c_five_hundred_million
  \tex_else:D
    \tex_advance:D \l_fp_output_decimal_int \c_one
    \tex_ifnum:D \l_fp_output_decimal_int < \c_one_thousand_million
    \tex_else:D
      \l_fp_output_decimal_int \c_zero
      \tex_advance:D \l_fp_output_integer_int \c_one
    \tex_fi:D
  \tex_fi:D
  \fp_standardise:NNNN
    \l_fp_output_sign_int
    \l_fp_output_integer_int
    \l_fp_output_decimal_int
    \l_fp_output_exponent_int
  \fp_exp_const:cx { c_fp_exp ( \l_fp_arg_tl ) _fp }
    {
      +   
      \int_use:N \l_fp_output_integer_int
      .
      \tex_expandafter:D \use_none:n 
        \tex_number:D \etex_numexpr:D
           \l_fp_output_decimal_int + \c_one_thousand_million
         \scan_stop:  
      e
      \int_use:N \l_fp_output_exponent_int    
    }
}
%    \end{macrocode}
% The Taylor series for \( \exp(x) \) is
%\[
%  1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + \cdots
%\] 
% which converges for \( -1 < x < 1 \). The code above sets up
% the \( x \) part, leaving the loop to multiply the running
% value by \( x / n \) and add it onto the sum. The way that this is
% done is that the running total is stored in the \texttt{exp} set of
% registers, while the current item is stored as \texttt{input_b}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_exp_Taylor: {
  \tex_advance:D \l_fp_count_int \c_one
  \tex_multiply:D \l_fp_input_b_sign_int \l_fp_input_a_sign_int
  \fp_mul:NNNNNN
    \l_fp_input_a_decimal_int \l_fp_input_a_extended_int
    \l_fp_input_b_decimal_int \l_fp_input_b_extended_int
    \l_fp_input_b_decimal_int \l_fp_input_b_extended_int
  \fp_div_integer:NNNNN
    \l_fp_input_b_decimal_int \l_fp_input_b_extended_int
    \l_fp_count_int
    \l_fp_input_b_decimal_int \l_fp_input_b_extended_int
  \tex_ifnum:D 
    \etex_numexpr:D 
      \l_fp_input_b_decimal_int + \l_fp_input_b_extended_int
      > \c_zero
    \tex_ifnum:D \l_fp_input_b_sign_int > \c_zero
      \tex_advance:D \l_fp_exp_decimal_int \l_fp_input_b_decimal_int
      \tex_advance:D \l_fp_exp_extended_int 
        \l_fp_input_b_extended_int
      \tex_ifnum:D \l_fp_exp_extended_int < \c_one_thousand_million
      \tex_else:D
        \tex_advance:D \l_fp_exp_decimal_int \c_one
        \tex_advance:D \l_fp_exp_extended_int 
          -\c_one_thousand_million
      \tex_fi:D
      \tex_ifnum:D \l_fp_exp_decimal_int < \c_one_thousand_million
      \tex_else:D
        \tex_advance:D \l_fp_exp_integer_int \c_one
        \tex_advance:D \l_fp_exp_decimal_int 
          -\c_one_thousand_million
      \tex_fi:D
    \tex_else:D
      \tex_advance:D \l_fp_exp_decimal_int -\l_fp_input_b_decimal_int
      \tex_advance:D \l_fp_exp_extended_int 
        -\l_fp_input_a_extended_int
      \tex_ifnum:D \l_fp_exp_extended_int < \c_zero
        \tex_advance:D \l_fp_exp_decimal_int \c_minus_one
        \tex_advance:D \l_fp_exp_extended_int \c_one_thousand_million
      \tex_fi:D 
      \tex_ifnum:D \l_fp_exp_decimal_int < \c_zero
        \tex_advance:D \l_fp_exp_integer_int \c_minus_one
        \tex_advance:D \l_fp_exp_decimal_int \c_one_thousand_million
      \tex_fi:D   
    \tex_fi:D
    \tex_expandafter:D \fp_exp_Taylor:
  \tex_fi:D
}
%    \end{macrocode}
% This is set up as a function so that the power code can redirect
% the effect.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_exp_const:Nx #1#2 {
  \tl_new:N #1
  \tl_gset:Nx #1 {#2}
}
\cs_generate_variant:Nn \fp_exp_const:Nx { c }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%\begin{macro}[aux]{\c_fp_ln_10_1_tl}
%\begin{macro}[aux]{\c_fp_ln_10_2_tl}
%\begin{macro}[aux]{\c_fp_ln_10_3_tl}
%\begin{macro}[aux]{\c_fp_ln_10_4_tl}
%\begin{macro}[aux]{\c_fp_ln_10_5_tl}
%\begin{macro}[aux]{\c_fp_ln_10_6_tl}
%\begin{macro}[aux]{\c_fp_ln_10_7_tl}
%\begin{macro}[aux]{\c_fp_ln_10_8_tl}
%\begin{macro}[aux]{\c_fp_ln_10_9_tl}
% Constants for working out logarithms: first those for the powers of
% ten.
%    \begin{macrocode}
\tl_new:c { c_fp_ln_10_1_tl }
\tl_set:cn { c_fp_ln_10_1_tl }
  { { 2 } { 302585092 } { 994045684 } { 0 } }
\tl_new:c { c_fp_ln_10_2_tl }
\tl_set:cn { c_fp_ln_10_2_tl }
  { { 4 } { 605170185 } { 988091368 } { 0 } }
\tl_new:c { c_fp_ln_10_3_tl }
\tl_set:cn { c_fp_ln_10_3_tl }
  { { 6 } { 907755278 } { 982137052 } { 0 } }
\tl_new:c { c_fp_ln_10_4_tl }
\tl_set:cn { c_fp_ln_10_4_tl }
  { { 9 } { 210340371 } { 976182736 } { 0 } }
\tl_new:c { c_fp_ln_10_5_tl }
\tl_set:cn { c_fp_ln_10_5_tl }
  { { 1 } { 151292546 } { 497022842 } { 1 } }
\tl_new:c { c_fp_ln_10_6_tl }
\tl_set:cn { c_fp_ln_10_6_tl }
  { { 1 } { 381551055 } { 796427410 } { 1 } }
\tl_new:c { c_fp_ln_10_7_tl }
\tl_set:cn { c_fp_ln_10_7_tl }
  { { 1 } { 611809565 } { 095831979 } { 1 } }
\tl_new:c { c_fp_ln_10_8_tl }
\tl_set:cn { c_fp_ln_10_8_tl }
  { { 1 } { 842068074 } { 395226547 } { 1 } }
\tl_new:c { c_fp_ln_10_9_tl }
\tl_set:cn { c_fp_ln_10_9_tl }
  { { 2 } { 072326583 } { 694641116 } { 1 } }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[aux]{\c_fp_ln_2_1_tl }
%\begin{macro}[aux]{\c_fp_ln_2_2_tl }
%\begin{macro}[aux]{\c_fp_ln_2_3_tl }
% The smaller set for powers of two.
%    \begin{macrocode}
\tl_new:c { c_fp_ln_2_1_tl }
\tl_set:cn { c_fp_ln_2_1_tl }
  { { 0 } { 693147180 } { 559945309 } { 0 } }
\tl_new:c { c_fp_ln_2_2_tl }
\tl_set:cn { c_fp_ln_2_2_tl }
  { { 1 } { 386294361 } { 119890618 } { 0 } }
\tl_new:c { c_fp_ln_2_3_tl }
\tl_set:cn { c_fp_ln_2_3_tl }
  { { 2 } { 079441541 } { 679835928 } { 0 } }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%
%\begin{macro}{\fp_ln:Nn, \fp_ln:cn}
%\UnitTested
%\begin{macro}{\fp_gln:Nn,\fp_gln:cn}
%\UnitTested
%\begin{macro}[aux]{\fp_ln_aux:NNn}
%\begin{macro}[aux]{\fp_ln_aux:}
%\begin{macro}[aux]{\fp_ln_exponent:}
%\begin{macro}[aux]{\fp_ln_internal:}
%\begin{macro}[aux]{\fp_ln_exponent_units:}
%\begin{macro}[aux]{\fp_ln_normalise:}
%\begin{macro}[aux]{\fp_ln_nornalise_aux:NNNNNNNNN}
%\begin{macro}[aux]{\fp_ln_mantissa:}
%\begin{macro}[aux]{\fp_ln_mantissa_aux:}
%\begin{macro}[aux]{\fp_ln_mantissa_divide_two:}
%\begin{macro}[aux]{\fp_ln_integer_const:nn}
%\begin{macro}[aux]{\fp_ln_Taylor:}
%\begin{macro}[aux]{\fp_ln_fixed:}
%\begin{macro}[aux]{\fp_ln_fixed_aux:NNNNNNNNN}
%\begin{macro}[aux]{\fp_ln_Taylor_aux:}
% The approach for logarithms is again based on a mix of tables and
% Taylor series. Here, the initial validation is a bit easier and so it
% is set up earlier, meaning less need to escape later on.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_ln:Nn {
  \fp_ln_aux:NNn \tl_set:Nn
}
\cs_new_protected_nopar:Npn \fp_gln:Nn {
  \fp_ln_aux:NNn \tl_gset:Nn
}
\cs_generate_variant:Nn \fp_ln:Nn  { c }
\cs_generate_variant:Nn \fp_gln:Nn { c }
\cs_new_protected_nopar:Npn \fp_ln_aux:NNn #1#2#3 {
  \group_begin:
    \fp_split:Nn a {#3}
    \fp_standardise:NNNN
      \l_fp_input_a_sign_int
      \l_fp_input_a_integer_int
      \l_fp_input_a_decimal_int
      \l_fp_input_a_exponent_int
    \tex_ifnum:D \l_fp_input_a_sign_int > \c_zero
      \tex_ifnum:D
        \etex_numexpr:D
          \l_fp_input_a_integer_int + \l_fp_input_a_decimal_int 
          > \c_zero
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \fp_ln_aux: 
      \tex_else:D
        \cs_set_protected_nopar:Npx \fp_tmp:w ##1##2
          {
            \group_end:
            ##1 \exp_not:N ##2 { \c_zero_fp }
          }
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \fp_ln_error_msg:
      \tex_fi:D
    \tex_else:D
      \cs_set_protected_nopar:Npx \fp_tmp:w ##1##2
        {
          \group_end:
          ##1 \exp_not:N ##2 { \c_zero_fp }
        }
      \tex_expandafter:D \fp_ln_error_msg:  
    \tex_fi:D
  \fp_tmp:w #1 #2
}
%    \end{macrocode}
% As the input at this stage meets the validity criteria above, the
% argument can now be saved for further processing. There is no need
% to look at the sign of the input as it must be positive. The function
% here simply sets up to either do the full calculation or recover
% the stored value, as appropriate.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_ln_aux: {      
  \tl_set:Nx \l_fp_arg_tl
    {
      +
      \int_use:N \l_fp_input_a_integer_int
      .
      \tex_expandafter:D \use_none:n 
        \tex_number:D \etex_numexpr:D
           \l_fp_input_a_decimal_int + \c_one_thousand_million
      e
      \int_use:N \l_fp_input_a_exponent_int
    }
  \etex_ifcsname:D c_fp_ln ( \l_fp_arg_tl ) _fp \tex_endcsname:D
  \tex_else:D 
    \tex_expandafter:D \fp_ln_exponent:  
  \tex_fi:D
  \cs_set_protected_nopar:Npx \fp_tmp:w ##1##2
    {
      \group_end:
      ##1 \exp_not:N ##2 
        { \use:c { c_fp_ln ( \l_fp_arg_tl ) _fp } }
    }
}
%    \end{macrocode}
% The main algorithm here uses the fact the logarithm can be divided
% up, first taking out the powers of ten, then powers of two and finally
% using a Taylor series for the remainder.
%\[
%  \ln ( 10^{n} \times 2^{m} \times x ) 
%    = \ln ( 10^{n} ) \times \ln ( 2^{m} ) \times \ln ( x )
%\] 
% The second point to remember is that
%\[
%  \ln ( x^{-1} ) = - \ln ( x )
%\] 
% which means that for the powers of \( 10 \) and \( 2 \) constants
% are only needed for positive powers.
% 
% The first step is to set up the sign for the output functions and 
% work out the powers of ten in the exponent. First the larger powers
% are sorted out. The values for the constants are the same as those
% for the smaller ones, just with a shift in the exponent.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_ln_exponent: {
  \fp_ln_internal:
  \tex_ifnum:D \l_fp_output_extended_int < \c_five_hundred_million
  \tex_else:D
    \tex_advance:D \l_fp_output_decimal_int \c_one
    \tex_ifnum:D \l_fp_output_decimal_int < \c_one_thousand_million
    \tex_else:D
      \l_fp_output_decimal_int \c_zero
      \tex_advance:D \l_fp_output_integer_int \c_one
    \tex_fi:D
  \tex_fi:D
  \fp_standardise:NNNN
    \l_fp_output_sign_int
    \l_fp_output_integer_int
    \l_fp_output_decimal_int
    \l_fp_output_exponent_int
  \tl_new:c { c_fp_ln ( \l_fp_arg_tl ) _fp }
  \tl_gset:cx { c_fp_ln ( \l_fp_arg_tl ) _fp }
    {
      \tex_ifnum:D \l_fp_output_sign_int > \c_zero
        +
      \tex_else:D
        -  
      \tex_fi:D
      \int_use:N \l_fp_output_integer_int
      .
      \tex_expandafter:D \use_none:n 
        \tex_number:D \etex_numexpr:D
           \l_fp_output_decimal_int + \c_one_thousand_million
         \scan_stop:  
      e
      \int_use:N \l_fp_output_exponent_int    
    }
}
\cs_new_protected_nopar:Npn \fp_ln_internal: {
  \tex_ifnum:D \l_fp_input_a_exponent_int < \c_zero
    \l_fp_input_a_exponent_int -\l_fp_input_a_exponent_int
    \l_fp_output_sign_int \c_minus_one
  \tex_else:D  
    \l_fp_output_sign_int \c_one
  \tex_fi:D
  \tex_ifnum:D \l_fp_input_a_exponent_int > \c_nine
    \tl_set:Nx \l_fp_tmp_tl
      { 
        \tex_expandafter:D \use_i:nn 
          \int_use:N \l_fp_input_a_exponent_int 
      }
    \l_fp_input_a_exponent_int 
      \etex_numexpr:D
        \l_fp_input_a_exponent_int - \l_fp_tmp_tl 0
      \scan_stop:
    \fp_ln_const:nn { 10 } { \l_fp_tmp_tl }
    \tex_advance:D \l_fp_exp_exponent_int \c_one
    \l_fp_output_integer_int  \l_fp_exp_integer_int
    \l_fp_output_decimal_int  \l_fp_exp_decimal_int
    \l_fp_output_extended_int \l_fp_exp_extended_int
    \l_fp_output_exponent_int \l_fp_exp_exponent_int
  \tex_else:D
    \l_fp_output_integer_int  \c_zero
    \l_fp_output_decimal_int  \c_zero
    \l_fp_output_extended_int \c_zero
    \l_fp_output_exponent_int \c_zero
  \tex_fi:D
  \fp_ln_exponent_units:
}  
%    \end{macrocode}
% Next the smaller powers of ten, which will need to be combined
% with the above: always an additive process.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_ln_exponent_units: {
  \tex_ifnum:D \l_fp_input_a_exponent_int > \c_zero
    \fp_ln_const:nn { 10 } { \int_use:N \l_fp_input_a_exponent_int }
    \fp_ln_normalise:
    \fp_add:NNNNNNNNN
      \l_fp_exp_integer_int \l_fp_exp_decimal_int \l_fp_exp_extended_int
      \l_fp_output_integer_int \l_fp_output_decimal_int 
        \l_fp_output_extended_int
      \l_fp_output_integer_int \l_fp_output_decimal_int 
        \l_fp_output_extended_int  
  \tex_fi:D
  \fp_ln_mantissa:
}
%    \end{macrocode}
% The smaller table-based parts may need to be exponent shifted so that
% they stay in line with the larger parts. This is similar to the
% approach in other places, but here there is a need to watch the
% extended part of the number.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_ln_normalise: {
  \tex_ifnum:D \l_fp_exp_exponent_int < \l_fp_output_exponent_int
    \tex_advance:D \l_fp_exp_decimal_int \c_one_thousand_million
    \tex_expandafter:D \use_i:nn \tex_expandafter:D 
      \fp_ln_normalise_aux:NNNNNNNNN
      \int_use:N \l_fp_exp_decimal_int
     \tex_expandafter:D \fp_ln_normalise:
   \tex_fi:D
}
\cs_new_protected_nopar:Npn 
  \fp_ln_normalise_aux:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  \tex_ifnum:D \l_fp_exp_integer_int = \c_zero
    \l_fp_exp_decimal_int #1#2#3#4#5#6#7#8 \scan_stop:
  \tex_else:D
    \tl_set:Nx \l_fp_tmp_tl
      {
        \int_use:N \l_fp_exp_integer_int 
        #1#2#3#4#5#6#7#8
      }
    \l_fp_exp_integer_int \c_zero
    \l_fp_exp_decimal_int \l_fp_tmp_tl \scan_stop:
  \tex_fi:D
  \tex_divide:D \l_fp_exp_extended_int \c_ten
  \tl_set:Nx \l_fp_tmp_tl 
    {
      #9
      \int_use:N \l_fp_exp_extended_int 
    }
  \l_fp_exp_extended_int \l_fp_tmp_tl \scan_stop:
  \tex_advance:D \l_fp_exp_exponent_int \c_one
}
%    \end{macrocode}
% The next phase is to decompose the mantissa by division by two to
% leave a value which is in the range \( 1 \le x < 2 \). The sum of the
% two powers needs to take account of the sign of the output: if it
% is negative then the result gets \emph{smaller} as the mantissa gets
% \emph{bigger}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_ln_mantissa: {
  \l_fp_count_int \c_zero
  \l_fp_input_a_extended_int \c_zero
  \fp_ln_mantissa_aux:
  \tex_ifnum:D \l_fp_count_int > \c_zero
    \fp_ln_const:nn { 2 } { \int_use:N \l_fp_count_int }
    \fp_ln_normalise:
    \tex_ifnum:D \l_fp_output_sign_int > \c_zero
      \tex_expandafter:D \fp_add:NNNNNNNNN
    \tex_else:D
      \tex_expandafter:D \fp_sub:NNNNNNNNN
    \tex_fi:D 
    \l_fp_output_integer_int \l_fp_output_decimal_int 
      \l_fp_output_extended_int
    \l_fp_exp_integer_int \l_fp_exp_decimal_int \l_fp_exp_extended_int
    \l_fp_output_integer_int \l_fp_output_decimal_int 
      \l_fp_output_extended_int   
  \tex_fi:D
  \tex_ifnum:D
    \etex_numexpr:D
      \l_fp_input_a_integer_int + \l_fp_input_a_decimal_int > \c_one
    \scan_stop:
    \tex_expandafter:D \fp_ln_Taylor:
  \tex_fi:D
}
\cs_new_protected_nopar:Npn \fp_ln_mantissa_aux: {
  \tex_ifnum:D \l_fp_input_a_integer_int > \c_one
    \tex_advance:D \l_fp_count_int \c_one
    \fp_ln_mantissa_divide_two:  
    \tex_expandafter:D \fp_ln_mantissa_aux:
  \tex_fi:D
}
%    \end{macrocode}
% A fast one-shot division by two.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_ln_mantissa_divide_two: {
  \tex_ifodd:D \l_fp_input_a_decimal_int
    \tex_advance:D \l_fp_input_a_extended_int \c_one_thousand_million
  \tex_fi:D
  \tex_ifodd:D \l_fp_input_a_integer_int
    \tex_advance:D \l_fp_input_a_decimal_int \c_one_thousand_million
  \tex_fi:D
  \tex_divide:D \l_fp_input_a_integer_int  \c_two
  \tex_divide:D \l_fp_input_a_decimal_int  \c_two
  \tex_divide:D \l_fp_input_a_extended_int \c_two
}
%    \end{macrocode}
% Recovering constants makes use of the same auxiliary code as for
% exponents.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_ln_const:nn #1#2 {
  \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
    \fp_exp_integer_const:nnnn 
    \tex_csname:D c_fp_ln_ #1 _ #2 _tl \tex_endcsname:D
}
%    \end{macrocode}
% The Taylor series for the logarithm function is best implemented using
% the identity
%\[
%  \ln(x) = \ln\left( \frac{y + 1}{y - 1} \right)
%\] 
% with 
%\[
%  y = \frac{x - 1}{x + 1}
%\]
% This leads to the series
%\[
%  \ln(x) 
%    = 2y 
%      \left( 
%        1 + y^{2} 
%          \left(
%            \frac{1}{3} + y^{2}
%              \left(
%                \frac{1}{5} + y^{2}
%                  \left(
%                    \frac{1}{7} + y^{2}
%                      \left(
%                        \frac{1}{9} + \cdots
%                      \right)
%                  \right)
%              \right)
%          \right) 
%      \right)
%\] 
% This expansion has the advantage that a lot of the work can be 
% loaded up early by finding \( y^{2} \) before the loop itself starts.
% (In practice, the implementation does the multiplication by two at the
% end of the loop, and expands out the brackets as this is an overall
% more efficient approach.)
%
% At the implementation level, the code starts by calculating \( y \)
% and storing that in input \texttt{a} (which is no longer needed
% for other purposes). That is done using the full division system
% avoiding the parsing step. The value is then switched to a fixed-point
% representation. There is then some shuffling to get all of the working
% space set up. At this stage, a lot of registers are in use and so
% the Taylor series is calculated within a group so that the 
% \texttt{output} variables can be used to hold the result. The value
% of \( y^{2} \) is held in input \texttt{b} (there are a few 
% assignments saved by choosing this over \texttt{a}), while input
% \texttt{a} is used for the `loop value'.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_ln_Taylor: {
  \group_begin:
    \l_fp_input_a_integer_int \c_zero
    \l_fp_input_a_exponent_int \c_zero
    \l_fp_input_b_integer_int \c_two
    \l_fp_input_b_decimal_int \l_fp_input_a_decimal_int
    \l_fp_input_b_exponent_int \c_zero
    \fp_div_internal:
    \fp_ln_fixed:
    \l_fp_input_a_integer_int  \l_fp_output_integer_int 
    \l_fp_input_a_decimal_int  \l_fp_output_decimal_int 
    \l_fp_input_a_exponent_int \l_fp_output_exponent_int 
    \l_fp_input_a_extended_int \c_zero
    \l_fp_output_decimal_int \c_zero
    \l_fp_output_decimal_int  \l_fp_input_a_decimal_int
    \l_fp_output_extended_int \l_fp_input_a_extended_int   
    \fp_mul:NNNNNN
      \l_fp_input_a_decimal_int \l_fp_input_a_extended_int
      \l_fp_input_a_decimal_int \l_fp_input_a_extended_int
      \l_fp_input_b_decimal_int \l_fp_input_b_extended_int
    \l_fp_count_int \c_one
    \fp_ln_Taylor_aux:
    \cs_set_protected_nopar:Npx \fp_tmp:w
      {
        \group_end:
        \exp_not:N \l_fp_exp_decimal_int 
          \int_use:N \l_fp_output_decimal_int \scan_stop:
        \exp_not:N \l_fp_exp_extended_int 
          \int_use:N \l_fp_output_extended_int \scan_stop:
        \exp_not:N \l_fp_exp_exponent_int 
          \int_use:N \l_fp_output_exponent_int \scan_stop:
      } 
  \fp_tmp:w
%    \end{macrocode}
% After the loop part of the Taylor series, the factor of \( 2 \) needs
% to be included. The total for the result can then be constructed.
%    \begin{macrocode}
  \tex_advance:D \l_fp_exp_decimal_int \l_fp_exp_decimal_int 
  \tex_ifnum:D \l_fp_exp_extended_int < \c_five_hundred_million
  \tex_else:D
    \tex_advance:D \l_fp_exp_extended_int -\c_five_hundred_million
    \tex_advance:D \l_fp_exp_decimal_int \c_one
  \tex_fi:D
  \tex_advance:D \l_fp_exp_extended_int \l_fp_exp_extended_int
  \tex_ifnum:D \l_fp_output_sign_int > \c_zero
    \tex_expandafter:D \fp_add:NNNNNNNNN
  \tex_else:D
    \tex_expandafter:D \fp_sub:NNNNNNNNN
  \tex_fi:D 
  \l_fp_output_integer_int \l_fp_output_decimal_int 
    \l_fp_output_extended_int
  \c_zero \l_fp_exp_decimal_int \l_fp_exp_extended_int
  \l_fp_output_integer_int \l_fp_output_decimal_int 
    \l_fp_output_extended_int    
}
%    \end{macrocode}
% The usual shifts to move to fixed-point working. This is done using
% the \texttt{output} registers as this saves a reassignment here.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_ln_fixed: {
  \tex_ifnum:D \l_fp_output_exponent_int < \c_zero
    \tex_advance:D \l_fp_output_decimal_int \c_one_thousand_million
    \tex_expandafter:D \use_i:nn \tex_expandafter:D 
      \fp_ln_fixed_aux:NNNNNNNNN
      \int_use:N \l_fp_output_decimal_int
     \tex_expandafter:D \fp_ln_fixed:
   \tex_fi:D
}
\cs_new_protected_nopar:Npn 
  \fp_ln_fixed_aux:NNNNNNNNN #1#2#3#4#5#6#7#8#9 {
  \tex_ifnum:D \l_fp_output_integer_int = \c_zero
    \l_fp_output_decimal_int #1#2#3#4#5#6#7#8 \scan_stop:
  \tex_else:D
    \tl_set:Nx \l_fp_tmp_tl
      {
        \int_use:N \l_fp_output_integer_int 
        #1#2#3#4#5#6#7#8
      }
    \l_fp_output_integer_int \c_zero
    \l_fp_output_decimal_int \l_fp_tmp_tl \scan_stop:
  \tex_fi:D
  \tex_advance:D \l_fp_output_exponent_int \c_one
}
%    \end{macrocode}
% The main loop for the Taylor series: unlike some of the other similar
% functions, the result here is not the final value and is therefore
% subject to further manipulation outside of the loop.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_ln_Taylor_aux: {
  \tex_advance:D \l_fp_count_int \c_two
  \fp_mul:NNNNNN
    \l_fp_input_a_decimal_int \l_fp_input_a_extended_int
    \l_fp_input_b_decimal_int \l_fp_input_b_extended_int
    \l_fp_input_a_decimal_int \l_fp_input_a_extended_int
  \tex_ifnum:D 
    \etex_numexpr:D 
      \l_fp_input_a_decimal_int + \l_fp_input_a_extended_int
      > \c_zero 
    \fp_div_integer:NNNNN
      \l_fp_input_a_decimal_int \l_fp_input_a_extended_int
      \l_fp_count_int
      \l_fp_exp_decimal_int \l_fp_exp_extended_int
      \tex_advance:D \l_fp_output_decimal_int \l_fp_exp_decimal_int
      \tex_advance:D \l_fp_output_extended_int \l_fp_exp_extended_int
      \tex_ifnum:D \l_fp_output_extended_int < \c_one_thousand_million
      \tex_else:D
        \tex_advance:D \l_fp_output_decimal_int \c_one
        \tex_advance:D \l_fp_output_extended_int 
          -\c_one_thousand_million
      \tex_fi:D
      \tex_ifnum:D \l_fp_output_decimal_int < \c_one_thousand_million
      \tex_else:D
        \tex_advance:D \l_fp_output_integer_int \c_one
        \tex_advance:D \l_fp_output_decimal_int 
          -\c_one_thousand_million
      \tex_fi:D      
    \tex_expandafter:D \fp_ln_Taylor_aux:
  \tex_fi:D
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%\begin{macro}{\fp_pow:Nn, \fp_pow:cn}
%\UnitTested
%\begin{macro}{\fp_gpow:Nn,\fp_gpow:cn}
%\UnitTested
%\begin{macro}[aux]{\fp_pow_aux:NNn}
%\begin{macro}[aux]{\fp_pow_aux_i:}
%\begin{macro}[aux]{\fp_pow_positive:}
%\begin{macro}[aux]{\fp_pow_negative:}
%\begin{macro}[aux]{\fp_pow_aux_ii:}
%\begin{macro}[aux]{\fp_pow_aux_iii:}
%\begin{macro}[aux]{\fp_pow_aux_iv:}
% The approach used for working out powers is to first filter out the
% various special cases and then do most of the work using the
% logarithm and exponent functions. The two storage areas are used 
% in the reverse of the `natural' logic as this avoids some
% re-assignment in the sanity checking code.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_pow:Nn {
  \fp_pow_aux:NNn \tl_set:Nn
}
\cs_new_protected_nopar:Npn \fp_gpow:Nn {
  \fp_pow_aux:NNn \tl_gset:Nn
}
\cs_generate_variant:Nn \fp_pow:Nn  { c }
\cs_generate_variant:Nn \fp_gpow:Nn { c }
\cs_new_protected_nopar:Npn \fp_pow_aux:NNn #1#2#3 {
  \group_begin:
    \fp_read:N #2
    \l_fp_input_b_sign_int     \l_fp_input_a_sign_int
    \l_fp_input_b_integer_int  \l_fp_input_a_integer_int
    \l_fp_input_b_decimal_int  \l_fp_input_a_decimal_int
    \l_fp_input_b_exponent_int \l_fp_input_a_exponent_int
    \fp_split:Nn a {#3}
    \fp_standardise:NNNN
      \l_fp_input_a_sign_int
      \l_fp_input_a_integer_int
      \l_fp_input_a_decimal_int
      \l_fp_input_a_exponent_int
    \tex_ifnum:D
      \etex_numexpr:D
        \l_fp_input_b_integer_int + \l_fp_input_b_decimal_int
        = \c_zero
       \tex_ifnum:D
         \etex_numexpr:D
           \l_fp_input_a_integer_int + \l_fp_input_a_decimal_int
           = \c_zero
           \cs_set_protected_nopar:Npx \fp_tmp:w ##1##2
             { 
               \group_end:
               ##1 ##2 { \c_undefined_fp } 
             }
         \tex_else:D 
           \cs_set_protected_nopar:Npx \fp_tmp:w ##1##2
             { 
               \group_end:
               ##1 ##2 { \c_zero_fp } 
             } 
        \tex_fi:D 
     \tex_else:D
       \tex_ifnum:D
         \etex_numexpr:D
           \l_fp_input_a_integer_int + \l_fp_input_a_decimal_int
           = \c_zero
           \cs_set_protected_nopar:Npx \fp_tmp:w ##1##2
             { 
               \group_end:
               ##1 ##2 { \c_one_fp } 
             }
         \tex_else:D 
           \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
             \fp_pow_aux_i:
        \tex_fi:D  
     \tex_fi:D   
  \fp_tmp:w #1 #2
}
%    \end{macrocode}
% Simply using the logarithm function directly will fail when negative
% numbers are raised to integer powers, which is a mathematically valid
% operation. So there are some more tests to make, after forcing the
% power into an integer and decimal parts, if necessary.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_pow_aux_i: {
  \tex_ifnum:D \l_fp_input_b_sign_int > \c_zero
    \tl_set:Nn \l_fp_sign_tl { + } 
    \tex_expandafter:D \fp_pow_aux_ii:
  \tex_else:D
    \l_fp_input_a_extended_int \c_zero
    \tex_ifnum:D \l_fp_input_a_exponent_int < \c_ten
      \group_begin:
      \fp_extended_normalise:
      \tex_ifnum:D
        \etex_numexpr:D
          \l_fp_input_a_decimal_int + \l_fp_input_a_extended_int
          = \c_zero
         \group_end:  
        \tl_set:Nn \l_fp_sign_tl { - }  
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
        \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \tex_expandafter:D \fp_pow_aux_ii:
      \tex_else:D
        \group_end:
        \cs_set_protected_nopar:Npx \fp_tmp:w ##1##2
          { 
            \group_end:
            ##1 ##2 { \c_undefined_fp } 
         }
      \tex_fi:D 
    \tex_else:D
      \cs_set_protected_nopar:Npx \fp_tmp:w ##1##2
        { 
          \group_end:
          ##1 ##2 { \c_undefined_fp } 
       }
    \tex_fi:D   
  \tex_fi:D
}
%    \end{macrocode}
% The approach used here for powers works well in most cases but gives
% poorer results for negative integer powers, which often have exact
% values.  So there is some filtering to do. For negative powers where
% the power is small, an alternative approach is used in which the 
% positive value is worked out and the reciprocal is then taken. The
% filtering is unfortunately rather long.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_pow_aux_ii: {
  \tex_ifnum:D \l_fp_input_a_sign_int > \c_zero
    \tex_expandafter:D \fp_pow_aux_iv: 
  \tex_else:D
    \tex_ifnum:D \l_fp_input_a_exponent_int < \c_ten
      \group_begin:
      \l_fp_input_a_extended_int \c_zero
      \fp_extended_normalise:
      \tex_ifnum:D \l_fp_input_a_decimal_int = \c_zero
        \tex_ifnum:D \l_fp_input_a_integer_int > \c_ten
          \group_end: 
          \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
            \fp_pow_aux_iv:
        \tex_else:D
          \group_end:
          \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
            \tex_expandafter:D \fp_pow_aux_iii:
        \tex_fi:D
      \tex_else:D
        \group_end:
          \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
          \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
            \tex_expandafter:D \fp_pow_aux_iv:
      \tex_fi:D
    \tex_else:D
      \tex_expandafter:D \tex_expandafter:D \tex_expandafter:D
        \fp_pow_aux_iv:
    \tex_fi:D  
  \tex_fi:D
  \cs_set_protected_nopar:Npx \fp_tmp:w ##1##2
    {
      \group_end:
      ##1 ##2
        {
          \l_fp_sign_tl
          \int_use:N \l_fp_output_integer_int
          .
          \tex_expandafter:D \use_none:n 
            \tex_number:D \etex_numexpr:D
               \l_fp_output_decimal_int + \c_one_thousand_million
             \scan_stop:  
          e
          \int_use:N \l_fp_output_exponent_int    
        }    
    }
}
%    \end{macrocode}
% For the small negative integer powers, the calculation is done for
% the positive power and the reciprocal is then taken.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_pow_aux_iii: {
  \l_fp_input_a_sign_int \c_one
  \fp_pow_aux_iv:
  \l_fp_input_a_integer_int  \c_one
  \l_fp_input_a_decimal_int  \c_zero
  \l_fp_input_a_exponent_int \c_zero
  \l_fp_input_b_integer_int  \l_fp_output_integer_int
  \l_fp_input_b_decimal_int  \l_fp_output_decimal_int
  \l_fp_input_b_exponent_int \l_fp_output_exponent_int
  \fp_div_internal:  
}
%    \end{macrocode}
% The business end of the code starts by finding the logarithm of the
% given base. There is a bit of a shuffle so that this does not have
% to be re-parsed and so that the output ends up in the correct place.
% There is also a need to enable using the short-cut for a 
% pre-calculated result. The internal part of the multiplication
% function can then be used to do the second part of the calculation
% directly. There is some more set up before doing the exponential:
% the idea here is to deactivate some internals so that everything works
% smoothly.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \fp_pow_aux_iv: {
  \group_begin:
    \l_fp_input_a_integer_int  \l_fp_input_b_integer_int
    \l_fp_input_a_decimal_int  \l_fp_input_b_decimal_int
    \l_fp_input_a_exponent_int \l_fp_input_b_exponent_int
    \fp_ln_internal:
    \cs_set_protected_nopar:Npx \fp_tmp:w
      {
        \group_end:
        \exp_not:N \l_fp_input_b_sign_int     
          \int_use:N \l_fp_output_sign_int \scan_stop:
        \exp_not:N \l_fp_input_b_integer_int  
          \int_use:N \l_fp_output_integer_int \scan_stop:
        \exp_not:N \l_fp_input_b_decimal_int  
          \int_use:N \l_fp_output_decimal_int \scan_stop:
        \exp_not:N \l_fp_input_b_extended_int 
          \int_use:N \l_fp_output_extended_int \scan_stop:
        \exp_not:N \l_fp_input_b_exponent_int 
          \int_use:N \l_fp_output_exponent_int \scan_stop:
      } 
  \fp_tmp:w 
  \l_fp_input_a_extended_int  \c_zero
  \fp_mul:NNNNNNNNN
    \l_fp_input_a_integer_int \l_fp_input_a_decimal_int  
      \l_fp_input_a_extended_int  
    \l_fp_input_b_integer_int \l_fp_input_b_decimal_int  
      \l_fp_input_b_extended_int
    \l_fp_input_a_integer_int \l_fp_input_a_decimal_int
      \l_fp_input_a_extended_int 
  \tex_advance:D \l_fp_input_a_exponent_int \l_fp_input_b_exponent_int
  \l_fp_output_integer_int  \c_zero
  \l_fp_output_decimal_int  \c_zero
  \l_fp_output_exponent_int \c_zero
  \cs_set_eq:NN \fp_exp_const:Nx \use_none:nn
  \fp_exp_internal:
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%
%
%
%\subsection{Tests for special values}
%
%\begin{macro}{\fp_if_undefined_p:N}
%\begin{macro}[TF]{\fp_if_undefined:N}
%\UnitTested
% Testing for an undefined value is easy.
%    \begin{macrocode}
\prg_new_conditional:Npnn \fp_if_undefined:N #1 { T , F , TF , p } {
  \tex_ifx:D #1 \c_undefined_fp
    \prg_return_true:
  \tex_else:D
    \prg_return_false:
  \tex_fi:D
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%
%
%
%\begin{macro}{\fp_if_zero_p:N}
%\begin{macro}[TF]{\fp_if_zero:N}
%\UnitTested
% Testing for a zero fixed-point is also easy.
%    \begin{macrocode}
\prg_new_conditional:Npnn \fp_if_zero:N #1 { T , F , TF , p } {
  \tex_ifx:D #1 \c_zero_fp
    \prg_return_true:
  \tex_else:D
    \prg_return_false:
  \tex_fi:D
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%
%
%
%
%
%\subsection{Floating-point conditionals}
%
%\begin{macro}[TF]{\fp_compare:nNn}
%\begin{macro}[TF]{\fp_compare:NNN}
%\UnitTested
%\begin{macro}[aux]{\fp_compare_aux:N}
%\begin{macro}[aux]{\fp_compare_=:}
%\begin{macro}[aux]{\fp_compare_<:}
%\begin{macro}[aux]{\fp_compare_<_aux:}
%\begin{macro}[aux]{\fp_compare_absolute_a>b:}
%\begin{macro}[aux]{\fp_compare_absolute_a<b:}
%\begin{macro}[aux]{\fp_compare_>:}
% The idea for the comparisons is to provide two versions: slower and
% faster. The lead off for both is the same: get the two numbers 
% read and then look for a function to handle the comparison.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \fp_compare:nNn #1#2#3 
  { T , F , TF }
  {
  \group_begin:
    \fp_split:Nn a {#1}
    \fp_standardise:NNNN
      \l_fp_input_a_sign_int
      \l_fp_input_a_integer_int
      \l_fp_input_a_decimal_int
      \l_fp_input_a_exponent_int
    \fp_split:Nn b {#3}
    \fp_standardise:NNNN
      \l_fp_input_b_sign_int
      \l_fp_input_b_integer_int
      \l_fp_input_b_decimal_int
      \l_fp_input_b_exponent_int
    \fp_compare_aux:N #2
}
\prg_new_protected_conditional:Npnn \fp_compare:NNN #1#2#3 
  { T , F , TF }
  {
  \group_begin:
    \fp_read:N #3
    \l_fp_input_b_sign_int     \l_fp_input_a_sign_int
    \l_fp_input_b_integer_int  \l_fp_input_a_integer_int
    \l_fp_input_b_decimal_int  \l_fp_input_a_decimal_int
    \l_fp_input_b_exponent_int \l_fp_input_a_exponent_int
    \fp_read:N #1
    \fp_compare_aux:N #2
}
\cs_new_protected_nopar:Npn \fp_compare_aux:N #1 {
  \cs_if_exist:cTF { fp_compare_#1: }
    { \use:c { fp_compare_#1: } }
    { 
      \group_end:
      \prg_return_false: 
    }
}
%    \end{macrocode}
% For equality, the test is pretty easy as things are either equal or
% they are not.   
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { fp_compare_=: } {
  \tex_ifnum:D \l_fp_input_a_sign_int = \l_fp_input_b_sign_int
    \tex_ifnum:D \l_fp_input_a_integer_int = \l_fp_input_b_integer_int
      \tex_ifnum:D \l_fp_input_a_decimal_int = \l_fp_input_b_decimal_int
        \tex_ifnum:D 
          \l_fp_input_a_exponent_int = \l_fp_input_b_exponent_int
          \group_end:
          \prg_return_true:
        \tex_else:D
          \group_end:
          \prg_return_false:
        \tex_fi:D  
      \tex_else:D
        \group_end:
        \prg_return_false:
      \tex_fi:D
    \tex_else:D
      \group_end:
      \prg_return_false:
    \tex_fi:D
  \tex_else:D
    \group_end:
    \prg_return_false:
  \tex_fi:D  
}
%    \end{macrocode}
% Comparing two values is quite complex. First, there is a filter step
% to check if one or other of the given values is zero. If it is then 
% the result is relatively easy to determine.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { fp_compare_>: } {
  \tex_ifnum:D \etex_numexpr:D
    \l_fp_input_a_integer_int + \l_fp_input_a_decimal_int
    = \c_zero
    \tex_ifnum:D \etex_numexpr:D
      \l_fp_input_b_integer_int + \l_fp_input_b_decimal_int
      = \c_zero
      \group_end:
      \prg_return_false:
    \tex_else:D
      \tex_ifnum:D \l_fp_input_b_sign_int > \c_zero
        \group_end:
        \prg_return_false:
      \tex_else:D
        \group_end:
        \prg_return_true:
      \tex_fi:D
    \tex_fi:D  
  \tex_else:D
    \tex_ifnum:D \etex_numexpr:D
      \l_fp_input_b_integer_int + \l_fp_input_b_decimal_int
      = \c_zero
      \tex_ifnum:D \l_fp_input_a_sign_int > \c_zero
        \group_end:
        \prg_return_true:
      \tex_else:D
        \group_end:
        \prg_return_false:
      \tex_fi:D 
    \tex_else:D
      \use:c { fp_compare_>_aux: }
    \tex_fi:D  
  \tex_fi:D  
}
%    \end{macrocode}
% Next, check the sign of the input: this again may give an obvious
% result. If both signs are the same, then hand off to comparing the
% absolute values.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { fp_compare_>_aux: } {
  \tex_ifnum:D \l_fp_input_a_sign_int > \l_fp_input_b_sign_int
    \group_end:
    \prg_return_true:
  \tex_else:D  
    \tex_ifnum:D \l_fp_input_a_sign_int < \l_fp_input_b_sign_int
      \group_end:
      \prg_return_false:
    \tex_else:D
      \tex_ifnum:D \l_fp_input_a_sign_int > \c_zero
        \use:c { fp_compare_absolute_a>b: }
      \tex_else:D
        \use:c { fp_compare_absolute_a<b: }
      \tex_fi:D
    \tex_fi:D
  \tex_fi:D 
}
%    \end{macrocode}
% Rather long runs of checks, as there is the need to go through each 
% layer of the input and do the comparison. There is also the need to
% avoid messing up with equal inputs at each stage.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { fp_compare_absolute_a>b: } {
  \tex_ifnum:D \l_fp_input_a_exponent_int > \l_fp_input_b_exponent_int
    \group_end:
    \prg_return_true:  
  \tex_else:D  
    \tex_ifnum:D \l_fp_input_a_exponent_int < \l_fp_input_b_exponent_int
      \group_end:
      \prg_return_false:
    \tex_else:D  
      \tex_ifnum:D \l_fp_input_a_integer_int > \l_fp_input_b_integer_int
        \group_end:
        \prg_return_true:
      \tex_else:D
        \tex_ifnum:D 
          \l_fp_input_a_integer_int < \l_fp_input_b_integer_int
          \group_end:
          \prg_return_false:
        \tex_else:D
          \tex_ifnum:D 
            \l_fp_input_a_decimal_int > \l_fp_input_b_decimal_int
            \group_end:
            \prg_return_true:
          \tex_else:D
            \group_end:
            \prg_return_false:
          \tex_fi:D
        \tex_fi:D
      \tex_fi:D
    \tex_fi:D
  \tex_fi:D
}
\cs_new_protected_nopar:cpn { fp_compare_absolute_a<b: } {
  \tex_ifnum:D \l_fp_input_b_exponent_int > \l_fp_input_a_exponent_int
    \group_end:
    \prg_return_true:
  \tex_else:D  
    \tex_ifnum:D \l_fp_input_b_exponent_int < \l_fp_input_a_exponent_int
      \group_end:
      \prg_return_false:  
    \tex_else:D  
      \tex_ifnum:D \l_fp_input_b_integer_int > \l_fp_input_a_integer_int
        \group_end:
        \prg_return_true:
      \tex_else:D
        \tex_ifnum:D 
          \l_fp_input_b_integer_int < \l_fp_input_a_integer_int
          \group_end:
          \prg_return_false:
        \tex_else:D
          \tex_ifnum:D 
            \l_fp_input_b_decimal_int > \l_fp_input_a_decimal_int
            \group_end:
            \prg_return_true:
          \tex_else:D
            \group_end:
            \prg_return_false:
          \tex_fi:D
        \tex_fi:D
      \tex_fi:D
    \tex_fi:D
  \tex_fi:D
}
%    \end{macrocode}
% This is just a case of reversing the two input values and then 
% running the tests already defined.
%    \begin{macrocode}
\cs_new_protected_nopar:cpn { fp_compare_<: } {
  \tl_set:Nx \l_fp_tmp_tl
    {
      \int_set:Nn \exp_not:N \l_fp_input_a_sign_int
        { \int_use:N \l_fp_input_b_sign_int }
      \int_set:Nn \exp_not:N \l_fp_input_a_integer_int
        { \int_use:N \l_fp_input_b_integer_int }
      \int_set:Nn \exp_not:N \l_fp_input_a_decimal_int
        { \int_use:N \l_fp_input_b_decimal_int }
      \int_set:Nn \exp_not:N \l_fp_input_a_exponent_int
        { \int_use:N \l_fp_input_b_exponent_int }
      \int_set:Nn \exp_not:N \l_fp_input_b_sign_int
        { \int_use:N \l_fp_input_a_sign_int }
      \int_set:Nn \exp_not:N \l_fp_input_b_integer_int
        { \int_use:N \l_fp_input_a_integer_int }
      \int_set:Nn \exp_not:N \l_fp_input_b_decimal_int
        { \int_use:N \l_fp_input_a_decimal_int }
      \int_set:Nn \exp_not:N \l_fp_input_b_exponent_int
        { \int_use:N \l_fp_input_a_exponent_int }
    }
  \l_fp_tmp_tl
  \use:c { fp_compare_>: }  
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\subsection{Messages}
%
%\begin{macro}{\fp_overflow_msg:}
% A generic overflow message, used whenever there is a possible
% overflow.
%    \begin{macrocode}
\msg_kernel_new:nnnn { fpu } { overflow } 
  { Number~too~big. }
  {
    The~input~given~is~too~big~for~the~LaTeX~floating~point~unit. \\
    Further~errors~may~well~occur!
  }
\cs_new_protected_nopar:Npn \fp_overflow_msg: {
  \msg_kernel_error:nn { fpu } { overflow }
}  
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\fp_exp_overflow_msg:}
% A slightly more helpful message for exponent overflows.
%    \begin{macrocode}
\msg_kernel_new:nnnn { fpu } { exponent-overflow } 
  { Number~too~big~for~exponent~unit. }
  {
    The~exponent~of~the~input~given~is~too~big~for~the~floating~point~
    unit:~the~maximum~input~value~for~an~exponent~is~230.
  }
\cs_new_protected_nopar:Npn \fp_exp_overflow_msg: {
  \msg_kernel_error:nn { fpu } { exponent-overflow }
}  
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\fp_ln_error_msg:}
% Logarithms are only valid for positive number
%    \begin{macrocode}
\msg_kernel_new:nnnn { fpu } { logarithm-input-error } 
  { Invalid~input~to~ln~function. }
  { Logarithms~can~only~be~calculated~for~positive~numbers. }
\cs_new_protected_nopar:Npn \fp_ln_error_msg: {
  \msg_kernel_error:nn { fpu } { logarithm-input-error }
}  
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\fp_trig_overflow_msg:}
% A slightly more helpful message for trigonometric overflows.
%    \begin{macrocode}
\msg_kernel_new:nnnn { fpu } { trigonometric-overflow } 
  { Number~too~big~for~trigonometry~unit. }
  {
    The~trigonometry~code~can~only~work~with~numbers~smaller~
    than~1000000000.
  }
\cs_new_protected_nopar:Npn \fp_trig_overflow_msg: {
  \msg_kernel_error:nn { fpu } { trigonometric-overflow }
}  
%    \end{macrocode}
%\end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
%\end{implementation}
%
%\PrintChanges
%
%\PrintIndex
