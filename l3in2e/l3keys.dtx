% \iffalse
%% File: l3keys.dtx Copyright (C) 2009 LaTeX3 project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``expl3 bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%<*driver|package>
\RequirePackage{l3names}
%</driver|package>
%\fi
\GetIdInfo$Id$
  {L3 Experimental key-value support}
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{l3keys.dtx}
\end{document}
%</driver>
% \fi
% 
% \title{The \textsf{l3keys} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Key--value support}
% \author{\Team}
% \date{\filedate}
% \maketitle
% 
%\begin{documentation}
%
% The key--value method is a popular system for creating large numbers
% of settings for controlling function or package behaviour.  For the
% user, the system normally results in input of the form
%\begin{verbatim}
%  \PackageControlMacro{
%    key-one = value one,
%    key-two = value two
%  }
%\end{verbatim}
% or
%\begin{verbatim}
%  \PackageMacro[
%    key-one = value one,
%    key-two = value two
%  ]{argument}.
%\end{verbatim}
% For the programmer, the original \pkg{keyval} package gives only
% the most basic interface for this work.  All key macros have to be
% created one at a time, and as a result the \pkg{kvoptions} and
% \pkg{xkeyval} packages have been written to extend the ease of
% creating keys.  A very different approach has been provided by
% the \pkg{pgfkeys} package, which uses a key--value list to
% generate keys.
% 
% The \pkg{l3keys} package is aimed at creating a programming 
% interface for key--value controls in \LaTeX3. Keys are
% created using a key--value interface, in a similar manner to 
% \pkg{pgfkeys}. Each key is created by setting one or more
% \emph{properties} of the key:
%\begin{verbatim}
%  \keys_define:nn { module }
%    key-one .code:n = code including parameter #1,
%    key-two .set    = \l_module_store_tl
%  }
%\end{verbatim}
% These values can then be set as with other key--value approaches:
%\begin{verbatim}
%  \keys_set:nn { module }
%    key-one = value one,
%    key-two = value two
%  }
%\end{verbatim}
%
% At a document level, \cs{keys_set:nn} is used within a  
% document function. For \LaTeXe, a generic set up function could be 
% created with
%\begin{verbatim}
%  \newcommand*\SomePackageSetup[1]{%
%    \@nameuse{keys_set:nn}{module}{#1}%
%  }
%\end{verbatim}
% or to use key--value input as the optional argument for a macro:
%\begin{verbatim}
%  \newcommand*\SomePackageMacro[2][]{%
%    \begingroup
%      \@nameuse{keys_set:nn}{module}{#1}%
%      % Main code for \SomePackageMacro
%    \endgroup
%  }
%\end{verbatim} 
% The same concepts using \pkg{xparse} for \LaTeX3 use:
%\begin{verbatim}
%  \DeclareDocumentCommand \SomePackageSetup { m } {
%    \keys_set:nn { module } { #1 }
%  }
%  \DeclareDocumentCommand \SomePackageMacro { o m } {
%    \group_begin:
%      \keys_set:nn { module } { #1 }
%      % Main code for \SomePackageMacro
%    \group_end:
%  }
%\end{verbatim}
%
% Key names may contain any tokens, as they are handled internally
% using \cs{tl_to_str:n}. As will be discussed in 
% section~\ref{sec:subdivision}, it is suggested that the character 
% ``\texttt{/}'' is reserved for sub-division of keys into logical
% groups. Macros are \emph{not} expanded when creating key names,
% and so
%\begin{verbatim}
%  \tl_set:Nn \l_module_tmp_tl { key }
%  \keys_define:nn { module } {
%    \l_module_tmp_tl .code:n = code
%  }
%\end{verbatim} 
% will create a key called \cs{l_module_tmp_tl}, and not one called
% \texttt{key}.
%
%\subsection{Creating keys}
%
%\begin{function}{\keys_define:nn}
%  \begin{syntax}
%    "\keys_define:nn" \Arg{module} \Arg{keyval list}
%  \end{syntax}
%  Parses the <keyval list> and defines the keys listed there for
%  <module>. This function is designed for use in code, and therefore
%  does  not check the category codes of characters or ignore spaces.
%\end{function}
% 
% Setting up and altering keys is carried out using one or more
% properties. The properties determine how a key acts, and may require 
% zero, one or two argument: this is indicated by an argument specifier,
% in the same way as a standard \LaTeX3 function. If only a single
% argument is required, braces around \texttt{n} arguments can be
% omitted.\footnote{This is a general feature of key--value input 
% methods.}
% 
% 
%\begin{function}{.bool:N}
%  \begin{syntax}
%    <key> .bool:N = <bool>
%  \end{syntax}
%  Defines <key> to set <bool> to <value> (which must be either 
%  \texttt{true} or \texttt{false}). 
%\end{function}
% 
%\begin{function}{.choice:}
%  \begin{syntax}
%    <key> .choice:
%  \end{syntax}
%  Sets <key> to act as a multiple choice key. Creating choices 
%  is discussed in section~\ref{sec:choice}.
%\end{function}
%
%\begin{function}{
%   .code:n|
%   .code:x
%  }
%  \begin{syntax}
%    <key> .code:n = <code>
%  \end{syntax}
%  Stores the <code> for execution when <key> is called. The <code> can
%  include one parameter (|#1|), which will be the <value> given for the
%  <key>.
%\end{function}
% 
%\begin{function}{
%   .code:Nn|
%   .code:Nx
% }
%  \begin{syntax}
%    <key> .code:Nn = <number> <code>
%  \end{syntax}
%  Stores the <code> for execution when <key> is called. The <code> can
%  include <number> parameters, which can be in the standard \TeX\ 
%  range 0--9. If too few parameters are given when the key is used, 
%  sufficient empty groups will be supplied to prevent an error
%  occurring.
%\end{function}
% 
%\begin{function}{
%   .default:n|
%   .default:V|
%  }
%  \begin{syntax}
%    <key> .default:n = <default>
%  \end{syntax}
%  Creates a <default> value for <key>, which is used if no value is 
%  given. This will be used if only the key name is given, but not if
%  a blank <value> is given:
%  \begin{verbatim}
%    \keys_define:nn { module } {
%      key .code:n  = Hello #1,
%      key .default = World
%    }
%    \keys_set:nn { module} {
%      key = Fred, % Prints "Hello Fred"
%      key,        % Prints "Hello World"
%      key = ,     % Prints "Hello "
%    }
%  \end{verbatim}
%  \begin{texnote}
%    The <default> is stored as a token list variable.
%  \end{texnote}
%\end{function}
%
%\begin{function}{.function:N}
%  \begin{syntax}
%    <key> .function:N = <function>
%  \end{syntax}
%  The input for <key> is used to define <function>, which internally
%  uses \cs{cs_set:Nn}. The effect is the same as \texttt{<key> 
%  .code:n = \{ \cs{cs_set:Nn} <function> } |{#1}| \texttt{ \} }.
%  The <function> should be an internal function, as the number of 
%  arguments is detected from the argument specifier. If the
%  <function> is not defined, it is initialised to empty.
%\end{function}
% 
%\begin{function}{
%   .generate_choices:nn|
%   .generate_choices:nx|
% }
%  \begin{syntax}
%    <key> .generate_choices:nn = <comma list> <code>
%  \end{syntax}
%  Makes <key> a multiple choice key, accepting the choices specified
%  in <comma list>. Each choice will execute <code> if it given. Within
%  <code>, the name of the current choice is available as 
%  \cs{l_keys_choice_tl},  and its position in the <comma list> as 
%  \cs{l_keys_choice_int}. Multiple choices are discussed further in 
%  section~\ref{sec:choice}.
%\end{function}
%
%\begin{function}{
%   .initial:n|
%   .initial:V
%  }
%  \begin{syntax}
%    <key> .initial:n = <initial>
%  \end{syntax}
%  Sets <key> using the <initial> value given. This can only be given
%  after the <key> is created.
%\end{function}
%
%\begin{function}{
%  .meta:n|
%  .meta:x
%}
%  \begin{syntax}
%    <key> .meta:n = <keys>
%  \end{syntax}
%  Makes <key> a meta-key, which will set several other <keys> in 
%  one go.  If <key> is given with a value, it is passed through to
%  the subsidiary <keys> for processing.
%\end{function}
% 
%\begin{function}{
%   .set:N|
%   .set_x:N
%}
%  \begin{syntax}
%    <key> .set:N = <variable>
%  \end{syntax}
%  Defines <key> to store the value given in <variable>. The type and 
%  scope (local or global) of <variable> are determined from the 
%  name. The \texttt{x} version performs an expanded assignment. For
%  example
%  \begin{verbatim}
%    \keys_define:nn { module } {
%      key-one .set:N = \l_module_tmpa_tl,  % Locally sets a tl var.
%      key_two .set:N = \g_module_tmpa_toks % Globally sets a toks
%    }
%    \keys_set:nn { module } {
%      key-one = Value, % \l_module_tmpa_tl contains "Value"
%      key-two = Stuff  % \g_module_tmpa_toks contains "Stuff"
%    }
%  \end{verbatim}
%  Assignments are automatically global for global variables. 
%  
%  A  \cs{<variable>_set:Nn} function must exist to allow setting of the
%  <variable>. An error will result if this is not the case. The 
%  \texttt{.set_x:N} version can only be applied to variable types which
%  have a \cs{<variable>_set:Nx} function: other cases will result in an 
%  error.
%\end{function}
% 
%\begin{function}{
%   .value_forbidden:|
%   .value_required:|
% }
%  \begin{syntax}
%    <key> .value_forbidden:
%  \end{syntax}
%  Flags for forbidding and requiring a <value> for <key>. Any <value>
%  given will be ignored.
%\end{function}
%
%\subsection{Sub-dividing keys}
%\label{sec:subdivision}
%
% When creating large numbers of keys, it may be desirable to divide 
% them into several sub-groups for a given module. This can be achieved
% either by adding a sub-division to the module name:
%\begin{verbatim}
%  \keys_define:nn { module / subgroup } {
%    key .code:n = code
%  }
%\end{verbatim} 
% or to the key name:
%\begin{verbatim}
%  \keys_define:nn { module } {
%    subgroup / key .code:n = code
%  }
%\end{verbatim}  
% As illustrated, the best choice of token for sub-dividing keys in
% this way is ``\texttt{/}''. This is because of the method that is
% used to represent keys internally. Both of the above code fragments
% set the same key, which has full name \texttt{module/subgroup/key}.
% 
% As will be illustrated in the next section, this subdivision is
% particularly relevant to making multiple choices.
%
%\subsection{Multiple choices}
%\label{sec:choice}
%
% Multiple choices are created by setting the \texttt{.choice:} 
% property:
%\begin{verbatim}
%  \keys_define:nn { module } {
%    key .choice:
%  }
%\end{verbatim}
% For keys which are set up as choices, the valid choices are generated
% by creating sub-keys of the choice key. This can be carried out in
% two ways.
% 
% In many cases, choices execute similar code which is dependant only 
% on the name of the choice or the position of the choice in the
% list of choices. Here, the keys can share the same code, and can
% be rapidly created using the \texttt{.generate_choices:nn}
% property:
%\begin{verbatim}
%  \keys_define:nn { module } {
%    key .generate_choices:nn = {
%      choice-a, choice-b, choice-c
%    } {
%      You~gave~choice~``\l_keys_choice_tl'',~
%      which~is~in~position~\l_keys_choice_int
%      \~in~the~list.
%    }
%  }
%\end{verbatim}
% 
%\begin{variable}{
%  \l_keys_choice_tl|
%  \l_keys_choice_int|
%}
%  Inside the code block, the variables \cs{l_keys_choice_tl} and
%  \cs{l_keys_choice_int} are available to indicate the name of the
%  current choice, and its position in the comma list.  The position
%  is indexed from \(1\).
%\end{variable}
%
% On the other hand, it is sometimes useful to create choices which
% use entirely different code from one another. This can be achieved
% by setting the \texttt{.choice:} property of a key, then manually
% defining sub-keys.
%\begin{verbatim}
%  \keys_define:nn { module } {
%    key choices:n,
%    key / choice-a .code:n = code-a,
%    key / choice-b .code:n = code-b,
%    key / choice-c .code:n = code-c,
%  }
%\end{verbatim}
%
% It is possible to mix the two methods, but manually-created choices
% should \emph{not} use \cs{l_keys_choice_tl} or \cs{l_keys_choice_int}.
%
%\subsection{Setting keys}
%
%\begin{function}{
%  \keys_set:nn|
%  \keys_set:nV|
%  \keys_set:nv
%}
%  \begin{syntax}
%    "\keys_set:nn" \Arg{module} \Arg{keyval list}
%  \end{syntax}
%  Parses the <keyval list>, and sets those keys which are defined
%  for <module>. The behaviour on finding an unknown key can be
%  set by defining a special \texttt{unknown} key: this will be 
%  illustrated later. In contrast to \cs{keys_define:nn}, this function
%  does check category codes and ignore spaces, and is therefore 
%  suitable for user input.
%\end{function}
%
% If a key is not known, \cs{keys_set:nn} will look for a special
% \texttt{unknown} key for the same module. This mechanism can be
% used to create new keys from user input.
%\begin{verbatim}
%  \keys_define:nn { module } {
%    unknown .code:n = 
%      You~tried~to~set~key~`\l_keys_path_tl'~to~`#1'
%  }
%\end{verbatim}
%
%\begin{variable}{\l_keys_key_tl}
%  When processing an unknown key, the name of the key is available
%  as \cs{l_keys_key_tl}. Note that this will have been processed
%  using \cs{tl_to_str:N}. The value passed to the key (if any) is
%  available as the macro parameter |#1|.
%\end{variable}
% 
%\subsection{Examining keys: internal representation}
%
%\begin{function}{\keys_if_exist:nn / (TF)}
%  \begin{syntax}
%    "\keys_if_exist:nnTF" \Arg{module} \Arg{key} \Arg{true code} 
%    ~~~~\Arg{false code}
%  \end{syntax}
%  Tests if <key> exists for <module>, by checking for the existence
%  of the internal function \cs{keys > <module>/<key>.cmd:w}.
%\end{function}
%
%\begin{function}{\keys_show:nn}
%  \begin{syntax}
%    "\keys_show:nn" \Arg{module} \Arg{key}
%  \end{syntax}
%  Shows the internal representation of a <key>. The function which
%  executes a <key> is called \cs{keys > <module>/<key>.cmd:w}.
%\end{function}
% 
%\subsection{Internal functions}
%
%\begin{function}{\keys_arguments_tidy:w}
%   \begin{syntax}
%     "\keys_arguments_tidy:w " <args> "\q_keys_stop"
%   \end{syntax}
%   Clears <args> from the stack: used to clean up after executing a
%   key.
%\end{function}
%
%\begin{function}{
%    \keys_bool_set:N |
%    \keys_bool_set_inverse:N
%}
%   \begin{syntax}
%     "\keys_bool_set:N" <bool>
%   \end{syntax}
%   Creates code to set <bool> when <key> is given.
%\end{function}
%
%\begin{function}{\keys_choice_make:}
%   \begin{syntax}
%     "\keys_choice_make:" 
%   \end{syntax}
%   Makes <key> a choice key.
%\end{function}
%
%\begin{function}{\keys_choices_generate:nx}
%   \begin{syntax}
%     "\keys_choices_generate:nx" \Arg{comma list} \Arg{code}
%   \end{syntax}
%   Makes <comma list> choices for <key>, each using <code>.
%\end{function}
%
%\begin{function}{\keys_choice_find:n}
%   \begin{syntax}
%     "\keys_choice_find:n" \Arg{choice}
%   \end{syntax}
%   Searches for <choice> as a sub-key of <key>.
%\end{function}
%
%\begin{function}{
%    \keys_cmd_set:nNn |
%    \keys_cmd_set:nNx
%}
%   \begin{syntax}
%     "\keys_cmd_set:nNn" \Arg{path} <num args> \Arg{code}
%   \end{syntax}
%   Creates a function for <path>, taking <num args> and using <code>.
%\end{function}
%
%\begin{function}{
%    \keys_default_set:n |
%    \keys_default_set:V
%}
%   \begin{syntax}
%     "\keys_default_set:n" \Arg{default}
%   \end{syntax}
%   Sets <default> for <key>.
%\end{function}
%
%\begin{function}{
%    \keys_define_elt:n |
%    \keys_define_elt:nn
%}
%   \begin{syntax}
%     "\keys_define_elt:nn" \Arg{key} \Arg{value}
%   \end{syntax}
%   Processing functions for key--value pairs when defining keys.
%\end{function}
%
%\begin{function}{\keys_define_key:n}
%   \begin{syntax}
%     "\keys_define_key:n" \Arg{key}
%   \end{syntax}
%   Defines <key>.
%\end{function}
%
%\begin{function}{\keys_execute:}
%   \begin{syntax}
%     "\keys_execute:" 
%   \end{syntax}
%   Executes <key>.
%\end{function}
%
%\begin{function}{\keys_execute_unknown:}
%   \begin{syntax}
%     "\keys_execute_unknown:" 
%   \end{syntax}
%   Handles unknown <key> names.
%\end{function}
%
%\begin{function}{\keys_if_value_requirement:nTF}
%   \begin{syntax}
%     "\keys_if_value_requirement:nTF" \Arg{requirement}
%     ~~~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   Check if <requirement> applies to <key>.
%\end{function}
%
%\begin{function}{
%    \keys_initial_value:n |
%    \keys_initial_value:V
%}
%   \begin{syntax}
%     "\keys_initial_value:n" \Arg{value}
%   \end{syntax}
%   Sets <value> as initial contents for <key>.
%\end{function}
%
%\begin{function}{
%  \keys_meta_make:n|
%  \keys_meta_make:x
%}
%   \begin{syntax}
%     "\keys_meta_make:n" \Arg{keys}
%   \end{syntax}
%   Makes <key> a meta-key to set <keys>.
%\end{function}
%
%\begin{function}{\keys_property_find:n}
%   \begin{syntax}
%     "\keys_property_find:n" \Arg{key}
%   \end{syntax}
%   Separates <key> from <property>.
%\end{function}
%
%\begin{function}{\keys_property_new:nn}
%   \begin{syntax}
%     "\keys_property_new:nn" \Arg{property} \Arg{code}
%   \end{syntax}
%   Makes a new <property> expanding to <code>
%\end{function}
%
%\begin{function}{\keys_property_undefine:n}
%   \begin{syntax}
%     "\keys_property_undefine:n" \Arg{property}
%   \end{syntax}
%   Deletes <property> of <key>.
%\end{function}
%
%\begin{function}{
%    \keys_set_elt:n  |
%    \keys_set_elt:nn 
%}
%   \begin{syntax}
%     "\keys_set_elt:nn" \Arg{key} \Arg{value}
%   \end{syntax}
%   Processing functions for key--value pairs when setting keys.
%\end{function}
%
%\begin{function}{\keys_tmp:w}
%   \begin{syntax}
%     "\keys_tmp:w" <args>
%   \end{syntax}
%   Used to store <code> to execute a <key>.
%\end{function}
%
%\begin{function}{\keys_value_or_default:n}
%   \begin{syntax}
%     "\keys_value_or_default:n" \Arg{value}
%   \end{syntax}
%   Sets \cs{l_keys_value_toks} to <value>, or <default> if
%   <value> was not given and if <default> is available.
%\end{function}
%
%\begin{function}{\keys_value_requirement:n}
%   \begin{syntax}
%     "\keys_value_requirement:n" \Arg{requirement}
%   \end{syntax}
%   Sets <key> to have <requirement> concerning <value>.
%\end{function}
%
%\begin{function}{\keys_variable_set:NN}
%   \begin{syntax}
%     "\keys_variable_set:NN" <expansion> <var>
%   \end{syntax}
%   Sets <key> to assign <value> to <variable>
%\end{function}
% 
%\begin{function}{
%    \keys_variable_get_scope:N / (EXP) |
%    \keys_variable_get_type:N  / (EXP)
%}
%   \begin{syntax}
%     "\keys_variable_get_scope:N" <var>
%   \end{syntax}
%   Returns the scope (\texttt{g} or blank) or the type of <var>.
%\end{function}
% 
%\subsection{Variables and constants}
%
%\begin{variable}{
%  \c_keys_properties_root_tl|
%  \c_keys_root_tl
%}
%  The root paths for keys and properties.
%\end{variable}
% 
%\begin{variable}{
%  \c_keys_value_forbidden_tl|
%  \c_keys_value_required_tl
%}
%  Marker text containers. 
%\end{variable}
% 
%\begin{variable}{
%  \l_keys_module_tl|
%  \l_keys_path_tl|
%  \l_keys_property_tl
%}
%  Various key paths need to be stored.
%\end{variable}
%
%\begin{variable}{
%  \l_keys_nesting_seq|
%  \l_keys_nesting_tl
%}
%  To allow safe nesting of \cs{keys_define:nn} and \cs{keys_set:nn}.
%\end{variable}
%
%\begin{variable}{\l_keys_no_value_bool}
%  A marker for ``no value'' as key input.
%\end{variable}
%
%\begin{variable}{\l_keys_value_toks}
%  Holds the currently supplied value.
%\end{variable}
%
%\begin{variable}{\q_keys_stop}
%  A quark for delimiting arguments.
%\end{variable}
% 
%\end{documentation}
% 
%\begin{implementation}
%
% The usual preliminaries.  
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
\package_check_loaded_expl:
%</package>
%<*initex|package>
%    \end{macrocode}
%
%\subsubsection{Variables and constants}
%
%\begin{macro}{\c_keys_root_tl}
%\begin{macro}{\c_keys_properties_root_tl}
% Where the keys are really stored.
%    \begin{macrocode}
\tl_new:Nn \c_keys_root_tl { keys~>~ }
\tl_new:Nn \c_keys_properties_root_tl { keys_properties }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\c_keys_value_forbidden_tl}
%\begin{macro}{\c_keys_value_required_tl}
% Two marker token lists.
%    \begin{macrocode}
\tl_new:Nn \c_keys_value_forbidden_tl { forbidden }
\tl_new:Nn \c_keys_value_required_tl { required }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_keys_choice_int}
%\begin{macro}{\l_keys_choice_tl}
% Used for the multiple choice system.
%    \begin{macrocode}
\int_new:N \l_keys_choice_int
\tl_new:N \l_keys_choice_tl
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_keys_key_tl}
%\begin{macro}{\l_keys_path_tl}
%\begin{macro}{\l_keys_property_tl}
% Storage for the current key name and the path of the key (key name 
% plus module name).
%    \begin{macrocode}
\tl_new:N \l_keys_key_tl
\tl_new:N \l_keys_path_tl
\tl_new:N \l_keys_property_tl
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_keys_module_tl}
% The module for an entire set of keys.
%    \begin{macrocode}
\tl_new:N \l_keys_module_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_keys_nesting_seq}
%\begin{macro}{\l_keys_nesting_tl}
% For nesting.
%    \begin{macrocode}
\seq_new:N \l_keys_nesting_seq
\tl_new:Nn \l_keys_nesting_tl { none }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_keys_no_value_bool}
% To indicate that no value has been given.
%    \begin{macrocode}
\bool_new:N \l_keys_no_value_bool
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_keys_value_toks}
% A token register for the given value.
%    \begin{macrocode}
\toks_new:N \l_keys_value_toks
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\q_keys_stop}
% A quark for delimiting keys: no one else should use it!
%    \begin{macrocode}
\quark_new:N \q_keys_stop
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Internal functions}
%
%\begin{macro}{\keys_arguments_tidy:w}
% So that nothing runs away, a safety precaution is taken in the code.
%    \begin{macrocode}
\cs_new:Npn \keys_arguments_tidy:w #1 \q_keys_stop { }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_bool_set:N}
%\begin{macro}{\keys_bool_set_inverse:N}
%\begin{macro}[aux]{\keys_bool_set_aux:N}
% Boolean keys are really just choices, but all done by hand.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_bool_set:N {
  \keys_cmd_set:nNx { \l_keys_path_tl / true } 1 {
    \exp_not:c { bool_ \keys_variable_get_scope:N #1 set_true:N } 
      \exp_not:N #1
  }
  \keys_cmd_set:nNx { \l_keys_path_tl / false } 1 {
    \exp_not:N \use:c 
      { bool_ \keys_variable_get_scope:N #1 set_false:N } 
      \exp_not:N #1
  }
  \keys_bool_set_aux:N #1
}
\cs_new_nopar:Nn \keys_bool_set_inverse:N {
  \keys_cmd_set:nNx { \l_keys_path_tl / true } 1 {
    \exp_not:c { bool_ \keys_variable_get_scope:N #1 set_false:N }
      \exp_not:N #1
  }
  \keys_cmd_set:nNx { \l_keys_path_tl / false } 1 {
    \exp_not:c { bool_ \keys_variable_get_scope:N #1 set_true:N }
      \exp_not:N #1
  }
  \keys_bool_set_aux:N #1
}
\cs_new_nopar:Nn \keys_bool_set_aux:N {
  \keys_choice_make:
  \cs_if_exist:NF #1 {
    \bool_new:N #1
  }
  \keys_default_set:n { true }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_choice_find:n}
% Executing a choice has two parts. First, try the choice given, then
% if that fails call the unknown key. That will exist, as it is created
% when a choice is first made. So there is no need for any escape code.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_choice_find:n {
  \keys_execute_aux:nn { \l_keys_path_tl / #1 } {
    \keys_execute_aux:nn { \l_keys_path_tl / unknown } { }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_choice_make:}
% To make a choice from a key, two steps: set the code, and set the 
% unknown key.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_choice_make: {
  \keys_cmd_set:nNn { \l_keys_path_tl } 1 {
    \keys_choice_find:n {##1}
  }
  \keys_cmd_set:nNn { \l_keys_path_tl / unknown } 1 {
    \msg_kernel_error:nxx { key-choice-unknown } { \l_keys_path_tl }
      {##1} 
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_choices_generate:nx}
%\begin{macro}[aux]{\keys_choices_generate_aux:n}
% Creating multiple-choices means setting up the ``indicator'' code,
% then applying whatever the user wanted.
%    \begin{macrocode}
\cs_new:Nn \keys_choices_generate:nx {
  \keys_choice_make:
  \int_zero:N \l_keys_choice_int
  \cs_set_nopar:Nn \keys_choices_generate_aux:n {
    \int_incr:N \l_keys_choice_int
    \keys_cmd_set:nNx { \l_keys_path_tl / ##1 } 1 {
      \exp_not:n { \tl_set:Nn \l_keys_choice_tl } {##1}
      \exp_not:n { \int_set:Nn \l_keys_choice_int }
        { \int_use:N \l_keys_choice_int }
      #2
    }
  }
  \clist_map_function:nN {#1} \keys_choices_generate_aux:n 
}
\cs_new_nopar:Nn \keys_choices_generate_aux:n { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_cmd_set:nNn}
%\begin{macro}{\keys_cmd_set:nNx}
%\begin{macro}[aux]{\keys_cmd_set_aux:nN}
% Creating a new command means setting properties and then creating
% a function with the correct number of arguments.
%    \begin{macrocode}
\cs_new:Nn \keys_cmd_set:nNn {
  \keys_cmd_set_aux:nN {#1} #2
  \cs_generate_from_arg_count:cNnn { \c_keys_root_tl #1 .cmd:w } 
    \cs_set:Npn #2 { #3 \keys_arguments_tidy:w }
}
\cs_new:Nn \keys_cmd_set:nNx {
  \keys_cmd_set_aux:nN {#1} #2
  \cs_generate_from_arg_count:cNnn { \c_keys_root_tl #1 .cmd:w } 
    \cs_set:Npx #2 { #3 \exp_not:N \keys_arguments_tidy:w }
}
\cs_new_nopar:Nn \keys_cmd_set_aux:nN {
  \keys_property_undefine:n { #1 .default_tl }
  \num_set:cn { \c_keys_root_tl #1 .args_num } {#2}
  \tl_set:cn  { \c_keys_root_tl #1 .req_tl } { } 
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_default_set:n}
%\begin{macro}{\keys_default_set:V}
% Setting a default value is easy.
%    \begin{macrocode}
\cs_new:Nn \keys_default_set:n {
  \tl_set:cn { \c_keys_root_tl \l_keys_path_tl .default_tl } {#1}
}
\cs_generate_variant:Nn \keys_default_set:n { V }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_define:nn}
% The main key-defining function mainly sets up things for \pkg{l3keyval}
% to use.
%    \begin{macrocode}
\cs_new:Nn \keys_define:nn {
  \tl_set:Nn \l_keys_module_tl {#1}
  \cs_set_eq:NN \KV_key_no_value_elt:n \keys_define_elt:n
  \cs_set_eq:NN \KV_key_value_elt:nn \keys_define_elt:nn
  \seq_push:NV \l_keys_nesting_seq \l_keys_nesting_tl
  \tl_set:Nn \l_keys_nesting_tl { define }
  \KV_parse_no_space_removal_no_sanitize:n {#2}
  \seq_pop:NN \l_keys_nesting_seq \l_keys_nesting_tl
  \cs_set_eq:Nc \KV_key_no_value_elt:n 
    { keys_ \l_keys_nesting_tl _elt:n }
  \cs_set_eq:Nc \KV_key_value_elt:nn 
    { keys_ \l_keys_nesting_tl _elt:nn }  
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_define_elt:n}
%\begin{macro}{\keys_define_elt:nn}
% The element processors for defining keys.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_define_elt:n {
  \bool_set_true:N \l_keys_no_value_bool
  \keys_define_elt_aux:nn {#1} { }
}
\cs_new:Nn \keys_define_elt:nn {
  \bool_set_false:N \l_keys_no_value_bool
  \keys_define_elt_aux:nn {#1} {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}[aux]{\keys_define_elt_aux:nn}
% The auxiliary function does most of the work.
%    \begin{macrocode}
\cs_new:Nn \keys_define_elt_aux:nn {
  \keys_property_find:n {#1}
  \cs_set_eq:Nc \keys_tmp:w 
    { \c_keys_properties_root_tl \l_keys_property_tl }
  \cs_if_exist:NTF \keys_tmp:w {
    \keys_define_key:n {#2}
  }{
    \msg_kernel_error:nx { key-property-unknown } 
      { \l_keys_property_tl }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_define_key:n}
% Defining a new key means finding the code for the appropriate 
% property then running it. As properties have signatures, a check
% can be made for required values without needing anything set
% explicitly.
%    \begin{macrocode}
\cs_new:Nn \keys_define_key:n {
  \bool_if:NTF \l_keys_no_value_bool {
    \intexpr_compare:nTF { 
      \exp_args:Nc \cs_get_arg_count_from_signature:N 
        { \l_keys_property_tl } = \c_zero
    } {
      \keys_tmp:w \q_keys_stop
    }{
      \msg_kernel_error:nx { key-property-value-required } 
        { \l_keys_property_tl }
    }  
  }{
    \intexpr_compare:nTF { 
      \exp_args:Nc \cs_get_arg_count_from_signature:N 
        { \l_keys_property_tl }  = \c_one
    } {
      \keys_tmp:w {#1} \q_keys_stop
    }{
      \keys_tmp:w #1 { } { } { } { } { } { } { } { } { } \q_keys_stop
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_execute:}
%\begin{macro}{\keys_execute_unknown:}
%\begin{macro}[aux]{\keys_execute_aux:nn}
% Actually executing a key is done in two parts. First, look for the
% key itself, then look for the \texttt{unknown} key with the same
% path. If both of these fail, complain!
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_execute: {
  \keys_execute_aux:nn { \l_keys_path_tl } {
    \keys_execute_unknown:
  }
}
\cs_new_nopar:Nn \keys_execute_unknown: {
  \keys_execute_aux:nn { \l_keys_module_tl / unknown } {
    \msg_kernel_error:nx { key-unknown } { \l_keys_path_tl }
  }
}
%    \end{macrocode}
% If there is only one argument required, it is wrapped in braces so
% that everything is passed through properly. On the other hand, if more
% than one is needed it is down to the user to have put things in 
% correctly! The use of \cs{q_keys_stop} here means that arguments
% do not run away (hence the nine empty groups), but that the module
% can clean up the spare groups at the end of executing the key.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_execute_aux:nn {
  \cs_set_eq:Nc \keys_tmp:w { \c_keys_root_tl #1 .cmd:w }
  \cs_if_exist:NTF \keys_tmp:w {
    \intexpr_compare:nTF { 
      \num_use:c { \c_keys_root_tl #1 .args_num } = \c_one
    } {
      \exp_args:NV \keys_tmp:w \l_keys_value_toks \q_keys_stop
    }{
      \exp_after:wN \keys_tmp:w \toks_use:N \l_keys_value_toks
      { } { } { } { } { } { } { } { } { } \q_keys_stop
    }
  }{
    #2
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}[TF]{\keys_if_exist:nn}
% A check for the existance of a key. This works by looking for the
% command function for the key (which ends \texttt{.cmd:w}).
%    \begin{macrocode}
\prg_set_conditional:Nnn \keys_if_exist:nn {TF,T,F} {
  \cs_if_exist:cTF { \c_keys_root_tl #1 / #2 .cmd:w } {
    \prg_return_true:
  }{
    \prg_return_false:
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_if_value_requirement:nTF}
% To test if a value is required or forbidden. Only one version is
% needed, so done by hand.
%    \begin{macrocode}
\cs_new_nopar:Npn \keys_if_value_requirement:nTF #1 {
  \tl_if_eq:ccTF { c_keys_value_ #1 _tl } {
    \c_keys_root_tl \l_keys_path_tl .req_tl
  } 
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_initial_value:n}
%\begin{macro}{\keys_initial_value:V}
% Pretty easy to set initial values.
%    \begin{macrocode}
\cs_new:Nn \keys_initial_value:n {
  \toks_set:Nn \l_keys_value_toks {#1}
  \keys_execute_aux:nn { \l_keys_path_tl } {
    \msg_kernel_error:nx { key-initial-without-code } 
      { \l_keys_path_tl }
  }
}
\cs_generate_variant:Nn \keys_initial_value:n { V }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_meta_make:n}
%\begin{macro}{\keys_meta_make:x}
% To create a met-key, simply set up to pass data through.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_meta_make:n {
  \keys_cmd_set:nNx { \l_keys_path_tl } 1 {
    \exp_not:N \keys_set:nn { \l_keys_module_tl } {#1}
  }
}
\cs_generate_variant:Nn \keys_meta_make:n { x }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_property_find:n}
%\begin{macro}[aux]{\keys_property_find_aux:n}
%\begin{macro}[aux]{\keys_property_find_aux:w}
% Searching for a property means finding the last ``\texttt{.}'' in
% the input, and storing the text before and after it.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_property_find:n {
  \tl_set:Nx \l_keys_path_tl { \l_keys_module_tl / }
  \tl_if_in:nnTF {#1} {.} {
    \keys_property_find_aux:n {#1}
  }{
    \msg_kernel_error:nx { key-no-property } { #1 }
  }
}
\cs_new_nopar:Nn \keys_property_find_aux:n {
  \keys_property_find_aux:w #1 \q_stop
}
\cs_new_nopar:Npn \keys_property_find_aux:w #1 . #2 \q_stop {
  \tl_if_in:nnTF {#2} {.} {
    \tl_set:Nx \l_keys_path_tl { 
      \l_keys_path_tl \tl_to_str:n {#1} .
    }
    \keys_property_find_aux:w #2 \q_stop
  }{
    \tl_set:Nx \l_keys_path_tl { \l_keys_path_tl \tl_to_str:n {#1} }
    \tl_set:Nn \l_keys_property_tl { . #2 }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_property_new:nn}
% Creating a new property is simply a case of making the correctly-named
% function.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_property_new:nn {
  \cs_new:cn { \c_keys_properties_root_tl #1 } 
    { #2 \keys_arguments_tidy:w }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_property_undefine:n}
% Removing a property means undefining it.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_property_undefine:n {
  \cs_set_eq:cN { \c_keys_root_tl #1 } \c_undefined
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_set:nn}
%\begin{macro}{\keys_set:nV}
%\begin{macro}{\keys_set:nv}
% The main setting function just does the set up to get \pkg{l3keyval}
% to do the hard work.
%    \begin{macrocode}
\cs_new:Nn \keys_set:nn {
  \tl_set:Nn \l_keys_module_tl {#1}
  \cs_set_eq:NN \KV_key_no_value_elt:n \keys_set_elt:n
  \cs_set_eq:NN \KV_key_value_elt:nn \keys_set_elt:nn
  \seq_push:NV \l_keys_nesting_seq \l_keys_nesting_tl
  \tl_set:Nn \l_keys_nesting_tl { set }
  \KV_parse_space_removal_sanitize:n {#2}
  \seq_pop:NN \l_keys_nesting_seq \l_keys_nesting_tl
  \cs_set_eq:Nc \KV_key_no_value_elt:n 
    { keys_ \l_keys_nesting_tl _elt:n }
  \cs_set_eq:Nc \KV_key_value_elt:nn 
    { keys_ \l_keys_nesting_tl _elt:nn }
}
\cs_generate_variant:Nn \keys_set:nn { nV, nv }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_set_elt:n}
%\begin{macro}{\keys_set_elt:nn}
% The two element processors are almost identical, and pass the data 
% through to the underlying auxiliary, which does the work.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_set_elt:n {
  \bool_set_true:N \l_keys_no_value_bool
  \keys_set_elt_aux:nn {#1} { }
}
\cs_new:Nn \keys_set_elt:nn {
  \bool_set_false:N \l_keys_no_value_bool
  \keys_set_elt_aux:nn {#1} {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}[aux]{\keys_set_elt_aux:nn}
%\begin{macro}[aux]{\keys_set_elt_aux:}
% First, set the current path and add a default if needed. There are 
% then checks to see if the a value is required or forbidden. If 
% everything passes, move on to execute the code.
%    \begin{macrocode}
\cs_new:Nn \keys_set_elt_aux:nn {
  \tl_set:Nx \l_keys_key_tl { \tl_to_str:n {#1} }
  \tl_set:Nx \l_keys_path_tl { \l_keys_module_tl / \l_keys_key_tl }
  \keys_value_or_default:n {#2}
  \keys_if_value_requirement:nTF { required } {
    \bool_if:NTF \l_keys_no_value_bool {
      \msg_kernel_error:nx  { key-value-required } { \l_keys_path_tl }
    }{
      \keys_set_elt_aux:
    }
  }{
    \keys_set_elt_aux:
  } 
}
\cs_new_nopar:Nn \keys_set_elt_aux: {
  \keys_if_value_requirement:nTF { forbidden } {
    \bool_if:NTF \l_keys_no_value_bool {
      \keys_execute:
    }{
      \msg_kernel_error:nxx { key-value-forbidden } { \l_keys_path_tl }
        { \toks_use:N \l_keys_value_toks }
    }
  }{
    \keys_execute:
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_show:nn}
% Showing a key is just a question of using the correct name.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_show:nn {
  \cs_show:c { \c_keys_root_tl #1 / \tl_to_str:n {#2} .cmd:w }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_tmp:w}
% This scratch function is used to actually execute keys.
%    \begin{macrocode}
\cs_new:Npn \keys_tmp:w {}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_value_or_default:n}
% If a value is given, return it as |#1|, otherwise send a default if
% available.
%    \begin{macrocode}
\cs_new:Nn \keys_value_or_default:n {
  \toks_set:Nn \l_keys_value_toks  {#1}
  \bool_if:NT \l_keys_no_value_bool {
    \cs_if_exist:cT { \c_keys_root_tl \l_keys_path_tl .default_tl } {
      \toks_set:Nv \l_keys_value_toks  { 
        \c_keys_root_tl \l_keys_path_tl .default_tl 
      }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_value_requirement:n}
% Values can be required or forbidden by having the appropriate marker
% set.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_value_requirement:n { 
  \tl_set_eq:cc { \c_keys_root_tl \l_keys_path_tl .req_tl } 
    { c_keys_value_ #1 _tl }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_variable_get_scope:N}
%\begin{macro}[aux]{\keys_variable_get_scope_aux:w}
%\begin{macro}{\keys_variable_get_type:N}
%\begin{macro}[aux]{\keys_variable_get_type:w}
% Expandable functions to find the type of a variable, and to 
% return \texttt{g} if the variable is global. The trick for 
% \cs{keys_variable_get_scope:N} is the same as that in 
% \cs{cs_split_function:NN}, but it can be simplified as the
% requirements here are less complex.
%    \begin{macrocode}
\group_begin:
  \char_set_lccode:nn {`\&} {`\g}
  \char_make_other:N \&
\tl_to_lowercase:n {
  \group_end:
  \cs_new_nopar:Nn \keys_variable_get_scope:N {
    \exp_last_unbraced:Nf \keys_variable_get_scope_aux:w
    { \cs_to_str:N #1 \exp_stop_f: \q_nil }
  }
  \cs_new_nopar:Npn \keys_variable_get_scope_aux:w #1#2 \q_nil {
    \token_if_eq_meaning:NNT & #1 {g}
  }
}
\group_begin:
  \char_set_lccode:nn {`\&} {`\_}
  \char_make_other:N \&
\tl_to_lowercase:n {
  \group_end:
  \cs_new_nopar:Nn \keys_variable_get_type:N {
    \exp_after:wN \keys_variable_get_type_aux:w 
      \token_to_str:N #1 & a \q_nil 
  }
  \cs_new_nopar:Npn \keys_variable_get_type_aux:w #1 & #2#3 \q_nil {
    \token_if_eq_meaning:NNTF a #2 {
      #1
    }{
      \keys_variable_get_type_aux:w #2#3 \q_nil
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_variable_set:NN}
% To set a variable, there is first a check so that it must exist.
% The setting function is then created by recovering the type and
% scope from the variable name.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_variable_set:NN {
  \cs_if_exist:cF {
    \keys_variable_get_type:N #2 _
    \keys_variable_get_scope:N #2 set:N #1
  } {
    \msg_kernel_error:nxx { key-no-set-function } {
      \exp_not:c {
        \keys_variable_get_type:N #2 _
        \keys_variable_get_scope:N #2 set:N #1
      }
    } {#2}
  }
  \cs_if_exist:NF #2 {
    \use:c { \keys_variable_get_type:N #2 _new:N } #2
  }
  \keys_cmd_set:nNx { \l_keys_path_tl } 1 {
    \exp_not:c { 
      \keys_variable_get_type:N #2 _
      \keys_variable_get_scope:N #2 set:N #1 
    } \exp_not:N #2 {##1}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Properties}
%
%\begin{macro}{.bool:N}
% One function for this.
%    \begin{macrocode}
\keys_property_new:nn { .bool:N } {
  \keys_bool_set:N #1
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{.choice:}
% Making a choice is handled internally, as it is also needed by
% \texttt{.generate_choices:nn}.
%    \begin{macrocode}
\keys_property_new:nn { .choice: } {
  \keys_choice_make:
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{.code:n}
%\begin{macro}{.code:x}
%\begin{macro}{.code:Nn}
%\begin{macro}{.code:Nx}
% Creating code is simply a case of passing through to the underlying
% \texttt{set} function.
%    \begin{macrocode}
\keys_property_new:nn { .code:n } {
  \keys_cmd_set:nNn { \l_keys_path_tl } 1 {#1}
}
\keys_property_new:nn { .code:Nn } {
  \keys_cmd_set:nNn { \l_keys_path_tl } #1 {#2}
}
\keys_property_new:nn { .code:x } {
  \keys_cmd_set:nNx { \l_keys_path_tl } 1 {#1}
}
\keys_property_new:nn { .code:Nx } {
  \keys_cmd_set:nNx { \l_keys_path_tl } #1 {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.default:n}
%\begin{macro}{.default:V}
% Expansion is left to the internal functions.
%    \begin{macrocode}
\keys_property_new:nn { .default:n } {
  \keys_default_set:n  {#1} 
}
\keys_property_new:nn { .default:V } {
  \keys_default_set:V #1
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.function:N}
% Creating functions is pretty easy, so is done without an extra
% internal function. There is a check to ensure that the function is 
% defined.
%    \begin{macrocode}
\keys_property_new:nn { .function:N } {
  \keys_cmd_set:nNn { \l_keys_path_tl } 1 {
    \cs_set:Nn #1 {##1}
  } 
  \cs_if_free:NT #1 {
    \cs_set:Nn #1 { }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{.generate_choices:nn}
%\begin{macro}{.generate_choices:nx}
% Making choices is expansion-dependent.
%    \begin{macrocode}
\keys_property_new:nn { .generate_choices:nn } {
  \keys_choices_generate:nx {#1} { \exp_not:n {#2} }
}
\keys_property_new:nn { .generate_choices:nx } {
  \keys_choices_generate:nx {#1} {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.initial:n}
%\begin{macro}{.initial:V}
% Sending things off as usual.
%    \begin{macrocode}
\keys_property_new:nn { .initial:n } {
  \keys_initial_value:n {#1}
}
\keys_property_new:nn { .initial:V } {
  \keys_initial_value:V #1
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.meta:n}
%\begin{macro}{.meta:x}
% Making a meta is handled internally.
%    \begin{macrocode}
\keys_property_new:nn { .meta:n } {
  \keys_meta_make:n {#1}
}
\keys_property_new:nn { .meta:x } {
  \keys_meta_make:x {#1}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.set:N}
%\begin{macro}{.set_x:N}
% Setting a variable is very easy: just pass the data along.
%    \begin{macrocode}
\keys_property_new:nn { .set:N } {
  \keys_variable_set:NN n #1
}
\keys_property_new:nn { .set_x:N } {
  \keys_variable_set:NN x #1
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.value_forbidden:}
%\begin{macro}{.value_required:}
% These are very similar, so both call the same function.
%    \begin{macrocode}
\keys_property_new:nn { .value_forbidden: } {
  \keys_value_requirement:n { forbidden }
}
\keys_property_new:nn { .value_required: } {
  \keys_value_requirement:n { required } 
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsubsection{Messages}
%
% For when there is a need to complain.
%    \begin{macrocode}
\msg_kernel_new:nn { key-choice-unknown } {%
  Choice `#2' unknown for key `#1':\\%
  the key is being ignored.%
}
\msg_kernel_new:nn { key-initial-without-code } {%
  An initial value cannot be set for key `#1':
  the key has not yet been created.%
}
\msg_kernel_new:nn { key-unknown } {%
  The key `#1' is unknown and is being ignored.%
}
\msg_kernel_new:nn { key-value-forbidden }{%
  The key `#1' cannot taken a value:\\%
  the given input `#2' is being ignored.%
}
\msg_kernel_new:nn { key-value-required } {%
  The key `#1' requires a value\\%
  and is being ignored.%
}
\msg_kernel_new:nn { key-no-property } {%
  No property given in definition of key `#1'.%
}
\msg_kernel_new:nnn { key-no-set-function } {%
  There is no function #1\\%
  for setting variable \exp_not:N #2.%
}{%
  LaTeX can only `set' variables which have a function\\%
  \exp_not:N \<var>_(g)set:Nn, or in some cases 
  \exp_not:N \<var>_(g)set:Nx.\\%
  You have asked to `set' some other kind of variable.%
  
}
\msg_kernel_new:nn { key-property-unknown } {%
  The key property `#1' is unknown.%
}
\msg_kernel_new:nn { key-property-value-required } {%
  The property `#1' requires a value\\%
  and is being ignored.%
}
%    \end{macrocode}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
%\end{implementation}