% \iffalse
%% File: l3seq.dtx Copyright (C) 1990-2009 LaTeX3 project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``expl3 bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{l3names}
%</driver|package>
%\fi
\GetIdInfo$Id$
          {L3 Experimental sequences and stacks}
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass[full]{l3doc}
\begin{document}
\DocInput{\filename.\filenameext}
\end{document}
%</driver>
% \fi
%
%
% \title{The \textsf{l3seq} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Sequences}
% \author{\Team}
% \date{\filedate}
% \maketitle
%
%
%
% \section{Sequences}
%
% \LaTeX3 implements a data type called `sequences'. These are special
% token lists that can be accessed via special function on the `left'.
% Appending tokens is possible at both ends. Appended token lists can be
% accessed only as a union.  The token lists that form the individual
% items of a sequence might contain any tokens except two internal
% functions that are used to structure sequences (see section internal
% functions below).  It is also possible to map functions on such
% sequences so that they are executed for every item on the sequence.
%
% All functions that return items from a sequence in some \m{tlp} assume
% that the \m{tlp} is local. See remarks below if you need a global
% returned value.
%
% The defined functions are not orthogonal in the sense that every
% possible variation possible is actually available. If you need a new
% variant use the expansion functions described in the package
% \texttt{l3expan} to build it.
%
% Adding items to the left of a sequence can currently be done with
% either something like "\seq_put_left:Nn" or with a ``stack'' function
% like "\seq_push:Nn" which has the same effect. Maybe one should
% therefore remove the ``left'' functions totally.
%
% \subsection{Functions for creating/initialising sequences}
%
% \begin{function}{ \seq_new:N |
%                   \seq_new:c }
% \begin{syntax}
%    "\seq_new:N" <sequence>
% \end{syntax}
% Defines <sequence> to be a variable of type "seq".
% \end{function}
%
% \begin{function}{ \seq_clear:N |
%                   \seq_clear:c |
%                  \seq_gclear:N |
%                  \seq_gclear:c }
% \begin{syntax}
%   "\seq_clear:N"  <sequence>
% \end{syntax}
% These functions locally or globally clear <sequence>.
% \end{function}
%
% \begin{function}{ \seq_clear_new:N |
%                   \seq_clear_new:c |
%                  \seq_gclear_new:N |
%                  \seq_gclear_new:c }
% \begin{syntax}
%   "\seq_clear_new:N"  <sequence>
% \end{syntax}
% These functions locally or globally clear <sequence> if it exists or 
% otherwise allocates it.
% \end{function}
%
% \begin{function}{ \seq_set_eq:NN |
%                   \seq_set_eq:cN |
%                   \seq_set_eq:Nc |
%                   \seq_set_eq:cc }
% \begin{syntax}
%   "\seq_set_eq:NN" <seq1> <seq2>
% \end{syntax}
% Function that locally makes <seq1> identical to <seq2>.
% \end{function}
%              
% \begin{function}{ \seq_gset_eq:NN |
%                   \seq_gset_eq:cN |
%                   \seq_gset_eq:Nc |
%                   \seq_gset_eq:cc }
% \begin{syntax}
%   "\seq_gset_eq:NN" <seq1> <seq2>
% \end{syntax}
% Function that globally makes <seq1> identical to <seq2>.
% \end{function}
%
% \begin{function}{%
%                  \seq_gconcat:NNN |
%                  \seq_gconcat:ccc |
% }
% \begin{syntax}
%   "\seq_gconcat:NNN" <seq1> <seq2> <seq3>
% \end{syntax}
% Function that conatenates <seq2> and <seq3> and globally assigns the
% result to <seq1>.
% \end{function}
%
% \subsection{Adding data to sequences}
%
% \begin{function}{%
%                  \seq_put_left:Nn |
%                  \seq_put_left:No |
%                  \seq_put_left:Nx |
%                  \seq_put_left:cn |
%                  \seq_put_left:co |
% }
% \begin{syntax}
%   "\seq_put_left:Nn" <sequence> <token list>
% \end{syntax}
% Locally  appends <token list> as a single item to the left
% of <sequence>. <token list> might get expanded before
% appending according to the variant.
% \end{function}
%
% \begin{function}{%
%                  \seq_put_right:Nn |
%                  \seq_put_right:No |
%                  \seq_put_right:Nx |
%                  \seq_put_right:cn |
%                  \seq_put_right:co |
% }
% \begin{syntax}
%   "\seq_put_right:Nn" <sequence> <token list>
% \end{syntax}
% Locally  appends <token list> as a single item to the right
% of <sequence>. <token list> might get expanded before
% appending according to the variant.
% \end{function}
%
% \begin{function}{%
%                  \seq_gput_left:Nn |
%                  \seq_gput_left:No |
%                  \seq_gput_left:Nx |
%                  \seq_gput_left:cn |
%                  \seq_gput_left:co |
% }
% \begin{syntax}
%   "\seq_gput_left:Nn" <sequence> <token list>
% \end{syntax}
% Globally appends <token list> as a single item to the left
% of <sequence>.
% \end{function}
%
% \begin{function}{%
%                  \seq_gput_right:Nn |
%                  \seq_gput_right:No |
%                  \seq_gput_right:Nx |
%                  \seq_gput_right:cn |
%                  \seq_gput_right:co |
% }
% \begin{syntax}
%   "\seq_gput_right:Nn" <sequence> <token list>
% \end{syntax}
% Globally appends <token list> as a single item to the right
% of <sequence>.
% \end{function}
%
% \begin{function}{%
%                  \seq_gput_right:Nc |
% }
% Variant of the above used in the |xor| package.
% Will probably be moved soon to that package. (Sep 2008)
% \end{function}
%
% \subsection{Working with sequences}
%
% \begin{function}{%
%                  \seq_get:NN |
%                  \seq_get:cN |
% }
% \begin{syntax}
%    "\seq_get:NN" <sequence> <tlp>
% \end{syntax}
% Functions that locally assign the left-most item of <sequence> to the
% token list pointer <tlp>. Item is not removed from <sequence>! If you
% need a global return value you need to code something like this:
% \begin{quote}
%   "\seq_get:NN" <sequence> "\l_tmpa_tlp" \\
%   "\tlp_gset_eq:NN" <global tlp> "\l_tmpa_tlp"
% \end{quote}
% But if this kind of construction is used often enough a separate
% function should be provided.
% \end{function}
%
%
% \begin{function}{\seq_map_variable:NNn |
%                  \seq_map_variable:cNn
% }
% \begin{syntax}
%   "\seq_map_variable:NNn" <sequence> <tlp> \Arg{code using tlp}
% \end{syntax}
% Every element in <sequence> is assigned to <tlp> and then <code
% using tlp> is executed. The operation is not expandable which means
% that it can't be used within write operations etc. However, this
% function can be nested which the others can't.
% \end{function}
%
% \begin{function}{ \seq_map:NN |
%                   \seq_map:cN }
% \begin{syntax}
%    "\seq_map:NN" <sequence> <function>
% \end{syntax}
% This function applies <function> (which must be a function with one
% argument) to every item of <sequence>. <function> is not executed
% within a sub-group so that side effects can be achieved locally. The
% operation is not expandable which means that it can't be used within
% write operations etc.
%
% In the current implementation the next functions are more efficient and
% should be preferred.
% \end{function}
%
% \begin{function}{\seq_map_inline:Nn |
%                  \seq_map_inline:cn
% }
% \begin{syntax}
%   "\seq_map_inline:Nn" <sequence> \Arg{inline function}
% \end{syntax}
% Applies <inline function> (which should be the direct coding for a
% function with one argument (i.e.\ use "#1" as the place holder for
% this argument)) to every item of <sequence>.  <inline function> is not
% executed within a sub-group so that side effects can be achieved locally.
% The operation is not expandable which means that it can't be used
% within write operations etc.
% \end{function}
%
% \begin{function}{ \seq_show:N |
%                   \seq_show:c }
% \begin{syntax}
%   "\seq_show:N" <sequence>
% \end{syntax}
% Function that pauses the compilation and displays <seq> in the terminal
% output and in the log file. (Usually used for diagnostic purposes.)
% \end{function}
%
% \begin{function}{ \seq_display:N |
%                   \seq_display:c }
% \begin{syntax}
%   "\seq_display:N" <sequence>
% \end{syntax}
% As with "\seq_show:N" but pretty prints the output one line per element.
% \end{function}
%
% \subsection{Predicates and conditionals}
%
% \begin{function}{ \seq_if_empty_p:N / (EXP) | 
%                   \seq_if_empty_p:c / (EXP) }
% \begin{syntax}
%   "\seq_if_empty_p:N" <sequence>
% \end{syntax}
% This predicate returns `true' if <sequence> is `empty' i.e., doesn't
% contain any items. Note that this is `false' even if the <sequence> only
% contains a single empty item.
% \end{function}
%
% \begin{function}{ \seq_if_empty:N / (TF) |
%                   \seq_if_empty:c / (TF) }
% \begin{syntax}
%   "\seq_if_empty:NTF" <sequence> \Arg{true code} \Arg{false code}
% \end{syntax}
% Set of conditionals that test whether or not a particular <sequence>
% is empty and if so executes either <true code> or <false code>.
% \end{function}
%
% \begin{function}{ \seq_if_in:Nn / (TF) |
%                   \seq_if_in:cn / (TF) |
%                   \seq_if_in:co / (TF) |
%                   \seq_if_in:cx / (TF) }
% \begin{syntax}
%   "\seq_if_in:NnTF" <sequence> \Arg{item} \Arg{true code} \Arg{false code}
% \end{syntax}
% Functions that test if <item> is in <sequence>. Depending on the result
% either <true code> or <false code> is executed.
% \end{function}
%
% \subsection{Internal functions}
%
% \begin{function}{\seq_if_empty_err:N}
% \begin{syntax}
%   "\seq_if_empty_err:N" <sequence>
% \end{syntax}
% Signals an \LaTeX3 error if <sequence> is empty.
% \end{function}
%
% \begin{function}{\seq_pop_aux:nnNN}
% \begin{syntax}
%   "\seq_pop_aux:nnNN" <assign1> <assign2> <sequence> <tlp>
% \end{syntax}
% Function that assigns the left-most item of <sequence> to <tlp> using
% <assign1> and assigns the tail to <sequence> using <assign2>. This
% function could be used to implement a global return function.
% \end{function}
%
% \begin{function}{%
%                  \seq_get_aux:w |
%                  \seq_pop_aux:w |
%                  \seq_put_aux:Nnn |
%                  \seq_put_aux:w |
% }
% Functions used to implement put and get operations. They  are not for
% meant for direct use.
% \end{function}
%
% \begin{function}{ \seq_map_variable_aux:nw |
%                   \seq_map_break: | \seq_map_break:n }
% Functions used to implement mapping operations. They  are not for
% meant for direct use.
% \end{function}
%
% \begin{function}{ \seq_elt:w    |
%                   \seq_elt_end: }
% Functions (usually used as constants) that separates items within a
% sequence. They might get special meaning during mapping operations and
% are not supposed to show up as tokens within an item appended to a
% sequence.
% \end{function}
%
% \subsection{Functions for `Sequence Stacks'}
%
% Special sequences in \LaTeX3 are `stacks' with their usual operations
% of `push', `pop', and `top'. They are internally implemented as
% sequences and share some of the functions (like "\seq_new:N" etc.)
%
% \begin{function}{%
%                  \seq_push:Nn |
%                  \seq_push:No |
%                  \seq_push:cn |
%                  \seq_gpush:Nn |
%                  \seq_gpush:No |
%                  \seq_gpush:Nv |
%                  \seq_gpush:cn |
% }
% \begin{syntax}
%   "\seq_push:Nn" <stack> \Arg{token list}
% \end{syntax}
% Locally or globally pushes <token list> as a single item onto the
% <stack>.
% \end{function}
%
% \begin{function}{%
%                  \seq_pop:NN |
%                  \seq_pop:cN |
%                  \seq_gpop:NN |
%                  \seq_gpop:cN |
% }
% \begin{syntax}
%    "\seq_pop:NN" <stack> <tlp>
% \end{syntax}
% Functions that assign the top item of <stack> to the token
% list pointer <tlp> and removes it from <stack>!
% \end{function}
%
% \begin{function}{%
%                  \seq_top:NN |
%                  \seq_top:cN |
% }
% \begin{syntax}
%    "\seq_top:NN" <stack> <tlp>
% \end{syntax}
% Functions that locally assign the top item of <stack> to the token
% list pointer <tlp>. Item is \emph{not} removed from <stack>!
% \end{function}
%
% \StopEventually{}
%
% \subsection{Implementation}
%
%
% We start by ensuring that the required packages are loaded. \file{l3toks}, 
% \file{l3io}, and \file{l3messages} are only required for "\seq_display:N".
%    \begin{macrocode}
%<package>\ProvidesExplPackage
%<package>  {\filename}{\filedate}{\fileversion}{\filedescription}
%<package&!check>\RequirePackage{l3quark}
%<package&!check>\RequirePackage{l3tlp}
%<package&check>\RequirePackage{l3chk}
%<package>\RequirePackage{l3expan}
%<package>\RequirePackage{l3toks}
%<package>\RequirePackage{l3io}
%<package>\RequirePackage{l3messages}
%    \end{macrocode}
%
% A sequence is a control sequence whose top-level expansion is of the
% form `|\seq_elt:w| \m{text$\sb1$} |\seq_elt_end:| \ldots{}
% |\seq_elt:w| \meta{text$\sb{n}$} \ldots'. We use explicit delimiters
% instead of braces around \m{text} to allow efficient searching for
% an item in the sequence.
%
% \begin{macro}{\seq_elt:w}
% \begin{macro}{\seq_elt_end:}
%    We allocate the delimiters and make them errors if executed.
%    \begin{macrocode}
%<*initex|package>
\cs_new_eq:NN \seq_elt:w \ERROR
\cs_new_eq:NN \seq_elt_end: \ERROR
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Allocating and initialisation}
%
% \begin{macro}{\seq_new:N}
% \begin{macro}{\seq_new:c}
%    Sequences are implemented using token lists.
%    \begin{macrocode}
\cs_new_eq:NN \seq_new:N \tlp_new:N
\cs_new_eq:NN \seq_new:c \tlp_new:c
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\seq_clear:N}
% \begin{macro}{\seq_clear:c}
% \begin{macro}{\seq_gclear:N}
% \begin{macro}{\seq_gclear:c}
%    Clearing a sequence is the same as clearing a token list.
%    \begin{macrocode}
\cs_new_eq:NN \seq_clear:N  \tlp_clear:N
\cs_new_eq:NN \seq_clear:c  \tlp_clear:c
\cs_new_eq:NN \seq_gclear:N \tlp_gclear:N
\cs_new_eq:NN \seq_gclear:c \tlp_gclear:c
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\seq_clear_new:N}
% \begin{macro}{\seq_clear_new:c}
% \begin{macro}{\seq_gclear_new:N}
% \begin{macro}{\seq_gclear_new:c}
%    Clearing a sequence is the same as clearing a token list.
%    \begin{macrocode}
\cs_new_eq:NN \seq_clear_new:N  \tlp_clear_new:N
\cs_new_eq:NN \seq_clear_new:c  \tlp_clear_new:c
\cs_new_eq:NN \seq_gclear_new:N \tlp_gclear_new:N
\cs_new_eq:NN \seq_gclear_new:c \tlp_gclear_new:c
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}   
%                              
% \begin{macro}{\seq_set_eq:NN}
% \begin{macro}{\seq_set_eq:Nc} 
% \begin{macro}{\seq_set_eq:cN}
% \begin{macro}{\seq_set_eq:cc} 
%    We can set one "seq" equal to another.
%    \begin{macrocode}                
\cs_new_eq:NN \seq_set_eq:NN \cs_set_eq:NN   
\cs_new_eq:NN \seq_set_eq:cN \cs_set_eq:cN   
\cs_new_eq:NN \seq_set_eq:Nc \cs_set_eq:Nc   
\cs_new_eq:NN \seq_set_eq:cc \cs_set_eq:cc                        
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\seq_gset_eq:NN}
% \begin{macro}{\seq_gset_eq:cN}
% \begin{macro}{\seq_gset_eq:Nc}
% \begin{macro}{\seq_gset_eq:cc}
%    And of course globally which seems to be needed far more
%    often.\footnote{To save a bit of space these functions could be made
%    identical to those from the tlp or clist module.}
%    \begin{macrocode}               
\cs_new_eq:NN \seq_gset_eq:NN \cs_gset_eq:NN 
\cs_new_eq:NN \seq_gset_eq:cN \cs_gset_eq:cN 
\cs_new_eq:NN \seq_gset_eq:Nc \cs_gset_eq:Nc 
\cs_new_eq:NN \seq_gset_eq:cc \cs_gset_eq:cc                       
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\seq_gconcat:NNN}
% \begin{macro}{\seq_gconcat:ccc}
%    |\seq_gconcat:NNN| \m{seq~1} \m{seq~2} \m{seq~3} will globally
%    assign \m{seq~1} the concatenation of \m{seq~2} and \m{seq~3}.
%    \begin{macrocode}
\cs_new_nopar:Npn \seq_gconcat:NNN #1#2#3{
  \tlp_gset:Nx #1 {\exp_not:o{#2}\exp_not:o{#3}}
}
\cs_new_nopar:Npn \seq_gconcat:ccc { \exp_args:Nccc \seq_gconcat:NNN }
%    \end{macrocode}
% \end{macro}
% \end{macro} 
%
% \subsubsection{Predicates and conditionals}
%
% \begin{macro}{\seq_if_empty_p:N}
% \begin{macro}{\seq_if_empty_p:c}
%    A predicate which evaluates to |\c_true| iff the sequence is empty.
%    \begin{macrocode}
\cs_new_eq:NN \seq_if_empty_p:N \tlp_if_empty_p:N
\cs_new_eq:NN \seq_if_empty_p:c \tlp_if_empty_p:c
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[TF]{\seq_if_empty:N}
% \begin{macro}[TF]{\seq_if_empty:c}
%    |\seq_if_empty:NTF|\m{seq}\m{true~case}\m{false~case} will check
%    whether the \m{seq} is empty and then select one of the other
%    arguments.
%    \begin{macrocode}
\cs_new_eq:NN  \seq_if_empty:NTF \tlp_if_empty:NTF
\cs_new_eq:NN  \seq_if_empty:NFT \tlp_if_empty:NFT
\cs_new_eq:NN  \seq_if_empty:NT  \tlp_if_empty:NT
\cs_new_eq:NN  \seq_if_empty:NF  \tlp_if_empty:NF
\cs_new_eq:NN  \seq_if_empty:cTF \tlp_if_empty:cTF
\cs_new_eq:NN  \seq_if_empty:cFT \tlp_if_empty:cFT
\cs_new_eq:NN  \seq_if_empty:cT  \tlp_if_empty:cT
\cs_new_eq:NN  \seq_if_empty:cF  \tlp_if_empty:cF
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\seq_if_empty_err:N}
%   Signals an error if the sequence is empty.
%    \begin{macrocode}
\cs_new_nopar:Npn \seq_if_empty_err:N #1 {
  \if_meaning:NN #1 \c_empty_tlp
%    \end{macrocode}
%    As I said before, I don't think we need to provide checks for this
%    kind of error, since it is a severe internal macro package error
%    that can not be produced by the user directly. Can it? So the
%    next line of code should be probably removed.
%    (Will: I have no idea what this comment means.)
%    \begin{macrocode}
    \tlp_clear:N \l_testa_tlp % catch prefixes
    \err_latex_bug:x{Empty~sequence~`\token_to_str:N#1'}
  \fi:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[TF]{\seq_if_in:Nn}
% \begin{macro}[TF]{\seq_if_in:cn}
% \begin{macro}[TF]{\seq_if_in:co}
% \begin{macro}[TF]{\seq_if_in:cx}
%    |\seq_if_in:NnTF| \m{seq}\m{item} \m{true~case} \m{false~case}
%    will check whether \m{item} is in \m{seq} and then either execute
%    the \m{true~case} or the \m{false~case}. \m{true~case} and
%    \m{false~case} may contain incomplete |\if_charcode:w|
%    statements.
%
%    Note that |##2| in the definition below for "\tmp:w" contains 
%    exactly one token which we can compare with |\q_no_value|.
%    \begin{macrocode}
\def_long_test_function_new:npn {seq_if_in:Nn} #1#2 {
  \cs_set:Npn \tmp:w ##1 \seq_elt:w #2 \seq_elt_end: ##2##3 \q_stop {
    \reverse_if:N \if_meaning:NN \q_no_value ##2
  }
  \exp_after:NN \tmp:w #1 \seq_elt:w #2 \seq_elt_end: \q_no_value \q_stop
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_nopar:Npn \seq_if_in:coTF { \exp_args:Nco \seq_if_in:NnTF }
\cs_new_nopar:Npn \seq_if_in:coT  { \exp_args:Nco \seq_if_in:NnT  }
\cs_new_nopar:Npn \seq_if_in:coF  { \exp_args:Nco \seq_if_in:NnF  }
\cs_new_nopar:Npn \seq_if_in:coFT { \exp_args:Nco \seq_if_in:NnFT }
\cs_new_nopar:Npn \seq_if_in:cnTF { \exp_args:Nc  \seq_if_in:NnTF }
\cs_new_nopar:Npn \seq_if_in:cnT  { \exp_args:Nc  \seq_if_in:NnT  }
\cs_new_nopar:Npn \seq_if_in:cnF  { \exp_args:Nc  \seq_if_in:NnF  }
\cs_new_nopar:Npn \seq_if_in:cnFT { \exp_args:Nc  \seq_if_in:NnFT }
\cs_new_nopar:Npn \seq_if_in:cxTF { \exp_args:Ncx \seq_if_in:NnTF }
\cs_new_nopar:Npn \seq_if_in:cxT  { \exp_args:Ncx \seq_if_in:NnT  }
\cs_new_nopar:Npn \seq_if_in:cxF  { \exp_args:Ncx \seq_if_in:NnF  }
\cs_new_nopar:Npn \seq_if_in:cxFT { \exp_args:Ncx \seq_if_in:NnFT }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Getting data out}
%
% \begin{macro}{\seq_get:NN}
% \begin{macro}{\seq_get:cN}
% \begin{macro}{\seq_get_aux:w}
%    |\seq_get:NN |\meta{sequence}\meta{cmd} defines \meta{cmd} to be the
%    left-most element of \meta{sequence}.
%    \begin{macrocode}
\cs_new_nopar:Npn \seq_get:NN #1 {
  \seq_if_empty_err:N #1
  \exp_after:NN \seq_get_aux:w #1 \q_stop
}
\cs_new:Npn \seq_get_aux:w \seq_elt:w #1 \seq_elt_end: #2 \q_stop #3 {
  \tlp_set:Nn #3 {#1}
}
\cs_new_nopar:Npn \seq_get:cN { \exp_args:Nc \seq_get:NN }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\seq_pop_aux:nnNN}
% \begin{macro}{\seq_pop_aux:w}
%    |\seq_pop_aux:nnNN| \meta{def$\sb1$} \meta{def$\sb2$} \meta{sequence}
%    \meta{cmd} assigns the left_most element of \meta{sequence} to
%    \meta{cmd} using \meta{def$\sb2$}, and assigns the tail of
%    \meta{sequence} to \meta{sequence} using \meta{def$\sb1$}.
%    \begin{macrocode}
\cs_new:Npn \seq_pop_aux:nnNN #1#2#3 {
  \seq_if_empty_err:N #3
  \exp_after:NN \seq_pop_aux:w #3 \q_stop #1#2#3
}
\cs_new:Npn \seq_pop_aux:w 
    \seq_elt:w #1 \seq_elt_end: #2\q_stop #3#4#5#6 {
  #3 #5 {#2}
  #4 #6 {#1}
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\seq_show:N}
% \begin{macro}{\seq_show:c}
%    \begin{macrocode}
\cs_new_eq:NN \seq_show:N \tlp_show:N
\cs_new_eq:NN \seq_show:c \tlp_show:c
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\seq_display:N}
% \begin{macro}{\seq_display:c}
%    \begin{macrocode}
\cs_new_nopar:Npn \seq_display:N #1 {
  \io_put_term:x { Sequence~\token_to_str:N #1~contains~
                   the~elements~(without~outer~braces):} 
  \toks_clear:N \l_tmpa_toks
  \seq_map_inline:Nn #1 {
    \toks_if_empty:NF  \l_tmpa_toks {
      \toks_put_right:Nx \l_tmpa_toks {^^J>~}
    }
    \toks_put_right:Nx \l_tmpa_toks {\text_put_four_sp:\c_iow_lbrace_char}
    \toks_put_right:Nn \l_tmpa_toks {##1}
    \toks_put_right:Nx \l_tmpa_toks {\c_iow_rbrace_char}
  }
  \toks_show:N\l_tmpa_toks
}
\cs_new_nopar:Npn \seq_display:c { \exp_args:Nc \seq_display:N }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsubsection{Putting data in}
%
% \begin{macro}{\seq_put_aux:Nnn}
% \begin{macro}{\seq_put_aux:w}
%    |\seq_put_aux:Nnn| \meta{sequence} \meta{left} \meta{right} adds the
%    elements specified by \meta{left} to the left of \meta{sequence}, and
%    those specified by \meta{right} to the right.
%    \begin{macrocode}
\cs_new:Npn \seq_put_aux:Nnn #1 {
  \exp_after:NN \seq_put_aux:w #1 \q_stop #1
}
\cs_new:Npn \seq_put_aux:w #1\q_stop #2#3#4 { \tlp_set:Nn #2 {#3#1#4} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\seq_put_left:Nn}
% \begin{macro}{\seq_put_left:No}
% \begin{macro}{\seq_put_left:Nx}
% \begin{macro}{\seq_put_left:cn}
% \begin{macro}{\seq_put_left:co}
% \begin{macro}{\seq_put_right:Nn}
% \begin{macro}{\seq_put_right:No}
% \begin{macro}{\seq_put_right:Nx}
% \begin{macro}{\seq_put_right:cn}
% \begin{macro}{\seq_put_right:co}
%    Here are the usual operations for adding to the left and right.
%    \begin{macrocode}
\cs_new:Npn \seq_put_left:Nn #1#2 {
  \seq_put_aux:Nnn #1 {\seq_elt:w #2\seq_elt_end:} {}
}
%    \end{macrocode}
%    We can't put in a |\use_noop:| instead of |{}| above since this argument 
%    is passed literally (and we would end up with many |\use_noop:|s inside
%    the sequences).
%    \begin{macrocode}
\cs_new_nopar:Npn \seq_put_left:No { \exp_args:NNo \seq_put_left:Nn }
\cs_new_nopar:Npn \seq_put_left:Nx { \exp_args:NNx \seq_put_left:Nn }
\cs_new_nopar:Npn \seq_put_left:cn { \exp_args:Nc  \seq_put_left:Nn }
\cs_new_nopar:Npn \seq_put_left:co { \exp_args:Nco \seq_put_left:Nn }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \seq_put_right:Nn #1#2{
        \seq_put_aux:Nnn #1{}{\seq_elt:w #2\seq_elt_end:}}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_nopar:Npn \seq_put_right:No { \exp_args:NNo \seq_put_right:Nn }
\cs_new_nopar:Npn \seq_put_right:Nx { \exp_args:NNx \seq_put_right:Nn }
\cs_new_nopar:Npn \seq_put_right:cn { \exp_args:Nc  \seq_put_right:Nn }
\cs_new_nopar:Npn \seq_put_right:co { \exp_args:Nco \seq_put_right:Nn }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\seq_gput_left:Nn}
% \begin{macro}{\seq_gput_left:No}
% \begin{macro}{\seq_gput_left:Nx}
% \begin{macro}{\seq_gput_left:cn}
% \begin{macro}{\seq_gput_left:co}
% \begin{macro}{\seq_gput_right:Nn}
% \begin{macro}{\seq_gput_right:No}
% \begin{macro}{\seq_gput_right:Nx}
% \begin{macro}{\seq_gput_right:cn}
% \begin{macro}{\seq_gput_right:co}
%    \begin{macrocode}
\cs_new:Npn \seq_gput_left:Nn {
%<*check>
  \pref_global_chk:
%</check>
%<*!check> 
  \pref_global:D
%</!check>
  \seq_put_left:Nn
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \seq_gput_right:Nn {
%<*check>
  \pref_global_chk:
%</check>
%<*!check> 
  \pref_global:D
%</!check>
  \seq_put_right:Nn
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_nopar:Npn \seq_gput_left:No {\exp_args:NNo \seq_gput_left:Nn}
\cs_new_nopar:Npn \seq_gput_left:Nx {\exp_args:NNx \seq_gput_left:Nn}
\cs_new_nopar:Npn \seq_gput_left:cn {\exp_args:Nc  \seq_gput_left:Nn}
\cs_new_nopar:Npn \seq_gput_left:co {\exp_args:Nco \seq_gput_left:Nn}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_nopar:Npn \seq_gput_right:No {\exp_args:NNo \seq_gput_right:Nn}
\cs_new_nopar:Npn \seq_gput_right:Nx {\exp_args:NNx \seq_gput_right:Nn}
\cs_new_nopar:Npn \seq_gput_right:cn {\exp_args:Nc  \seq_gput_right:Nn}
\cs_new_nopar:Npn \seq_gput_right:co {\exp_args:Nco \seq_gput_right:Nn}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\seq_gput_right:Nc}
% TODO: move to |xor| (Sep 2008)
%    \begin{macrocode}
\cs_new_nopar:Npn \seq_gput_right:Nc {\exp_args:NNc \seq_gput_right:Nn}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Mapping}
%
% \begin{macro}{\seq_map_variable:NNn}
% \begin{macro}{\seq_map_variable:cNn}
% \begin{macro}{\seq_map_variable_aux:nw}
% \begin{macro}{\seq_map_break:}
% \begin{macro}{\seq_map_break:n}
%   Nothing spectacular here. The shuffling of the arguments in
%   |\seq_map_variable:NNn| below could also be done with
%   |\exp_args:NNnE|.
%    \begin{macrocode}
\cs_new:Npn \seq_map_variable_aux:Nnw #1#2 \seq_elt:w #3 \seq_elt_end: {
  \tlp_set:Nx #1{\exp_not:n{#3}}
  \quark_if_nil:NT #1 \seq_map_break:
  #2
  \seq_map_variable_aux:Nnw #1{#2}
}
\cs_new:Npn \seq_map_variable:NNn #1#2#3 {
  \tlp_set:Nx #2 {\exp_not:n{\seq_map_variable_aux:Nnw #2{#3}}}
  \exp_after:NN #2 #1 \seq_elt:w \q_nil\seq_elt_end: \q_stop
}
\cs_new_nopar:Npn \seq_map_variable:cNn { \exp_args:Nc \seq_map_variable:NNn }
\cs_new_eq:NN \seq_map_break: \use_none_delimit_by_q_stop:w
\cs_new_eq:NN \seq_map_break:n \use_i_delimit_by_q_stop:nw
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\seq_map:NN}
% \begin{macro}{\seq_map:cN}
%    |\seq_map:NN| \meta{sequence} \meta{cmd} applies \meta{cmd} to each
%    element of \meta{sequence}, from left to right. Since we don't have
%    braces, this implementation is not very efficient. It might be
%    better to say that \meta{cmd} must be a function with one argument
%    that is delimited by |\seq_elt_end:|.
%    \begin{macrocode}
\cs_new_nopar:Npn \seq_map:NN #1#2 {
  \cs_set:Npn \seq_elt:w ##1 \seq_elt_end: {#2{##1}}
  #1
  \cs_set_eq:NN \seq_elt:w \ERROR
}
\cs_new_nopar:Npn \seq_map:cN { \exp_args:Nc \seq_map:NN }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\seq_map_inline:Nn}
% \begin{macro}{\seq_map_inline:cn}
%    When no braces are used, this version of mapping seems more
%    natural.
%    \begin{macrocode}
\cs_new_nopar:Npn \seq_map_inline:Nn #1#2 {
  \cs_set:Npn \seq_elt:w ##1 \seq_elt_end: {#2}
  #1
  \cs_set_eq:NN \seq_elt:w \ERROR
}
\cs_new_nopar:Npn \seq_map_inline:cn { \exp_args:Nc \seq_map_inline:Nn }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Sequence stacks}
%
% \begin{macro}{\seq_push:Nn}
% \begin{macro}{\seq_push:No}
% \begin{macro}{\seq_push:cn}
% \begin{macro}{\seq_pop:NN}
% \begin{macro}{\seq_pop:cN}
%    Since sequences can be used as stacks, we ought to have both
%    `push' and `pop'. In most cases they are nothing more then new
%    names for old functions.
%    \begin{macrocode}
\cs_new_eq:NN \seq_push:Nn \seq_put_left:Nn
\cs_new_eq:NN \seq_push:No \seq_put_left:No
\cs_new_eq:NN \seq_push:cn \seq_put_left:cn
\cs_new_nopar:Npn \seq_pop:NN { \seq_pop_aux:nnNN \tlp_set:Nn \tlp_set:Nn }
\cs_new_nopar:Npn \seq_pop:cN { \exp_args:Nc \seq_pop:NN }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\seq_gpush:Nn}
% \begin{macro}{\seq_gpush:No}
% \begin{macro}{\seq_gpush:cn}
% \begin{macro}{\seq_gpush:Nv}
% \begin{macro}{\seq_gpop:NN}
% \begin{macro}{\seq_gpop:cN}
%    I don't agree with Denys that one needs only local stacks,
%    actually I believe that one will probably need the functions
%    here more often. In case of |\seq_gpop:NN| the value is
%    nevertheless returned locally.
%    \begin{macrocode}
\cs_new_eq:NN  \seq_gpush:Nn \seq_gput_left:Nn
\cs_new_nopar:Npn \seq_gpush:No { \exp_args:NNo \seq_gpush:Nn }
\cs_new_nopar:Npn \seq_gpush:cn { \exp_args:Nc  \seq_gpush:Nn }
\cs_new_nopar:Npn \seq_gpush:Nv { \exp_args:NNv \seq_gpush:Nn }
\cs_new_nopar:Npn \seq_gpop:NN  { \seq_pop_aux:nnNN \tlp_gset:Nn \tlp_set:Nn }
\cs_new_nopar:Npn \seq_gpop:cN  { \exp_args:Nc  \seq_gpop:NN }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\seq_top:NN}
% \begin{macro}{\seq_top:cN}
%    Looking at the top element of the stack without removing it is
%    done with this operation.
%    \begin{macrocode}
\cs_new_eq:NN \seq_top:NN \seq_get:NN
\cs_new_eq:NN \seq_top:cN \seq_get:cN
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
% 
%    Show token usage:
%    \begin{macrocode}
%<*showmemory>
%\showMemUsage
%</showmemory>
%    \end{macrocode}
%
% \Finale
% \PrintIndex
%
% \endinput
