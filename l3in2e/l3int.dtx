% \iffalse
%% File: l3int.dtx Copyright (C) 1990-2005 LaTeX3 project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3a of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``expl3 bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%
%<*!initex>
% \fi
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{%^^A}$
  \def\fileversion{#3}%
  \def\filedate{#4}%
%\iffalse
%<*dtx>
%\fi
     \ProvidesFile{#2.dtx}[#4 v#3 #8]%
%\iffalse
%</dtx>
%<package> \ProvidesPackage{#2}[#4 v#3 #8]%
%<driver>  \ProvidesFile{#2.drv}[#4 v#3 #8]%
% \fi
}
%\iffalse
%</!initex>
%\fi
\next$Id$
          {L3 Experimental Integer module}
%
% \iffalse
%<*driver>
\documentclass{l3doc}

\begin{document}
\DocInput{l3int.dtx}
\end{document}
%</driver>
% \fi
%
%
% \title{The \textsf{l3int} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Counters}
% \author{\Team}
% \date{\filedate}
% \maketitle
%
% \section{Counters}
%
% \LaTeX3 maintains two type of integer registers for internal use.
% One (associated with the name "int") uses the builtin counter
% registers of \TeX{} and is therefore relatively fast and one
% (associated with the name "fint" for fake counter) that implements the
% operations within the \TeX{} macro language and is therefore much
% slower in processing. This type of counter is also far more restricted
% in its range.
%
% The fake counter should be used for variables that are not accessed
% very often since this saves the important fast internal registers
% (\TeX{} has only 255 of those). For example, all allocation routines
% in \LaTeX3 make use of fake counters to remember the values of recent
% allocated register numbers etc.
%
% Since all functions for both types are very similar (they usually
% differ only in the initial "f") we describe them together. But
% remember that you need to use "fint" variables when using "fint"
% functions.
%
% \subsection{Functions}
%
% \begin{function}{%
%                  \int_new:N |
%                  \int_new:c |
%                  \fint_new:N |
% }
% \begin{syntax}
%    "\int_new:N"   <int>
%    "\fint_new:N" <fint>
% \end{syntax}
% Defines <int> to be a new variable of type "int". There is no way to
% define constant counters with these functions.
% \begin{texnote}
% "\int_new:N" is the equivalent to plain \TeX{}'s \tn{newcount}.
% However, the internal register allocation is done differently.
% \end{texnote}
% \end{function}
%
% \begin{function}{%
%                  \int_incr:N |
%                  \int_gincr:N |
%                  \int_gincr:c |
%                  \fint_incr:N |
%                  \fint_gincr:N |
% }
% \begin{syntax}
%   "\int_incr:N"   <int>
%   "\fint_incr:N" <fint>
% \end{syntax}
% Increments <int> by one. For global variables the global versions
% should be used.
% \end{function}
%
% \begin{function}{%
%                  \int_decr:N |
%                  \int_gdecr:N |
%                  \int_gdecr:c |
%                  \fint_decr:N |
%                  \fint_gdecr:N |
% }
% \begin{syntax}
%   "\int_decr:N"   <int>
%   "\fint_decr:N" <fint>
% \end{syntax}
% Decrements <int> by one. For global variables the global versions
% should be used.
% \end{function}
%
% \begin{function}{%
%                  \int_set:Nn |
%                  \int_set:cn |
%                  \int_gset:Nn |
%                  \int_gset:cn |
%                  \fint_set:Nn |
%                  \fint_gset:Nn |
% }
% \begin{syntax}
%   "\int_set:Nn"   <int> "{" <integer> "}"
%   "\fint_set:Nn" <fint> "{" <integer> "}"
% \end{syntax}
% These functions will set the <int> register to the <integer> value.
% \end{function}


% \begin{function}{%
%                  \int_zero:N |
%                  \int_zero:c |
%                  \int_gzero:N |
%                  \int_gzero:c |
% }
% \begin{syntax}
%   "\int_zero:N"   <int>
% \end{syntax}
% These functions sets the <int> register to zero either locally
% or globally.
% \end{function}
%
%
%
% \begin{function}{%
%                  \fint_set_eq:NN |
%                  \fint_gset_eq:NN |
% }
% \begin{syntax}
%    "\fint_set_eq:NN" <fint1> <fint2>
% \end{syntax}
% Fast form for
% \begin{syntax}
%    "\fint_set:No" <fint1> "{\fint_use:N" <fint2> "}"
% \end{syntax}
% when <fint2> is known to be a variable of fake counter. Note that a
% corresponding function for real counters is not implemented since the
% "\int_set:Nn" function does this operation sufficiently when then second
% argument is a <int> instead of "{"<integer>"}" value.
% \end{function}
%
% \begin{function}{%
%                  \int_add:Nn |
%                  \int_add:cn |
%                  \int_gadd:Nn |
%                  \fint_add:Nn |
%                  \fint_gadd:Nn |
% }
% \begin{syntax}
%   "\int_add:Nn"   <int> "{" <integer> "}"
%   "\fint_add:Nn" <fint> "{" <integer> "}"
% \end{syntax}
% These functions will add to the <int> register the value <integer>.  If
% the second argument is a <int> register too, the surrounding braces
% can be left out.
%
% It not allowed to use a <fint> instead of the <integer>. If a fake
% counter should be used as the second argument one needs to turn the
% <fint> first into an <integer> by applying "\fint_use:N".
% \end{function}
%
% \begin{function}{%
%                  \int_sub:Nn |
%                  \int_gsub:Nn |
%                  \fint_sub:Nn |
%                  \fint_gsub:Nn |
% }
% \begin{syntax}
%   "\int_gsub:Nn"   <int> "{" <integer> "}"
%   "\fint_gsub:Nn" <fint> "{" <integer> "}"
% \end{syntax}
% These functions will subtract from the <int> register the value
% <integer>.  If the second argument is a <int> register too, the
% surrounding braces can be left out.
%
% It is not allowed to use a <fint> instead of the <integer>. If a fake
% counter should be used as the second argument one needs to turn the
% <fint> first into an <integer> by applying "\fint_use:N".
% \end{function}
%
% \begin{function}{%
%                  \int_use:N |
%                  \int_use:c |
%                  \fint_use:N |
% }
% \begin{syntax}
%   "\int_use:N"   <int>
%   "\fint_use:N" <fint>
% \end{syntax}
% This function returns the integer value kept in <int> in a way
% suitable for further processing. Be sure to use "\fint_use:N" if you
% are accessing the value of a fake counter because otherwise your
% result will be to some surprise to you (there is no check).
% \begin{texnote}
% The function "\int_use:N" could be implemented directly as the \TeX{}
% primitive "\tex_the:D" which is also responsible to produce the values for
% other internal quantities.  We have chosen to use individual functions
% for counters, dimenions etc.\ to allow checks and to make the code
% more selfexplaining.
% \end{texnote}
% \end{function}
%
% \subsection{Formatting a counter value}
%
% \begin{function}{\int_to_arabic:n |
%  \int_to_alph:n |
%  \int_to_Alph:n |
%  \int_to_roman:n |
%  \int_to_Roman:n |
%  \int_to_symbol:n |
% }
% \begin{syntax}
%   "\int_to_alph:n" "{" <integer> "}"
%   "\int_to_alph:n"  <int>
%   "\int_to_alph:n" "{" "\fint_use:N" <fint> "}"
% \end{syntax}
% If some <integer> or the the current value of a <int> should be
% displayed or typeset in a special ways (e.g., as uppercase roman
% numerals) these function can be used.  We need braces if the argument
% is a simple <integer>, they can be omitted in case of a <int>.
%
%  To format <fint>s with these functions it is necessary to turn the
% value of the <fint> first into an <integer> by applying "\fint_use:N"
% within the argument braces.
%
% All functions are fully expandable and will therefore produce the
% correct output when used inside of deferred writes, etc.
% \begin{texnote}
% These are more or less the internal \LaTeX2 functions \tn{@arabic},
% \tn{@alph}, \tn{Alph}, \tn{@roman}, \tn{@Roman}, and \tn{@fnsymbol}
% except that "\int_to_symbol:n" is also allowed outside math mode.
% \end{texnote}
% \end{function}
%
% \subsection{Variable and constants}
%
% \begin{variable}{%
%                  \c_int_max |
%                  \c_fint_max |
% }
% Constant that denote the maximum value which can be stored in a <int>
% or <fint> register.
% \end{variable}
%
% \begin{variable}{%
%                  \c_minus_one |
%                  \c_zero |
%                  \c_one |
%                  \c_two |
%                  \c_three |
%                  \c_four |
%                  \c_six |
%                  \c_seven |
%                  \c_sixteen |
%                  \c_hundred_one |
%                  \c_twohundred_fifty_five |
%                  \c_twohundred_fifty_six |
%                  \c_thousand |
%                  \c_ten_thousand |
%                  \c_twenty_thousand |
% }
% Set of constants denoting useful values.
% \begin{texnote}
% Most of these constants have been available under \LaTeX2 under names
% like \tn{tw@}, \tn{thr@@} etc.
% \end{texnote}
% \end{variable}
%
% \begin{variable}{%
%                  \l_tmpa_int |
%                  \l_tmpb_int |
%                  \l_tmpc_int |
%                  \g_tmpa_int |
%                  \g_tmpb_int |
% }
% Scratch register for immediate use. They are not used by conditionals
% or predicate functions.
% \end{variable}
%
%
% \subsection{Testing and evaluating integer expressions}
%
% \begin{function}{%
%                  \int_eval:n |
%                  \int_div_truncate:nn |
%                  \int_div_round:nn |
%                  \int_mod:nn |
% }
% \begin{syntax}
%   "\int_eval:n"   "{"<int~expr>"}" \\
%   "\int_div_truncate:n"   "{"<int~expr>"}" "{"<int~expr>"}" \\
%   "\int_mod:nn"   "{"<int~expr>"}" "{"<int~expr>"}"
% \end{syntax}
% Evaluates the value of a integer expression so that
% "\int_eval:n {3*5/4}" puts "4" back into the input stream. Note that
% the results of divisions are rounded by the primitive operations. If
% you want the result of a division to be truncated use
% "\int_div_truncate:nn". "\int_div_round:nn" is added for
% completeness. "\int_mod:nn" returns the remainder of a division. All
% of these functions are expandable.
% \begin{texnote}
% "\int_eval:n" is the eTeX primitive \tn{numexpr} turned into a function
% taking an argument.
% \end{texnote}
% \end{function}
%
% \begin{function}{%
%                  \int_compare:nNnTF |
%                  \int_compare:nNnT |
%                  \int_compare:nNnF |
% }
% \begin{syntax}
%   "\int_compare:nNnTF"   "{"<int~expr>"}" <rel> "{"<int~expr>"}"
%                          "{"<true>"}" "{"<false>"}"
% \end{syntax}
% These functions test two integer expressions against each other. They
% are both evaluated by "\int_eval:n". Note that if both expressions
% are normal integer variables as in
% \begin{quote}
% "\int_compare:nNnTF \l_temp_int < \c_zero {negative}{non-negative}"
% \end{quote}
% you can safely omit the braces.
% \begin{texnote}
% This is the \TeX{} primitive \tn{ifnum} turned into a function.
% \end{texnote}
% \end{function}
%
% \begin{function}{%
%                  \int_compare_p:nNn |
% }
% \begin{syntax}
%   "\int_compare_p:nNn"   "{"<int~expr>"}" <rel> "{"<int~expr>"}"
% \end{syntax}
% A predicate version of the above mentioned functions.
% \end{function}
%
%
% \begin{function}{%
%                  \int_while:nNnT |
%                  \int_while:nNnF |
%                  \int_dowhile:nNnT |
%                  \int_dowhile:nNnF |
% }
% \begin{syntax}
%   "\int_while:nNnT"   <int expr> <rel> <int~expr> "{"<true>"}"
% \end{syntax}
%  "\int_while:nNnT" tests the integer expressions and if true performs
%  the body "T" until the test fails. "\int_dowhile:nNnT" is similar
%  but executes the body first and then performs the check, thus
%  ensuring that the body is executed at least once. The "F" versions
%  are similar but continue the loop as long as the test is false. They
%  could be omitted as it is just a matter of switching the arguments
%  in the test.
% \end{function}
%
% \StopEventually{}
% \section{Integer registers}
%
%
%    We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<package&!check>\RequirePackage{l3basics}\par
%<package&check>\RequirePackage{l3chk}\par
%<*initex|package>
%    \end{macrocode}
%
% Functions that support \LaTeX's user accessible counters should be
% added here, too. But first the internal counters.
%
% \begin{macro}{\int_incr:N}
% \begin{macro}{\int_decr:N}
% \begin{macro}{\int_gincr:N}
% \begin{macro}{\int_gdecr:N}
%    Incrementing and decrementing of integer registers is done with
%    the following functions.
%    \begin{macrocode}
\def_new:Npn \int_incr:N #1{\tex_advance:D#1\c_one
%<*check>
        \chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn \int_decr:N #1{\tex_advance:D#1\c_minus_one
%<*check>
        \chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn \int_gincr:N {
%    \end{macrocode}
%    We make sure that a local variable is not updated globally by
%    changing the internal test (i.e.\ |\chk_local_or_pref_global:N|) before
%    making the assignment. This is done by |\pref_global_chk:| which also
%    issues the necessary |\pref_global:D|. This is not very efficient, but
%    this code will be only included for debugging purposes. Using
%    |\pref_global:D| in front of the local function is better in the
%    production versions.
%    \begin{macrocode}
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \int_incr:N}
\def_new:Npn \int_gdecr:N {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \int_decr:N}
%    \end{macrocode}
%    With the |\int_add:Nn| functions we can shorten the above code.
%    If this makes it too slow \ldots
%    \begin{macrocode}
\def:Npn \int_incr:N #1{\int_add:Nn#1\c_one}
\def:Npn \int_decr:N #1{\int_add:Nn#1\c_minus_one}
\def:Npn \int_gincr:N #1{\int_gadd:Nn#1\c_one}
\def:Npn \int_gdecr:N #1{\int_gadd:Nn#1\c_minus_one}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\int_new:N}
% \begin{macro}{\int_new:c}
%    Allocation of a new internal counter is already done above. Here we define
%    the next likely variant.
%    \begin{macrocode}
%<*initex>
\io_put_term:x{FIXME~Register~allocation~routine~(count)~missing~!}
\def_new:Npn \int_new:N #1{}            % but since we don't distribute
%</initex>
%<package>\let:NN \int_new:N \newcount% allocation better nick the LaTeX one...
\def_new:Npn \int_new:c {\exp_args:Nc \int_new:N}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\int_set:Nn}
% \begin{macro}{\int_set:cn}
% \begin{macro}{\int_gset:Nn}
% \begin{macro}{\int_gset:cn}
%    Setting counters is again something that I would like to make
%    uniform at the moment to get a better overview.
%    \begin{macrocode}
\def_new:Npn \int_set:Nn #1#2{#1#2\scan_stop:
%<*check>
\chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn \int_gset:Nn {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \int_set:Nn }
\def_new:Npn \int_set:cn {\exp_args:Nc \int_set:Nn }
\def_new:Npn \int_gset:cn {\exp_args:Nc \int_gset:Nn }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%  \begin{macro}{\int_zero:N}
%  \begin{macro}{\int_zero:c}
%  \begin{macro}{\int_gzero:N}
%  \begin{macro}{\int_gzero:c}
%  Functions that reset an \m{int} register to zero.
%    \begin{macrocode}
\def_new:Npn \int_zero:N  #1 {#1=\c_zero}
\def_new:Npn \int_zero:c  #1 {\exp_args:Nc \int_zero:N}
\def_new:Npn \int_gzero:N #1 {\pref_global:D #1=\c_zero}
\def_new:Npn \int_gzero:c {\exp_args:Nc \int_gzero:N}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}{\int_add:Nn}
% \begin{macro}{\int_add:cn}
% \begin{macro}{\int_gadd:Nn}
% \begin{macro}{\int_sub:Nn}
% \begin{macro}{\int_gsub:Nn}
%    Adding and substracting to and from a counter \ldots
%    We should think of using these functions
%    \begin{macrocode}
\def_new:Npn \int_add:Nn #1#2{
%    \end{macrocode}
%    We need to say |by| in case the first argment is a register
%    accessed by its number, e.g., |\count23|.
%    \begin{macrocode}
    \tex_advance:D#1 by #2\scan_stop:
%<*check>
    \chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn\int_add:cn{\exp_args:Nc\int_add:Nn}
\def_new:Npn \int_sub:Nn #1#2{
    \tex_advance:D#1-#2\scan_stop:
%<*check>
\chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn \int_gadd:Nn {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \int_add:Nn }
\def_new:Npn \int_gsub:Nn {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \int_sub:Nn }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\int_use:N}
% \begin{macro}{\int_use:c}
%    Here is how counters are accessed:
%    \begin{macrocode}
\let_new:NN \int_use:N \tex_the:D
\def_new:Npn \int_use:c #1{\int_use:N \cs:w#1\cs_end:}
%    \end{macrocode}
% \end{macro}
% \end{macro}

%
% \begin{macro}{\int_gincr:c}
% \begin{macro}{\int_gdecr:c}
%    We also need \ldots
%    \begin{macrocode}
\def_new:Npn \int_gincr:c {\exp_args:Nc \int_gincr:N}
\def_new:Npn \int_gdecr:c {\exp_args:Nc \int_gdecr:N}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\l_tmpa_int}
% \begin{macro}{\l_tmpb_int}
% \begin{macro}{\l_tmpc_int}
% \begin{macro}{\g_tmpa_int}
% \begin{macro}{\g_tmpb_int}
%    We provide two local and two global scratch counters, maybe we
%    need more or less. Instead of using the allocation routines we
%    partly allocate them by hand.
%    \begin{macrocode}
\chk_new_cs:N \l_tmpa_int
%    \end{macrocode}
%    If it turns out that we don't need local counters then this
%    register should be used for global counter. We might also think of
%    using the |\l_last_alloc_fint| as a scratch register.
%    \begin{macrocode}
%%%\tex_countdef:D\l_tmpa_int 255   % not possible while this is taken
%%%                                 % up by \count@
\int_new:N \l_tmpa_int
\int_new:N \l_tmpb_int
\int_new:N \l_tmpc_int
\int_new:N \g_tmpa_int
\int_new:N \g_tmpb_int

\int_new:N \l_loop_int  % a variable for use in loops (whilenum etc)
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\c_minus_one}
% \begin{macro}{\c_zero}
% \begin{macro}{\c_one}
% \begin{macro}{\c_two}
% \begin{macro}{\c_three}
% \begin{macro}{\c_four}
% \begin{macro}{\c_six}
% \begin{macro}{\c_seven}
% \begin{macro}{\c_sixteen}
% \begin{macro}{\c_thirty_two}
% \begin{macro}{\c_hundred_one}
% \begin{macro}{\c_twohundred_fifty_five}
% \begin{macro}{\c_twohundred_fifty_six}
% \begin{macro}{\c_thousand}
% \begin{macro}{\c_ten_thousand}
% \begin{macro}{\c_ten_thousand_one}
% \begin{macro}{\c_ten_thousand_two}
% \begin{macro}{\c_ten_thousand_three}
% \begin{macro}{\c_ten_thousand_four}
% \begin{macro}{\c_twenty_thousand}
% \begin{macro}{\c_int_max}
%    And the usual constants, others are still missing. Please, make
%    every constant a real constant at least for the moment. We can
%    easily convert things in the end when we have found what
%    constants are used in critical places and what not.
%    \begin{macrocode}
 %% \def:Npn       \c_minus_one { -1 }       %% in l3basics
 %% \tex_chardef:D \c_zero    = 0\scan_stop: %% in l3basics
 %% \let:NN \c_zero \z@                      %% in l3basics (package)
\tex_chardef:D \c_one        = 1 \scan_stop:
\tex_chardef:D \c_two        = 2 \scan_stop:
\tex_chardef:D \c_three      = 3 \scan_stop:
\tex_chardef:D \c_four       = 4 \scan_stop:
\tex_chardef:D \c_six        = 6 \scan_stop:
\tex_chardef:D \c_seven      = 7 \scan_stop:
\tex_chardef:D \c_sixteen    = 16 \scan_stop:
\tex_chardef:D \c_thirty_two = 32 \scan_stop:
%    \end{macrocode}
% The next one may seem a little odd (obviously!) but is useful when
% dealing with logical operators.
%    \begin{macrocode}
\tex_chardef:D \c_hundred_one              = 101 \scan_stop:
\tex_chardef:D \c_twohundred_fifty_five    = 255 \scan_stop:
\tex_mathchardef:D \c_twohundred_fifty_six = 256 \scan_stop:
\tex_mathchardef:D \c_thousand             = 1000 \scan_stop:
\tex_mathchardef:D \c_ten_thousand         = 10000 \scan_stop:
\tex_mathchardef:D \c_ten_thousand_one     = 10001 \scan_stop:
\tex_mathchardef:D \c_ten_thousand_two     = 10002 \scan_stop:
\tex_mathchardef:D \c_ten_thousand_three   = 10003 \scan_stop:
\tex_mathchardef:D \c_ten_thousand_four    = 10004 \scan_stop:
\tex_mathchardef:D \c_twenty_thousand      = 20000 \scan_stop:
% already defined ...
%\int_new:N \c_minus_one
%  \c_minus_one         = -1
%    \end{macrocode}
%    The |\c_int_max| will be defined internally as the largest
%    dimen.
%    \begin{macrocode}
%\int_new:N \c_int_max
%  \c_int_max           = 2147483647
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\int_eval:n}
% \begin{macro}{\int_div_truncate:nn}
% \begin{macro}{\int_div_round:nn}
% \begin{macro}{\int_mod:nn}
% Evaluating a calc expression using normal operators. First a wrapper
% for "\etex_numexpr:D" turning it into a function.
%    \begin{macrocode}
\def_new:Npn \int_eval:n #1 {\etex_numexpr:D #1 \scan_stop:}
%    \end{macrocode}
% As "\etex_numexpr:D" rounds the result of a division we also
% provide a version that truncates the result.
%    \begin{macrocode}
\def_new:Npn \int_div_truncate:nn #1#2 {
  \etex_numexpr:D
    (2*\etex_numexpr:D #1\scan_stop: - \etex_numexpr:D #2) /
    (2*\etex_numexpr:D #2)
  \scan_stop:
}
%    \end{macrocode}
% For the sake of completeness:
%    \begin{macrocode}
\def_new:Npn \int_div_round:nn #1#2 {
  \etex_numexpr:D
    \etex_numexpr:D #1\scan_stop:/\etex_numexpr:D #2\scan_stop:
  \scan_stop:
}
%    \end{macrocode}
% Finally there's the modulus operation.
%    \begin{macrocode}
\def_new:Npn \int_mod:nn #1#2 {
  \etex_numexpr:D
    \etex_numexpr:D #1 \scan_stop: -
    \int_div_truncate:nn {#1}{#2} * \etex_numexpr:D #2 \scan_stop:
  \scan_stop:
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\int_compare:nNnTF}
% \begin{macro}{\int_compare:nNnT}
% \begin{macro}{\int_compare:nNnF}
% Simple comparison tests.
%    \begin{macrocode}
\def_new:Npn \int_compare:nNnTF #1#2#3{
  \if_num:w \etex_numexpr:D #1 \scan_stop: #2
            \etex_numexpr:D #3 \scan_stop:
    \exp_after:NN \use_arg_i:nn
  \else:
    \exp_after:NN \use_arg_ii:nn
  \fi:
}
\def_new:Npn \int_compare:nNnT #1#2#3{
  \if_num:w \etex_numexpr:D #1 \scan_stop: #2
            \etex_numexpr:D #3 \scan_stop:
    \exp_after:NN \use_arg_ii:nn
  \fi:
  \use_none:n
}
\def_new:Npn \int_compare:nNnF #1#2#3{
  \if_num:w \etex_numexpr:D #1 \scan_stop: #2
            \etex_numexpr:D #3 \scan_stop:
    \exp_after:NN \use_none:n
  \else:
    \exp_after:NN \use_arg_i:n
  \fi:
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\int_compare_p:nNn}
% A predicate function.
%    \begin{macrocode}
\def_new:Npn \int_compare_p:nNn #1#2#3{
  \if_num:w \etex_numexpr:D #1 \scan_stop: #2
            \etex_numexpr:D #3 \scan_stop:
    \c_true
  \else:
    \c_false
  \fi:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\int_while:nNnT}
% \begin{macro}{\int_while:nNnF}
% \begin{macro}{\int_dowhile:nNnT}
% \begin{macro}{\int_dowhile:nNnF}
%  These are quite easy given the above functions. The "while" versions
%  test first and then execute the body. The "dowhile" does it the
%  other way round.
%    \begin{macrocode}
\def_new:Npn \int_while:nNnT #1#2#3#4{
  \int_compare:nNnT {#1}#2{#3}{#4 \int_while:nNnT {#1}#2{#3}{#4}}
}
\def_new:Npn \int_while:nNnF #1#2#3#4{
  \int_compare:nNnF {#1}#2{#3}{#4 \int_while:nNnF {#1}#2{#3}{#4}}
}
\def_new:Npn \int_dowhile:nNnT #1#2#3#4{
  #4 \int_compare:nNnT {#1}#2{#3}{\int_dowhile:nNnT {#1}#2{#3}{#4}}
}
\def_new:Npn \int_dowhile:nNnF #1#2#3#4{
  #4 \int_compare:nNnF {#1}#2{#3}{\int_dowhile:nNnF {#1}#2{#3}{#4}}
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%    Show token usage:
%    \begin{macrocode}
%</initex|package>
%<*showmemory>
\showMemUsage
%</showmemory>
%    \end{macrocode}
%
%
% \section{Fake registers}
%
% Fake registers are registers which implement \m{counter}s,
% \m{dimen}s, etc.\ which aren't used often and therefore don't need
% to run efficiently. One possible way of using them is to prepare certain
% registers this way, but |\let:NN| the mutator functions to real
% \m{counter}s as long as we have a sufficient number available. Now
% if we are making real large formats (by adding Pic\TeX, for example)
% we can turn them easily into fake registers and everything will work
% as before (only a bit slower).
%
%
% I haven't implemented anything besides counters so far, but \m{dimen}
% and \m{skip} present no principal problem and should probably be
% added.
%
% \subsection{Fake counters}
%
% \begin{macro}{\fint_new:N}
%    A fake counter is internally a \m{muskip} register. A count value
%    \m{x} is saved as \m{x}|mu| (more exactly as \m{x}|.0mu|) in this
%    register. This means that fake counter values are far more
%    restricted then usual counters, the largest value is 16383,
%    i.e.\ the |pt| part of \TeX{}'s largest \m{dimen}. This could be
%    changed by using more complicated conversion routines, but it
%    might be all right in usual applications.
%
%    Of course, we should make sure that we don't reach the borders,
%    otherwise the user will be faced by the surprising message that
%    some dimension got to large. (Not done yet).
%    \begin{macrocode}
%<*initex|package>
%<*initex>
\io_put_term:x{FIXME~Register~allocation~routine~(muskip)~missing~!}
\def_new:Npn \muskip_new:N #1 {\tex_muskipdef:D #1 \c_one}%!!wrong,  temp hack!!
\let_new:NN \fint_new:N \muskip_new:N
%</initex>
%<package>\let_new:NN \fint_new:N \newmuskip     % nicked from LaTeX
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fint_use:N}
% \begin{macro}{\fint_use_aux:w}
%    To use the value of a fake counter we have to get rid of |.0mu| in
%    an expandable way, since we want to allow constructions like
% \begin{verbatim}
%  \if_num:w\fint_use:N \l_test_fint > 55\scan_stop: ...
%\end{verbatim}
%    The simplest way I came up with (not much thinking behind) was
%    using parameter matching.
%    \begin{macrocode}
\def_new:Npn \fint_use:N {\exp_after:NN\fint_use_aux:w\the_internal:D}
%    \end{macrocode}
%    In the |\fint_use_aux:w| function we remove the |.0mu| and pass the
%    the result back into the input stream. The only thing we
%    have to think of, is that both |mu| have category code 12 when
%    they are returned by |\the_internal:D|.
%    \begin{macrocode}
\tex_lccode:D`\!=`\m \tex_lccode:D`\?=`\u
\tex_lowercase:D{\def_new:Npn \fint_use_aux:w #1.0!?{#1}}
\tex_lccode:D`\!=0\scan_stop:  \tex_lccode:D`\?=0\scan_stop:
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\fint_set:Nn}
% \begin{macro}{\fint_gset:Nn}
%    The way both routines are set up, the second argument might be
%    either a \m{normal integer}, or an internal register.
%    \begin{macrocode}
\def_new:Npn \fint_set:Nn #1#2{#1#2~mu\scan_stop:
%<*check>
   \chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn \fint_gset:Nn{
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
  \fint_set:Nn}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\fint_set_eq:NN}
% \begin{macro}{\fint_gset_eq:NN}
%    We can easily set two  fake counters equal to each other, but if
%    fake counters and real counters are used, we have to use the
%    slower |set| functions.
%    \begin{macrocode}
\def_new:Npn \fint_set_eq:NN #1#2{#1#2
%<*check>
    \chk_local_or_pref_global:N #1\chk_var_or_const:N #2
%</check>
}
\def_new:Npn \fint_gset_eq:NN {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \fint_set_eq:NN}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\fint_add:Nn}
% \begin{macro}{\fint_gadd:Nn}
% \begin{macro}{\fint_sub:Nn}
% \begin{macro}{\fint_gsub:Nn}
%    Adding and substracting; we make use of the fact that internally
%    \TeX{} always use the same primitives to advance a register.
%    \begin{macrocode}
\def_new:Npn \fint_add:Nn #1#2{\int_add:Nn#1{#2mu}}
\def_new:Npn \fint_gadd:Nn {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \fint_add:Nn}
\def_new:Npn \fint_sub:Nn #1#2{\int_sub:Nn#1{#2mu}}
\def_new:Npn \fint_gsub:Nn {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \fint_sub:Nn}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\fint_incr:N}
% \begin{macro}{\fint_gincr:N}
% \begin{macro}{\fint_decr:N}
% \begin{macro}{\fint_gdecr:N}
%    Incrementing and decrementing the fake counters:
%    \begin{macrocode}
\def_new:Npn \fint_incr:N #1{\advance:D#1\c_one mu\scan_stop:
%<*check>
  \chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn \fint_decr:N #1{\advance:D#1\c_minus_one mu\scan_stop:
%<*check>
  \chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn \fint_gincr:N {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \fint_incr:N}
\def_new:Npn \fint_gdecr:N {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \fint_decr:N}
%    \end{macrocode}
%    This can be achieved with less tokens but extra expansions:
%    \begin{macrocode}
\def:Npn \fint_incr:N #1{\fint_add:Nn#1\c_one}
\def:Npn \fint_decr:N #1{\fint_add:Nn#1\c_minus_one}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\c_fint_max}
%    A constant, denoting the largest possible value for fake counters.
%    \begin{macrocode}
\tex_mathchardef:D\c_fint_max=16383 \scan_stop:
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Fake skip registers}
%
% One has to convert simply from the \m{x}|pt| |plus| \m{y}|pt| |minus|
% \m{z}|pt| representation produced by |\the_internal:D|, to the
% corresponding |mu| representation. Complications arise from the
% possibility that |plus| and/or |minus| is not present,\footnote{This
% can be catched by adding a suitable constant and removing the
% corresponding constant in the other representation.} and by the
% possibility that the stretch or shrink component is a |fil| unit.
%
% \subsection{Fake dimen registers}
%
% I suppose this could be viewed as a subcase of the skip registers.
% See later section for a fake fake version for the moment.
%
%
% \subsection{Allocation routines}
%
% Counters are rare goods in \TeX{} and we are near the limit, if
% for example \LaTeX{} and Pic\TeX{} are merged. Therefore we should
% be careful not to throw away counter registers unnecessarily. One
% place for instance, where we can save some of them are the
% allocation routines.  Instead of using counters we maintain the
% number of the last allocated register in a fake counter.
%
%
%    \begin{macrocode}
%</initex|package>
%<*showmemory>
\showMemUsage
%</showmemory>
%    \end{macrocode}
%
% \endinput
%
% $Log$
% Revision 1.14  2005/03/16 22:36:30  braams
% Added the tweaks necessary to be able to load with initex
%
% Revision 1.13  2005/03/11 21:38:31  braams
% Fixed the use of RCS information; added \StopEventually
%
