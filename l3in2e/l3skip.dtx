% \iffalse
%% File: l3seq.dtx Copyright (C) 2004 Frank Mittelbach, LaTeX3 project
%<*package>
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{
  \ProvidesPackage{#2}[#4 #3 #5 #6]}
\next$Id$
       {L3 Experimental skip registers}
%</package>
% \fi
%
% \iffalse
%<*driver>
\documentclass{l3doc}

\begin{document}
\DocInput{l3clist.dtx}
\end{document}
%</driver>
% \fi
%
%
% \def\next#1: #2.dtx,v #3 #4 #5 #6 #7${
%  \def\filename{#2}%
%  \def\fileversion{#3}%
%  \def\filedate{#4}}
% \next$Id$
%
% \title{The \textsf{l3skip} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Counters}
% \author{Frank Mittelbach}
% \date{\filedate}
% \maketitle
%
% \section{Skip registers}
%
% \LaTeX3 knows about two type of length registers for internal use:
% rubber and rigit lengths.
%
%
% \subsection{Functions}
%
% \begin{function}{%
%                  \skip_new:N |
%                  \skip_new:c 
% }
% \begin{syntax}
%    "\skip_new:N"   <skip>
% \end{syntax}
% Defines <skip> to be a new variable of type ``skip''. 
% \begin{texnote}
% "\skip_new:N" is the equivalent to plain \TeX{}'s \tn{newskip}.
% However, the internal register allocation is done differently.
% \end{texnote}
% \end{function}
%
% \begin{function}{%
%                  \skip_zero:N |
%                  \skip_zero:c |
%                  \skip_gzero:N |
%                  \skip_gzero:c |
% }
% \begin{syntax}
%   "\skip_zero:N"   <skip>
% \end{syntax}
% Locally or globally reset <skip> to zero. 
% For global variables the global versions
% should be used.
% \end{function}
%
%
% \begin{function}{%
%                  \skip_set:Nn |
%                  \skip_set:cn |
%                  \skip_gset:Nn |
%                  \skip_gset:cn |
%                  \fskip_set:Nn |
%                  \fskip_gset:Nn |
% }
% \begin{syntax}
%   "\skip_set:Nn"   <skip> "{" <skip value> "}"
%   "\fskip_set:Nn" <fskip> "{" <skip value> "}"
% \end{syntax}
% These functions will set the <skip> register to the <length> value.
% \end{function}
%
%
% \begin{function}{%
%                  \skip_add:Nn |
%                  \skip_add:cn |
%                  \skip_gadd:Nn |
% }
% \begin{syntax}
%   "\skip_add:Nn"   <skip> "{" <length> "}"
% \end{syntax}
% These functions will add to the <skip> register the value <length>.  If
% the second argument is a <skip> register too, the surrounding braces
% can be left out.
% \end{function}
%
% \begin{function}{%
%                  \skip_sub:Nn |
%                  \skip_gsub:Nn |
% }
% \begin{syntax}
%   "\int_gsub:Nn"   <int> "{" <length> "}"
% \end{syntax}
% These functions will subtract from the <skip> register the value
% <length>.  If the second argument is a <skip> register too, the
% surrounding braces can be left out.
% \end{function}
%
% \begin{function}{%
%                  \skip_use:N |
%                  \skip_use:c |
% }
% \begin{syntax}
%   "\skip_use:N"   <skip>
% \end{syntax}
% This function returns the length value kept in <skip> in a way
% suitable for further processing. Be sure to use "\fint_use:N" if you
% are accessing the value of a fake counter because otherwise your
% result will be to some surprise to you (there is no check).
% \begin{texnote}
% The function "\skip_use:N" could be implemented directly as the \TeX{}
% primitive "\tex_the:D" which is also responsible to produce the values for
% other internal quantities.  We have chosen to use individual functions
% for counters, dimenions etc.\ to allow checks and to make the code
% more selfexplaining.
% \end{texnote}
% \end{function}
%


% \begin{function}{%
%                  \skip_get_parts:nnNN |
% }
% \begin{syntax}
%   "\skip_get_part:nnNN"   <template-key> <skip value> <dim-plus> <dim-minus>
% \end{syntax}
% Syntax should change see comments!
%
% Assignments to  <dim-plus> and <dim-minus> are local.
%
%
%
% \subsection{Formatting a skip register value}
%
%
% \subsection{Variable and constants}
%
% \begin{variable}{%
%                  \c_max_skip |
% }
% Constant that denotes the maximum value which can be stored in a <skip>
% register.
% \end{variable}
%
% \begin{variable}{%
%                  \c_zero_skip
% }
% Set of constants denoting useful values.
% \begin{texnote}
% \end{texnote}
% \end{variable}
%
% \begin{variable}{%
%                  \l_tmpa_skip |
%                  \l_tmpb_skip |
%                  \l_tmpc_skip |
%                  \g_tmpa_skip |
%                  \g_tmpb_skip |
% }
% Scratch register for immediate use. 
% \end{variable}
%
%
% \section{Implementation}
%
% 
%    We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<package&!check>\RequirePackage{l3basics}\par
%<package&check>\RequirePackage{l3chk}\par
%<*package>
%    \end{macrocode}
%
%
%
% \begin{macro}{\skip_new:N}
% \begin{macro}{\skip_new:c}
%    Allocation of a new internal registers.
%    \begin{macrocode}
\def_new:Npn \skip_new:N {}  
\let:NN \skip_new:N \newskip 
\def_new:Npn \skip_new:c {\exp_args:Nc \skip_new:N}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\skip_set:Nn}
% \begin{macro}{\skip_set:cn}
% \begin{macro}{\skip_gset:Nn}
% \begin{macro}{\skip_gset:cn}
%    Setting counters is again something that I would like to make
%    uniform at the moment to get a better overview.
%    \begin{macrocode}
\def_new:Npn \skip_set:Nn #1#2{#1#2\scan_stop:
%<*check>
\chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn \skip_gset:Nn {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \skip_set:Nn }
\def_new:Npn \skip_set:cn {\exp_args:Nc \skip_set:Nn }
\def_new:Npn \skip_gset:cn {\exp_args:Nc \skip_gset:Nn }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\skip_zero:N}
% \begin{macro}{\skip_gzero:N}
% \begin{macro}{\skip_zero:c}
% \begin{macro}{\skip_gzero:c}
%    Reset the register to zero.
%    \begin{macrocode}
\def_new:Npn \skip_zero:N #1{#1\c_zero_skip
%<*check>
        \chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn \skip_gzero:N {
%    \end{macrocode}
%    We make sure that a local variable is not updated globally by
%    changing the internal test (i.e.\ |\chk_local_or_pref_global:N|) before
%    making the assignment. This is done by |\pref_global_chk:| which also
%    issues the necessary |\pref_global:D|. This is not very efficient, but
%    this code will be only included for debugging purposes. Using
%    |\pref_global:D| in front of the local function is better in the
%    production versions.
%    \begin{macrocode}
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \skip_zero:N}
\def_new:Npn \skip_zero:c  {\exp_args:Nc \skip_zero:N}
\def_new:Npn \skip_gzero:c {\exp_args:Nc \skip_gzero:N}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\skip_add:Nn}
% \begin{macro}{\skip_add:cn}
% \begin{macro}{\skip_gadd:Nn}
% \begin{macro}{\skip_sub:Nn}
% \begin{macro}{\skip_gsub:Nn}
%    Adding and substracting to and from <skip>s
%    \begin{macrocode}
\def_new:Npn \skip_add:Nn #1#2{
%    \end{macrocode}
%    We need to say |by| in case the first argment is a register
%    accessed by its number, e.g., |\skip23|.
%    \begin{macrocode}
    \tex_advance:D#1 by #2\scan_stop:
%<*check>
    \chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn\skip_add:cn{\exp_args:Nc\skip_add:Nn}
\def_new:Npn \skip_sub:Nn #1#2{
    \tex_advance:D#1-#2\scan_stop:
%<*check>
\chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn \skip_gadd:Nn {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \skip_add:Nn }
\def_new:Npn \skip_gsub:Nn {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \skip_sub:Nn }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\skip_use:N}
% \begin{macro}{\skip_use:c}
%    Here is how counters are accessed:
%    \begin{macrocode}
\let_new:NN \skip_use:N \tex_the:D
\def_new:Npn \skip_use:c #1{\skip_use:N \cs:w#1\cs_end:}
%    \end{macrocode}
% \end{macro}
% \end{macro}

%
%
% \begin{macro}{\l_tmpa_skip}
% \begin{macro}{\l_tmpb_skip}
% \begin{macro}{\l_tmpc_skip}
% \begin{macro}{\g_tmpa_skip}
% \begin{macro}{\g_tmpb_skip}
%    We provide two local and two global scratch registers, maybe we
%    need more or less. 
%    \begin{macrocode}
%%\chk_new_cs:N \l_tmpa_skip
%%\tex_skipdef:D\l_tmpa_skip 255  %currently taken up by \skip@
\skip_new:N \l_tmpa_skip
\skip_new:N \l_tmpb_skip
\skip_new:N \l_tmpc_skip
\skip_new:N \g_tmpa_skip
\skip_new:N \g_tmpb_skip
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\c_zero_skip}
% \begin{macro}{\c_max_skip}
%    \begin{macrocode}
\let:NN \c_zero_skip \z@
\let:NN \c_max_skip \maxdimen
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \subsection{General helper Routines}
%
%
% \begin{macro}{\split_get_parts:nnNN}
%
% This macro should get different set of arguments: error prehaps
% conditional? (to make it more generally useful)
%
%    |\split_get_parts:nnNN| takes four aguments: a template key name (for error
%    recovery), a skip specification (e.g., either the value of a skip
%    register via |\the|\meta{register}, or a macro holding the
%    information, or the specification directly), and two dimen
%    registers. The skip specification is taken apart and the first
%    dimen register receives ``plus'' part and the second the
%    ``minus'' part. If the specification contains any |fil| parts an
%    error is generated since these values can't be assigned to a
%    dimen register.
%    \begin{macrocode}
\begingroup
%    \end{macrocode}
%    We employ the |\lowercase| trick to get certain letters with
%    |\catcode| 12 since we have to scan for them (they are what
%    |\the| outputs. So if we say |MIXUS| below we get |minus| but all
%    |\catcode|d 12.
%    \begin{macrocode}
\catcode`\M=12
\catcode`\I=12
\catcode`\X=12
\lccode`\X=`\n
\catcode`\U=12
\catcode`\S=12
%    \end{macrocode}
%    We need |p| with |\catcode| 12 to scan for |pt| but we also need
%    |P| with |\catcode| 11 to be able to say |\PackageError|. So we
%    claim lowecase of |Z| is |p| and then say |ZT| and |ZLUS| below.
%    \begin{macrocode}
\catcode`\Z=12
\lccode`\Z=`\p
\catcode`\T=12
%    \end{macrocode}
%    And we need to scan for |FIL|:
%    \begin{macrocode}
\catcode`\L=12
\catcode`\F=12
%    \end{macrocode}
%    And the error message contains uppercase |V| and |O| and we want
%    to retain those.
%    \begin{macrocode}
\lccode`\V=`\V
\lccode`\O=`\O
%    \end{macrocode}
%    With the above prelims we now apply |\lowercase| to all the
%    definitions below, which will put the correctly |\catcode|d
%    strings in the parsing part of the macros.
%    \begin{macrocode}
\lowercase{
\gdef:Npn \split_get_parts:nnNN #1#2#3#4{
%    \end{macrocode}
%    |#2| is the skip specification. To be sure that the strings
%    ``plus'', ``minus'', ``pt'' are always having |\catcode| 12 we
%    assign it to a register first. Otherwise a user supplied string
%    like |1in plus .5in| wouldn't be parsable since we are only
%    looking for |pt| and also because in this case the |\catcode|s of
%    |plus| would be 11.
%    \begin{macrocode}
  \skip_set:Nn \l_tmpa_skip {#2}
%    \end{macrocode}
%    Then we pass this on to |\skip_check_for_fil:w| which will make sure
%    that there isn't any |fil| present and if not does the rest of
%    the processing.
%    \begin{macrocode}
  \exp_after:NN \skip_check_for_fil:w 
                  \skip_use:N \l_tmpa_skip FIL \relax
                \skip_check_for_fil:w
     {\skip_use:N \l_tmpa_skip}{#3}{#4}{#1}
 }
}
%    \end{macrocode}
% \end{macro}
%    
% \begin{macro}{\skip_check_for_fil:w}
%    \begin{macrocode}
\lowercase{
\gdef:Npn \skip_check_for_fil:w #1FIL#2 \skip_check_for_fil:w #3#4#5#6
 {
  \if_meaning:NN \relax #2
    \exp_after:NN
      \skip_get_minus_part:w #3MIXUS 0ZT \skip_get_minus_part:w{#4}{#5}
  \else:
    #4\z@
    #5\z@
    \PackageError{template}{Value~ for~ key~ #6~ contains~ `fil(ll)'}
       {Only~ finite~ minus~ or~ plus~ parts~ are~ allowed~ for~ this~ key.}
  \fi:
 }
}
%    \end{macrocode}
% \end{macro}
%    
% \begin{macro}{\skip_get_plus_part:w}
%    \begin{macrocode}
\lowercase{
\gdef:Npn \skip_get_plus_part:w #1ZLUS#2ZT#3\skip_get_plus_part:w#4{
  #4=#2pt\relax
 }
}
%    \end{macrocode}
% \end{macro}
%    
% \begin{macro}{\skip_get_minus_part:w}
%    \begin{macrocode}
\lowercase{
\gdef:Npn \skip_get_minus_part:w  #1MIXUS#2ZT#3\skip_get_minus_part:w #4#5
 {
  \skip_get_plus_part:w #1ZLUS 0ZT\skip_get_plus_part:w {#4}
  #5=#2pt\relax
 }
}
\endgroup
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Dimen registers}
%
%    \begin{macrocode}
\def_new:Npn \dim_new:N {}  
\let:NN \dim_new:N \newdimen
\def_new:Npn \dim_new:c {\exp_args:Nc \dim_new:N}
\def_new:Npn \dim_set:Nn #1#2{#1#2\scan_stop:
}
\def_new:Npn \dim_gset:Nn {
 \pref_global:D
   \dim_set:Nn }
\def_new:Npn \dim_set:cn {\exp_args:Nc \dim_set:Nn }
\def_new:Npn \dim_set:Nc {\exp_args:NNc \dim_set:Nn }
\def_new:Npn \dim_gset:cn {\exp_args:Nc \dim_gset:Nn }
\def_new:Npn \dim_gset:Nc {\exp_args:NNc \dim_gset:Nn }
\def_new:Npn \dim_gset:cc {\exp_args:Ncc \dim_gset:Nn }

\def_new:Npn \dim_zero:N #1{#1\c_zero_dim}
\def_new:Npn \dim_gzero:N {
 \pref_global:D
   \dim_zero:N}
\def_new:Npn \dim_zero:c  {\exp_args:Nc \dim_zero:N}
\def_new:Npn \dim_gzero:c {\exp_args:Nc \dim_gzero:N}
\def_new:Npn \dim_add:Nn #1#2{
%    \end{macrocode}
%    We need to say |by| in case the first argment is a register
%    accessed by its number, e.g., |\dimen23|.
%    \begin{macrocode}
    \tex_advance:D#1 by #2\scan_stop:
}
\def_new:Npn\dim_add:cn{\exp_args:Nc\dim_add:Nn}
\def_new:Npn\dim_add:Nc{\exp_args:NNc\dim_add:Nn}
\def_new:Npn \dim_sub:Nn #1#2{
    \tex_advance:D#1-#2\scan_stop:
}
\def_new:Npn\dim_sub:cn{\exp_args:Nc\dim_sub:Nn}
\def_new:Npn\dim_sub:Nc{\exp_args:NNc\dim_sub:Nn}

\def_new:Npn \dim_gadd:Nn {
 \pref_global:D
   \dim_add:Nn }
\def_new:Npn \dim_gsub:Nn {
 \pref_global:D
   \dim_sub:Nn }
\let_new:NN \dim_use:N \tex_the:D
\def_new:Npn \dim_use:c #1{\dim_use:N \cs:w#1\cs_end:}

%%\chk_new_cs:N \l_tmpa_dim
%%\tex_dimendef:D\l_tmpa_dim 255
\dim_new:N \l_tmpa_dim
\dim_new:N \l_tmpb_dim
\dim_new:N \l_tmpc_dim
\dim_new:N \l_tmpd_dim
\dim_new:N \g_tmpa_dim
\dim_new:N \g_tmpb_dim
\let:NN \c_zero_dim \z@
\let:NN \c_max_dim \maxdimen
%    \end{macrocode}
%
%
%
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
