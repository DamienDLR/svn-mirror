% \iffalse
%% File: l3skip.dtx Copyright (C) 2005 Frank Mittelbach, LaTeX3 project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3a of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``expl3 bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%% \fi
\def\next#1: #2.dtx,v #3 #4 #5 #6 #7$#8{%^^A}$
  \def\fileversion{#3}%
  \def\filedate{#4}%
%\iffalse
%<*dtx>
%\fi
     \ProvidesFile{#2.dtx}[#4 v#3 #8]%
%\iffalse
%</dtx>
%<package> \ProvidesPackage{#2}[#4 v#3 #8]%
%<driver>  \ProvidesFile{#2.drv}[#4 v#3 #8]%
% \fi
}
\next$Id$
       {L3 Experimental skip registers}
%
% \iffalse
%<*driver>
\documentclass{l3doc}

\begin{document}
\DocInput{l3skip.dtx}
\end{document}
%</driver>
% \fi
%
%
% \def\next#1: #2.dtx,v #3 #4 #5 #6 #7${
%  \def\filename{#2}%
%  \def\fileversion{#3}%
%  \def\filedate{#4}}
% \next$Id$
%
% \title{The \textsf{l3skip} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Counters}
% \author{Frank Mittelbach}
% \date{\filedate}
% \maketitle
%
% \section{Skip registers}
%
% \LaTeX3 knows about two type of length registers for internal use:
% rubber and rigid lengths.
%
%
% \subsection{Functions}
%
% \begin{function}{%
%                  \skip_new:N |
%                  \skip_new:c
% }
% \begin{syntax}
%    "\skip_new:N"   <skip>
% \end{syntax}
% Defines <skip> to be a new variable of type ``skip''.
% \begin{texnote}
% "\skip_new:N" is the equivalent to plain \TeX{}'s \tn{newskip}.
% However, the internal register allocation is done differently.
% \end{texnote}
% \end{function}
%
% \begin{function}{%
%                  \skip_zero:N |
%                  \skip_zero:c |
%                  \skip_gzero:N |
%                  \skip_gzero:c |
% }
% \begin{syntax}
%   "\skip_zero:N"   <skip>
% \end{syntax}
% Locally or globally reset <skip> to zero.
% For global variables the global versions
% should be used.
% \end{function}
%
%
% \begin{function}{%
%                  \skip_set:Nn |
%                  \skip_set:cn |
%                  \skip_gset:Nn |
%                  \skip_gset:cn |
%                  \fskip_set:Nn |
%                  \fskip_gset:Nn |
% }
% \begin{syntax}
%   "\skip_set:Nn"   <skip> "{" <skip value> "}"
%   "\fskip_set:Nn" <fskip> "{" <skip value> "}"
% \end{syntax}
% These functions will set the <skip> register to the <length> value.
% \end{function}
%
%
% \begin{function}{%
%                  \skip_add:Nn |
%                  \skip_add:cn |
%                  \skip_gadd:Nn |
% }
% \begin{syntax}
%   "\skip_add:Nn"   <skip> "{" <length> "}"
% \end{syntax}
% These functions will add to the <skip> register the value <length>.  If
% the second argument is a <skip> register too, the surrounding braces
% can be left out.
% \end{function}
%
% \begin{function}{%
%                  \skip_sub:Nn |
%                  \skip_gsub:Nn |
% }
% \begin{syntax}
%   "\int_gsub:Nn"   <int> "{" <length> "}"
% \end{syntax}
% These functions will subtract from the <skip> register the value
% <length>.  If the second argument is a <skip> register too, the
% surrounding braces can be left out.
% \end{function}
%
% \begin{function}{%
%                  \skip_use:N |
%                  \skip_use:c |
% }
% \begin{syntax}
%   "\skip_use:N"   <skip>
% \end{syntax}
% This function returns the length value kept in <skip> in a way
% suitable for further processing. Be sure to use "\fint_use:N" if you
% are accessing the value of a fake counter because otherwise your
% result will be to some surprise to you (there is no check).
% \begin{texnote}
% The function "\skip_use:N" could be implemented directly as the \TeX{}
% primitive "\tex_the:D" which is also responsible to produce the values for
% other internal quantities.  We have chosen to use individual functions
% for counters, dimenions etc.\ to allow checks and to make the code
% more selfexplaining.
% \end{texnote}
% \end{function}
%


% \begin{function}{%
%                  \skip_infinite_glue:nTF |
% }
% \begin{syntax}
%   "\skip_infinite_glue:nTF" "{"<skip>"}" "{"<true>"}" "{"<false>"}"
% \end{syntax}
% Checks if <skip> contains infinite stretch or shrink components
% and executes either <true> or <false>. Also works on input like
% "3pt plus .5in".
% \end{function}
%
%
%
% \begin{function}{%
%                  \skip_split_finite_else_action:nnNN |
% }
% \begin{syntax}
%   "\skip_split_finite_else_action:nnNN" "{"<skip>"}" "{"<action>"}" <dimen1> <dimen2>
% \end{syntax}
% Checks if <skip> contains finite glue. If it does then it assigns
% <dimen1> the stretch component and <dimen2> the shrink component. If
% it contains infinite glue set <dimen1> and <dimen2> to zero and execute
% "#2" which is usually an error or warning message of some sort.
% \end{function}
%
%
% \subsection{Formatting a skip register value}
%
%
% \subsection{Variable and constants}
%
% \begin{variable}{%
%                  \c_max_skip |
% }
% Constant that denotes the maximum value which can be stored in a <skip>
% register.
% \end{variable}
%
% \begin{variable}{%
%                  \c_zero_skip |
% }
% Set of constants denoting useful values.
% \end{variable}
%
% \begin{variable}{%
%                  \l_tmpa_skip |
%                  \l_tmpb_skip |
%                  \l_tmpc_skip |
%                  \g_tmpa_skip |
%                  \g_tmpb_skip |
% }
% Scratch register for immediate use.
% \end{variable}
%
% \subsection{Testing and evaluating expressions}
%
% \begin{function}{%
%                  \dim_eval:n |
%                  \skip_eval:n |
% }
% \begin{syntax}
%   "\dim_eval:n"   "{"<dim expr>"}"
% \end{syntax}
%  Evaluates the value of a dimension expression so that
%  "\dim_eval:n {5pt+3pt}" puts "8pt" back into the input stream.
%  "\skip_eval:n" handles stretch and shrink specifications.
%  Expandable.
% \begin{texnote}
% These are the e\TeX{} primitives \tn{dimexpr} and \tn{glueexpr}
% turned into functions taking an argument.
% \end{texnote}
% \end{function}
%
% \begin{function}{%
%                  \dim_compare:nNnTF |
%                  \dim_compare:nNnT |
%                  \dim_compare:nNnF |
% }
% \begin{syntax}
%   "\dim_compare:nNnTF"   "{"<dim~expr>"}" <rel> "{"<dim~expr>"}"
%                         "{"<true>"}" "{"<false>"}"
% \end{syntax}
% These functions test two dimension expressions against each other. They
% are both evaluated by "\dim_eval:n". Note that if both expressions
% are normal dimension variables as in
% \begin{verbatim}
% \dim_compare:nNnTF \l_temp_dim < \c_zero_skip {negative}{non-negative}
% \end{verbatim}
% you can safely omit the braces.
% \begin{texnote}
% This is the \TeX{} primitive \tn{ifdim} turned into a function.
% \end{texnote}
% \end{function}
%
% \begin{function}{%
%                  \dim_compare_p:nNn |
% }
% \begin{syntax}
%   "\dim_compare_p:nNn"   "{"<dim~expr>"}" <rel> "{"<dim~expr>"}"
% \end{syntax}
% Predicate version of the above functions.
% \end{function}
%
% \begin{function}{%
%                  \dim_while:nNnT |
%                  \dim_while:nNnF |
%                  \dim_dowhile:nNnT |
%                  \dim_dowhile:nNnF |
% }
% \begin{syntax}
%   "\dim_while:nNnT"   <dim expr> <rel> <dim~expr> <true>
% \end{syntax}
%  "\dim_while:nNnT" tests the dimension expressions and if true performs
%  the body "T" until the test fails. "\dim_dowhile:nNnT" is similar
%  but executes the body first and then performs the check, thus
%  ensuring that the body is executed at least once. The "F" versions
%  are similar but continue the loop as long as the test is false.
% \end{function}
%
% \StopEventually{}
%
% \section{Implementation}
%
%
%    We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<package&!check>\RequirePackage{l3basics,l3prg,l3int}\par
%<package&check>\RequirePackage{l3chk}\par
%<*package>
%    \end{macrocode}
%
%
%
% \begin{macro}{\skip_new:N}
% \begin{macro}{\skip_new:c}
%    Allocation of a new internal registers.
%    \begin{macrocode}
\def_new:Npn \skip_new:N {}
\let:NN \skip_new:N \newskip
\def_new:Npn \skip_new:c {\exp_args:Nc \skip_new:N}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\skip_set:Nn}
% \begin{macro}{\skip_set:cn}
% \begin{macro}{\skip_gset:Nn}
% \begin{macro}{\skip_gset:cn}
%    Setting counters is again something that I would like to make
%    uniform at the moment to get a better overview.
%    \begin{macrocode}
\def_new:Npn \skip_set:Nn #1#2{#1#2\scan_stop:
%<*check>
\chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn \skip_gset:Nn {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \skip_set:Nn }
\def_new:Npn \skip_set:cn {\exp_args:Nc \skip_set:Nn }
\def_new:Npn \skip_gset:cn {\exp_args:Nc \skip_gset:Nn }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\skip_zero:N}
% \begin{macro}{\skip_gzero:N}
% \begin{macro}{\skip_zero:c}
% \begin{macro}{\skip_gzero:c}
%    Reset the register to zero.
%    \begin{macrocode}
\def_new:Npn \skip_zero:N #1{#1\c_zero_skip \scan_stop:
%<*check>
        \chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn \skip_gzero:N {
%    \end{macrocode}
%    We make sure that a local variable is not updated globally by
%    changing the internal test (i.e.\ |\chk_local_or_pref_global:N|) before
%    making the assignment. This is done by |\pref_global_chk:| which also
%    issues the necessary |\pref_global:D|. This is not very efficient, but
%    this code will be only included for debugging purposes. Using
%    |\pref_global:D| in front of the local function is better in the
%    production versions.
%    \begin{macrocode}
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \skip_zero:N}
\def_new:Npn \skip_zero:c  {\exp_args:Nc \skip_zero:N}
\def_new:Npn \skip_gzero:c {\exp_args:Nc \skip_gzero:N}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\skip_add:Nn}
% \begin{macro}{\skip_add:cn}
% \begin{macro}{\skip_gadd:Nn}
% \begin{macro}{\skip_sub:Nn}
% \begin{macro}{\skip_gsub:Nn}
%    Adding and substracting to and from <skip>s
%    \begin{macrocode}
\def_new:Npn \skip_add:Nn #1#2{
%    \end{macrocode}
%    We need to say |by| in case the first argment is a register
%    accessed by its number, e.g., |\skip23|.
%    \begin{macrocode}
    \tex_advance:D#1 by #2\scan_stop:
%<*check>
    \chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn\skip_add:cn{\exp_args:Nc\skip_add:Nn}
\def_new:Npn \skip_sub:Nn #1#2{
    \tex_advance:D#1-#2\scan_stop:
%<*check>
\chk_local_or_pref_global:N #1
%</check>
}
\def_new:Npn \skip_gadd:Nn {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \skip_add:Nn }
\def_new:Npn \skip_gsub:Nn {
%<*check>
   \pref_global_chk:
%</check>
%<-check> \pref_global:D
   \skip_sub:Nn }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\skip_use:N}
% \begin{macro}{\skip_use:c}
%    Here is how counters are accessed:
%    \begin{macrocode}
\let_new:NN \skip_use:N \tex_the:D
\def_new:Npn \skip_use:c #1{\skip_use:N \cs:w#1\cs_end:}
%    \end{macrocode}
% \end{macro}
% \end{macro}

%
%
% \begin{macro}{\l_tmpa_skip}
% \begin{macro}{\l_tmpb_skip}
% \begin{macro}{\l_tmpc_skip}
% \begin{macro}{\g_tmpa_skip}
% \begin{macro}{\g_tmpb_skip}
%    We provide two local and two global scratch registers, maybe we
%    need more or less.
%    \begin{macrocode}
%%\chk_new_cs:N \l_tmpa_skip
%%\tex_skipdef:D\l_tmpa_skip 255  %currently taken up by \skip@
\skip_new:N \l_tmpa_skip
\skip_new:N \l_tmpb_skip
\skip_new:N \l_tmpc_skip
\skip_new:N \g_tmpa_skip
\skip_new:N \g_tmpb_skip
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\c_zero_skip}
% \begin{macro}{\c_max_skip}
%    \begin{macrocode}
\let:NN \c_zero_skip \z@
\let:NN \c_max_skip  \maxdimen
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%  \subsection{General helper Routines}
%
%  \begin{macro}{\skip_infinite_glue:nTF}
%  With e\TeX{} we all of a sudden get access to a lot information we
%  should otherwise consider ourselves lucky to get. One is
%  the stretch and shrink components of a skip register and the order
%  or those components. "\skip_infinite_glue:nTF" tests it directly by
%  looking at the stretch and shrink order. If either of the predicate
%  functions return \m{true} "\prg_logic_or_p:nn" will return \m{true}
%  and the logic test will take the true branch.
%    \begin{macrocode}
\def_new:Npn \skip_infinite_glue:nTF #1{
  \prg_logic_test:nTF {
    \prg_logic_or_p:nn
      { \int_compare_p:nNn {\etex_gluestretchorder:D #1 } > \c_zero }
      { \int_compare_p:nNn {\etex_glueshrinkorder:D #1 } > \c_zero }
  }
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\skip_split_finite_else_action:nnNN}
%  This macro is useful when performing error checking in certain
%  circumstances. If the \m{skip} register holds finite glue it sets
%  "#3" and "#4" to the stretch and shrink component resp. If it holds
%  infinite glue set "#3" and "#4" to zero and issue the special action
%  "#2" which is probably an error message.
%  Assignments are global.
%    \begin{macrocode}
\def_new:Npn \skip_split_finite_else_action:nnNN #1#2#3#4{
  \skip_infinite_glue:nTF {#1}
  {
    #3 = \c_zero_skip
    #4 = \c_zero_skip
    #2
  }
  {
    #3 = \etex_gluestretch:D #1 \scan_stop:
    #4 = \etex_glueshrink:D  #1 \scan_stop:
  }
}
%    \end{macrocode}
%  \end{macro}
%
%
%  The next bit is now obsolete but it shows some of the hoops one has
%  to jump through to get certain kinds of information.
%    \begin{macrocode}
%<*obsolete>
%    \end{macrocode}
% \begin{macro}{\split_get_parts:nnNN}
%
% This macro should get different set of arguments: error prehaps
% conditional? (to make it more generally useful)
%
%    |\split_get_parts:nnNN| takes four aguments: a template key name (for error
%    recovery), a skip specification (e.g., either the value of a skip
%    register via |\the|\meta{register}, or a macro holding the
%    information, or the specification directly), and two dimen
%    registers. The skip specification is taken apart and the first
%    dimen register receives ``plus'' part and the second the
%    ``minus'' part. If the specification contains any |fil| parts an
%    error is generated since these values can't be assigned to a
%    dimen register.
%    \begin{macrocode}
\group_begin:
%    \end{macrocode}
%    We employ the |\lowercase| trick to get certain letters with
%    |\catcode| 12 since we have to scan for them (they are what
%    |\the| outputs. So if we say |MIXUS| below we get |minus| but all
%    |\catcode|d 12.
%    \begin{macrocode}
\catcode`\M=12
\catcode`\I=12
\catcode`\X=12
\lccode`\X=`\n
\catcode`\U=12
\catcode`\S=12
%    \end{macrocode}
%    We need |p| with |\catcode| 12 to scan for |pt| but we also need
%    |P| with |\catcode| 11 to be able to say |\PackageError|. So we
%    claim lowecase of |Z| is |p| and then say |ZT| and |ZLUS| below.
%    \begin{macrocode}
\catcode`\Z=12
\lccode`\Z=`\p
\catcode`\T=12
%    \end{macrocode}
%    And we need to scan for |FIL|:
%    \begin{macrocode}
\catcode`\L=12
\catcode`\F=12
%    \end{macrocode}
%    And the error message contains uppercase |V| and |O| and we want
%    to retain those.
%    \begin{macrocode}
\lccode`\V=`\V
\lccode`\O=`\O
%    \end{macrocode}
%    With the above prelims we now apply |\lowercase| to all the
%    definitions below, which will put the correctly |\catcode|d
%    strings in the parsing part of the macros.
%    \begin{macrocode}
\lowercase{
\gdef:Npn \split_get_parts:nnNN #1#2#3#4{
%    \end{macrocode}
%    |#2| is the skip specification. To be sure that the strings
%    ``plus'', ``minus'', ``pt'' are always having |\catcode| 12 we
%    assign it to a register first. Otherwise a user supplied string
%    like |1in plus .5in| wouldn't be parsable since we are only
%    looking for |pt| and also because in this case the |\catcode|s of
%    |plus| would be 11.
%    \begin{macrocode}
  \skip_set:Nn \l_tmpa_skip {#2}
%    \end{macrocode}
%    Then we pass this on to |\skip_check_for_fil:w| which will make sure
%    that there isn't any |fil| present and if not does the rest of
%    the processing.
%    \begin{macrocode}
  \exp_after:NN \skip_check_for_fil:w
                  \skip_use:N \l_tmpa_skip FIL \relax
                \skip_check_for_fil:w
     {\skip_use:N \l_tmpa_skip}{#3}{#4}{#1}
 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\skip_check_for_fil:w}
%    \begin{macrocode}
\lowercase{
\gdef:Npn \skip_check_for_fil:w #1FIL#2 \skip_check_for_fil:w #3#4#5#6
 {
  \if_meaning:NN \relax #2
    \exp_after:NN
      \skip_get_minus_part:w #3MIXUS 0ZT \skip_get_minus_part:w{#4}{#5}
  \else:
    #4\z@
    #5\z@
    \PackageError{template}{Value~ for~ key~ #6~ contains~ `fil(ll)'}
       {Only~ finite~ minus~ or~ plus~ parts~ are~ allowed~ for~ this~ key.}
  \fi:
 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\skip_get_plus_part:w}
%    \begin{macrocode}
\lowercase{
\gdef:Npn \skip_get_plus_part:w #1ZLUS#2ZT#3\skip_get_plus_part:w#4{
  #4=#2pt\relax
 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\skip_get_minus_part:w}
%    \begin{macrocode}
\lowercase{
\gdef:Npn \skip_get_minus_part:w  #1MIXUS#2ZT#3\skip_get_minus_part:w #4#5
 {
  \skip_get_plus_part:w #1ZLUS 0ZT\skip_get_plus_part:w {#4}
  #5=#2pt\relax
 }
}
\group_end:
%    \end{macrocode}
% \end{macro}
%

%    \begin{macrocode}
%</obsolete>
%    \end{macrocode}
%
% \subsection{Dimen registers}
%
%    \begin{macrocode}
\def_new:Npn \dim_new:N {}
\let:NN \dim_new:N \newdimen
\def_new:Npn \dim_new:c {\exp_args:Nc \dim_new:N}
%    \end{macrocode}
% We add |\etex_dimexpr:D| in order to allow simple arithmetic
% and a space just for those using |\dimen1| or alike. See OR!
%    \begin{macrocode}
\def_new:Npn \dim_set:Nn #1#2{#1~ \etex_dimexpr:D#2\scan_stop:}
\def_new:Npn \dim_gset:Nn {
 \pref_global:D
   \dim_set:Nn }
\def_new:Npn \dim_set:cn {\exp_args:Nc \dim_set:Nn }
\def_new:Npn \dim_set:Nc {\exp_args:NNc \dim_set:Nn }
\def_new:Npn \dim_gset:cn {\exp_args:Nc \dim_gset:Nn }
\def_new:Npn \dim_gset:Nc {\exp_args:NNc \dim_gset:Nn }
\def_new:Npn \dim_gset:cc {\exp_args:Ncc \dim_gset:Nn }

\def_new:Npn \dim_zero:N #1{#1\c_zero_skip}
\def_new:Npn \dim_gzero:N {
 \pref_global:D
   \dim_zero:N}
\def_new:Npn \dim_zero:c  {\exp_args:Nc \dim_zero:N}
\def_new:Npn \dim_gzero:c {\exp_args:Nc \dim_gzero:N}
\def_new:Npn \dim_add:Nn #1#2{
%    \end{macrocode}
%    We need to say |by| in case the first argment is a register
%    accessed by its number, e.g., |\dimen23|.
%    \begin{macrocode}
    \tex_advance:D#1 by \etex_dimexpr:D#2\scan_stop:\scan_stop:
}
\def_new:Npn\dim_add:cn{\exp_args:Nc\dim_add:Nn}
\def_new:Npn\dim_add:Nc{\exp_args:NNc\dim_add:Nn}
\def_new:Npn \dim_sub:Nn #1#2{
    \tex_advance:D#1-#2\scan_stop:
}
\def_new:Npn\dim_sub:cn{\exp_args:Nc\dim_sub:Nn}
\def_new:Npn\dim_sub:Nc{\exp_args:NNc\dim_sub:Nn}

\def_new:Npn \dim_gadd:Nn {
 \pref_global:D
   \dim_add:Nn }
\def_new:Npn \dim_gsub:Nn {
 \pref_global:D
   \dim_sub:Nn }
\let_new:NN \dim_use:N \tex_the:D
\def_new:Npn \dim_use:c #1{\dim_use:N \cs:w#1\cs_end:}

%%\chk_new_cs:N \l_tmpa_dim
%%\tex_dimendef:D\l_tmpa_dim 255
\dim_new:N \l_tmpa_dim
\dim_new:N \l_tmpb_dim
\dim_new:N \l_tmpc_dim
\dim_new:N \l_tmpd_dim
\dim_new:N \g_tmpa_dim
\dim_new:N \g_tmpb_dim
\let:NN \c_zero_skip \z@
\let:NN \c_max_skip \maxdimen
%    \end{macrocode}
%
% \begin{macro}{\dim_eval:n}
% \begin{macro}{\skip_eval:n}
% Evaluating a calc expression.
%    \begin{macrocode}
\def_new:Npn \dim_eval:n #1 {\etex_dimexpr:D #1 \scan_stop:}
\def_new:Npn \skip_eval:n #1 {\etex_glueexpr:D #1 \scan_stop:}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\dim_compare:nNnTF}
% \begin{macro}{\dim_compare:nNnT}
% \begin{macro}{\dim_compare:nNnF}
% Check the expression and choose branch.
%    \begin{macrocode}
\def_new:Npn \dim_compare:nNnTF #1#2#3{
  \tex_ifdim:D \dim_eval:n {#1} #2 \dim_eval:n {#3}
    \exp_after:NN \use_arg_i:nn
  \else:
    \exp_after:NN \use_arg_ii:nn
  \fi:
}
\def_new:Npn \dim_compare:nNnT #1#2#3{
  \tex_ifdim:D \dim_eval:n {#1} #2 \dim_eval:n {#3}
    \exp_after:NN \use_arg_ii:nn
  \fi:
  \use_none:n
}
\def_new:Npn \dim_compare:nNnF #1#2#3{
  \tex_ifdim:D \dim_eval:n {#1} #2 \dim_eval:n {#3}
    \exp_after:NN \use_none:n
  \else:
    \exp_after:NN \use_arg_i:n
  \fi:
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\dim_compare_p:nNn}
% A predicate function.
%    \begin{macrocode}
\def_new:Npn \dim_compare_p:nNn #1#2#3{
  \tex_ifdim:D \dim_eval:n {#1} #2 \dim_eval:n {#3}
    \c_true
  \else:
    \c_false
  \fi:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\dim_while:nNnT}
% \begin{macro}{\dim_while:nNnF}
% \begin{macro}{\dim_dowhile:nNnT}
% \begin{macro}{\dim_dowhile:nNnF}
% "while" and "do-while" functions for dimensions. Same as for the
% "int" type only the names have changed.
%    \begin{macrocode}
\def_new:Npn \dim_while:nNnT #1#2#3#4{
  \dim_compare:nNnT {#1}#2{#3}{#4 \dim_while:nNnT {#1}#2{#3}{#4}}
}
\def_new:Npn \dim_while:nNnF #1#2#3#4{
  \dim_compare:nNnF {#1}#2{#3}{#4 \dim_while:nNnF {#1}#2{#3}{#4}}
}
\def_new:Npn \dim_dowhile:nNnT #1#2#3#4{
  #4 \dim_compare:nNnT {#1}#2{#3}{\dim_dowhile:nNnT {#1}#2{#3}{#4}}
}
\def_new:Npn \dim_dowhile:nNnF #1#2#3#4{
  #4 \dim_compare:nNnF {#1}#2{#3}{\dim_dowhile:nNnF {#1}#2{#3}{#4}}
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \endinput
%
% $Log$
% Revision 1.6  2005/03/11 21:42:48  braams
% Fixed the use of RCS information; added \StopEventually
%
