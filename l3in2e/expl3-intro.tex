\documentclass{ltugboat}
\makeatletter
\def\acro#1{\scalebox{1.1}{\fontsize{8pt}{8pt}\selectfont #1}}
\def\pkg#1{\textsf{#1}}

\usepackage[T1]{fontenc}
\usepackage{array,calc,graphicx,listings,lmodern,microtype,multicol,shortvrb,url,xcolor}
\MakeShortVerb{|}

\lstset{basicstyle=\small\ttfamily,columns=flexible}

\title{Getting started with \LaTeX3}
\author{Will Robertson}
\netaddress{will.robertson@latex-project.org}
\address{}
\AtBeginDocument{\maketitle}
\AtEndDocument{\makesignature}

\begin{document}

\begin{abstract}

The \LaTeX3 project now has functional code for macro writing on \acro{CTAN}
and included in the major \TeX\ distributions. This article is a high-level
introduction to the code so that macros writers can begin to adopt this new
system.

\end{abstract}  

\section{Introduction}
\label{sec:intro}

The \LaTeX3 project was initiated many years ago as a way to consider future
improvements of the then-current \LaTeX2.09 and later \LaTeXe\ systems. There
are three broad aspects to the project: to support the current version of
\LaTeX, to build a macro programming model to improve upon \LaTeXe, and to
develop new user-level interfaces for a \LaTeXe\ successor.

The \pkg{expl3} package is a suite of modules that define a new \LaTeX\
programming model. Over the years, many macro writers have been dissatisfied
with the tools (or lack thereof) provided by \LaTeXe, and rolled their own
layers above it. There are a number of packages on \acro{CTAN} that have their
own `spin-off' programming interface that are generally simple extensions to
the few features provided by \LaTeXe\ itself; the most modern and perhaps
popular of these is Philipp Lehman's \pkg{etoolbox} package.

Despite the lack of visible progress, \pkg{expl3} has been maturing now for
years and provides a flexible and robust platform for macro programming. It
provides hooks so that it can be used with \LaTeXe\ along with existing
documents and packages. This article shows how to get started with writing
code using the \pkg{expl3} codebase.

Note that this article does not discuss the more experimental components of
the \LaTeX3 project known as the `\pkg{xpackages}', which are more concerned
with the user interface of \LaTeX3 itself.

\section{The files}

The official release for the \pkg{expl3} package is located on \acro{CTAN}:
\url{http://tug.ctan.org/pkg/expl3}. Along with the code itself, two
documentation files are linked from there: \url{expl3.pdf} and
\url{source3.pdf}. The former is an introduction to philosophy of the
\pkg{expl3} package and full overview of the programming modules available;
the latter is the full documentation for the \pkg{expl3} package. Skimming
through \url{source3.pdf} gives a glimpse of the sheer scope of the
programming interface.

The complete \pkg{expl3} bundle provides the list of packages shown in
Table~\ref{tab:expl3-pkg}. While there is hardly scope to cover each of these
packages, the general theme of this collection will hopefully be made clear in
the course of this article.

\begin{table}
\caption{Packages provided by \pkg{expl3}; emphasised \emph{\pkg{l3doc}} is
the class used to document \pkg{expl3}-related packages.}
\label{tab:expl3-pkg}
\begin{multicols}{4}
\small\sffamily\centering
\begin{obeylines}
l3basics
l3box
l3calc
l3chk
l3clist
\emph{l3doc}
l3expan
l3int
l3io
l3keyval
l3messages
l3names
l3num
l3precom
l3prg
l3prop
l3quark
l3seq
l3skip
l3tlp
l3token
l3toks
l3xref
\end{obeylines}
\end{multicols}
\end{table}

\section{Starting off} 

Most \LaTeX\ users will be familiar with the standard `name-spacing' technique
of hiding non-user macros with the |@| sign, which is set up when reading
package and class files to behave like a letter so that macros such as
|\@secondoftwo| can be defined without possibility of a document author
accidentally calling that macro.

The \pkg{expl3} bundle extends this concept to the characters |_| and |:|,
setting the scene for macros such as |\use_arg_ii:nn| that look rather
unfamiliar to the typical \LaTeX\ user. (That particular macro is identical in
meaning to the preceding |\@secondoftwo|.)

Unlike \LaTeX\ coding practise, where |@| is used fairly haphazardly in
internal package names, the philosophy around the \pkg{expl3} bundle is
consistency and clarity. The |_| symbol is used to separate the macro name
into logical chunks, and the |:| symbol is used to delimit the \emph{name} of
the macro with the definition of its \emph{arguments}.

There is not yet a `wrapper' package that loads the \pkg{expl3} bundle in its
entirety. At this stage, macro writers should load the modules they are
interested in. To get started, load the \pkg{l3basics} package; this does the
appropriate macro name setup to begin working with the \pkg{expl3} syntax and
defines the `basic' command set for defining macros, setting and executing
conditionals, and so on.

Here's how a package that uses the \pkg{expl3} bundle might begin:
\begin{lstlisting}
\RequirePackage{l3basics}
\ProvidesExplPackage{test-expl3} {2008/08/22}
  {v0.1} {A test package for expl3}
\end{lstlisting}
Note the new command for declaring the \pkg{expl3}--based package; this is the
important command that sets up the package for the new syntax. There's an
equivalent command for declaring an \pkg{expl3}--based class, as well.

If the \pkg{expl3} bundle has been loaded but you're \emph{not} inside a class
or package that's set up for the new syntax, it is possible to locally
activate it for a block of code by wrapping it in
|\Expl|\-|Syntax|\-|On|/|\Expl|\-|Syntax|\-|Off|.\footnote{Or should I say
\texttt{\string\CodeStart}/\texttt{\string\CodeStop} instead?} These are
analogous to \LaTeXe's |\make|\-|at|\-|letter|/|\make|\-|at|\-|other| pair,
albeit with much more useful names.

And now we're ready to start writing code! I guess it's time to introduce the
new programming syntax, then.

\section{The programming syntax}

Two of the biggest problems with programming in \LaTeXe\ are the fussiness of
how to deal with whitespace and the lack of structure for dealing with
advanced macro expansion (you know, all of that |\expandafter| stuff).

I bring up whitespace early because there's good news that's quick to
describe: you don't need to worry about it any more. Spaces in the input for
\pkg{expl3} code are ignored, which dramatically improves the readability and
maintenance of code like
\def\optpc{\textcolor[gray]{0.7}{\%}}
\begin{lstlisting}[escapeinside=<>]
\def:NNn \mymacro 1 {<\optpc>
  \tlist_if_blank:nTF {#1} {<\optpc>
    [empty]<\optpc>
  }{<\optpc>
    #1<\optpc>
  }<\optpc>
}
\end{lstlisting}
which defines |\mymacro| which expands to `[empty]' if given an empty argument
and expands to its argument otherwise. The percent signs which would be
required in \LaTeXe\ are shown in light grey and can and should be omitted
when using \pkg{expl3}.

It's easy to get distracted by that funny |:nTF| suffix for the function
|\tlist_if_blank|. These suffixes require some explanation, and full detail is
given in |expl3.pdf|. Each character refers to an argument of the macro. With
a macro like |\tlist_reverse:n|, we know simply from the macro name that it
takes a single argument (in this case, |\tlist_reverse:n{abc}| expands to
|cba|).

In the example above, |\tlist_if_blank:nTF| expands to the second argument
(denoted by |T|, since the conditional has evaluated to true) if the first
argument is blank; otherwise it expands to the third argument (which is |F| to
stand for the false branch).

Yet another macro is |\tlist_if_eq:nnTF| which expands to the |T| argument if
the first two arguments are the same and expands to the |F| argument
otherwise.

So |n| refers to a `normal' argument that is generally surrounded by braces;
other argument types include |N| which refers to a single token only (no
braces), and |x| which passes the argument to the macro only after fully
expanding it first. An example of this |x| argument is the analogue to the
familiar |\typeout| command which now looks like |\io_put_term:x|.

\section{Basic macro wrangling}

Having introduced why things looks weird, we can now show some examples of
these macros and things begin to make more sense. In this section and the next
we'll look at defining macros and using booleans and predicates for
conditional processing.

\subsection{Defining functions}

The \pkg{expl3} codebase provides a suite of commands for defining macros at a
very low level. Note that these are not intended to provide \emph{user-level}
interfaces to creating commands with optional arguments and other
bells'n'whistles. In fact, since these commands are centred around macros that
take arguments, we're going to start calling them `functions'.

Here are two equivalent ways of defining the function |\foo:nn|:
\begin{lstlisting}
\def:Npn \foo:nn #1#2 {(#1)/(#2)}
\def:cpn {foo:nn} #1#2 {(#1)/(#2)}
\end{lstlisting}
These macros are respectively equivalent to \TeX's |\def\foo:nn| and
|\expandafter\def\csname foo:nn\endcsname|. Note the |:nn| suffix to denote
that |\foo| takes two arguments. Here, the |\def|{\color{red}|_new|} instead
of |\def| ensures that the function name has not previously been defined.
|\|{\color{red}|g|}|def| defines the function globally. |\def:Npx| is
equivalent to \TeX's |\edef|.

Further \TeX\ functionality is encapsulated within ever-longer function names.
Having seen the example above, it should be easy to guess the meaning of this:
\par{\centering|\gdef_protected_long_new:Npn| \par} Related commands (with
easy to guess names) are defined for defining commands that aren't global, or
aren't long, or aren't protected, or any combination of the above. Again,
remember that these commands are designed to be understandable because they're
used in low-level code; their verbosity is intended. User macros can be as
succinct as you wish.

\pkg{expl3}'s equivalent commands for \TeX's |\let| are a good demonstration
of the `function suffix' ideas. The following four functions each set the
macro |\foo| to have the same meaning as |\bar|:

\begin{lstlisting}
\let:NN \foo  \bar    
\let:cN {foo} \bar
\let:cc {foo} {bar}   
\let:Nc \foo  {bar}
\end{lstlisting}

There's also a |\let|{\color{red}|_new|} function to ensure you're not
|\let|-ing over a previous definition of |\foo|.

\section{True or false?}

Anyone who's experimented with complicated boolean nesting in \LaTeXe\ will be
familiar with the problem of |missing \fi inserted| and the like, when the
result of the conditional statement is expanded within the |\if...\fi|
statement. To avoid these problems, the \pkg{expl3} bundle takes a different
approach than the classical |\newif| approach. As we will see, this results
in a very rich framework for boolean logic that \LaTeX\ has typically missed
in the past.

\begin{lstlisting}
\predicate:nTF{\c_false}{yes}{no}
\end{lstlisting}

\section{Lists of tokens and lists of lists of tokens}



\section{Lua\TeX}

So what does it mean to be talking about a new macro programming interface
when Lua\TeX\ is just around the corner? The Con\TeX{}t project has been being
re-written in sync with Lua\TeX\ development, but the \LaTeX\ project is not
afforded that flexibility.

Consider that Con\TeX{}t has been evolving as a monolithic software project
for many years. Its underlying architecture is built on solid foundations, and
this makes it conceptually much more possible to switch out areas of
processing with Lua

Despite its advantages, \LaTeX\ has no such structure. It has remained with a
piecemeal kernel for many years while the \pkg{expl3} programming syntax has
been developed, since there's no point fixing what will be thrown out. Once
complete, however, \pkg{expl3} gives \LaTeX\ a structured base that can be
re-written in Lua as needed. For example, the quicksort algorithm in
\pkg{l3prg}, which is currently written with \TeX\ code.

\end{document} 