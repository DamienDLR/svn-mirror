% \iffalse
%% File: l3keyval.dtx Copyright (C) 2006 LaTeX3 project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3b of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the ``expl3 bundle'' (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/cgi-bin/cvsweb.cgi/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%<package>\RequirePackage{l3names}
%<*dtx>
%\fi
\def\GetIdInfo$#1: #2.dtx,v #3 #4 #5 #6 #7$#8{%
  \def\fileversion{#3}%
  \def\filedate{#4}%
  \ProvidesFile{#2.dtx}[#4 v#3 #8]%
}
%\iffalse
%</dtx>
%\fi
\GetIdInfo$Id$
       {L3 Experimental keyval processing}
% \iffalse
%<*driver>
\documentclass{l3doc}

\begin{document}
\DocInput{l3keyval.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{l3keyval} package\thanks{This file
%         has version number \fileversion, last
%         revised \filedate.}\\
% Key-value parsing}
% \author{\Team}
% \date{\filedate}
% \maketitle
%
% \section{Introduction}
%
% Currently, this module only provides functions for extracting keys
% and values from a list. How this information is used is up to the
% programmer.
%
% A \meta{keyval list} is a list consisting of
% \begin{verbatim}
% key 1 = value 1 ,
% key 2           ,
% key 3 = value 3 ,
% \end{verbatim}
% 
% The function names for retrieving the keys and values are long but
% explain what they do. All these functions start with the name
% |\KV_parse_|. If a value is surrounded by braces, one level (and
% only one) is removed from the value. This is useful if you need to
% input a value which contains |=| or |,|. There are two primary
% actions we can take on a \meta{keyval list}.
% \begin{itemize}
% \item A \meta{keyval list} can be sanitized so that top level active
%   commas or equal signs are converted into catcode 12. When
%   declaring templates in the preamble one can probably safely assume
%   that there are no active commas or equals; these things should
%   only be active in the document. The name for this is either
%   |no_sanitize| or |sanitize|.
% \item Spaces on either side of a key or value can be trimmed. When
%   using the \LaTeX3 programming interface, spaces are automatically
%   ignored so there it would be a waste of time to search for extra
%   spaces since there would be none. At the document level however,
%   spaces must be removed. The name for this is either
%   |no_space_removal| or |space_removal|.
% \end{itemize}
%
% During the parsing process, keys or values are not expanded and no
% |#|s are doubled.  When the parsing process is over, the keys and
% values are executed in the form
% \begin{quote}
% "\KV_key_value_elt:nn{key 1}{value 1}" \\
% "\KV_key_no_value_elt:n{key 2}"        \\
% "\KV_key_value_elt:nn{key 3}{value 3}"
% \end{quote}
% It is up to the programmer to provide a suitable definition of these
% two functions before starting the parsing process.
%
% \subsection{Functions}
%
%
%
%
% \begin{function}{
%     \KV_parse_no_space_removal_no_sanitize:n |
% }
%   \begin{syntax}
%     "\KV_parse_no_space_removal_no_sanitize:n" "{"<keyval list>"}"
%   \end{syntax}
%   Parses the keys and values literally. For use when spaces are
%   ignored and |=| and |,| have normal catcodes.
% \end{function}
%
% \begin{function}{
%     \KV_parse_space_removal_no_sanitize:n |
% }
%   \begin{syntax}
%     "\KV_parse_space_removal_no_sanitize:n" "{"<keyval list>"}"
%   \end{syntax}
%   As above but also removes spaces around keys and values. For use
%   when spaces are not ignored.
% \end{function}
%
% \begin{function}{
%     \KV_parse_space_removal_sanitize:n |
% }
%   \begin{syntax}
%     "\KV_parse_space_removal_sanitize:n" "{"<keyval list>"}"
%   \end{syntax}
%   As above but additionally also replaces top-level active |=| and
%   |,| with harmless versions.
% \end{function}
%
% \begin{function}{
%     \KV_key_no_value_elt:n |
%     \KV_key_value_elt:nn |
% }
%   \begin{syntax}
%     "\KV_key_no_value_elt:n" "{"<key>"}" \\
%     "\KV_key_value_elt:n" "{"<key>"}" "{"<value>"}"
%   \end{syntax}
%   Functions returned by the |\KV_parse_| functions. The default
%   definition of these two functions is an error message!
% \end{function}
%
%
% \StopEventually{}
%
% \section{Implementation}
%
%
%    We start by ensuring that the required packages are loaded.
%    \begin{macrocode}
%<*package>
\RequirePackage{l3quark}
\RequirePackage{l3toks}
\RequirePackage{l3int}
\RequirePackage{l3token}
%</package>
%<*initex|package>
%    \end{macrocode}
%
%
%
%
% \begin{macro}{\l_KV_tmpa_tlp}
% \begin{macro}{\l_KV_tmpb_tlp}
% \begin{macro}{\c_KV_single_equal_sign_tlp}
% Various useful things.
%    \begin{macrocode}
\tlp_new:Nn\l_KV_tmpa_tlp{}
\tlp_new:Nn\l_KV_tmpb_tlp{}
\tlp_new:Nn \c_KV_single_equal_sign_tlp{=}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\l_KV_parse_toks}
% \begin{macro}{\l_KV_currkey_toks}
% \begin{macro}{\l_KV_currval_toks}
% Some more useful things.
%    \begin{macrocode}
\toks_new:N \l_KV_parse_toks
\toks_new:N \l_KV_currkey_toks
\toks_new:N \l_KV_currval_toks
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\KV_sanitize_outerlevel_active_equals:N}
% \begin{macro}{\KV_sanitize_outerlevel_active_commas:N}
%   Some functions for sanitizing top level equals and commas. Replace
%   |=|$\sb{13}$ and |,|$\sb{13}$ with |=|$\sb{12}$ and |,|$\sb{12}$
%   resp.
%    \begin{macrocode}
\group_begin:
\char_set_catcode:nn{`\=}{13}
\char_set_catcode:nn{`\,}{13}
\char_set_lccode:nn{`\8}{`\=}
\char_set_lccode:nn{`\9}{`\,}
\tlist_to_lowercase:n{\group_end:
\def_new:Npn \KV_sanitize_outerlevel_active_equals:N #1{
  \tlp_replace_all_in:Nnn #1 = 8
}
\def_new:Npn \KV_sanitize_outerlevel_active_commas:N #1{
  \tlp_replace_all_in:Nnn #1 , 9
}
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
%
% \begin{macro}{\KV_remove_surrounding_spaces:nw}
% \begin{macro}{\KV_remove_surrounding_spaces_auxi:w}
% \begin{macro}{\KV_remove_surrounding_spaces_auxii:w}
% \begin{macro}{\KV_add_element_helper:w}
% \begin{macro}{\KV_set_key_element:w}
% \begin{macro}{\KV_set_value_element:w}
%   The macro |\KV_remove_surrounding_spaces:Nw| removes a possible
%   leading space plus a possible ending space from its second
%   argument and stores it in the token register |#1|.
%
%   Based on Around the Bend No.~15 but with some enhancements. For
%   instance, this definition is purely expandable.
%
%   We use a funny token |Q|$\sb3$ as a delimiter.
%    \begin{macrocode}
\group_begin:
\char_set_catcode:nn{`\Q}{3}
%    \end{macrocode}
%    \begin{macrocode}
\gdef_long_new:Npn\KV_remove_surrounding_spaces:nw#1#2\q_nil{
%    \end{macrocode}
% The idea in this processing is to use a Q with strange catcode to
% remove a trailing space. But first, how to get this expansion going?
%
% If you have read the fine print in the \textsf{l3expan} module,
% you'll know that the |f| type expansion will expand until the first
% non-expandable token is seen and if this token is a space, it will
% be gobbled. Sounds useful for removing a leading space but we also
% need to make sure that it does nothing but removing that space!
% Therefore we prepend the argument to be trimmed with an
% |\exp_not:N|. Now why is that? |\exp_not:N| in itself is an
% expandable command so will allow the |f| expansion to continue. If
% the first token in the argument to be trimmed is a space, it will be
% gobbled and the expansion stop. If the first token isn't a space,
% the |\exp_not:N| turns it temporarily into |\scan_stop:| which is
% unexpandable. The processing stops but the token following directly
% after |\exp_not:N| is now back to normal.
%
% The function here allows you to insert arbitrary functions in the
% first argument but they should all be with an |f| type
% expansion. For the application in this module, we use
% |\toks_set:Nf|.
%
% Once the expansion has been kick-started, we apply
% |\KV_remove_surrounding_spaces_auxi:w| to the replacement text of
% |#2|, adding a leading |\exp_not:N|. Note that no braces are
% stripped off of the original argument.
%    \begin{macrocode}
  #1{\KV_remove_surrounding_spaces_auxi:w \exp_not:N#2Q~Q}
}
%    \end{macrocode}
% |\KV_remove_surrounding_spaces_auxi:w| removes a trailing space if
% present, then calls |\KV_remove_surrounding_spaces_auxii:w| to clean
% up any leftover bizarre Qs. In order for
% |\KV_remove_surrounding_spaces_auxii:w| to work properly we need to
% put back a Q first.
%    \begin{macrocode}
\gdef_long_new:Npn\KV_remove_surrounding_spaces_auxi:w#1~Q{
  \KV_remove_surrounding_spaces_auxii:w #1 Q
}
%    \end{macrocode}
% Now all that is left to do is remove a leading space which should be
% taken care of by the function used to initiate the expansion. Simply
% return the argument before the funny Q.
%    \begin{macrocode}
\gdef_long_new:Npn\KV_remove_surrounding_spaces_auxii:w#1Q#2{#1}
%    \end{macrocode}
% Here are some specialized versions of the above. They do exactly
% what we want in one go.
%    \begin{macrocode}
\gdef_long:Npn \KV_add_element_helper:w#1\q_nil{{#1}}
\gdef_long_new:Npn\KV_add_value_element:w\q_stop#1\q_nil{
  \toks_put_right:Nd\l_KV_parse_toks
  {
    \exp_after:NN\KV_add_element_helper:w
    \int_to_roman:w -`0
    \KV_remove_surrounding_spaces_auxi:w \exp_not:N#1Q~Q
    \q_nil
  }
}
\gdef_long_new:Npn\KV_set_key_element:w#1\q_nil{
  \toks_set:Nd\l_KV_currkey_toks
  {
    \exp_after:NN\KV_add_element_helper:w
    \int_to_roman:w -`0
    \KV_remove_surrounding_spaces_auxi:w \exp_not:N#1Q~Q
    \q_nil
  }
}
\group_end:
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% 
%
%
% Parse a list of keyvals, put them into list form with entries like
% |\KV_key_no_value_elt:n{key1}| and |\KV_key_value_elt:nn{key2}{val2}|.
%
% \begin{macro}{\KV_parse_sanitize_aux:Nn}
%   The slow parsing algorithm sanitizes active commas and equal signs
%   at the top level first. Then uses |#1| as inspector of each
%   element in the comma list.
%    \begin{macrocode}
\def_long_new:Npn \KV_parse_sanitize_aux:Nn #1#2{
  \group_begin:
  \toks_clear:N \l_KV_parse_toks
  \tlp_set:Nx\l_KV_tmpa_tlp{\exp_not:n{#2}}
  \KV_sanitize_outerlevel_active_equals:N\l_KV_tmpa_tlp
  \KV_sanitize_outerlevel_active_commas:N\l_KV_tmpa_tlp
  \exp_after:NN #1 \l_KV_tmpa_tlp,\q_nil,
%    \end{macrocode}
% We evaluate the parsed keys and values outside the group so the
% token register is restored to its previous value.
%    \begin{macrocode}
  \exp_after:NN\group_end:
  \toks_use:N \l_KV_parse_toks
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\KV_parse_no_sanitize_aux:Nn}
%   Like above but we don't waste time sanitizing. This is probably
%   the one we will use for preamble parsing where catcodes of |=| and
%   |,| are as expected!
%    \begin{macrocode}
\def_long_new:Npn \KV_parse_no_sanitize_aux:Nn #1#2{
  \group_begin:
  \toks_clear:N \l_KV_parse_toks
  #1 #2,\q_nil,
  \exp_after:NN\group_end:
  \toks_use:N \l_KV_parse_toks
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\KV_parse_elt_safe:w}
%   This version allows unmatched conditionals in the values. Needed?
%   Note that this doesn't actually work yet because there is no
%   |\quark_if_nil:nF| function\dots
%    \begin{macrocode}
\def_long_new:Npn \KV_parse_elt_safe:w #1,{
  \quark_if_nil:nF{#1}{
    \tlist_if_blank:nF{#1}{
      \KV_split_key_value_current:w #1==\q_nil
      \KV_parse_elt_safe:w
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\KV_parse_elt:w}
%   This version doesn't allow unmatched conditionals in the values.
%    \begin{macrocode}
\def_long_new:Npn \KV_parse_elt:w #1,{
  \exp_after:NN\if_meaning:NN\exp_after:NN =\use_arg_i:n#1=
    \exp_after:NN \KV_parse_elt:w
  \else:
    \if_meaning:NN\q_nil #1
    \else:
      \KV_split_key_value_current:w #1==\q_nil
      \exp_after:NN\exp_after:NN\exp_after:NN \KV_parse_elt:w
    \fi:
  \fi:
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\KV_split_key_value_current:w}
% The function called to split the keys and values.
%    \begin{macrocode}
\let_new:NN \KV_split_key_value_current:w \ERROR
%    \end{macrocode}
% \end{macro}
%
% We provide two functions for splitting keys and values. The reason
% being that most of the time, we should probably be in the special
% coding regime where spaces are ignored. Hence it makes no sense to
% spend time searching for extra space tokens and we can do the
% settings directly. When comparing these two versions (neither doing
% any sanitizing) the |no_space_removal| version is more than 40\%
% faster than |space_removal|.
%
% It is up to functions like |\DeclareTemplate| to check which catcode
% regime is active and then pick up the version best suited for it.
%
%
%
% \begin{macro}{\KV_split_key_value_space_removal:w}
% \begin{macro}{\KV_split_key_value_space_removal_detect_error:wTF}
% \begin{macro}{\KV_split_key_value_space_removal_aux:w}
%   The code below removes extraneous spaces around the keys and
%   values plus one set of braces around the entire value.
%
%   Unlike the version to be used when spaces are ignored, this one
%   only grabs the key which is everything up to the first = and save
%   the rest for closer inspection. Reason is that if a user has
%   entered |mykey={{myval}},| then the outer braces have already been
%   removed before we even look at what might come after the key. So
%   this is slightly more tedious (but only slightly) but at least it
%   always removes only one level of braces.
%    \begin{macrocode}
\def_long_new:Npn \KV_split_key_value_space_removal:w #1 = #2\q_nil{
%    \end{macrocode}
%   First grab the key.
%    \begin{macrocode}
  \KV_set_key_element:w#1\q_nil
%    \end{macrocode}
% Then we start checking. If only a key was entered, |#2| contains
% |=| and nothing else, so we test for that first.
%    \begin{macrocode}
  \tlp_set:Nx\l_KV_tmpa_tlp{\exp_not:n{#2}}
  \tlp_if_eq:NNTF\l_KV_tmpa_tlp\c_KV_single_equal_sign_tlp
%    \end{macrocode}
% Then we just insert the default key.
%    \begin{macrocode}
  {
    \toks_put_right:No\l_KV_parse_toks{
      \exp_after:NN \KV_key_no_value_elt:n \toks_use:N\l_KV_currkey_toks
    }
  }
%    \end{macrocode}
% Otherwise we must take a closer look at what is left. The remainder
% of the original list up to the comma is now stored in |#2| plus an
% additional |==|, which wasn't gobbled during the initial reading of
% arguments.  If there is an error then we can see at least one more
% |=| so we call an auxiliary function to check for this.
%    \begin{macrocode}
  {
    \KV_split_key_value_space_removal_detect_error:wTF#2\q_no_value\q_nil
    {\KV_split_key_value_space_removal_aux:w \q_stop #2}
    {\ERROR}
  }
}
%    \end{macrocode}
% The error test.
%    \begin{macrocode}
\def_long_new:Npn
  \KV_split_key_value_space_removal_detect_error:wTF#1=#2#3\q_nil{
    \tlist_if_head_eq_meaning:nNTF{#3}\q_no_value
}
%    \end{macrocode}
% Now we can start extracting the value. Recall that |#1| here starts
% with |\q_stop| so all braces are still there! First we try to see
% how much is left if we gobble three brace groups from |#1|. If |#1|
% is empty or blank, all three quarks are gobbled. If |#1| consists of
% exactly one token or brace group, only the latter quark is left.
%    \begin{macrocode}
\def_long_new:Npn\KV_split_key_value_space_removal_aux:w #1=={
  \tlp_set:Nx\l_KV_tmpa_tlp{\exp_not:o{\use_none:nnn#1\q_nil\q_nil}}
  \toks_put_right:No\l_KV_parse_toks{
    \exp_after:NN \KV_key_value_elt:nn \toks_use:N\l_KV_currkey_toks
  }
%    \end{macrocode}
% If there a blank space or nothing at all, |\l_KV_tmpa_tlp| is now
% completely empty.
%    \begin{macrocode}
    \tlp_if_empty:NTF\l_KV_tmpa_tlp
%    \end{macrocode}
% We just put an empty value on the stack.
%    \begin{macrocode}
  { \toks_put_right:Nn\l_KV_parse_toks{{}} }
  {
%    \end{macrocode}
% If there was exactly one brace group or token in |#1|,
% |\l_KV_tmpa_tlp| is now equal to |\q_nil|. Then we can just pick it
% up as the second argument of |#1|. This will also take care of any
% spaces which might surround it.
%    \begin{macrocode}
    \quark_if_nil:NTF\l_KV_tmpa_tlp
    {
      \toks_put_right:No\l_KV_parse_toks{
        \exp_after:NN{
          \use_arg_ii:nnn #1\q_nil}
      }
    }
%    \end{macrocode}
% Otherwise we grab the value.
%    \begin{macrocode}
    { \KV_add_value_element:w #1\q_nil }
  }
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\KV_split_key_value_no_space_removal:w}
%   This version is for when in the special coding regime where spaces
%   are ignored so there is no need to do any fancy space hacks,
%   however fun they may be. Since there are no spaces, a set of
%   braces around a value is automatically stripped by \TeX.
%    \begin{macrocode}
\def_long_new:Npn \KV_split_key_value_no_space_removal:w #1=#2=#3\q_nil{
  \tlp_set:Nn\l_KV_tmpa_tlp{#3}
  \tlp_if_empty:NTF \l_KV_tmpa_tlp
  {
    \toks_put_right:Nn\l_KV_parse_toks{\KV_key_no_value_elt:n{#1}}
  }
  {
    \tlp_if_eq:NNTF\c_KV_single_equal_sign_tlp\l_KV_tmpa_tlp
    {
      \toks_put_right:Nn\l_KV_parse_toks{\KV_key_value_elt:nn{#1}{#2}}
    }
    {\ERROR}
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\KV_key_no_value_elt:n}
% \begin{macro}{\KV_key_value_elt:nn}
%    \begin{macrocode}
\def_long_new:Npn \KV_key_no_value_elt:n #1{\ERROR}
\def_long_new:Npn \KV_key_value_elt:nn #1#2{\ERROR}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% 
%
% \begin{macro}{\KV_parse_no_space_removal_no_sanitize:n}
%   Finally we can put all the things
%   together. |\KV_parse_no_space_removal_no_sanitize:n| is the
%   version that disallows unmatched conditional and does no space
%   removal.
%    \begin{macrocode}
\def_new:Npn \KV_parse_no_space_removal_no_sanitize:n {
  \let:NN \KV_split_key_value_current:w \KV_split_key_value_no_space_removal:w
  \KV_parse_no_sanitize_aux:Nn \KV_parse_elt:w
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\KV_parse_space_removal_sanitize:n}
% \begin{macro}{\KV_parse_space_removal_no_sanitize:n}
%   The other varieties can be defined in a similar manner. For the
%   version needed at the document level, we can use this one.
%    \begin{macrocode}
\def_new:Npn \KV_parse_space_removal_sanitize:n {
  \let:NN \KV_split_key_value_current:w \KV_split_key_value_space_removal:w
  \KV_parse_sanitize_aux:Nn \KV_parse_elt:w
}
%    \end{macrocode}
% For preamble use by the non-programmer this is probably best.
%    \begin{macrocode}
\def_new:Npn \KV_parse_space_removal_no_sanitize:n {
  \let:NN \KV_split_key_value_current:w \KV_split_key_value_space_removal:w
  \KV_parse_no_sanitize_aux:Nn \KV_parse_elt:w
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%    \begin{macrocode}
%</initex|package>
%<*showmemory>
\showMemUsage
%</showmemory>
%    \end{macrocode}
%
% \endinput
%
%  $Log$
%  Revision 1.1  2006/01/27 10:14:24  morten
%  Initial version of keyval parser
%
