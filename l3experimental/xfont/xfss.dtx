% \iffalse
%% File: xfss.dtx Copyright (C) 2011- LaTeX3 project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX Project Team.
%%
%% -----------------------------------------------------------------------
%
%
%<*driver|package>
\RequirePackage{expl3,l3hooks}
\GetIdInfo$Id$
  {L3 Experimental Font Selection}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \textsf{xfss} package\\ Experimental Font Selection^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
% \maketitle
% \tableofcontents
%
% \begin{documentation}
%
% \section{Introduction}
% A re-implementation of the NFSS in \pkg{expl3}.
% This has been written by dumping the plain un-commented
% code as part of the NFSS, then translating it piece-by-piece
% into the \pkg{expl3} syntax.
%
% As such, all code comments have been lost. (Most of) these will
% be restored as the code becomes functional.
%
% \section{Use}
% Load \pkg{xfss} as early as possible, preferably before the
% document class.
%
% \section{Third-party packages}
%
% The following packages will be incorporated into the functionality here.
% \begin{itemize}
% \item [everysel] Provides \cs{EverySelectfont} and \cs{AtNextSelectfont}.
% \item [relsize] Provides \cs{larger}, \cs{smaller} and similar commands.
% \item [extsizes]
% \end{itemize}
%
% \section{Commands}
%
% \subsection{User-level \LaTeXe{} commands}
%
% \begin{function}{\DeclareTextCommand,\ProvideTextCommand}
%   \begin{syntax}
%     \cs{DeclareTextCommand} <cmd> \Arg{enc.} <opt. arg> \Arg{def'n}
%   \end{syntax}
%   This defines <cmd> in the encoding <enc.> to have the definition <def'n>.
%   The optional argument can either follow the style of \cs{newcommand}
%   (two optional arguments: the number of arguments, and the default
%   argument in case the defined command should have an argument), or
%   the style of \pkg{xparse} (a braced argument specification).
% \end{function}
%
% \begin{function}{\DeclareTextCommandDefault,\ProvideTextCommandDefault}
%   \begin{syntax}
%     \cs{DeclareTextCommandDefault} <cmd> <opt. arg> \Arg{def'n}
%   \end{syntax}
%   This defines the behaviour of <cmd> when encountered in an%^^Ahere
% \end{function}
%
% \section{Internal commands}
%
% \begin{function}{\xfss_set_font_size_commands:n}
% \begin{syntax}
% "\xfss_set_font_size_commands:n {10}"
% \end{syntax}
% Sets the full range of size commands (\cs{small}, \cs{large}, etc.)
% according to the nominal font size "#1".
% In \LaTeXe, this command is executed \cs{AtBeginDocument} based on the
% current definition of \cs{normalsize} so the class font size is picked up.
% \end{function}
%
% \begin{function}{\xfss_switch_catcodes:}
% \begin{syntax}
% "  \group_begin:"\\
% "    \xfss_switch_catcodes:"\\
% "    ..."\\
% "  \group_end:"
% \end{syntax}
% Enables the catcode regime required for the parsing of font definition
% files.
% \begin{texnote}
% Was \LaTeXe's \cs{nfss@catcodes}
% \end{texnote}
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{xfss} implementation}
%
% The eventual goal is to have this package loadable both on top of
% \LaTeXe, overriding the NFSS, or in a standalone \LaTeX3 kernel.
%
%    \begin{macrocode}
%<*package|initex>
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
\RequirePackage{xparse}
\RequirePackage{l3font}
%<*package>
\makeatletter
%</package>
%    \end{macrocode}
%
% \subsection{Unloading the original NFSS}
%
% These are only the commands required to be undefined before
% replacing them.
%
%    \begin{macrocode}
%<*package>
\tl_map_function:nN
  {
    \mathrm \mathnormal \mathcal \mathbf \mathsf \mathit \mathup \mathtt
    \rmdefault \sfdefault \ttdefault \bfdefault
    \mddefault \itdefault \sldefault \scdefault
    \updefault \encodingdefault \familydefault
    \seriesdefault \shapedefault
    \symlargesymbols \symsymbols \symoperators \symletters
    \small \footnotesize \scriptsize \tiny
    \large \Large \LARGE \huge \Huge
  }
  \cs_undefine:N
%</package>
%    \end{macrocode}
%
%
% \subsection{l3font candidates}
%
% \subsubsection{Spaceskip and spacefactor}
%
% \begin{macro}{\font_set_spaceskip:n,\font_set_extra_spaceskip:n}
% Override the interword space that is usually specified on a per-font basis.
%    \begin{macrocode}
\cs_new:Npn \font_set_spaceskip:n       { \skip_set:Nn \tex_spaceckip:D  }
\cs_new:Npn \font_set_extra_spaceskip:n { \skip_set:Nn \tex_xspaceskip:D }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\font_reset_spaceskip:,\font_reset_xspaceskip:}
% Use the interword space specified by the font.
%    \begin{macrocode}
\cs_new:Npn \font_reset_spaceskip:       { \skip_zero:N \tex_spaceskip:D  }
\cs_new:Npn \font_reset_extra_spaceskip: { \skip_zero:N \tex_xspaceskip:D }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_spacefactor_save:,\xfss_spacefactor_restore:}
%   Sometimes we need to save and restore the space factor.
%   Not sure what the correct behaviour with respect to groups
%   should be.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xfss_spacefactor_save:
  {
    \cs_gset_protected_nopar:Npx \xfss_spacefactor_restore:
      { \tex_spacefactor:D = \tex_the:D \tex_spacefactor:D \tex_relax:D }
  }
\cs_new_protected_nopar:Npn \xfss_spacefactor_restore: { \ERROR }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Math fonts}
%
% \begin{macro}{\c_max_math_fonts_int}
%   The maximum number of math fonts.\footnote{Bruno: is that the
%     same as math groups?}
%    \begin{macrocode}
\int_const:Nn \c_max_math_fonts_int {16}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\mathgroup_new:N,\mathgroup_new:c}
%   Allocating math groups. In package mode, we copy \cs{new@mathgroup}.
%   In format mode, we use \pkg{l3alloc}. The maximum number of
%   math groups is sixteen.\footnote{Bruno: is it the same as
%     \cs{c_max_math_fonts_int}? Are math groups and math fonts
%     the same concept?}
%    \begin{macrocode}
%<*package>
\cs_new_eq:NN \mathgroup_new:N \new@mathgroup
%</package>
%<*initex>
\alloc_new:nnnN {mathgroup} \c_zero \c_sixteen \tex_chardef:D
%</initex>
\cs_generate_variant:Nn \mathgroup_new:N {c}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\mathgroup_use:N,\mathgroup_use:n}
%   Same as \TeX{}'s \tn{fam}. The \texttt{N} version is meant
%   to be used with actual \texttt{mathgroup} variables, while
%   the \texttt{n} version can be used with explicit numbers.
%   That one will be removed soon.
%    \begin{macrocode}
\cs_new_eq:NN \mathgroup_use:N \tex_fam:D
\cs_new:Npn \mathgroup_use:n #1
  { \tex_fam:D \int_eval:w #1 \int_eval_end: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\mathgroup}
%   Packages may expect \cs{mathgroup} to be \cs{tex_fam:D}.
%    \begin{macrocode}
%<package>\cs_set_eq:NN \mathgroup \mathgroup_use:N
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\newfam,\newfont}
% \cs{newfam} is a user function for creating new maths families.
% Shouldn't be necessary.
% Keep these here for the time being.
% \cs{newfont} is taken care of by \pkg{l3font}, so deprecate it.
%    \begin{macrocode}
%<*deprecated>
\cs_set_eq:NN \newfam  \mathgroup_new:N
\cs_set_eq:NN \newfont \fontface_new:Nn
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Function variants}
%
%    \begin{macrocode}
\cs_generate_variant:Nn \prop_gput:Nnn {Nx, Nxx, Nco, Ncx}
\cs_generate_variant:Nn \prop_if_in:NnTF {Nx}
\cs_generate_variant:Nn \prop_gpop:NnNTF {Nx}
%    \end{macrocode}
%
% \begin{macro}{\exp_args:NNccc}
%    \begin{macrocode}
\cs_generate_internal_variant:n {nc}
\cs_generate_internal_variant:n {nccc}
%    \end{macrocode}
% \end{macro}
%
% \subsection{expl3 extensions}
%
% \subsubsection{General}
%
% \begin{macro}{\mode_leave_vertical:}
% \begin{macro}{\xfss_text_in_math:n}
%   \LaTeXe's \cs{leavevmode} and \cs{mbox}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \mode_leave_vertical:
  { \hbox_unpack_clear:N \c_empty_box }
\cs_if_free:NT \xfss_text_in_math:n
  {
    \cs_new_protected:Npn \xfss_text_in_math:n
      { \mode_leave_vertical: \hbox:n }
  }
\cs_set_protected:Npn \xfss_text_in_math:n #1 {{\mbox{#1}}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\cs_clear:N,\cs_gclear:N}
% Debatable names, but useful functions.
%    \begin{macrocode}
\cs_new_protected:Npn \cs_clear:N  #1 { \cs_set_eq:NN  #1 \prg_do_nothing: }
\cs_new_protected:Npn \cs_gclear:N #1 { \cs_gset_eq:NN #1 \prg_do_nothing: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cs_null:N,\cs_gnull:N}
% Debatable names, but useful functions.
% The distinction between undefined/empty/relax can be important!
%    \begin{macrocode}
\cs_new_protected:Npn \cs_null:N  #1 { \cs_set_eq:NN  #1 \scan_stop: }
\cs_new_protected:Npn \cs_gnull:N #1 { \cs_gset_eq:NN #1 \scan_stop: }
\cs_generate_variant:Nn \cs_gnull:N {c}
%    \end{macrocode}
% \end{macro}
%
% \begin{function}{\cs_meaning_if_in:NN / (TF)}
%   \begin{syntax}
%     \cs{cs_meaning_if_in:NNTF} <cs1> <cs2> \Arg{true} \Arg{false}
%   \end{syntax}
%   These conditionals test if <cs2> is used within the definition (or meaning)
%   of <cs1>. Note this test can only make this test using string comparison,
%   so commands with escaped backslashes will still register as positives.
% \end{function}
%
% \begin{macro}[pTF]{\cs_meaning_if_in:NN}
%    \begin{macrocode}
\prg_new_conditional:Npnn \cs_meaning_if_in:NN #1#2 {TF,T,F}
  {
    \exp_args:Nxx \tl_if_in:nnTF
      { \cs_meaning:N #1 } { \token_to_str:N #2 }
      \prg_return_true: \prg_return_false:
  }
\cs_generate_variant:Nn \cs_meaning_if_in:NNTF {c}
\cs_generate_variant:Nn \cs_meaning_if_in:NNT  {c}
\cs_generate_variant:Nn \cs_meaning_if_in:NNF  {c}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_use:cF}
%   If the command exists, use it. Otherwise, use the \texttt{F} branch.
%    \begin{macrocode}
\cs_new:Npn \xfss_use:cF #1
  {
    \cs_if_exist:cTF {#1}
      { \use:c {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Dimensions and skips}
%
% \begin{macro}{\dim_abs:n}
%   Compute the argument, then remove a potential leading \texttt{-} sign.
%    \begin{macrocode}
\cs_new_nopar:Npn \dim_abs:n
  { \exp_last_unbraced:Nf \dim_abs_aux:N \dim_eval:n }
\cs_new_nopar:Npn \dim_abs_aux:N #1
  { \if_meaning:w - #1 \else: \exp_after:wN #1 \fi: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_dim_strip_pt:n}
% \begin{macro}[aux]{\xfss_dim_strip_pt:w}
%   Mixture of \LaTeXe{}'s \cs{strip@pt} and \cs{@defaultunits}.
%   Accepts arguments valid for \cs{dim_eval:n} as well as real numbers
%   (whose default unit will be \texttt{pt}). Returns a dimension
%   without its \texttt{pt} unit.
%    \begin{macrocode}
\cs_new_nopar:Npn \xfss_dim_strip_pt:n #1
  {
    \exp_after:wN \xfss_dim_strip_pt:w
    \dim_use:N \dim_eval:w #1 pt \dim_eval_end: \q_stop
  }
\use:x
  {
    \cs_new_nopar:Npn \exp_not:N \xfss_dim_strip_pt:w
        ##1.##2 \tl_to_str:n {pt} ##3 \exp_not:N \q_stop
      {
        ##1
        \exp_not:N \int_compare:nNnT {##2} > \c_zero {.##2}
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xfss_default_units:w}
%   Straight from \LaTeXe{}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xfss_default_units:w
  { \tex_afterassignment:D \use_none_delimit_by_q_nil:w }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_last_skip}
% This \emph{read-only} variable contains the amount of any glue
% placed into the output list directly prior to its being queried.
% \end{variable}
%
% \begin{macro}{\l_last_skip}
%    \begin{macrocode}
\cs_set_eq:NN \l_last_skip \tex_lastskip:D
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Props}
%
% \begin{function}{\prop_length:N}
%   \begin{syntax}
%     \cs{prop_length:N} <prop var>
%   \end{syntax}
%   Counts the number of key--value pairs in the property list.
%    \begin{macrocode}
\cs_set_nopar:Npn \prop_length:N #1
  {
    \int_eval:n
      {
        0
        \prop_map_function:NN #1 \prop_length_aux:nn
      }
  }
\cs_new_nopar:Npn \prop_length_aux:nn #1 #2 { + 1 }
%    \end{macrocode}
% \end{function}
%
% \subsubsection{Math}
%
% \begin{function}{\math_inner:}
%   \begin{syntax}
%     "$"\cs{math_inner:} \dots{} "$"
%   \end{syntax}
%   This command is used inside an inline math environment; it removes
%   the surrounding space that normally appears around it in the text.
%   It is used when creating symbols and using maths inside tight boxes where
%   this space padding is unnecessary/inappropriate.
%   \begin{texnote}
%     This is \LaTeXe's \tn{m@th}.
%   \end{texnote}
% \end{function}
%
% \begin{macro}{\math_inner:}
% This is \LaTeXe's "\m@th".
%    \begin{macrocode}
\cs_new:Npn \math_inner: { \tex_mathsurround:D \c_zero_dim }
%<package>\cs_set_eq:NN \m@th \math_inner:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\math_nospace:}
%    \begin{macrocode}
\cs_new:Npn \math_nospace:
  {
    \tex_nulldelimiterspace:D \c_zero_dim
    \tex_mathsurround:D \c_zero_dim
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Messages}
%
% The message texts are set up within a group where spaces
% are not ignored.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_space:n {32}
%    \end{macrocode}
%
% \subsubsection{Info messages}
%
%    \begin{macrocode}
  \msg_new:nnn {xfss} {overwrite-enc-defaults}
    {Overwriting encoding scheme #1 defaults}
  \msg_new:nnn {xfss} {try-load} {Trying to load font information for #1}
  \msg_new:nnn {xfss} {calc-math-sizes} {Calculating math sizes for size <#1>}
  \msg_new:nnn {xfss} {checking-defaults} {Checking defaults for #1}
  \msg_new:nnn {xfss} {okay!} { ... okay }
  \msg_new:nnn {xfss} {enc-change}
    {%
      Encoding `#1' has changed to `#2' for symbol font\\%
      `#3' in the math version `#4'%
    }
  \msg_new:nnn {xfss} {overwrite-symfont}
    {%
      Overwriting symbol font `#1' in version `#2'\\%
      \ \ \ \ #3 --> #4%
    }
  \msg_new:nnn {xfss} {overwrite-mathalph}
    {%
      Overwriting math alphabet `#1' in version `#2'\\%
      \ \ \ \ #3 --> #4%
    }
  \msg_new:nnn {xfss} {redeclaring} {Redeclaring #1 `#2'}
%    \end{macrocode}
%
%
% \subsubsection{Warnings}
%
%    \begin{macrocode}
  \msg_new:nnn {xfss} {missing-font-shape}
    {Font shape `#1' undefined; using `#2' instead #3}
  \msg_new:nnn {xfss} {size-subst}
    {Size substitutions with differences of up to #1 have occurred.}
  \msg_new:nnn {xfss} {font-shape-unavail}
    {Font shape `#1' in size <#2> not available, size <#3> substituted.}
  \msg_new:nnn {xfss} {some-font-shapes-unavail}
    {Some font shapes were not available, defaults substituted.}
  \msg_new:nnn {xfss} {deprecated-function}
    {%
      The command #1 is deprecated and will be ignored. Any commands
      that are supposed to be defined here will not exist!%
    }
%    \end{macrocode}
%
% \subsubsection{Errors}
%
%    \begin{macrocode}
  \msg_new:nnn {xfss} {cmd-defined} {Command `#1' already defined}
%    \end{macrocode}
%
% \subsubsection{Wrappers for messages}
%
%    \begin{macrocode}
  \msg_new:nnn {xfss} {only-math-cmd} {#1 allowed only in math mode}
  \msg_new:nnn {xfss} {not-math-cmd} {Command #1 invalid in math mode}
  \msg_new:nnnn {xfss} {invalid-in-math}
    {Command \token_to_str:N #1 \ invalid in math mode}
    {%
       \str_if_eq:xxTF {\exp_not:N #1} { \relax }
         {%
           Please define a new math alphabet
           if you want to use a special font in math mode%
         }
         {%
            Please use the math alphabet \token_to_str:N #2 \
            instead of the #1 command%
         }%
       .%
    }
%    \end{macrocode}
%
%    \begin{macrocode}
  \msg_new:nnnn {xfss} {no-math-alph}
    {%
      Math alphabet identifier #1 is undefined in math
      version `\l_xfss_math_version_tl'.%
    }
    {%
      Your requested math alphabet is undefined in the current
      math version. Check the spelling or use the
      \token_to_str:N \SetMathAlphabet \ command.%
    }
  \msg_new:nnnn {xfss} {no-math-alph-cmd}
    {Command `#1' not defined as a math alphabet.}
    {Use \token_to_str:N \DeclareMathAlphabet \ to define it.}
%    \end{macrocode}
%
%    \begin{macrocode}
  \msg_new:nnn {xfss} {unavail-in-enc}
    {Command #1 unavailable in encoding \l_xfss_encoding_current_tl.}
  \msg_new:nnn {xfss} {font-family-unknown} {Font family `#1' unknown.}
  \msg_new:nnn {xfss} {font-enc-unknown} {Encoding scheme `#1' unknown.}
  \msg_new:nnn {xfss} {sym-font-unknown} {Symbol font `#1' not defined.}
  \msg_new:nnnn {xfss} {math-version-unknown}
    {Math version `#1' is not defined.}
    {%
      You probably mispelled the name of the math version.
      Or you have to specify an additional package.%
    }
  \msg_new:nnn {xfss} {font-not-found} {Font `#1' not found.}
  \msg_new:nnn {xfss} {too-many-alphabets}
    {Too many math alphabets used in version #1.}
  \msg_new:nnn {xfss} {not-cmd} {Not a command name: `#1'}
%    \end{macrocode}
%
%    \begin{macrocode}
  \msg_new:nnnn {xfss} {xfss-broken} {This XFSS system isn't set up properly.}
    {For encoding scheme #1 the defaults #2 do not form a valid font shape.}
  \msg_new:nnnn {xfss} {no-error-font} {This XFSS system isn't set up properly.}
    {%
      The system maintainer forgot to specify a suitable substitution
      font shape using the \token_to_str:N \DeclareErrorFont \ command.%
    }
%    \end{macrocode}
%
% \subsubsection{Font definition parsing messages}
%
%    \begin{macrocode}
  \msg_new:nnn {xfss} {font-shape-scale}
    {%
      Font shape `\l_xfss_current_font_tl' will be
      scaled to size \dim_use:N \l_xfss_tmpb_dim.%
    }
  \msg_new:nnn {xfss} {font-shape-size-missing}
    {%
      Font shape `\l_xfss_current_font_tl' in size
      <\l_xfss_fsize_tl> not available.
      Font shape `\l_xfss_mandatory_arg_tl' tried instead.%
    }
  \msg_new:nnn {xfss} {font-shape-size-instead}
    {%
      Font shape `\l_xfss_current_font_tl' in size
      <\l_xfss_fsize_tl> not available.
      External font `\l_xfss_mandatory_arg_tl' used.%
    }
  \msg_new:nnn {xfss} {ext-font-loaded}
    {%
      External font `\l_xfss_external_font_tl' loaded for size
      <\l_xfss_fsize_tl>%
    }
%    \end{macrocode}
% Finally restore the normal catcode for the space character.
%    \begin{macrocode}
\group_end:
%    \end{macrocode}
%
% Three functions which only issue messages when in math mode.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_check_not_math:N #1
  {
    \mode_if_math:T
      { \msg_warning:nnx {xfss} {not-math-cmd} { \token_to_str:N #1 } }
  }
\cs_new_protected:Npn \xfss_check_not_math_alphabet:NN #1 #2
  {
    \mode_if_math:T
      { \msg_error:nnxx {xfss} {invalid-in-math} #1 #2 }
  }
\cs_new_protected:Npn \xfss_no_alphabet_error:N #1
  {
    \mode_if_math:T
      { \msg_error:nnx {xfss} {no-math-alph} { \token_to_str:N #1 } }
  }
%    \end{macrocode}
%
%
%
% \subsection{Preliminaries}
%
% \begin{macro}{\g_hook_kernel_math_tl,\g_hook_kernel_display_tl}
%   Dirty kludge to remove the \cs{frozen@every} functions.
%   This should eventually move to the setup of \pkg{l3hooks}.
%    \begin{macrocode}
\tl_gput_left:Nn \g_hook_kernel_math_tl    { \xfss_check_math_fonts: }
\tl_gput_left:Nn \g_hook_kernel_display_tl { \xfss_check_math_fonts: }
\seq_remove_all:Nn \g_hook_display_seq
  { \hook_item:n {\tex_the:D \frozen@everymath } }
\seq_remove_all:Nn \g_hook_display_seq
  { \hook_item:n {\tex_the:D \frozen@everydisplay } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_hook_math_size_seq,\g_hook_kernel_math_size_tl}
%   Wrapper for the \LaTeXe{} \cs{every@math@size}.
%    \begin{macrocode}
\hook_new:n { math_size }
%<package>\hook_pre_push:nn { math_size } { \tex_the:D \every@math@size }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\baselinestretch}
%    \begin{macrocode}
\tl_set:Nn \baselinestretch {1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\defaultscriptratio,\defaultscriptscriptratio}
%    \begin{macrocode}
\tl_set:Nn \defaultscriptratio {.7}
\tl_set:Nn \defaultscriptscriptratio {.5}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Variables, booleans, etc.}
%
%    \begin{macrocode}
\bool_new:N \l_xfss_math_fonts_bool
\bool_set_true:N \l_xfss_math_fonts_bool
%    \end{macrocode}
%
%    \begin{macrocode}
\bool_new:N \l_xfss_maybe_ic_bool
%    \end{macrocode}
%
%    \begin{macrocode}
\bool_new:N \l_xfss_tmp_bool
\skip_new:N \l_xfss_tmp_skip
\dim_new:N \l_xfss_tmpa_dim
\dim_new:N \l_xfss_tmpb_dim
\dim_new:N \l_xfss_tmpc_dim
\tl_new:N \l_xfss_tmpa_tl
\tl_new:N \l_xfss_tmpb_tl
\tl_new:N \l_xfss_tmpc_tl
\tl_new:N \l_xfss_tmpd_tl
%    \end{macrocode}
%
%
%    \begin{macrocode}
\tl_clear:N \g_xfss_curr_math_size_tl
%    \end{macrocode}
%
% Used to calculate font sizes and baselineskips automatically:
%    \begin{macrocode}
\fp_new:N \l_xfss_fsize_fp
\fp_new:N \l_xfss_bskip_fp
\fp_new:N \l_xfss_pow_fp
%    \end{macrocode}
%
% Used when parsing ranges for font substitution.
%    \begin{macrocode}
\dim_new:N \l_xfss_lower_bound_dim
\dim_new:N \l_xfss_upper_bound_dim
%    \end{macrocode}
%
% \begin{variable}{\g_xfss_math_alphabet_prop}
%   Maps math alphabets such as \cs{mathit } (with trailing space)
%   to a setup command, and a font name.\footnote{Bruno: clarify.}
%    \begin{macrocode}
\prop_new:N \g_xfss_math_alphabet_prop
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xfss_math_sym_font_prop}
%   Maps a sym font name (in the form \enquote{\texttt{operators}}
%   rather than \LaTeXe{}'s \cs{symoperators}) to a corresponding
%   font name.
%    \begin{macrocode}
\prop_new:N \g_xfss_math_sym_font_prop
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_xfss_cdp_prop}
%   Maps an encoding to the default family, series and shape.
%    \begin{macrocode}
\prop_new:N \g_xfss_cdp_prop
%    \end{macrocode}
% \end{variable}
%
%
% \begin{macro}{\c_backslash_tl}
% A backslash `string'.
%    \begin{macrocode}
\tl_const:Nx \c_backslash_tl { \cs_to_str:N \\ }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{variable}{\g_xfss_font_csname_tl}
%    \begin{macrocode}
\tl_new:N \g_xfss_font_csname_tl
\tl_clear:N \LastDeclaredEncoding
\bool_new:N \l_xfss_update_sizes_bool
\tl_new:N \l_xfss_family_tl
\tl_new:N \l_xfss_series_tl
\tl_new:N \l_xfss_shape_tl
\tl_new:N \l_xfss_fsize_tl
\tl_new:N \l_xfss_baselineskip_tl
\tl_new:N \l_xfss_linespread_tl
\tl_new:N \g_xfss_setup_currsize_tl
\tl_new:N \g_xfss_last_font_shape_tl
%    \end{macrocode}
% \end{variable}
%
% \subsection{Tools}
%
% \begin{macro}{\xfss_switch_catcodes:}
% Turn on the catcode regime.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xfss_switch_catcodes:
  {
     \makeatletter
     \char_set_catcode_ignore:n {32} % space
     \char_set_catcode_ignore:N \^^I
     \char_set_catcode_ignore:N \^^M
     \char_set_catcode_escape:N \\
     \char_set_catcode_group_begin:N \{
     \char_set_catcode_group_end:N \}
     \char_set_catcode_parameter:N \#
     \char_set_catcode_math_superscript:N \^
     \char_set_catcode_comment:N \%
     \char_set_catcode_other:N \<
     \char_set_catcode_other:N \>
     \char_set_catcode_other:N \*
     \char_set_catcode_other:N \.
     \char_set_catcode_other:N \-
     \char_set_catcode_other:N \/
     \char_set_catcode_other:N \[
     \char_set_catcode_other:N \]
     \char_set_catcode_other:N \`
     \char_set_catcode_other:N \'
     \char_set_catcode_other:N \"
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\xfss_use_to_slash_nil:ww}
%   Returns the first piece of
%   \meta{stuff}\texttt{/}\meta{stuff}\texttt{/}\ldots\cs{q_nil}
%    \begin{macrocode}
\cs_new:Npn \xfss_use_to_slash_nil:ww #1 / #2 \q_nil {#1}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_extract_encoding_from_font:NN #1 #2
  {
    \tl_set:Nx #1
      {
        \exp_last_unbraced:Nf \xfss_use_to_slash_nil:ww
          { \cs_to_str:N #2 } \q_nil
      }
  }
%    \end{macrocode}
%
% \begin{macro}{\use_iv_to_str:nnnN}
%    \begin{macrocode}
\cs_new:Npn \use_iv_to_str:nnnN #1#2#3#4 { \cs_to_str:N #4 }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Encodings}
%
% These contain any default setup commands for when selecting the
% default text/math encodings. The token lists hold the encoding wanted by
% the user, the current encoding, and a saved encoding for use
% in accents.
%    \begin{macrocode}
\tl_new:N \g_xfss_encoding_setup_text_default_tl
\tl_new:N \g_xfss_encoding_setup_math_default_tl
\tl_new:N \l_xfss_encoding_tl
\tl_new:N \l_xfss_encoding_current_tl
\tl_new:N \l_xfss_encoding_saved_tl
%    \end{macrocode}
%
% \begin{macro}{\xfss_encoding_check_exists:nT}
% \begin{macro}{\xfss_encoding_if_exists:nTF}
%   The \enquote{\texttt{check}} command raises an error
%   if the encoding does not exist.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_encoding_check_exists:nT #1 #2
  {
    \cs_if_exist:cTF {g_xfss_encoding_setup_text_ #1 _tl}
      { #2 }
      { \msg_error:nnx {xfss} {font-enc-unknown} {#1} }
  }
\prg_new_conditional:Npnn \xfss_encoding_if_exists:n #1 {TF}
  {
    \cs_if_exist:cTF {g_xfss_encoding_setup_text_ #1 _tl}
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_set_encoding:x}
%   Sets the encoding to |#1|, checking that it exists.
%   However, no font change is made: we only set here what
%   we \emph{want} the encoding to become at the next font
%   change.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_set_encoding:x #1
  {
    \xfss_encoding_check_exists:nT {#1}
      { \tl_set:Nx \l_xfss_encoding_tl {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_use_text_encoding:x}
%   Change to the encoding |#1|, selecting the relevant font.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_use_text_encoding:x #1
  {
     \xfss_set_encoding:x {#1}
     \xfss_font_provide:c { \l_xfss_current_font_tl / \l_xfss_fsize_tl }
     \use:c { \g_xfss_font_csname_tl }
     \xfss_update_encoding:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_update_encoding:}
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \xfss_update_encoding:
  {
    \cs_set_eq:cN { xfss_ \l_xfss_encoding_tl _cmd:NN } \xfss_current_cmd:NN
    \cs_set_eq:cN { xfss_ \l_xfss_encoding_current_tl _cmd:NN }
      \xfss_changed_cmd:NN
%<*package>
    \cs_set_eq:cN {\l_xfss_encoding_tl -cmd}         \xfss_current_cmd:NN
    \cs_set_eq:cN {\l_xfss_encoding_current_tl -cmd} \xfss_changed_cmd:NN
%</package>
    \g_xfss_encoding_setup_text_default_tl
    \use:c {g_xfss_encoding_setup_text_ \l_xfss_encoding_tl _tl}
    \use:c {g_xfss_encoding_setup_defaults_ \l_xfss_encoding_tl _tl}
    \tl_set_eq:NN \l_xfss_encoding_current_tl \l_xfss_encoding_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareFontFamily}
%   Not sure what it does.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareFontFamily {mmm}
  {
    \xfss_encoding_check_exists:nT {#1}
      { \tl_gset:cn {#1+#2} {#3} }
  }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\DeclareFontEncoding}
%   
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareFontEncoding {}
  {
    \group_begin:
    \xfss_switch_catcodes:
    \exp_after:wN \group_end:
    \xfss_declare_font_encoding:nnn
  }
\cs_new_protected:Npn \xfss_declare_font_encoding:nnn #1#2#3
  {
    \xfss_new_font_encoding:n {#1}
    \tl_gset:cn {g_xfss_encoding_setup_text_ #1 _tl} {#2}
    \tl_gset:cn {g_xfss_encoding_setup_math_ #1 _tl}
      { \g_xfss_encoding_setup_math_default_tl #3 }
    \tl_gset:Nx \LastDeclaredEncoding {#1}
  }
\cs_new_protected:Npn \xfss_new_font_encoding:n #1
  {
    \xfss_encoding_if_exists:nTF {#1}
      { \msg_info:nnxx {xfss} {redeclaring} {font~encoding} {#1} }
      {
        \prop_gput:Nxx \g_xfss_cdp_prop {#1}
          {
            \g_xfss_default_family_tl /
            \g_xfss_default_series_tl /
            \g_xfss_default_shape_tl
          }
        \cs_set_eq:cN {xfss_#1_cmd:NN} \xfss_changed_cmd:NN
%<package>        \cs_set_eq:cN {#1-cmd} \xfss_changed_cmd:NN
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareFontSubstitution}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareFontSubstitution {mmmm}
  {
    \xfss_encoding_check_exists:nT {#1}
      {
        \prop_gput:Nxn \g_xfss_cdp_prop {#1} { #2 / #3 / #4 }
        \tl_gset:cn {g_xfss_encoding_setup_defaults_ #1 _tl}
          {
            \tl_set:Nn \g_xfss_default_family_tl {#2}
            \tl_set:Nn \g_xfss_default_series_tl {#3}
            \tl_set:Nn \g_xfss_default_shape_tl  {#4}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareFontEncodingDefaults}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareFontEncodingDefaults {mm}
  {
    \str_if_eq:nnF {\relax} {#1}
      {
        \tl_if_empty:NF \g_xfss_encoding_setup_text_default_tl
          { \msg_info:nnx {xfss} {overwrite-enc-defaults} {text} }
        \tl_gset:Nn \g_xfss_encoding_setup_text_default_tl {#1}
      }
    \str_if_eq:nnF {\relax} {#2}
      {
        \tl_if_empty:NF \g_xfss_encoding_setup_math_default_tl
          { \msg_info:nnx {xfss} {overwrite-enc-defaults} {math} }
        \tl_gset:Nn \g_xfss_encoding_setup_math_default_tl {#2}
      }
  }


\DeclareDocumentCommand \DeclarePreloadSizes {mm mmm}
  {
    \xfss_encoding_check_exists:nT {#1}
      {
        \group_begin:
          \clist_map_inline:nn {#5}
            {
              \xfss_font_provide:c {#1/#2/#3/#4/##1}
              \cs_gnull:c { \g_xfss_font_csname_tl }
            }
        \group_end:
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Declaring stuff (?)}
%
%%% From File: ltoutenc.dtx
%
% \begin{macro}[aux]{\xfss_declare_text_command:NNn}
%   A given glyph can be found at different slots depending on the
%   encoding of the font. Hence, text commands must check the encoding
%   and use the definition relevant for the current encoding.
%   The \cs{xfss_declare_text_command:NNn} function defines the text
%   command |#2| in the encoding |#3| using the declaration command
%   |#1|, either \cs{DeclareRobustCommand}, xparse's
%   \cs{DeclareDocumentCommand}, or the \cs{tex_chardef:D}, \emph{etc.}
%   The \cs{xfss_\meta{enc.}_cmd:NN} function at the start of the definition
%   of |#2| is responsible for either using \cs{\meta{enc.}\#2} if
%   the current encoding coincides with \meta{enc.}, or finding the
%   correct encoding-specific command to use in the current encoding.
%   It is always either \cs{xfss_current_cmd:NN} or
%   \cs{xfss_changed_cmd:NN}.\footnote{Bruno: add check that encoding exists?}
%    \begin{macrocode}
\cs_new:Npn \xfss_declare_text_command:NNn #1#2#3
  {
    \cs_set_protected:Npx #2
      {
        \exp_not:c {xfss_#3_cmd:NN}
        \exp_not:N #2
        \exp_not:c {#3\token_to_str:N#2}
      }
    \exp_args:Nc #1 {#3\token_to_str:N#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_current_cmd:NN,\xfss_changed_cmd:NN}
% \begin{macro}{\xfss_text_symbol_unavailable:N}
%   These two functions take a text command, and an encoding-specific
%   version of it as their arguments. The \cs{xfss_current_cmd:NN}
%   function is used when the current encoding coincides with
%   the encoding of the text command. Hence, it can simply leave
%   its second argument to be typeset. The \cs{xfss_changed_cmd:NN}
%   function is used when the encodings differ. Then, the version
%   of the text command specific to the current encoding is built
%   and used. If it does not exist, then there is an attempt to
%   use the default \texttt{?} command. If all else fails, the
%   symbol is simply not available in the current encoding,
%   and we must resign with an error.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_current_cmd:NN #1#2
  {
    \xfss_check_not_math:N #1
    #2
  }
\cs_new_protected:Npn \xfss_changed_cmd:NN #1#2
  {
    \xfss_check_not_math:N #1
    \xfss_use:cF { \l_xfss_encoding_current_tl \token_to_str:N #1 }
      {
        \xfss_use:cF { ? \token_to_str:N #1 }
          { \xfss_text_symbol_unavailable:N #1 }
      }
  }
\cs_new_protected:Npn \xfss_text_symbol_unavailable:N #1
  { \msg_error:nnx {xfss} {unavail-in-enc} { \token_to_str:N #1 } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xfss_?_cmd}
%   Always other than the current encoding. Used for instance
%   by \cs{UndeclareTextCommand}.
%    \begin{macrocode}
\cs_new_eq:cN {xfss_?_cmd} \xfss_changed_cmd:NN
%<package>\cs_set_eq:cN {?-cmd} \xfss_changed_cmd:NN
%    \end{macrocode}
% \end{macro}
%
%
% fixme: accent wrapper
%
% \begin{macro}{\DeclareTextCompositeCommand}
%   We should use a prop to store the list of exceptions with their def.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextCompositeCommand {mmmm}
  {
    \cs_set_eq:Nc \xfss_tmp:w { #2 \token_to_str:N #1 }
    \exp_args:No \tl_if_head_eq_meaning:nNF
      { \xfss_tmp:w \scan_stop: \scan_stop: }
      \xfss_text_composite:w
      {
        \use:x
          {
            \cs_set:cpn { #2 \token_to_str:N #1 } \exp_not:n {##1}
              {
                \exp_not:N \xfss_text_composite:w
                \exp_not:c { #2 \token_to_str:N #1 }
                \exp_not:n { ##1 \c_empty_tl \q_nil }
                { \exp_not:o { \xfss_tmp:w {##1} } }
              }
          }
      }
    \tl_set:cn { \token_to_str:c {#2} \tl_to_str:n {#1-#3} } {#4}
  }
\cs_new:Npn \xfss_text_composite:w #1#2#3 \q_nil
  { \xfss_use:cF { \token_to_str:N #1 - \token_to_str:N #2 } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareTextComposite}
%    \begin{macrocode}
\tl_set:Nx \l_xfss_tmpa_tl
  { \tex_catcode:D \c_zero=\tex_the:D\tex_catcode:D \c_zero\scan_stop: }
\char_set_catcode_letter:n {\c_zero} % which is "^^@" below
\DeclareDocumentCommand \DeclareTextComposite {mmmm}
  {
    \tl_set:Nn \l_xfss_tmpa_tl
      { \DeclareTextCompositeCommand #1 {#2} {#3} }
    \group_begin:
      \tex_lccode:D \c_zero #4
      \tex_lowercase:D  {
    \group_end:
    \l_xfss_tmpa_tl ^^@ }
  }
\l_xfss_tmpa_tl
%    \end{macrocode}
%
%
% \begin{macro}{\DeclareTextSymbolDefault,\DeclareTextAccentDefault,
%               \UndeclareTextCommand}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextSymbolDefault {mm}
  { \DeclareTextCommandDefault #1 { \UseTextSymbol {#2} #1 } }
\DeclareDocumentCommand \DeclareTextAccentDefault {mm}
  { \DeclareTextCommandDefault #1 { \UseTextAccent {#2} #1 } }
\DeclareDocumentCommand \UndeclareTextCommand {mm}
  {
    \cs_if_exist:cT { #2 \token_to_str:N #1 }
      {
        \cs_undefine:c { #2 \token_to_str:N #1 }
        \exp_after:wN \exp_after:wN \exp_after:wN
        \cs_if_free:NT \exp_after:wN \use_iii:nnn #1
          {
            \tl_gset:Nx #1
              {
                \exp_not:c {xfss_?_cmd:NN}
                \exp_not:N #1
                \exp_not:c { ? \token_to_str:N #1 }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Using characters, accents, symbols, encodings}
%
% \begin{macro}{\xfss_add_accent:nn}
%   We figure out what the correct spacefactor should be by typesetting
%   the accentee in a box and saving the relevant spacefactor,
%   then restoring it after the box has ended.\footnote{Bruno:
%     do we care about supporting multiple accents on one char? How?
%     Do we care about kerning before/after the accented character?}
%    \begin{macrocode}
\cs_new:Npn \xfss_add_accent:nn #1#2
  {
    \mode_leave_vertical:
    {
      \cs_set_eq:NN \xfss_outer_group_hmode:n \use:n
      \hbox_set:Nn \l_tmpa_box { #2 \xfss_spacefactor_save: }
      \tex_accent:D #1 #2
    }
    \xfss_spacefactor_restore:
  }
%    \end{macrocode}
% \end{macro}
%
% Bruno: we need to take into account Javier Bezos accents package.
% See pr/3160 for a discussion of the current implementation. I don't
% understand why \cs{xfss_outer_group_hmode:n} should be \cs{use:n}
% rather than \cs{prg_do_nothing:} within another accent.
%    \begin{macrocode}
\DeclareDocumentCommand \UseTextAccent {mmm}
  {
    \xfss_outer_group_hmode:n
      {
        \cs_set_eq:NN \xfss_outer_group_hmode:n \use:n
        \tl_set_eq:NN \l_xfss_encoding_saved_tl \l_xfss_encoding_current_tl
        \xfss_use_text_encoding:x {#1}
        #2 { \xfss_use_text_encoding:x { \l_xfss_encoding_saved_tl } #3 }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareDocumentCommand \UseTextSymbol {mm}
  {
    \xfss_outer_group_hmode:n
      {
        \tl_set:Nn \l_xfss_wrong_font_char_msg_tl
          { \MessageBreak for \exp_not:N\symbol`\token_to_str:N#2' }
        \xfss_use_text_encoding:x {#1}
        #2
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_outer_group_hmode:n #1
  { \mode_leave_vertical: {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_orig_accent:N}
%   This lets the user/programmer access the original accent
%   corresponding to its argument, even if that control sequence
%   was redefined.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_orig_accent:N #1
  { \exp_args:Nc \xfss_changed_cmd:NN { \token_to_str:N #1 } \scan_stop: }
\cs_set_eq:NN \a \xfss_orig_accent:N
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{User commands}
%
% \begin{macro}{\symbol}
%   Typeset the symbol corresponding to the slot \meta{integer}
%   of the current font.
%    \begin{macrocode}
\DeclareDocumentCommand \symbol {m}
  { \tex_char:D \int_eval:w #1 \int_eval_end: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareTextSymbol}
%   The simplest declaration for a text command that should simply
%   typeset a given character of the current font. Of course,
%   the number |#3| is only correct in the declared encoding, |#2|.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextSymbol {mmm}
  { \xfss_declare_text_command:NNn \tex_chardef:D #1 {#2} #3 \scan_stop: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareTextCommand,\ProvideTextCommand}
% \begin{macro}[aux]{\xfss_args_old_or_new_style:TFnnnn}
%   These two commands accept either \cs{newcommand}-style optional
%   arguments, or an \pkg{xparse}-style argument specification.
%   The only difference between \cs{DeclareTextCommand} and
%   \cs{ProvideTextCommand} is what function they use in the \pkg{xparse}
%   case.
%   The \cs{xfss_old_or_new_style:TFnnnn} function analyses its last
%   four arguments to decide whether they are in the old
%   (\cs{newcommand}) style, or the new xparse style.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextCommand {mmoomg}
  {
    \xfss_args_old_or_new_style:TFnnnn
      { \xfss_declare_text_command:NNn \DeclareRobustCommand   #1 {#2} }
      { \xfss_declare_text_command:NNn \DeclareDocumentCommand #1 {#2} }
      {#3} {#4} {#5} {#6}
  }
\DeclareDocumentCommand \ProvideTextCommand {mmoomg}
  {
    \xfss_args_old_or_new_style:TFnnnn
      { \xfss_declare_text_command:NNn \DeclareRobustCommand   #1 {#2} }
      { \xfss_declare_text_command:NNn \ProvideDocumentCommand #1 {#2} }
      {#3} {#4} {#5} {#6}
  }
\cs_new_protected:Npn \xfss_args_old_or_new_style:TFnnnn #1#2#3#4#5#6
  {
    \IfValueTF {#3}
      {% old-style argument
        \IfValueTF {#4}
          { #1 [{#3}] [{#4}] {#5} } % with default arg
          { #1 [{#3}]        {#5} } % no default arg
        \IfValueTF {#6} { \ERROR {#6} } % don't mix xparse with old-style!
      }
      {
        \IfValueTF {#6}
          { #2 {#5} {#6} } % xparse argument
          { #2 {  } {#5} } % no argument
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\DeclareTextCommandDefault,\ProvideTextCommandDefault}
%   Setup the default behaviour of the text command in an unknown encoding.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextCommandDefault {m}
  { \DeclareTextCommand #1 {?} }
\DeclareDocumentCommand \ProvideTextCommandDefault {m}
  { \ProvideTextCommand #1 {?} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\TextSymbolUnavailable}
%    \begin{macrocode}
%<*deprecated>
\DeclareDocumentCommand \TextSymbolUnavailable {m}
  { \xfss_text_symbol_unavailable:N #1 }
%</deprecated>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareTextAccent}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextAccent {mmm}
  {
    \xfss_declare_text_command:NNn
      \DeclareDocumentCommand #1 {#2} {m} { \xfss_add_accent:nn {#3} {##1} }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Maths font setup}
% From File: ltfssbas.dtx
%
%
% \begin{macro}{\math_operator_font:}
% This command is used to switch to the font for typesetting operators
% such as \cs{lim}.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \math_operator_font:
  { \mathgroup_use:N \symoperators }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\DeclareFontShape}
% \begin{macro}[aux]{\xfss_declare_font_shape:nnnnnn}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareFontShape {}
  {
    \group_begin:
      \xfss_switch_catcodes:
      \exp_after:wN
    \group_end:
    \xfss_declare_font_shape:nnnnnn
  }
\cs_new_protected:Npn \xfss_declare_font_shape:nnnnnn #1#2#3#4#5#6
  {
    \cs_if_exist:cTF {#1+#2}
      {
        \cs_gset:cpx {#1/#2/#3/#4} {\exp_not:c {#5}}
        \cs_gset:cpn {#5} {#6}
      }
      { \msg_error:nnx {xfss} {font-family-unknown} {#1+#2} }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\DeclareFixedFont}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareFixedFont { mmm mmm }
  {
    \group_begin:
      \bool_set_false:N \l_xfss_math_fonts_bool
      \tl_clear:N \g_hook_kernel_math_size_tl
      \xfss_set_fontsize:nnn {\baselinestretch} {#6} {\c_zero_dim}
      \xfss_set_encoding:x {#2}
      \xfss_set_family:x   {#3}
      \xfss_set_series:x   {#4}
      \xfss_set_shape:x    {#5}
      \selectfont
      \fontface_gset_to_current:N #1
    \group_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xfss_activate_subst_correction:}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xfss_activate_subst_correction:
  {
    \cs_gset:Npx \xfss_subst_correction:
      {
        \use:c { \g_xfss_font_csname_tl }
        \fontface_gset:cn { \l_xfss_current_font_tl/\l_xfss_fsize_tl }
          { \exp_not:N \fontface_current_info: }
      }
    \group_insert_after:N \xfss_subst_correction:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareMathSizes}
% The starred form seems undocumented? (Haven't checked TLC.)
% \begin{arguments}
% \item \meta{star?}
% \item text size \item math text size \item math script size
% \item math scriptscript size
% \end{arguments}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareMathSizes {s mm mm}
  {
    \tl_if_blank:nTF {#3}
      {
        \cs_set_eq:cN {xfss_set_font_size_ \xfss_dim_strip_pt:n {#2} :}
        \bool_set_false:N \l_xfss_math_fonts_bool
      }
      {
        \cs_gset:cpx {xfss_set_font_size_ \xfss_dim_strip_pt:n {#2} :}
          {
            \tl_gset:Nn \exp_not:N \g_xfss_tf_size_tl  {#3}
            \tl_gset:Nn \exp_not:N \g_xfss_sf_size_tl  {#4}
            \tl_gset:Nn \exp_not:N \g_xfss_ssf_size_tl {#5}
            \IfBooleanT #1
              { \bool_set_false:N \l_xfss_math_fonts_bool }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\xfss_set_family:x,\xfss_set_series:x,\xfss_set_shape:x}
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_set_family:x #1
  { \tl_set:Nx \l_xfss_family_tl {#1} }
\cs_new_protected:Npn \xfss_set_series:x #1
  { \tl_set:Nx \l_xfss_series_tl {#1} }
\cs_new_protected:Npn \xfss_set_shape:x #1
  { \tl_set:Nx \l_xfss_shape_tl  {#1} }
%    \end{macrocode}
% \end{macro}
%
%
%    \begin{macrocode}
\DeclareDocumentCommand \fontencoding {m} { \xfss_set_encoding:x {#1} }
\DeclareDocumentCommand \fontfamily   {m} { \xfss_set_family:x   {#1} }
\DeclareDocumentCommand \fontseries   {m} { \xfss_set_series:x   {#1} }
\DeclareDocumentCommand \fontshape    {m} { \xfss_set_shape:x    {#1} }
\DeclareDocumentCommand \usefont {mmmm}
  {
    \xfss_set_encoding:x {#1}
    \xfss_set_family:x   {#2}
    \xfss_set_series:x   {#3}
    \xfss_set_shape:x    {#4}
    \selectfont
    \tex_ignorespaces:D
  }
\DeclareDocumentCommand \linespread {m}
  { \xfss_set_fontsize:nnn {#1} \l_xfss_fsize_tl \l_xfss_baselineskip_tl }
\DeclareDocumentCommand \fontsize {mm}
  { \xfss_set_fontsize:nnn \baselinestretch {#1} {#2} }
\DeclareDocumentCommand \mathversion {m}
  {
    \xfss_check_not_math:N \mathversion
    \xfss_math_version_check_exists:nT {#1}
      {
        \tl_set:Nx \l_xfss_math_version_tl {#1}
        \tl_gclear:N \g_xfss_setup_currsize_tl
        \group_insert_after:N \g_xfss_global_settings_tl
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_font_provide:c #1
  {
    \tl_gset:Nx \g_xfss_font_csname_tl {#1}
    \cs_if_exist:cF { \g_xfss_font_csname_tl }
      {
        \group_begin:
          \int_set:Nn \tex_escapechar:D {\c_minus_one}
          \exp_after:wN \xfss_split_name:w \g_xfss_font_csname_tl \q_nil
          \xfss_try_load_fontshape: % try always
          \cs_if_exist:cTF { \l_xfss_current_font_tl }
            { \xfss_extract_font: }
            { \xfss_wrong_font_shape: }
        \group_end:
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_other:N \/
  \cs_new:Npn \xfss_split_name:w #1/#2/#3/#4/#5 \q_nil
    {
      \xfss_set_encoding:x {#1}
      \xfss_set_family:x   {#2}
      \xfss_set_series:x   {#3}
      \xfss_set_shape:x    {#4}
      \tl_set:Nx \l_xfss_fsize_tl    {#5} %?
    }
\group_end:
%    \end{macrocode}
%
%
%    \begin{macrocode}
\tl_gset:Nn \l_xfss_current_font_tl
  {
    \l_xfss_encoding_tl / \l_xfss_family_tl /
    \l_xfss_series_tl   / \l_xfss_shape_tl
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xfss_try_load_fontshape:
  {
    \cs_if_exist:cF {\l_xfss_encoding_tl+\l_xfss_family_tl}
      {
        \msg_info:nnx {xfss} {try-load}
          { \l_xfss_encoding_tl + \l_xfss_family_tl}
        \tl_gclear:c { \l_xfss_encoding_tl + \l_xfss_family_tl}
        \xfss_switch_catcodes:
        \cs_null:N \xfss_switch_catcodes: % fixme: better as "clear"?
        \use:x
          {
            \tex_lowercase:D
              { \file_input:n { \l_xfss_encoding_tl \l_xfss_family_tl .fd } }
          }
      }
  }
%    \end{macrocode}
%
% fixme: why use "split_name"??
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareErrorFont {mm mmm}
  {
    \cs_gset:Npx \xfss_error_font_shape:
      { \exp_not:N \xfss_split_name:w #1/#2/#3/#4/#5 \exp_not:N \q_nil }
    \tl_gset:Nn \g_xfss_default_family_tl {#2}
    \tl_gset:Nn \g_xfss_default_series_tl {#3}
    \tl_gset:Nn \g_xfss_default_shape_tl  {#4}
    \tl_set_eq:NN \l_xfss_family_tl \g_xfss_default_family_tl
    \tl_set_eq:NN \l_xfss_series_tl \g_xfss_default_series_tl
    \tl_set_eq:NN \l_xfss_shape_tl  \g_xfss_default_shape_tl
    \tl_set:Nn \l_xfss_fsize_tl {#5}
    \tl_set:Nn \l_xfss_baselineskip_tl {#5pt}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xfss_wrong_font_shape:
  { %we already know that the curr_font_shape doesn't exist!
    % install defaults if in math:
    \use:c {g_xfss_encoding_setup_defaults_ \l_xfss_encoding_tl _tl}
    \tl_set:Nx \l_xfss_tmpa_tl { \l_xfss_current_font_tl }
    \tl_if_eq:NNTF \g_xfss_last_font_shape_tl \l_xfss_tmpa_tl
      {
         \errmessage{Corrupted NFSS tables}
         \xfss_error_font_shape:
      }
      {
        \tl_set_eq:NN \l_xfss_shape_tl \g_xfss_default_shape_tl
        \cs_if_exist:cF {\l_xfss_current_font_tl}
          {
            \tl_set_eq:NN \l_xfss_series_tl \g_xfss_default_series_tl
            \cs_if_exist:cF {\l_xfss_current_font_tl}
              { \tl_set_eq:NN \l_xfss_family_tl \g_xfss_default_family_tl }
          }
      }
    \msg_warning:nnxxx {xfss} {missing-font-shape} { \l_xfss_tmpa_tl }
      { \l_xfss_current_font_tl } { \l_xfss_wrong_font_char_msg_tl }
    \tl_gset_eq:NN \g_xfss_last_font_shape_tl \l_xfss_tmpa_tl
    \cs_gset:Npn \xfss_subst_warning:
      { \msg_warning:nn {xfss} {some-font-shapes-unavail} }
    \tl_gset_eq:cc { \l_xfss_tmpa_tl } { \l_xfss_current_font_tl }
    \xfss_font_provide:c { \l_xfss_current_font_tl/\l_xfss_fsize_tl }
  }
%    \end{macrocode}
%
%
% \cs{xfss_extract_alphabet_from_version:nnN}
% \cs{g_xfss_math_version_}\meta{math version}\texttt{_tl}
% \Arg{arg2} \meta{math alphabet} pops the declaration of the math alphabet
% from the math version, and replaces it by a definition using
% \cs{xfss_use_math_group:nn}, but with the same font.
%    \begin{macrocode}
\tl_clear:N \l_xfss_wrong_font_char_msg_tl
\cs_null:N \xfss_subst_warning:
\cs_new_eq:NN \xfss_install_math_alphabet:Nn \cs_gset_protected_nopar:Npn
\cs_clear:N \xfss_assign_math_fonts:
\cs_new_protected:Npn \xfss_extract_alphabet_from_version:nnN #1#2#3
  {
    \cs_set:Npn \cs_tmp:w ##1 \xfss_install_math_alphabet:Nn #3##2##3 \q_nil
      {
        \tl_set:Nn \l_xfss_tmpb_tl {##2}
        \cs_set:Npn \xfss_tmpc:w ####1 { \tl_gset:Nn #1 { ##1 ####1 ##3 } }
      }
    \exp_after:wN \cs_tmp:w #1 \q_nil
    \cs_set:Npn \cs_tmp:w \xfss_select_math_group:Nnnn #3 ##1 ##2 \q_nil
      {
        \xfss_tmpc:w
          {
            \xfss_get_and_define_fonts:nn {#2} ##2
            \xfss_install_math_alphabet:Nn #3
              {
                \mode_if_math:F
                  {
                    \msg_error:nnx {xfss}
                      {only-math-cmd} { \token_to_str:N #3 }
                  }
                \xfss_use_math_group:nn ##1 {#2}
              }
          }
        \cs_gset_protected_nopar:Npn #3
          {
            \mode_if_math:F
              { \msg_error:nnx {xfss} {only-math-cmd} { \token_to_str:N #3 } }
            \xfss_use_math_group:nn ##1 {#2}
          }
      }
    \exp_after:wN \cs_tmp:w \l_xfss_tmpb_tl \q_nil
  }
\cs_new_protected:Npn \xfss_math_egroup:n #1 { #1 \egroup }
\cs_new_protected_nopar:Npn \xfss_calculate_math_sizes:
  {
    \msg_info:nnx {xfss} {calc-math-sizes} {\l_xfss_fsize_tl}
    \dim_set:Nn \l_xfss_tmpa_dim {\l_xfss_fsize_tl pt}
    \cs_gset:cpx {xfss_set_font_size_\l_xfss_fsize_tl :}
      {
        \tl_gset:Nn \exp_not:N \g_xfss_tf_size_tl  {\l_xfss_fsize_tl}
        \tl_gset:Nn \exp_not:N \g_xfss_sf_size_tl
          { \dim_strip_pt:n { \defaultscriptratio \l_xfss_tmpa_dim } }
        \tl_gset:Nn \exp_not:N \g_xfss_ssf_size_tl
          { \dim_strip_pt:n { \defaultscriptscriptratio \l_xfss_tmpa_dim } }
        \bool_set_true:N \l_xfss_math_fonts_bool
      }
  }
%    \end{macrocode}
%
% fixme: what to do in initex?
%    \begin{macrocode}
%<*package>
\tl_set_eq:NN \g_no_accents_tl \noaccents@
%</package>
%<*initex>
\tl_clear:N \g_no_accents_tl
%</initex>
%    \end{macrocode}
%
% \subsection{Selecting and tracing fonts}
% From File: ltfsstrc.dtx
%
%    \begin{macrocode}
\cs_set:Npn \tracingfonts
  {
    \FIXME % implement
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xfss_extract_font:
  {
    \xfss_get_external_font:
    \fontface_gset:cn \g_xfss_font_csname_tl {\l_xfss_external_font_tl}
    \use:c { \g_xfss_font_csname_tl }
    \scan_stop:
    \use:c {\l_xfss_encoding_tl+\l_xfss_family_tl}
    \use:c {\l_xfss_current_font_tl}
    \scan_stop:
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xfss_get_external_font:
  {
    \tl_clear:N \l_xfss_external_font_tl
    \tl_set:Nx \l_xfss_font_info_tl
      {
        \exp_last_unbraced:Nv \token_to_str:N
          { \l_xfss_current_font_tl }
      }
    \xfss_try_size_range:F
      {
        \xfss_try_size_subst:F
          {
            \msg_error:nnx {xfss} {font-not-found}
              { \g_xfss_font_csname_tl }
            \xfss_error_font_shape:
            \xfss_get_external_font:
          }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareDocumentCommand \selectfont {}
  {
    \tl_if_eq:NNF \l_xfss_linespread_tl \baselinestretch
      {
        \xfss_set_fontsize:nnn \baselinestretch
          \l_xfss_fsize_tl \l_xfss_baselineskip_tl
      }
    \xfss_font_provide:c {\l_xfss_current_font_tl/\l_xfss_fsize_tl}
    \use:c { \g_xfss_font_csname_tl }
    \bool_if:NT \l_xfss_update_sizes_bool    { \xfss_update_sizes:    }
    \tl_if_eq:NNF \l_xfss_encoding_current_tl \l_xfss_encoding_tl
      { \xfss_update_encoding: }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_set_fontsize:nnn #1#2#3
  {
    \tl_set:Nx \l_xfss_fsize_tl { \xfss_dim_strip_pt:n {#2} }
    \xfss_default_units:w \l_xfss_tmp_skip #3 pt \relax \q_nil
    \tl_set:Nx \l_xfss_baselineskip_tl { \skip_use:N \l_xfss_tmp_skip }
    \tl_set:Nx \l_xfss_linespread_tl {#1}
    \tl_set_eq:NN \baselinestretch \l_xfss_linespread_tl
    \bool_set_true:N \l_xfss_update_sizes_bool
  }
\cs_new:Npn \xfss_update_sizes:
  {
    \dim_set:Nn \baselineskip {\l_xfss_baselineskip_tl}
    \dim_set:Nn \baselineskip {\l_xfss_linespread_tl\baselineskip}
    \dim_set:Nn \normalbaselineskip {\baselineskip}
    \hbox_set:Nn \strutbox
      {
        \vrule height .7\baselineskip
               depth  .3\baselineskip
               width 0pt
      }
    \bool_set_false:N \l_xfss_update_sizes_bool
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\tl_set:Nn \g_xfss_global_settings_tl
  {
    \cs_if_exist:cF { xfss_set_font_size_ \l_xfss_fsize_tl : }
      { \xfss_calculate_math_sizes: }
    \use:c { xfss_set_font_size_ \l_xfss_fsize_tl : }
    \bool_if:NT \l_xfss_math_fonts_bool
      {
        \group_begin:
          \int_set:Nn \tex_escapechar:D {\c_minus_one}
          \use:c { g_xfss_math_version_ \l_xfss_math_version_tl _tl }
          \xfss_assign_math_fonts:
          \tl_gset_eq:NN \g_xfss_setup_currsize_tl \l_xfss_fsize_tl
        \group_end:
        \hook_use:n {math_size}
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xfss_check_math_fonts:
  {
    \tl_if_eq:NNF \g_xfss_setup_currsize_tl \l_xfss_fsize_tl
      {
         \g_xfss_global_settings_tl
         \xfss_init_restore_glb_settings:
      }
    \tl_set_eq:NN \g_xfss_curr_math_size_tl \l_xfss_fsize_tl
    \cs_set:Npn \xfss_init_restore_glb_settings: {
      \group_insert_after:N \xfss_restore_glb_settings:
    }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_clear:N \xfss_init_restore_glb_settings:
\cs_new_protected_nopar:Npn \xfss_restore_glb_settings:
  {
    \group_begin:
      \tl_set_eq:NN \l_xfss_fsize_tl \g_xfss_curr_math_size_tl
      \tl_if_eq:NNF \g_xfss_setup_currsize_tl \l_xfss_fsize_tl
        {\g_xfss_global_settings_tl}
    \group_end:
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_use_math_group:nn #1#2
  {
    \mode_if_math:T {
      \bgroup
        \tl_if_eq:cNF {g_xfss_encoding_setup_math_ \l_xfss_encoding_tl _tl} #1
          { #1 }
        \mathgroup_use:n {#2}
      \xfss_math_egroup:n
    }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_get_and_define_fonts:nn #1 #2
  {
    \xfss_font_provide:c { \token_to_str:N #2 / \g_xfss_tf_size_tl }
    \tl_set_eq:NN \l_xfss_textfont_csname_tl \g_xfss_font_csname_tl
    \xfss_font_provide:c { \token_to_str:N #2 / \g_xfss_sf_size_tl }
    \tl_set_eq:NN \l_xfss_scriptfont_csname_tl \g_xfss_font_csname_tl
    \xfss_font_provide:c { \token_to_str:N #2 / \g_xfss_ssf_size_tl }
    \tl_put_right:Nx \xfss_assign_math_fonts:
      {
        \tex_global:D \tex_textfont:D         #1
          \use:c { \l_xfss_textfont_csname_tl }
        \tex_global:D \tex_scriptfont:D       #1
          \use:c { \l_xfss_scriptfont_csname_tl }
        \tex_global:D \tex_scriptscriptfont:D #1
          \use:c { \g_xfss_font_csname_tl }
      }
  }
%    \end{macrocode}
%
% \subsection{Parsing fd files}
%
%    \begin{macrocode}
\cs_new:Npn \xfss_remove_angles:w #1 > { \xfss_set_simple_size_args:w }
\cs_new:Npn \xfss_remove_star:w #1 * {#1}
\cs_new:Npn \xfss_extract_sizefn:w #1 * #2 \q_nil
  {
    \if_charcode:w >#2>
      \xfss_set_size_funct_args:w #1 \q_nil
      \tl_clear:N \l_xfss_sizefn_info_tl
    \else:
      \exp_after:wN \xfss_set_size_funct_args:w \xfss_remove_star:w #2 \q_nil
      \tl_set:Nn \l_xfss_sizefn_info_tl {#1}
    \fi:
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xfss_try_simple_size:
  {
    \cs_set:Npn \xfss_tmp: {\cs_set:Npn \xfss_extract_font_info:w ####1 }
    \exp_after:wN \xfss_tmp: \exp_after:wN <\l_xfss_fsize_tl> ##2 < ##3 \q_stop
      {
        \quark_if_nil:NF {##2}
          {
            \xfss_set_simple_size_args:w ##2 < ##3 \q_stop
            \xfss_execute_size_function:n {\l_xfss_sizefn_info_tl}
          }
      }
    \exp_after:wN \exp_after:wN
    \exp_after:wN \xfss_extract_font_info:w
    \exp_after:wN \l_xfss_font_info_tl
    \exp_after:wN <\l_xfss_fsize_tl> \q_nil <\q_stop
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \xfss_set_simple_size_args:w #1 <
  {
    \if<#1<
      \exp_after:wN \xfss_remove_angles:w
    \else
      \xfss_extract_sizefn:w #1 * \q_nil
      \exp_after:wN \use_none_delimit_by_q_stop:w
    \fi
  }
\cs_new:Npn \xfss_extract_rangefontinfo:w #1 <#2>
  { \xfss_is_range:wq #2 -> \q_nil #2> }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \xfss_is_range:wq #1-#2 \q_nil
  {
    \if_charcode:w >#2
      \exp_after:wN \xfss_check_single:wq
    \else:
      \exp_after:wN \xfss_check_range:wq
    \fi:
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \xfss_check_range:wq #1 - #2 > #3 < #4 \q_stop
  {
    \quark_if_nil:NF {#3}
      {
        \tl_set:Nn \l_xfss_tmpf_tl
          { \xfss_extract_rangefontinfo:w < #4 \q_stop }
        \dim_set:Nn \l_xfss_upper_bound_dim { 0 #2 pt }
        \dim_compare:nNnT \l_xfss_upper_bound_dim = \c_zero_dim
          { \dim_set:Nn \l_xfss_upper_bound_dim {\maxdimen} }
        \dim_compare:nNnT {\l_xfss_fsize_tl pt} < \l_xfss_upper_bound_dim
          {
            \dim_set:Nn \l_xfss_lower_bound_dim { 0 #1 pt }
            \dim_compare:nNnF {\l_xfss_fsize_tl pt} < \l_xfss_lower_bound_dim
              {
                \xfss_set_simple_size_args:w#3<#4\q_stop
                \xfss_execute_size_function:n {\l_xfss_sizefn_info_tl}
                \tl_if_empty:NF \l_xfss_external_font_tl
                { \tl_clear:N \l_xfss_tmpf_tl }
              }
          }
        \l_xfss_tmpf_tl
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \xfss_check_single:wq #1 > #2 < #3 \q_stop
  {
    \tl_set:Nn \l_xfss_tmpf_tl { \xfss_extract_rangefontinfo:w < #3 \q_stop }
    \dim_compare:nNnT {\l_xfss_fsize_tl pt} = {#1pt}
      {
         \xfss_set_simple_size_args:w #2 < #3 \q_stop
         \xfss_execute_size_function:n {\l_xfss_sizefn_info_tl}
         \tl_if_empty:NF \l_xfss_external_font_tl
           { \tl_clear:N \l_xfss_tmpf_tl }
      }
    \l_xfss_tmpf_tl
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareDocumentCommand \xfss_set_size_funct_args:w { O{} u{ \q_nil } }
  {
    \tl_set:Nn \l_xfss_optional_arg_tl  {#1}
    \tl_set:Nn \l_xfss_mandatory_arg_tl {#2}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareSizeFunction {mm}
  { \cs_set:cpn {xfss_size_function_ #1 :} {#2} }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_execute_size_function:n #1
  { \use:c {xfss_size_function_ #1 :} }
%    \end{macrocode}
%
%    \begin{macrocode}
\prg_new_conditional:Npnn \xfss_try_size_range: {F}
  {
    \exp_after:wN
    \xfss_extract_rangefontinfo:w \l_xfss_font_info_tl <-*> \q_nil < \q_stop
    \tl_if_empty:NTF \l_xfss_external_font_tl
    \prg_return_false: \prg_return_true:
  }
\prg_new_conditional:Npnn \xfss_try_size_subst: {F}
  {
    \dim_set:Nn \l_xfss_tmpb_dim {\maxdimen}
    \tl_clear:N \l_xfss_best_size_tl
    \exp_after:wN
    \xfss_try_simples:w \l_xfss_font_info_tl <10000> \q_nil < \q_stop
    \tl_if_empty:NTF \l_xfss_external_font_tl
      \prg_return_false: \prg_return_true:
  }
\cs_new_protected_nopar:Npn \xfss_size_diff_warning:
  {
    \dim_compare:nNnT \g_xfss_font_submax_tl > \fontsubfuzz
    { \msg_warning:nnx {xfss} {size-subst} {\g_xfss_font_submax_tl} }
  }
\tl_set:Nn \g_xfss_font_submax_tl {0pt}
\tl_set:Nn \fontsubfuzz{.4pt}
\cs_new_protected:Npn \xfss_try_simples:w #1 <#2>
  {
    \xfss_try_if_simple:w #2 -> \xfss_try_if_simple:w
  }
\cs_new_protected:Npn \xfss_try_if_simple:w #1-#2 \xfss_try_if_simple:w
  {
    \cs_set_eq:NN \xfss_tmpf:w \xfss_try_simples:w
    \if_charcode:w > #2
      \dim_compare:nNnTF {#1 pt} < { 10000pt }
        {
          \dim_set:Nn \l_xfss_tmpc_dim
            { \dim_abs:n { #1pt - \l_xfss_fsize_tl pt} }
          \dim_compare:nNnT \l_xfss_tmpc_dim < \l_xfss_tmpb_dim
            {
              \dim_set:Nn \l_xfss_tmpb_dim {\l_xfss_tmpc_dim}
              \tl_set:Nn \l_xfss_best_size_tl {#1}
            }
        }
        {
          \tl_if_empty:NT \l_xfss_external_font_tl
            {
              \tl_if_empty:NF \l_xfss_best_size_tl
                {
                  \dim_compare:nNnT \l_xfss_tmpb_dim > \g_xfss_font_submax_tl
                    {
                      \tl_gset:Nx \g_xfss_font_submax_tl {\the\l_xfss_tmpb_dim}
                    }
                  \tl_set_eq:NN \l_xfss_user_size_tl \l_xfss_fsize_tl
                  \tl_set_eq:NN \l_xfss_fsize_tl \l_xfss_best_size_tl
                  \dim_compare:nNnT \l_xfss_tmpb_dim > \fontsubfuzz
                    {
                      \msg_warning:nnxxx {xfss} {font-shape-unavail}
                      {\l_xfss_current_font_tl} {\l_xfss_user_size_tl}
                      {\l_xfss_fsize_tl}
                    }
                  \xfss_try_simple_size:
                  \xfss_activate_subst_correction:
                }
            }
          \cs_set_eq:NN \xfss_tmpf:w \use_none_delimit_by_q_stop:w
        }
    \fi:
    \xfss_tmpf:w
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareSizeFunction{} { \xfss_empty_size_fn:N \msg_warning:nn }
\DeclareSizeFunction{s}{ \xfss_empty_size_fn:N \msg_info:nn }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_empty_size_fn:N #1
  {
    \dim_set:Nn \l_xfss_tmpb_dim {\l_xfss_fsize_tl pt}
    \tl_if_empty:NF \l_xfss_optional_arg_tl
      {
        \dim_set:Nn \l_xfss_tmpb_dim
          { \l_xfss_optional_arg_tl \l_xfss_tmpb_dim }
        #1 {xfss} {font-shape-scale}
      }
    \tl_set:Nx \l_xfss_external_font_tl
      { \l_xfss_mandatory_arg_tl\space at \dim_use:N \l_xfss_tmpb_dim }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareSizeFunction{gen} { \xfss_gen_size_fn:N \msg_warning:nn }
\DeclareSizeFunction{sgen}{ \xfss_gen_size_fn:N \msg_info:nn }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_gen_size_fn:N
  {
    \tl_set:Nx \l_xfss_mandatory_arg_tl
      { \l_xfss_mandatory_arg_tl \l_xfss_fsize_tl }
    \xfss_empty_size_fn:N
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareSizeFunction{genb} { \xfss_genb_size_fn:N \msg_warning:nn }
\DeclareSizeFunction{sgenb}{ \xfss_genb_size_fn:N \msg_info:nn }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_genb_size_fn:N
  {
    \tl_set:Nx \l_xfss_mandatory_arg_tl
      {
        \l_xfss_mandatory_arg_tl
        \exp_after:wN \xfss_gen_aux:w \l_xfss_fsize_tl .. \q_nil
      }
    \xfss_empty_size_fn:N
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \xfss_gen_aux:w #1.#2.#3 \q_nil
  {
    \int_compare:nNnT {#1} < {10} {0} \int_value:w #1 % LaTeX2e's "\two@digits"
    \xfss_gen_aux_ii:w #2 00 \q_nil
  }
\cs_new:Npn \xfss_gen_aux_ii:w #1 #2 #3 \q_nil { #1#2 }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareSizeFunction{sub} { \xfss_sub_size_fn:N \msg_warning:nn }
\DeclareSizeFunction{ssub}{ \xfss_sub_size_fn:N \msg_info:nn }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_sub_size_fn:N #1
  {
    \tl_set:Nx \l_xfss_mandatory_arg_tl
      { \l_xfss_encoding_tl / \l_xfss_mandatory_arg_tl }
    \group_begin:
      \exp_after:wN \xfss_split_name:w \l_xfss_mandatory_arg_tl / \q_nil
      \xfss_try_load_fontshape:
    \group_end:
    \tl_set_eq:NN \l_xfss_user_size_tl \l_xfss_fsize_tl
    \cs_if_exist:cTF { \l_xfss_mandatory_arg_tl }
      {
        #1 {xfss} {font-shape-size-missing}
        \exp_after:wN \xfss_split_name:w \l_xfss_mandatory_arg_tl / \q_nil
      }
      {
        \errmessage{No~declaration~for~shape~\l_xfss_mandatory_arg_tl}
        \xfss_error_font_shape:
      }
    \tl_set:Nx \l_xfss_fsize_tl {\l_xfss_user_size_tl}
    \xfss_get_external_font:
    \xfss_activate_subst_correction:
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareSizeFunction{subf} { \xfss_subf_size_fn:N \msg_warning:nn }
\DeclareSizeFunction{ssubf}{ \xfss_subf_size_fn:N \msg_info:nn }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_subf_size_fn:N #1
  {
    #1 {xfss} {font-shape-size-instead}
    \xfss_empty_size_fn:N #1
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareSizeFunction{fixed} { \xfss_fixed_size_fn:N \msg_warning:nn }
\DeclareSizeFunction{sfixed}{ \xfss_fixed_size_fn:N \msg_info:nn }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_fixed_size_fn:N #1
  {
    \tl_if_empty:NTF \l_xfss_optional_arg_tl
      { \tl_set_eq:NN \l_xfss_external_font_tl \l_xfss_mandatory_arg_tl }
      {
        \tl_set:Nx \l_xfss_external_font_tl
          { \l_xfss_mandatory_arg_tl\space at\l_xfss_optional_arg_tl pt }
      }
    #1 {xfss} {ext-font-loaded}
  }
%    \end{macrocode}
%
% \subsection{Font declarations}
% From File: ltfssdcl.dtx
%
%    \begin{macrocode}
\count18=0 % not sure why "0"
\cs_new:Npn \xfss_select_math_group:Nnnn #1#2#3#4
  {
    \c_group_begin_token % should be \group_begin: ?
      \mode_if_math:TF
        {
          \exp_args:Nc \int_compare:nNnTF
            { g_xfss_mversion_ \l_xfss_math_version_tl _int}
            < \c_max_math_fonts_int
            {
              \group_begin:
                \int_set:Nn \tex_escapechar:D {\c_minus_one}
                \exp_args:Nc \xfss_get_and_define_fonts:nn
                  {g_xfss_mversion_ \l_xfss_math_version_tl _int} #3
                \xfss_assign_math_fonts:
              \group_end:
              \xfss_init_restore_version:
              \tl_gset:Nx #1
                {
                  \exp_not:N \xfss_use_math_group:nn \exp_not:N #2
                  { \int_use:c {g_xfss_mversion_ \l_xfss_math_version_tl _int} }
                }
              \int_gincr:c {g_xfss_mversion_ \l_xfss_math_version_tl _int}
            }
            {
              \cs_null:N #1 % fixme: why not "\c_undefined" ?
              \msg_error:nnx {xfss}
                {too-many-alphabets} {\l_xfss_math_version_tl}
            }
        }
        { \msg_error:nnx {xfss} {only-math-cmd} { \token_to_str:N #1 } }
      #1 {#4}
    \c_group_end_token
  }
\cs_new_protected_nopar:Npn \xfss_init_restore_version:
  {
    \cs_gclear:N \xfss_init_restore_version:
    \cs_set_nopar:Npx \xfss_restore_mathversion:
      {
        \exp_not:c {g_xfss_math_version_ \l_xfss_math_version_tl _tl}
        \exp_not:N \int_gset:cn {g_xfss_mversion_ \l_xfss_math_version_tl _int}
        { \int_use:c {g_xfss_mversion_ \l_xfss_math_version_tl _int} }
      }
    \group_insert_after:N \xfss_restore_version:
  }
\cs_new_protected_nopar:Npn \xfss_restore_version:
  {
    \mode_if_math:TF
      { \group_insert_after:N \xfss_restore_version: }
      {
        \cs_set_nopar:Npn \xfss_init_restore_version:
          {
            \cs_gclear:N \xfss_init_restore_version:
            \cs_set_nopar:Npx \xfss_restore_mathversion:
              {
                \exp_not:c { g_xfss_math_version_ \l_xfss_math_version_tl _tl }
                \exp_not:N \int_gset:cn
                  { g_xfss_mversion_ \l_xfss_math_version_tl _int }
                  { \int_use:c {g_xfss_mversion_ \l_xfss_math_version_tl _int} }
              }
            \group_insert_after:N \xfss_restore_version:
          }
        \group_begin:
          \cs_set_eq:NN \xfss_get_and_define_fonts:nn \use_none:nn
          \xfss_restore_mathversion:
        \group_end:
      }
  }
\cs_new_protected:Npn \xfss_document_select_math_group:Nnnn #1#2#3#4
  {
    \c_group_begin_token % \group_begin: ?
      \mode_if_math:TF
        {
          \exp_args:Nc \int_compare:nNnTF
            { g_xfss_mversion_ \l_xfss_math_version_tl _int }
            < \c_max_math_fonts_int
            {
              \group_begin:
                \int_set:Nn \tex_escapechar:D {\c_minus_one}
                \exp_args:Nc \xfss_get_and_define_fonts:nn
                  {g_xfss_mversion_ \l_xfss_math_version_tl _int} #3
                \xfss_assign_math_fonts:
              \group_end:
              \exp_args:Ncv
                \xfss_extract_alphabet_from_version:nnN
                {g_xfss_math_version_ \l_xfss_math_version_tl _tl}
                {g_xfss_mversion_ \l_xfss_math_version_tl _int}
                #1
              \int_gincr:c {g_xfss_mversion_ \l_xfss_math_version_tl _int}
            }
            {
              \cs_null:N #1
              \msg_error:nnx {xfss}
                {too-many-alphabets} {\l_xfss_math_version_tl}
            }
        }
        { \msg_error:nnx {xfss} {only-math-cmd} { \token_to_str:N #1 } }
      #1{#4}
    \c_group_end_token
  }
%    \end{macrocode}
% This is executed in "\begin{document}"
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xfss_process_table:
  {
    \prop_map_inline:Nn \g_xfss_cdp_prop
      {
        \msg_info:nnx {xfss} {checking-defaults} {##1/##2}
        \cs_if_exist:cF {##1/##2}
          {
            \group_begin:
              \xfss_set_encoding:x {##1}
              \xfss_set_family:x { \xfss_use_to_slash_nil:ww ##2 / \q_nil }
              \xfss_try_load_fontshape:
            \group_end:
          }
        \cs_if_exist:cTF {##1/##2}
          { \msg_info:nn {xfss} {okay!} }
          { \msg_error:nnxx {xfss} {xfss-broken} {##1} {##2} }
      }
    \group_begin:
      \int_set:Nn \tex_escapechar:D {\c_minus_one}
      \xfss_error_font_shape:
      \cs_if_exist:cF {\l_xfss_current_font_tl}
        {
          \group_begin:
            \xfss_try_load_fontshape:
          \group_end:
        }
      \cs_if_exist:cF {\l_xfss_current_font_tl}
        { \msg_error:nn {xfss} {no-error-font} }
    \group_end:
    \cs_set_eq:NN
      \xfss_select_math_group:Nnnn
      \xfss_document_select_math_group:Nnnn
%    \end{macrocode}
% Install the default font attributes they are currently pointing to error
% font shape.
%    \begin{macrocode}
    \xfss_set_encoding:x {\encodingdefault}
    \xfss_set_family:x   {\familydefault}
    \xfss_set_series:x   {\seriesdefault}
    \xfss_set_shape:x    {\shapedefault}
  }
%    \end{macrocode}
%
%
% \subsection{Math versions, alphabets, symbol fonts}
%
% We define
% \begin{itemize}
% \item \cs{DeclareMathVersion} \Arg{version name}
% \item \cs{DeclareMathAlphabet} \meta{alphabet} \meta{font specification}
% \item \cs{SetMathAlphabet} \meta{alphabet} \Arg{version}
%   \meta{font specification}
% \item \cs{DeclareSymbolFont} \Arg{sym name} \meta{font specification}
% \item \cs{SetSymbolFont} \Arg{sym name} \Arg{version name}
%   \meta{font specification}
% \item \cs{DeclareSymbolFontAlphabet} \meta{alphabet} \Arg{sym name}
% \end{itemize}
% where \meta{version name} is typically \texttt{normal} or \texttt{bold},
% \meta{alphabet} can be for instance \cs{mathit} or \cs{mathnormal},
% \meta{font specification} is four brace groups (the encoding, the family,
% the series, and the shape), and \meta{sym name} is typically
% \texttt{operators}, \texttt{letters}, \texttt{symbols}, or
% \texttt{largesymbols}.
%
% \begin{variable}{\g_xfss_math_version_seq}
%   List of all math versions. Contrarily to \LaTeXe{}'s \cs{version@list},
%   the items are \texttt{normal} and \texttt{bold} rather than
%   \cs{mv@normal} and \cs{mv@bold}.
%    \begin{macrocode}
\seq_new:N  \g_xfss_math_version_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\xfss_math_version_check_exists:nT}
% \begin{macro}{\xfss_math_version_if_exists:nTF}
%   Error if the math version does not exist.
%   Should it use \cs{seq_if_in:Nn} \cs{g_xfss_math_version_seq}?
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_math_version_check_exists:nT #1 #2
  {
    \cs_if_exist:cTF { g_xfss_mversion_ #1 _int }
      {#2}
      { \msg_error:nnx {xfss} {math-version-unknown} {#1} }
  }
\cs_new_protected:Npn \xfss_math_version_if_exists:nTF #1
  { \cs_if_exist:cTF { g_xfss_mversion_ #1 _int } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\DeclareMathVersion}
%   ^^A Todo: rename \mv_normal => \g_xfss_math_version_normal_tl.
%   
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareMathVersion {m}
  {
    \xfss_math_version_if_exists:nTF {#1}
      { \msg_info:nnxx {xfss} {redeclaring} {math~version} {#1} }
      {
        \int_new:c {g_xfss_mversion_ #1 _int}
        \seq_put_right:Nn \g_xfss_math_version_seq {#1}
      }
    \tl_gclear_new:c { g_xfss_math_version_ #1 _tl }
    \prop_map_inline:Nn \g_xfss_math_sym_font_prop
      {
        \tl_gput_right:cx { g_xfss_math_version_ #1 _tl }
          {
            \exp_not:N \xfss_get_and_define_fonts:nn
            \exp_not:c {sym ##1} \exp_not:c {##2}
          }
      }
    \int_gset:cn { g_xfss_mversion_ #1 _int }
      { \prop_length:N \g_xfss_math_sym_font_prop }
    \prop_map_inline:Nn \g_xfss_math_alphabet_prop
      {
        \tl_gput_right:cx { g_xfss_math_version_ #1 _tl }
          {
            \exp_not:N \xfss_install_math_alphabet:Nn \exp_not:c {##1}
              {
                \exp_after:wN \cs_if_eq:NNTF
                  \use_i:nn ##2
                  \xfss_no_alphabet_error:N
                  {
                    \exp_not:N \xfss_no_alphabet_error:N
                    \exp_not:c {##1}
                  }
                  {
                    \exp_not:N \xfss_select_math_group:Nnnn
                    \exp_not:c {##1}
                    \exp_not:n {##2}
                  }
              }
          }
      }
  }
\DeclareDocumentCommand \DeclareSymbolFont {mm mmm}
  {
    \xfss_encoding_check_exists:nT {#2}
      {
        \cs_if_free:cTF {sym#1}
          {
            \mathgroup_new:c {sym#1}
            \xfss_new_symbol_font:nnnnn {#1} {#2}{#3}{#4}{#5}
          }
          {
            \msg_info:nnxx {xfss} {redeclaring} {symbol~font} {#1}
            \prop_gput:Nxx \g_xfss_math_sym_font_prop {#1} { #2 / #3 / #4 / #5 }
            \seq_map_inline:Nn \g_xfss_math_version_seq
              {
                \exp_args:Nc \xfss_set_symbol_font:Nnn
                  {#2/#3/#4/#5} {#1} {##1}
              }
          }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_new_symbol_font:nnnnn #1#2#3#4#5
  {
    \prop_gput:Nxx \g_xfss_math_sym_font_prop {#1} { #2 / #3 / #4 / #5 }
    \seq_map_inline:Nn \g_xfss_math_version_seq
      {
        \tl_put_right:cx { g_xfss_math_version_ ##1 _tl }
          {
            \exp_not:N \xfss_get_and_define_fonts:nn
            \exp_not:c {sym#1}
            \exp_not:c {#2/#3/#4/#5}
          }
        \int_gincr:c { g_xfss_mversion_ ##1 _int }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareDocumentCommand \SetSymbolFont {mmm mmm}
  {
    \xfss_encoding_check_exists:nT {#3}
      {
        \exp_args:Nc \xfss_set_symbol_font:Nnn
          {#3/#4/#5/#6} {#1} {#2}
      }
  }
%    \end{macrocode}
%
%
%
% \begin{macro}{\xfss_set_symbol_font:Nnn}
% \begin{arguments}
% \item \meta{NFSS font identifier} (\cs{enc/fam/series/shape})
% \item \meta{symbol font}
% \item \meta{math version}
% \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_set_symbol_font:Nnn #1#2#3
  {
    \xfss_math_version_check_exists:nT {#3}
      {
        \xfss_check_symbol_font_exists:nT {#2}
          {
            \group_begin:
              \xfss_extract_encoding_from_font:NN \l_xfss_tmpa_tl #1
              \tl_clear:N \l_xfss_tmpd_tl
              \cs_set:Npn \xfss_install_math_alphabet:Nn ##1 ##2
                {
                  \tl_put_right:Nn \l_xfss_tmpd_tl
                    { \xfss_install_math_alphabet:Nn ##1 {##2} }
                }
              \cs_set:Npn \xfss_get_and_define_fonts:nn ##1 ##2
                {
                  \int_compare:nNnTF {##1} = { \use:c {sym#2} }
                    {
                      \tl_put_right:Nx \l_xfss_tmpd_tl
                        {
                          \exp_not:N \xfss_get_and_define_fonts:nn
                          \exp_not:c {sym#2}
                          \exp_not:n {#1}
                        }
                      \xfss_extract_encoding_from_font:NN \l_xfss_tmpb_tl ##2
                      \cs_if_eq:NNF \l_xfss_tmpa_tl \l_xfss_tmpb_tl
                         {
                            \msg_info:nnxxxx {xfss} {enc-change}
                              {\l_xfss_tmpb_tl} {\l_xfss_tmpa_tl}
                              { #2 }
                              { #3 }
                         }
                       \msg_info:nnxxxx {xfss} {overwrite-symfont}
                         { #2 }
                         { #3 }
                         { \cs_to_str:N ##2 } { \cs_to_str:N #1 }
                    }
                    {
                      \tl_put_right:Nn \l_xfss_tmpd_tl
                        { \xfss_get_and_define_fonts:nn ##1 ##2 }
                    }
                }
              \use:c { g_xfss_math_version_ #3 _tl }
              \tl_gset_eq:cN { g_xfss_math_version_ #3 _tl } \l_xfss_tmpd_tl
            \group_end:
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\DeclareMathAlphabet}
% \begin{arguments}
% \item command to switch math alphabet font
% \item encoding \item fam \item series \item shape
% \end{arguments}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareMathAlphabet {mm mmm}
  {
    \xfss_encoding_check_exists:nT {#2}
      {
        \cs_if_free:NTF #1
          { \xfss_new_math_alphabet:Nnnnn #1 {#2}{#3}{#4}{#5} }
          {
            \cs_meaning_if_in:NNTF #1 \xfss_select_math_group:Nnnn
              {
                \msg_info:nnxx {xfss}
                  {redeclaring} {math~alphabet} { \token_to_str:N #1 }
                \seq_map_inline:Nn \g_xfss_math_version_seq
                  {
                    \xfss_set_math_alphabet:Nnnn
                      #1
                      {##1}
                      {#2}
                      {#2/#3/#4/#5}
                  }
              }
              {
                \cs_meaning_if_in:NNTF #1 \xfss_use_math_group:nn
                  {
                    \msg_info:nnxx {xfss}
                      {redeclaring} {math~alphabet} { \token_to_str:N #1 }
                    \xfss_new_math_alphabet:Nnnnn #1 {#2}{#3}{#4}{#5}
                  }
                  {
                    \msg_error:nnx {xfss} {cmd-defined} { \token_to_str:N #1 }
                  }
              }
          }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_new_math_alphabet:Nnnnn #1#2#3#4#5
  {
    \cs_set_protected_nopar:Npx #1
      {
        \tl_if_empty:nTF {#5}
          {
            \exp_not:N \xfss_no_alphabet_error:N
            \exp_not:N #1
          }{
            \exp_not:N \xfss_select_math_group:Nnnn
            \exp_not:N #1
            \exp_not:c { g_xfss_encoding_setup_math_ #2 _tl }
            \exp_not:c {#2/#3/#4/#5}
          }
      }
    \prop_gput:Nxx \g_xfss_math_alphabet_prop { \cs_to_str:N #1 }
      {
        \tl_if_empty:nTF {#5}
          {
            \exp_not:N \xfss_no_alphabet_error:N
            \exp_not:N \xfss_no_alphabet_error:N
          }{
            \exp_not:c { g_xfss_encoding_setup_math_ #2 _tl}
            \exp_not:c {#2/#3/#4/#5}
          }
      }
    \seq_map_inline:Nn \g_xfss_math_version_seq
      {
        \tl_put_right:cx { g_xfss_math_version_ ##1 _tl }
          {
            \exp_not:N \xfss_install_math_alphabet:Nn
            \exp_not:N #1
            { \exp_not:o {#1} }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SetMathAlphabet}
%   Arguments are: \meta{control sequence}, \meta{math version},
%   \meta{encoding}, \meta{family}, \meta{series}, \meta{shape}.
%    \begin{macrocode}
\DeclareDocumentCommand \SetMathAlphabet {mmm mmm}
  {
    \xfss_math_version_check_exists:nT {#2}
      {
        \xfss_encoding_check_exists:nT {#3}
          {
            \xfss_set_math_alphabet:Nnnn
              #1
              {#2}
              {#3}
              {#3/#4/#5/#6}
          }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_set_math_alphabet:Nnnn #1#2#3#4
  {% <cs> {version} {encoding} {font name}
    \prop_if_in:NxTF \g_xfss_math_alphabet_prop { \cs_to_str:N #1 }
      { \xfss_set_math_alphabet_existing:Nnnn #1 {#2} {#3} {#4} }
      {
        \cs_meaning_if_in:NNTF #1 \xfss_use_math_group:nn
          { \xfss_set_math_alphabet_umg:Nnnn #1 {#2} {#3} {#4} }
          {
            \msg_error:nnx {xfss}
              {no-math-alph-cmd} { \token_to_str:N #1 }
          }
      }
  }
\cs_new_protected:Npn \xfss_set_math_alphabet_existing:Nnnn #1#2#3#4
  {
    \group_begin:
      \tl_clear:N \l_xfss_tmpd_tl
      \cs_set:Npn \xfss_get_and_define_fonts:nn ##1 ##2
        {
          \tl_put_right:Nn \l_xfss_tmpd_tl
            { \xfss_get_and_define_fonts:nn ##1 ##2 }
        }
      \cs_set:Npn \xfss_install_math_alphabet:Nn ##1 ##2
        {
          \cs_if_eq:NNTF ##1 #1
            {
              \tl_put_right:Nx \l_xfss_tmpd_tl
                {
                  \exp_not:N \xfss_install_math_alphabet:Nn
                  \exp_not:N #1
                    {
                      \exp_not:N \xfss_select_math_group:Nnnn
                      \exp_not:N #1
                      \exp_not:c { g_xfss_encoding_setup_math_ #3 _tl }
                      \exp_not:c {#4}
                    }
                }
              \msg_info:nnxxxx {xfss} {overwrite-mathalph}
                { \token_to_str:N #1 } {#2}
                { \use_iv_to_str:nnnN ##2 } {#4}
            }
            {
              \tl_put_right:Nn \l_xfss_tmpd_tl
                { \xfss_install_math_alphabet:Nn ##1 {##2} }
            }
        }
      \use:c { g_xfss_math_version_ #2 _tl }
      \tl_gset:cx {g_xfss_math_version_ #2 _tl }
        { \exp_not:o { \l_xfss_tmpd_tl } }
    \group_end:
  }
\cs_new_protected:Npn \xfss_set_math_alphabet_umg:Nnnn #1#2#3#4
  {
    \cs_set:Npn \xfss_tmp:w ##1 \xfss_use_math_group:nn ##2 ##3
      {
        \tl_set:Nn \l_xfss_tmpb_tl {##3}
        \tl_set:Nn \l_xfss_tmpc_tl {##2}
      }
    \exp_after:wN \xfss_tmp:w #1
    \group_begin:
      \cs_set:Npn \xfss_install_math_alphabet:Nn ##1 ##2
        {
          \tl_put_right:Nn \l_xfss_tmpd_tl
            { \xfss_install_math_alphabet:Nn ##1 {##2} }
        }
      \cs_set:Npn \xfss_get_and_define_fonts:nn ##1 ##2
        {
          \tl_put_right:Nn \l_xfss_tmpd_tl
            { \xfss_get_and_define_fonts:nn ##1 ##2 }
          \int_compare:nNnT {##1} = \l_xfss_tmpb_tl
            {
              \exp_after:wN \tl_put_right:Nn
              \exp_after:wN \l_xfss_tmpd_tl
              \exp_after:wN {
                \exp_after:wN \xfss_install_math_alphabet:Nn
                \exp_after:wN #1 \exp_after:wN {
                  \exp_after:wN
                  \xfss_select_math_group:Nnnn
                  \exp_after:wN #1 \l_xfss_tmpc_tl ##2
                }
              }
            }
        }
      \seq_map_inline:Nn \g_xfss_math_version_seq
        {
          \tl_clear:N \l_xfss_tmpd_tl
          \use:c { g_xfss_math_version_ ##1 _tl }
          \tl_gset:cx { g_xfss_math_version_ ##1 _tl }
            { \exp_not:o { \l_xfss_tmpd_tl } }
        }
    \group_end:
    \prop_gput:Nxn \g_xfss_math_alphabet_prop
      { \cs_to_str:N #1 }
      { \xfss_no_alphabet_error:N } %should be doubled??
    \tl_gset:Nn #1 { \xfss_no_alphabet_error:N #1 }% fake things :-)
    \xfss_set_math_alphabet:Nnnn #1 {#2} {#3} {#4}
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\DeclareMathAccent}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareMathAccent {mmmm}
  {
    \xfss_check_symbol_font_exists:nT {#3}
      {
        \token_if_cs:NTF #1
          {
            \cs_meaning_if_in:NNTF #1 \tex_mathaccent:D
              {
                \msg_info:nnxx {xfss}
                  {redeclaring} {math~accent} { \token_to_str:N #1 }
                \math_gset_accent:NNnn #1 #2 { \use:c {sym #3} } {#4}
              }
              { \math_new_accent:NNnn #1 #2 { \use:c {sym #3} } {#4} }
          }
          { \msg_error:nnx {xfss} {not-cmd} { \token_to_str:N #1 } }
      }
  }
\cs_null:N \mathalpha % so that \mathalpha is non-expandable.
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\DeclareMathSymbol}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareMathSymbol {mmmm}
  {
    \xfss_check_symbol_font_exists:nT {#3}
      {
        \token_if_cs:NTF #1
          {
            \cs_meaning_if_in:NNTF #1 \tex_mathchar:D
              {
                \msg_info:nnxx {xfss}
                  {redeclaring} {math~symbol} { \token_to_str:N #1 }
                \math_gset_symbol:NNnn #1 #2 { \use:c {sym #3} } {#4}
              }
              { \math_new_symbol:NNnn #1 #2 { \use:c {sym #3} } {#4} }
          }
          {
            \math_gset_mathcode:NNnn #1 #2 { \use:c{sym #3} } {#4}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\DeclareMathDelimiter}
%
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareMathDelimiter {m}
  {
    \token_if_cs:NTF #1
      \xfss_declare_math_delimiter_cs:NNnnnn
      \xfss_declare_math_delimiter_aux:nnnn
    #1
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_declare_math_delimiter_aux:nnnn #1#2#3#4
  {
    \DeclareMathSymbol #1 {#2} {#3} {#4}
    \xfss_declare_math_delimiter_aux_ii:nnnnn #1 {#3} {#4}
  }
\cs_new_protected:Npn \xfss_declare_math_delimiter_aux_ii:nnnnn #1#2#3#4#5
  {
    \xfss_check_symbol_font_exists:nT {#2}
      {
        \xfss_check_symbol_font_exists:nT {#4}
          {
            \math_gset_delcode:Nnnnn #1 {#2} { \use:c {sym #3} } {#4} {#5}
          }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_declare_math_delimiter_cs:NNnnnn #1#2#3#4#5#6
  {
    \xfss_check_symbol_font_exists:nT {#3}
      {
        \xfss_check_symbol_font_exists:nT {#5}
          {
            \cs_meaning_if_in:NNTF #1 \tex_delimiter:D
              {
                \math_gset_delimiter:NNnnnn #1 #2
                  { \use:c {sym #3} } {#4}
                  { \use:c {sym #5} } {#6}
                \msg_info:nnxx {xfss}
                  {redeclaring} {math~delimiter} { \token_to_str:N #1 }
              }
              {
                \math_new_delimiter:NNnnnn #1 #2
                  { \use:c {sym #3} } {#4}
                  { \use:c {sym #5} } {#6}
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\DeclareMathRadical}
%
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareMathRadical {mm mmm}
  {
    \xfss_check_symbol_font_exists:nT {#2}
      {
        \xfss_check_symbol_font_exists:nT {#4}
          {
            \cs_meaning_if_in:NNTF #1 \tex_radical:D
              {
                \msg_info:nnxx {xfss}
                  {redeclaring} {math~radical} { \token_to_str:N #1 }
                \math_gset_radical:Nnnnn #1
                  { \use:c {sym #2} } {#3}
                  { \use:c {sym #4} } {#5}
              }
              {
                \math_new_radical:Nnnnn #1
                  { \use:c {sym #2} } {#3}
                  { \use:c {sym #4} } {#5}
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% First step: find out if everything is in place to define the alphabet,
% setting the tmp boolean to false if it isn't. Then do the second step
% conditionally. What does \enquote{everything is in place mean?}
% \begin{itemize}
% \item If the math alphabet exists, then remove it from the alphabet prop,
%   then remove the corresponding \cs{xfss_install_math_alphabet:Nn}
%   |####1 {####2}| from each
%   \cs{g_xfss_math_version_}\meta{math version}\texttt{_tl} in the version seq.
% \item If the control sequence doesn't exist, everything is ok.
% \item If it contains \cs{xfss_use_math_group:nn} then it is also a math
%   alphabet.
% \item Otherwise, we're trying to redefine some random cs, and that's not ok.
% \end{itemize}
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareSymbolFontAlphabet {mm}
  { \exp_args:NNx \xfss_declare_symbol_font_alphabet:Nn #1 {#2} }
\cs_new_protected:Npn \xfss_declare_symbol_font_alphabet:Nn #1#2
  {
    \bool_set_true:N \l_xfss_tmp_bool
    \xfss_check_symbol_font_exists:nTF {#2}
      {
        \prop_gpop:NxNTF
          \g_xfss_math_alphabet_prop { \cs_to_str:N #1 } \l_xfss_tmpa_tl
          {
            \msg_info:nnxx {xfss}
              {redeclaring} {math~alphabet} { \token_to_str:N #1 }
            \seq_map_inline:Nn \g_xfss_math_version_seq
              {
                \group_begin:
                  \tl_clear:N \l_xfss_tmpd_tl
                  \cs_set:Npn \xfss_get_and_define_fonts:nn ####1 ####2
                    {
                      \tl_put_right:Nn \l_xfss_tmpd_tl
                        { \xfss_get_and_define_fonts:nn ####1 ####2 }
                    }
                  \cs_set:Npn \xfss_install_math_alphabet:Nn ####1 ####2
                    {
                      \cs_if_eq:NNF ####1 #1
                        {
                          \tl_put_right:Nn \l_xfss_tmpd_tl
                            { \xfss_install_math_alphabet:Nn ####1 {####2} }
                        }
                    }
                  \use:c { g_xfss_math_version_ ##1 _tl }
                  \tl_gset_eq:cN { g_xfss_math_version_ ##1 _tl }
                    \l_xfss_tmpd_tl
                \group_end:
              }
          }{
            \cs_if_exist:NT #1
              {
                \show #1 %^^Ahere
                \cs_meaning_if_in:NNTF #1 \xfss_use_math_group:nn
                  {
                    \msg_info:nnxx {xfss}
                      {redeclaring} {math~alphabet} { \token_to_str:N #1 }
                    % when does this happen?
                  }
                  {
                    \bool_set_false:N \l_xfss_tmp_bool
                    \msg_error:nnx {xfss} {cmd-defined}
                      { \token_to_str:N #1 }
                  }
              }
          }
      }
      { \bool_set_false:N \l_xfss_tmp_bool }
    \bool_if:NT \l_xfss_tmp_bool
      {
        \prop_get:NnNTF \g_xfss_math_sym_font_prop {#2} \l_xfss_tmpa_tl
          {
            \tl_set:Nx \l_xfss_tmpa_tl % pick up the encoding.
              {
                \exp_after:wN \xfss_use_to_slash_nil:ww
                \l_xfss_tmpa_tl / \q_nil
              }
          }
          { \ERROR \tl_set:Nn \l_xfss_tmpa_tl {?} }
        \cs_set_protected:Npx #1
          {
            \exp_not:n { \mode_if_math:F {
                \msg_error:nnx {xfss} {only-math-cmd} { \token_to_str:N #1 } } }
            \exp_not:N \xfss_use_math_group:nn
            \exp_not:c {g_xfss_encoding_setup_math_ \l_xfss_tmpa_tl _tl}
            \use:c {sym #2}
          }
      }
  }
%    \end{macrocode}
%
% \subsection{Conditionals}
%
% \begin{macro}{\xfss_check_symbol_font_exists:nT}
%   If false returns an error.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \xfss_check_symbol_font_exists:n #1 {T,TF}
  {
    \prop_if_in:NxTF \g_xfss_math_sym_font_prop {#1}
      { \prg_return_true: }
      {
        \msg_error:nnx {xfss} {sym-font-unknown} {#1}
        \prg_return_false:
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Font commands}
%
% From file: ltfntcmd.dtx
%
% \begin{macro}{\DeclareTextFontCommand}
%
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareTextFontCommand {mm}
  {
    \DeclareDocumentCommand #1 {m}
      {
        \mode_if_math:TF
          { \xfss_text_in_math:n {#2##1} }
          {
            \mode_leave_vertical:
            \bgroup
              \xfss_text_command:n {##1}
              #2 \xfss_check_ic_l: ##1 \xfss_check_ic_r:
            \egroup
          }
      }
  }
%    \end{macrocode}
%
% \subsubsection{Italic correction}
%
%    \begin{macrocode}
\cs_null:N \nocorr
\cs_clear:N \xfss_check_ic_l:
\cs_clear:N \xfss_check_ic_r:
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_text_command:n #1
  {
    \tl_if_blank:nTF {#1}
    {
      \cs_clear:N \xfss_check_ic_l:
      \cs_clear:N \xfss_check_ic_r:
    }
    { \xfss_check_nocorr:w #1\nocorr \q_nil }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_check_nocorr:w #1#2 \nocorr #3 \q_nil
  {
    \cs_set_eq:NN \xfss_check_ic_l: \xfss_maybe_ic:
    \cs_set:Npn \xfss_check_ic_r:
      { \mode_if_vertical:F { \group_insert_after:N \xfss_maybe_ic: } }
    \tl_if_eq:nnTF {\nocorr} {#1} % seems odd.
      {
        \tl_if_empty:nTF {#3}
          { \cs_clear:N \xfss_check_ic_l: }
          {
            \cs_clear:N \xfss_check_ic_l:
            \cs_clear:N \xfss_check_ic_r:
          }
      }
      {
        \tl_if_empty:nF {#3} { \cs_clear:N \xfss_check_ic_r: }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xfss_maybe_ic:
  { \peek_after:Nw \xfss_maybe_ic_aux: }
\cs_new_protected_nopar:Npn \xfss_maybe_ic_aux:
  {
    \dim_compare:nNnF \fontface_current_slant: > \c_zero_dim
      {
        \bool_set_true:N \l_xfss_maybe_ic_bool
        \tl_map_function:NN \nocorrlist \xfss_test_nocorr:N
        \bool_if:NT \l_xfss_maybe_ic_bool { \xfss_sw_slant: }
      }
  }
%    \end{macrocode}
% Surely it is faster to do the mapping as a function rather than inline.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_test_nocorr:N #1
  {
    \token_if_eq_meaning:NNT #1 \l_peek_token
    {
      \bool_set_false:N \l_xfss_maybe_ic_bool
      \tl_map_break:
    }
  }
\cs_new_protected_nopar:Npn \xfss_sw_slant:
  {
    \dim_compare:nNnTF \l_last_skip = \c_zero_dim
      { \xfss_fix_penalty: }
      {
        \l_xfss_tmp_skip \l_last_skip
        \unskip
        \xfss_fix_penalty:
        \hskip \l_xfss_tmp_skip
      }
  }
\cs_new_protected_nopar:Npn \xfss_fix_penalty:
  {
    \int_compare:nNnTF \tex_lastpenalty:D = 0
      { \tex_italiccor:D }
      {
        \int_set:Nn \l_xfss_tmpa_int \tex_lastpenalty:D
        \tex_unpenalty:D
        \tex_italiccor:D
        \tex_penalty:D \l_xfss_tmpa_int
      }
  }
\tl_set:Nn \nocorrlist {,.}
%    \end{macrocode}
% fixme: "\tex_unpenalty:D", etc., wrappers
%
%    \begin{macrocode}
\int_new:N \l_xfss_tmpa_int
%    \end{macrocode}
%
% \end{macro}
%
%
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareOldFontCommand {mmm}
  {
    \msg_warning:nnx {xfss} {deprecated-function}
      { \token_to_str:N \DeclareOldFontCommand }
  }
%    \end{macrocode}
%
% \subsection{Sizing}
%
%
% \begin{macro}{\xfss_current_fontsize_switch:}
%    \begin{macrocode}
\cs_new:Npn \xfss_current_fontsize_switch: {}
%    \end{macrocode}
% \end{macro}
%
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_set_font_size:Nnn #1#2#3
  {
    \xfss_check_not_math:N #1
    \cs_set_eq:NN \xfss_current_fontsize_switch: #1
    \xfss_set_fontsize:nnn \baselinestretch {#2}{#3}
    \selectfont
  }
%    \end{macrocode}
%
% Temporary just to get things working. Todo: incorporate packages
% \textsf{relsize} and \textsf{extsizes}. N.B. changing the font size
% should be orthogonal to design decisions, probably.
%
% N.B. \LaTeXe\ uses non-integer sizes here so we're being hugely
% incompatible at the moment.
%
% \begin{macro}{\xfss_set_font_size_commands:n}
% Sets the fontsize changing commands automatically based on the following
% relationships:
% \[
% f = f_0 \times 2^{n/8} \qquad b = f^{1.08}
% \]
% where $f$ and $b$ are the fontsize and baselineskip based on a nominal
% fontsize of $f_0$ and size index $n$.
% These equations were derived empircally pretty quickly
% and could be improved.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_set_font_size_commands:n #1
  {
    \xfss_declare_font_cmd:Nnn \tiny         {#1} {-8}
    \xfss_declare_font_cmd:Nnn \scriptsize   {#1} {-4}
    \xfss_declare_font_cmd:Nnn \footnotesize {#1} {-2}
    \xfss_declare_font_cmd:Nnn \small        {#1} {-1}
    \xfss_declare_font_cmd:Nnn \normalsize   {#1} {0}
    \xfss_declare_font_cmd:Nnn \large        {#1} {2}
    \xfss_declare_font_cmd:Nnn \Large        {#1} {4}
    \xfss_declare_font_cmd:Nnn \LARGE        {#1} {6}
    \xfss_declare_font_cmd:Nnn \huge         {#1} {8}
    \xfss_declare_font_cmd:Nnn \Huge         {#1} {10}
    \normalsize
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\xfss_declare_font_cmd:Nnn}
% \begin{arguments}
% \item command
% \item nominal size
% \item size index
% \end{arguments}
% As mentioned above, this is the command that does the calculations
% for the font sizing.
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_declare_font_cmd:Nnn #1#2#3
  {
    \fp_set:Nn \l_xfss_pow_fp {1.0905} % 2^(1/8)
    \fp_pow:Nn \l_xfss_pow_fp {#3}
    \fp_set:Nn \l_xfss_fsize_fp {#2}
    \fp_mul:Nn \l_xfss_fsize_fp {\l_xfss_pow_fp}
    \fp_set:Nn \l_xfss_bskip_fp {\l_xfss_fsize_fp}
    \fp_pow:Nn \l_xfss_bskip_fp {1.08} % empirical
    \xfss_declare_font_cmd_aux:Nxx #1
      {\fp_to_dim:N \l_xfss_fsize_fp} {\fp_to_dim:N \l_xfss_bskip_fp}
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\cs_new_protected:Npn \xfss_declare_font_cmd_aux:Nnn #1#2#3
  {
    \DeclareDocumentCommand #1
      { } { \xfss_set_font_size:Nnn #1 {#2} {#3} }
  }
\cs_generate_variant:Nn \xfss_declare_font_cmd_aux:Nnn {Nxx}
%    \end{macrocode}
%
% When used in \LaTeXe, extract the font size from \cs{normalsize}
% and replace the font changing commands with \pkg{xfss} methods.
% Note that \cs{small}, etc., no longer contain alterations to list settings,
% and so on.
%    \begin{macrocode}
%<*!initex>
\cs_new_nopar:Npn \xfss_extract_normalsize:
  {
    \exp_after:wN \xfss_extract_fsize_aux:Nnnw
    \normalsize \q_nil
  }
\cs_new:Npn \xfss_extract_fsize_aux:Nnnw #1#2#3#4 \q_nil {#3}
\AtBeginDocument
  {
    \exp_args:Nx \xfss_set_font_size_commands:n
      {\xfss_extract_normalsize:}
  }
%</!initex>
%    \end{macrocode}
%
%
% \subsection{NFSS interaction}
% Not yet comprehensive.
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% \subsubsection{Unloading the old commands}
%
%    \begin{macrocode}
\cs_undefine:N \font@name
%    \end{macrocode}
%
% \subsubsection{Supporting NFSS internal commands}
%
%    \begin{macrocode}
\tl_set:Nn \glb@settings {\g_xfss_global_settings_tl}
\tl_set:Nn \tf@size  {\g_xfss_tf_size_tl}
\tl_set:Nn \sf@size  {\g_xfss_sf_size_tl}
\tl_set:Nn \ssf@size {\g_xfss_ssf_size_tl}
\tl_set:Nn \noaccents@ {\g_no_accents_tl}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_set_protected_nopar:Npn \operator@font {\math_operator_font:}
%    \end{macrocode}
%
%    \begin{macrocode}
\tl_replace_once:Nnn \document {\process@table} {\xfss_process_table:}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_set:Npn \xfss_tmp:w #1 \@dofilelist #2 \@defaultsubs #3 \q_nil
  {
    \exp_not:n { #1 \@dofilelist }
    \exp_not:n { \xfss_size_diff_warning: \xfss_subst_warning: }
    \exp_not:n { #3 }
  }
\tl_set:Nx \enddocument { \exp_after:wN \xfss_tmp:w \enddocument \q_nil }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_set_eq:NN \reset@font \normalfont
%    \end{macrocode}
%
% fixme: perhaps patch these in the 2e kernel?
%    \begin{macrocode}
\cs_set_eq:NN \@acci \'
\cs_set_eq:NN \@accii \`
\cs_set_eq:NN \@acciii \=
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \subsection{Epilogue}
%
% \begin{macro}{\file_input:n}
%   Setup all the symbols, font etc.
%    \begin{macrocode}
\file_input:n {xfss-setup.cfg}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@onlypreamble}
% These are out-commented because for Unicode maths we no
% longer have the restriction of loading a small number of fonts.
%
% Some of them may still be wanted, though, so we'll keep them around
% until we know they're no longer required.
%    \begin{macrocode}
%<*package>
% \@onlypreamble\DeclareTextCommand
% \@onlypreamble\DeclareTextSymbol
% \@onlypreamble\DeclareTextCommandDefault
% \@onlypreamble\DeclareTextAccent
% \@onlypreamble\DeclareTextCompositeCommand
% \@onlypreamble\DeclareTextComposite
% \@onlypreamble\DeclareTextSymbolDefault
% \@onlypreamble\DeclareTextAccentDefault
% \@onlypreamble\UndeclareTextCommand
% \@onlypreamble\mathgroup_new:N
% \@onlypreamble\DeclareFontEncoding
% \@onlypreamble\DeclareFontEncoding@
% \@onlypreamble\DeclareFontSubstitution
% \@onlypreamble\DeclareFontEncodingDefaults
% \@onlypreamble\DeclarePreloadSizes
% \@onlypreamble\DeclareMathSizes
% \@onlypreamble\@DeclareMathSizes
% \@onlypreamble\DeclareErrorFont
% \@onlypreamble\DeclareSizeFunction
% \@onlypreamble\xfss_restore_mathversion:
% \@onlypreamble\xfss_init_restore_version:
% \@onlypreamble\xfss_restore_version:
\@onlypreamble \xfss_process_table:
% \@onlypreamble\DeclareMathVersion
% \@onlypreamble\xfss_new_math_version:N
% \@onlypreamble\DeclareSymbolFont
% \@onlypreamble\xfss_new_symbol_font:nnnnn
% \@onlypreamble\SetSymbolFont
% \@onlypreamble\xfss_set_symbol_font:nNn
% \@onlypreamble\xfss_get_cdp:wqN
% \@onlypreamble\DeclareMathAlphabet
% \@onlypreamble\xfss_new_math_alphabet:Nnnnn
% \@onlypreamble\SetMathAlphabet
% \@onlypreamble\xfss_set_math_alphabet:?
% \@onlypreamble\DeclareMathAccent
% \@onlypreamble\math_gset_accent:NNnn
% \@onlypreamble\DeclareMathSymbol
% \@onlypreamble\math_gset_mathcode:NNnn
% \@onlypreamble\math_gset_symbol:NNnn
% \@onlypreamble\DeclareMathDelimiter
% \@onlypreamble\xfss_declare_math_delimiter_aux:nnnn
% \@onlypreamble\xfss_declare_math_delimiter_cs:NNnnnn
% \@onlypreamble\xfss_declare_math_delimiter_aux_ii:nnnnn
% \@onlypreamble\math_gset_delimiter:NNnnnn
% \@onlypreamble\math_gset_delcode:Nnnnn
% \@onlypreamble\DeclareMathRadical
% \@onlypreamble\xfss_mclass_to_int:N
% \@onlypreamble\DeclareSymbolFontAlphabet
% \@onlypreamble\DeclareSymbolFontAlphabet@
% \@onlypreamble\DeclareTextFontCommand
%</package>
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</package|initex>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
%
% \endinput
