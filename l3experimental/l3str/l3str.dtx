% \iffalse meta-comment
%
%% File: l3str.dtx Copyright (C) 2011 The LaTeX3 Project
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% This file is part of the "l3experimental bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%%
%% The released version of this bundle is available from CTAN.
%%
%% -----------------------------------------------------------------------
%%
%% The development version of the bundle can be found at
%%
%%    http://www.latex-project.org/svnroot/experimental/trunk/
%%
%% for those people who are interested.
%%
%%%%%%%%%%%
%% NOTE: %%
%%%%%%%%%%%
%%
%%   Snapshots taken from the repository represent work in progress and may
%%   not work or may contain conflicting material!  We therefore ask
%%   people _not_ to put them into distributions, archives, etc. without
%%   prior consultation with the LaTeX3 Project.
%%
%% -----------------------------------------------------------------------
%
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {L3 Experimental Strings}
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}
\usepackage{amsmath}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%
% \title{^^A
%   The \textsf{l3str} package: manipulating strings of characters^^A
%   \thanks{This file describes v\ExplFileVersion,
%     last revised \ExplFileDate.}^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \ExplFileDate}
%
% \maketitle
%
% \begin{documentation}
%
% \LaTeX3 provides a set of functions to manipulate token lists
% as strings of characters, ignoring the category codes of those
% characters.
%
% String variables are simply specialised token lists, but by convention
% should be named with the suffix \texttt{\ldots str}. Such variables should
% contain characters with category code $12$ (other), except spaces, which
% have category code $10$ (blank space). All the \enquote{safe} functions in
% this module first convert their argument to a string for internal processing,
% and will not treat a token list or the corresponding string representation
% differently.
%
% Most functions in this module come in three flavours:
% \begin{itemize}
%   \item \cs{str_...:N...}, which expect a token list
%     variable as their argument;
%   \item \cs{str_...:n...}, taking any token list (or string) as an argument;
%   \item \cs{str_..._ignore_spaces:n...}, which ignores any space encountered
%     during the operation: these functions are faster than those
%     which take care of escaping spaces appropriately;
% \end{itemize}
% When performance is important, the internal \cs{str_..._unsafe:n...}
% functions, which expect a \enquote{safe} string in which spaces
% have category code $12$ instead of $10$, might be useful.
%
% \section{Conversion and input of strings}
%
% \begin{variable}
%   {
%     \c_backslash_str,
%     \c_lbrace_str,
%     \c_rbrace_str,
%     \c_hash_str,
%     \c_tilde_str,
%     \c_percent_str
%   }
%   Constant strings, containing a single character, with category code $12$.
% \end{variable}
%
% \begin{function}[EXP]{\tl_to_str:N, \tl_to_str:n}
%   \begin{syntax}
%     \cs{tl_to_str:N} \meta{tl var}
%     \cs{tl_to_str:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string}, leaving the resulting
%   tokens in the input stream.
% \end{function}
%
% \begin{function}{\str_const:Nn, \str_const:Nx, \str_const:cn, \str_const:cx}
%   \begin{syntax}
%     \cs{str_const:Nn} \meta{str~var} \Arg{token list}
%   \end{syntax}
%   Creates a new constant \meta{str~var} or raises an error
%   if the name is already taken. The value of the
%   \meta{str~var} will be set globally to the
%   \meta{token list}, after being converted to a string.
% \end{function}
%
% \begin{function}{\str_set:Nn, \str_set:Nx, \str_set:cn, \str_set:cx}
%   \begin{syntax}
%     \cs{str_set:Nn} \meta{str var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string},
%   and saves the result in \meta{str var}.
% \end{function}
%
% \begin{function}{\str_gset:Nn, \str_gset:Nx, \str_gset:cn, \str_gset:cx}
%   \begin{syntax}
%     \cs{str_gset:Nn} \meta{str~var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string},
%   and saves the result in \meta{str~var} globally.
% \end{function}
%
% \begin{function}
%   {
%     \str_put_left:Nn, \str_put_left:Nx,
%     \str_put_left:cn, \str_put_left:cx
%   }
%   \begin{syntax}
%     \cs{str_put_left:Nn} \meta{str var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string},
%   and prepends the result to \meta{str var}.
%   The current contents of the \meta{str var} are not
%   automatically converted to a string.
% \end{function}
%
% \begin{function}
%   {
%     \str_gput_left:Nn, \str_gput_left:Nx,
%     \str_gput_left:cn, \str_gput_left:cx
%   }
%   \begin{syntax}
%     \cs{str_gput_left:Nn} \meta{str var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string},
%   and prepends the result to \meta{str var}, globally.
%   The current contents of the \meta{str var} are not
%   automatically converted to a string.
% \end{function}
%
% \begin{function}
%   {
%     \str_put_right:Nn, \str_put_right:Nx,
%     \str_put_right:cn, \str_put_right:cx
%   }
%   \begin{syntax}
%     \cs{str_put_right:Nn} \meta{str var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string},
%   and appends the result to \meta{str var}.
%   The current contents of the \meta{str var} are not
%   automatically converted to a string.
% \end{function}
%
% \begin{function}
%   {
%     \str_gput_right:Nn, \str_gput_right:Nx,
%     \str_gput_right:cn, \str_gput_right:cx
%   }
%   \begin{syntax}
%     \cs{str_gput_right:Nn} \meta{str var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string},
%   and appends the result to \meta{str var}, globally.
%   The current contents of the \meta{str var} are not
%   automatically converted to a string.
% \end{function}
%
% \begin{function}{\str_input:Nn, \str_ginput:Nn}
%   \begin{syntax}
%     \cs{str_input:Nn} \meta{str var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} into a \meta{string}, and stores
%   it in the \meta{str var}, within the current \TeX{} group level
%   for the \texttt{input} variant and globally for the \texttt{ginput}
%   version.
%   Special characters can be input by
%   escaping them with a backslash.
%   \begin{itemize}
%     \item Spaces are ignored unless escaped with a backslash.
%     \item |\xhh| produces the character with code \texttt{hh}
%       in hexadecimal: when |\x| is encountered, up to two hexadecimal digits
%       (\texttt{0}--\texttt{9}, \texttt{a}--\texttt{f},
%       \texttt{A}--\texttt{F})
%       are read to give a number between $0$ and $255$.
%     \item |\x{hh...}| produces the character with code \texttt{hh...}
%       (an arbitrary number of hexadecimal digits are read):
%       this is mostly useful for \LuaTeX{} and \XeTeX{}.
%     \item |\a|, |\e|, |\f|, |\n|, |\r|, |\t| stand for specific characters:
%     \begin{center}
%       \begin{tabular}{cccc}
%         |\a| & |\^^G| & alarm  & hex \texttt{07} \\
%         |\e| & |\^^[| & escape & hex \texttt{1B} \\
%         |\f| & |\^^L| & form feed & hex \texttt{0C} \\
%         |\n| & |\^^J| & new line  & hex \texttt{0A} \\
%         |\r| & |\^^M| & carriage return & hex \texttt{0D} \\
%         |\t| & |\^^I| & horizontal tab  & hex \texttt{09} \\
%       \end{tabular}
%     \end{center}
%   \end{itemize}
%   For instance,
%   \begin{quote}
%     \cs{tl_new:N} \cs{l_my_str} \\
%     \cs{str_input:Nn} \cs{l_my_str} |{\x3C \\ \# abc\ def\^\n}|
%   \end{quote}
%   results in \cs{l_my_str} containing the characters |<\#abc def^|,
%   followed by a newline character (hex \texttt{0A})
%   since |<| has \textsc{ascii} code \texttt{3C} (in hexadecimal).
% \end{function}
%
% \section{Characters given by their position}
%
% \begin{function}[EXP]
%   {\str_length:N, \str_length:n, \str_length_ignore_spaces:n}
%   \begin{syntax}
%     \cs{str_length:n} \Arg{token list}
%   \end{syntax}
%   Leaves the length of the string representation of \meta{token list}
%   in the input stream as an integer denotation. The functions differ in
%   their treatment of spaces.
%   In the case of \cs{str_length:N} and \cs{str_length:n},
%   all characters including spaces are counted.
%   The \cs{str_length_ignore_spaces:n} leaves the number of non-space
%   characters in the input stream.
%   \begin{texnote}
%     The \cs{str_length:n} of a given token list may depend
%     on the category codes in effect when it is measured,
%     and the value of the \tn{escapechar}: for instance
%     |\str_length:n {\a}| may return $1$, $2$ or $3$ depending
%     on the escape character, and the category code of \texttt{a}.
%   \end{texnote}
% \end{function}
%
% \begin{function}[EXP]{\str_head:N, \str_head:n, \str_head_ignore_spaces:n}
%   \begin{syntax}
%     \cs{str_head:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} into a \meta{string}.
%   The first character in the \meta{string} is then
%   left in the input stream, with category code \enquote{other}.
%   The functions differ in their treatment of spaces.
%   In the case of \cs{str_head:N} and \cs{str_head:n},
%   a leading space is returned with category code $10$ (blank space).
%   The \cs{str_head_ignore_spaces:n} function leaves  the first
%   non-space character in the input stream.
%   If the \meta{token list} is empty (or blank in the case of the
%   \texttt{_ignore_spaces} variant), then nothing is left on the
%   input stream.
% \end{function}
%
% \begin{function}[EXP]{\str_tail:N, \str_tail:n, \str_tail_ignore_spaces:n}
%   \begin{syntax}
%     \cs{str_tail:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string},
%   removes the first character, and leaves
%   the remaining characters (if any) in the input stream,
%   with category codes $12$ and $10$ (for spaces).
%   The functions differ in the case where the first character
%   is a space: \cs{str_tail:N} and \cs{str_tail:n} will trim
%   only that space, while \cs{str_tail_ignore_spaces:n} trims
%   the first non-space character.
% \end{function}
%
% \begin{function}[EXP]{\str_item:Nn, \str_item:nn, \str_item_ignore_spaces:nn}
%   \begin{syntax}
%     \cs{str_item:nn} \Arg{token list} \Arg{integer expression}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string}, and
%   leaves in the input stream the character in position
%   \meta{integer expression} of the \meta{string}.
%   In the case of \cs{str_item:Nn} and \cs{str_item:nn},
%   all characters including spaces are taken into account.
%   The \cs{str_item_ignore_spaces:nn} function skips spaces
%   in its argument.
%   If the \meta{integer expression} is negative, characters
%   are counted from the end of the \meta{string}. Hence, $-1$ is
%   the right-most character, \emph{etc.}, while $0$ is the first
%   (left-most) character.
% \end{function}
%
% \begin{function}[EXP]
%   {\str_substr:Nnn, \str_substr:nnn, \str_substr_ignore_spaces:nnn}
%   \begin{syntax}
%     \cs{str_substr:nnn} \Arg{token list} \Arg{start index} \Arg{end index}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string},
%   and leaves in the input stream the characters
%   between \meta{start index} (inclusive) and \meta{end index} (exclusive).
%   If either of \meta{start index} or \meta{end index} is negative,
%   then it is incremented by the length of the list. Both \meta{start index}
%   and \meta{end index} count from $0$ for the first (left most) character.
% \end{function}
%
% \section{String conditionals}
%
% \begin{function}[EXP, pTF]
%   {
%     \str_if_eq:NN,
%     \str_if_eq:nn, \str_if_eq:Vn, \str_if_eq:on, \str_if_eq:no,
%     \str_if_eq:nV, \str_if_eq:VV, \str_if_eq:xx
%   }
%   \begin{syntax}
%     \cs{str_if_eq_p:nn} \Arg{tl1} \Arg{tl2}
%     \cs{str_if_eq:nnTF} \Arg{tl1} \Arg{tl2} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Compares the two \meta{token lists} on a character by character
%   basis, and is \texttt{true} if the two lists contain the same
%   characters in the same order. Thus for example
%   \begin{verbatim}
%     \str_if_eq_p:xx { abc } { \tl_to_str:n { abc } }
%   \end{verbatim}
%   is logically \texttt{true}. All versions of these functions are fully
%   expandable (including those involving an \texttt{x}-type
%   expansion).
% \end{function}
%
% \begin{function}[EXP, pTF]{\str_if_bytes:N}
%   \begin{syntax}
%     \cs{str_if_bytes:NTF} \meta{str var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the \meta{str var} only contains characters
%   in the range $0$ to $255$. This is automatically true when
%   the pdf\TeX{} is in use.
% \end{function}
%
% \section{Byte conversion}
%
% Byte conversions are necessary where strings are to be used in PDF
% string objects or within URLs. In both cases, only a restricted subset
% of characters are permitted. These functions act on strings of bytes,
% \emph{i.e.}, every character code should be in the interval $[0,255]$.
% Hence, a general string should first be encoded using one of the functions
% described in the following section, which pertains encodings.
%
% \begin{function}[rEXP]
%   {\str_bytes_escape_hexadecimal:n, \str_bytes_unescape_hexadecimal:n}
%   \begin{syntax}
%     \cs{str_bytes_escape_hexadecimal:n} \Arg{token list}
%     \cs{str_bytes_unescape_hexadecimal:n} \Arg{token list}
%   \end{syntax}
%   The \texttt{escape} variant takes each character in the \meta{token list}
%   and converts it into a two-digit hexadecimal representation.
%   Characters codes above $255$ trigger an error.
%   The \texttt{unescape} variant reverses this process.
%   Thus for example
%   \begin{verbatim}
%     \iow_term:x { \str_bytes_escape_hexadecimal:n { Hello ( ) } }
%   \end{verbatim}
%   will print the string |48656C6C6F2829| to the terminal,
%   while
%   \begin{verbatim}
%     \iow_term:x { \str_bytes_unescape_hexadecimal:n { 48656C6C6F2829 } }
%   \end{verbatim}
%   will print the string |Hello()| to the terminal.
%   See also \tn{pdfescapehex}.
% \end{function}
%
% \begin{function}[rEXP]
%   {\str_bytes_escape_name:n, \str_bytes_unescape_name:n}
%   \begin{syntax}
%     \cs{str_bytes_escape_name:n} \Arg{token list}
%     \cs{str_bytes_unescape_name:n} \Arg{token list}
%   \end{syntax}
%   The \texttt{escape} variant takes each character in the \meta{token list}
%   and replaces any which cannot be used directly in a PDF string object
%   with the appropriate hexadecimal representation preceded by the |#|
%   character. The \texttt{unescape} variant reverses this process.
%   Thus for example
%   \begin{verbatim}
%     \iow_term:x { \str_bytes_escape_name:n { Hello ( ) } }
%   \end{verbatim}
%   will print the string |Hello#28#29| to the terminal,
%   while
%   \begin{verbatim}
%     \char_set_catcode_other:N \#
%     \iow_term:x { \str_bytes_unescape_name:n { Hello#28#29 } }
%   \end{verbatim}
%   will print the string |Hello()| to the terminal.
%   See also \tn{pdfescapename}.
% \end{function}
%
% \begin{function}[rEXP]
%   {\str_bytes_escape_string:n, \str_bytes_unescape_string:n}
%   \begin{syntax}
%     \cs{str_bytes_escape_string:n} \Arg{token list}
%     \cs{str_bytes_unescape_string:n} \Arg{token list}
%   \end{syntax}
%   The \texttt{escape} variant takes each character in the \meta{token list}
%   and prepends a |\| to any which cannot be used directly in a PDF string
%   object.  The \texttt{unescape} variant reverses this process.
%   Thus for example
%   \begin{verbatim}
%     \iow_term:x { \str_bytes_escape_string:n { Hello ( ) } }
%   \end{verbatim}
%   will print the string |Hello\(\)| to the terminal,
%   while
%   \begin{verbatim}
%     \iow_term:x { \str_bytes_unescape_string:n { Hello \( \) } }
%   \end{verbatim}
%   will print the string |Hello()| to the terminal.
%   Some characters (for example a space) are converted to a three-digit
%   octal representation, so for example a space gives |\040|.
%   See also \tn{pdfescapestring}.
% \end{function}
%
% \begin{function}[rEXP]
%   {\str_bytes_percent_encode:n, \str_bytes_percent_decode:n}
%   \begin{syntax}
%     \cs{str_bytes_percent_encode:n} \Arg{token list}
%     \cs{str_bytes_percent_decode:n} \Arg{token list}
%   \end{syntax}
%   The \texttt{encode} variant takes each character in the \meta{token list}
%   and replaces any which cannot be used directly in a URL
%   with the appropriate hexadecimal representation preceded by the |%|
%   character. The \texttt{decode} variant reverses this process.
%   Thus for example
%   \begin{verbatim}
%     \iow_term:x { \str_bytes_percent_encode:n { Hello ( ) } }
%   \end{verbatim}
%   will print the string |Hello%28%29| to the terminal,
%   while
%   \begin{verbatim}
%     \char_set_catcode_other:N \%
%     \iow_term:x { \str_bytes_percent_decode:n { Hello%28%29 } }
%   \end{verbatim}
%   will print the string |Hello()| to the terminal.
% \end{function}
%
% \section{Encoding functions}
%
% \begin{function}[rEXP]{\str_bytes_convert:nnn}
%   \begin{syntax}
%     \cs{str_bytes_convert:nnn}
%     ~~ \Arg{encoding 1} \Arg{encoding 2} \Arg{string}
%   \end{syntax}
%   Converts the \meta{string} from \meta{encoding 1} to
%   \meta{encoding 2}, and leaves the result in the input stream.
%   This function is restricted expandable, which means that it
%   should only be used within \texttt{x} or \texttt{c} expansion contexts.
%   Non-alphanumeric characters are ignored in the encoding names,
%   and the names are case insensitive. If either encoding is unknown,
%   an error is raised, and nothing is left in the input stream.
%   If the \meta{string} contains bytes which are not valid
%   in the \meta{encoding 1}, the Unicode replacement character
%   (encoded in the \meta{encoding 2}) is inserted.
%   List of encoding names currently supported:
%   \begin{itemize}
%   \item \texttt{native}
%   \item \texttt{internal}
%   \item \texttt{utf8}
%   \item \texttt{utf16}
%   \item \texttt{utf32}
%   \end{itemize}
%   However, it is not possible to convert to a native
%   string expandably. To produce a native string, see
%   \cs{str_set_convert:Nnn}.
% \end{function}
%
% \begin{function}{\str_set_convert:Nnn}
%   \begin{syntax}
%     \cs{str_set_convert:Nnn} \meta{str var} \Arg{encoding} \Arg{string}
%   \end{syntax}
%   Reads the \meta{string} as encoded with the \meta{encoding},
%   and converts it to a \enquote{native} string.
% \end{function}
%
% \section{Internal string functions}
%
% \begin{function}[EXP]{\tl_to_other_str:N, \tl_to_other_str:n}
%   \begin{syntax}
%     \cs{tl_to_other_str:n} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to an \meta{other string}, where
%   spaces have category code \enquote{other}. These functions create
%   \enquote{safe} strings.
%   \begin{texnote}
%     These functions can be \texttt{f}-expanded without fear of losing
%     a leading space, since spaces do not have category code $10$ in
%     their result.
%   \end{texnote}
% \end{function}
%
% \begin{function}[EXP]{\str_sanitize_args:Nn, \str_sanitize_args:Nnn}
%   \begin{syntax}
%     \cs{str_sanitize_args:Nnn} \meta{function}
%     ~~\Arg{token list1} \Arg{token list2}
%   \end{syntax}
%   Converts the \meta{token lists} to \enquote{safe} strings
%   (where spaces have category code \enquote{other}),
%   and hands-in the result as arguments to \meta{function}.
% \end{function}
%
% \begin{function}{\str_aux_gset_other:Nn}
%   \begin{syntax}
%     \cs{str_aux_gset_other:Nn} \meta{tl~var} \Arg{token list}
%   \end{syntax}
%   Converts the \meta{token list} to an \meta{other string}, where
%   spaces have category code \enquote{other}, and assigns the result
%   to the \meta{tl~var}, globally.
% \end{function}
%
% \begin{function}[rEXP]{\str_map_tokens:Nn, \str_map_tokens:nn}
%   \begin{syntax}
%     \cs{str_map_tokens:Nn} \meta{str var} \meta{tokens}
%   \end{syntax}
%   Maps the \meta{tokens} over every character in the \meta{str var}.
% \end{function}
%
% \begin{function}[EXP, pTF]
%   {\str_if_contains_char:NN, \str_if_contains_char:nN}
%   \begin{syntax}
%     \cs{str_if_contains_char:nN} \Arg{token list} \meta{char}
%   \end{syntax}
%   Converts the \meta{token list} to a \meta{string}
%   and tests whether the \meta{char} is present in the \meta{string}.
%   The \meta{char} can be given either directly, or as a one
%   letter control sequence.
% \end{function}
%
% \begin{function}{\str_aux_escape:NNNn}
%   \begin{syntax}
%     \cs{str_aux_escape:NNNn} \meta{fn1} \meta{fn2} \meta{fn3} \Arg{token list}
%   \end{syntax}
%   The \meta{token list} is converted to a string, then read from
%   left to right, interpreting backslashes as escaping the next character.
%   Unescaped characters are fed to the function \meta{fn1},
%   and escaped characters are fed to the function \meta{fn2}
%   within an \texttt{x}-expansion context (typically those functions
%   perform some tests on their argument to decide how to output them).
%   The escape sequences |\a|, |\e|, |\f|, |\n|, |\r|, |\t| and |\x|
%   are recognized as described for \cs{str_input:Nn}, and those
%   are replaced by the corresponding character, then fed to
%   \meta{fn3}. The result is assigned globally to \cs{g_str_result_tl}.
% \end{function}
%
% \section{Possibilities}
%
% \begin{itemize}
% \item More encodings (see Heiko's \pkg{stringenc}).
%   In particular, what is needed for pdf: \texttt{UTF-16}?
% \item \cs{str_between:nnn} \Arg{str}
%   \Arg{begin delimiter} \Arg{end delimiter} giving the piece of
%   \meta{str} between \meta{begin} and \meta{end}; could be used
%   with empty \meta{begin} or \meta{end} to indicate that we
%   want everything until \meta{end} or starting from \meta{begin},
%   respectively;
% \item \cs{str_count_in:nn} \Arg{str} \Arg{substr} giving the number
%   of occurrences of \meta{substr} in \meta{str};
% \item \cs{str_if_head_eq:nN} alias of \cs{tl_if_head_eq_charcode:nN}
% \item \cs{str_if_numeric/decimal/integer:n}, perhaps in \pkg{l3fp}?
% \end{itemize}
% Some functionalities of \pkg{stringstrings} and \pkg{xstring} as well.
%
%^^A Should "str_item" be "str_char"?
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3str} implementation}
%
%    \begin{macrocode}
%<*initex|package>
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesExplPackage
  {\ExplFileName}{\ExplFileDate}{\ExplFileVersion}{\ExplFileDescription}
%    \end{macrocode}
%
% Those string-related functions are defined in \pkg{l3kernel}.
% \begin{itemize}
%   \item \cs{str_if_eq:nn}[pTF] and variants,
%   \item \cs{str_if_eq_return:on},
%   \item \cs{tl_to_str:n}, \cs{tl_to_str:N}, \cs{tl_to_str:c},
%   \item \cs{token_to_str:N}, \cs{cs_to_str:N}
%   \item \cs{str_head:n}, \cs{str_head_aux:w}, (copied here)
%   \item \cs{str_tail:n}, \cs{str_tail_aux:w}, (copied here)
%   \item \cs{str_length_skip_spaces} (deprecated)
%   \item \cs{str_length_loop:NNNNNNNNN} (unchanged)
% \end{itemize}
%
% \subsection{General functions}
%
% \begin{macro}[EXP,aux]{\use_i:nnnnnnnn}
%   A function which may already be defined elsewhere.
%    \begin{macrocode}
\cs_if_exist:NF \use_i:nnnnnnnn
  { \cs_new:Npn \use_i:nnnnnnnn #1#2#3#4#5#6#7#8 {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}
%   {
%     \c_forty_eight, \c_fifty_eight, \c_sixty_five, \c_ninety_one,
%     \c_ninety_seven, \c_one_hundred_twenty_three,
%     \c_one_hundred_twenty_seven
%   }
%   We declare here some integer values which delimit ranges of
%   ASCII characters of various types. This is mostly used in
%   \pkg{l3regex}.
%    \begin{macrocode}
\int_const:Nn \c_forty_eight  { 48 }
\int_const:Nn \c_fifty_eight  { 58 }
\int_const:Nn \c_sixty_five   { 65 }
\int_const:Nn \c_ninety_one   { 91 }
\int_const:Nn \c_ninety_seven { 97 }
\int_const:Nn \c_one_hundred_twenty_three { 123 }
\int_const:Nn \c_one_hundred_twenty_seven { 127 }
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}
%   {
%     \str_set:Nn, \str_set:Nx,
%     \str_set:cn, \str_set:cx,
%     \str_gset:Nn, \str_gset:Nx,
%     \str_gset:cn, \str_gset:cx,
%     \str_const:Nn, \str_const:Nx,
%     \str_const:cn, \str_const:cx,
%     \str_put_left:Nn, \str_put_left:Nx,
%     \str_put_left:cn, \str_put_left:cx,
%     \str_gput_left:Nn, \str_gput_left:Nx,
%     \str_gput_left:cn, \str_gput_left:cx,
%     \str_put_right:Nn, \str_put_right:Nx,
%     \str_put_right:cn, \str_put_right:cx,
%     \str_gput_right:Nn, \str_gput_right:Nx,
%     \str_gput_right:cn, \str_gput_right:cx,
%   }
%   Simply convert the token list inputs to \meta{strings}.
%    \begin{macrocode}
\group_begin:
  \cs_set_protected_nopar:Npn \str_tmp:w #1
    {
      \cs_new_protected:cpx { str_ #1 :Nn } ##1##2
        { \exp_not:c { tl_ #1 :Nx } ##1 { \exp_not:N \tl_to_str:n {##2} } }
      \exp_args:Nc \cs_generate_variant:Nn { str_ #1 :Nn } { Nx , cn , cx }
    }
  \str_tmp:w { set }
  \str_tmp:w { gset }
  \str_tmp:w { const }
  \str_tmp:w { put_left }
  \str_tmp:w { gput_left }
  \str_tmp:w { put_right }
  \str_tmp:w { gput_right }
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \subsection{Variables and constants}
%
% \begin{macro}{\str_tmp:w}
% \begin{variable}{\g_str_tmpa_tl}
%   Internal scratch space for some functions.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \str_tmp:w { }
\tl_new:N \g_str_tmpa_tl
%    \end{macrocode}
% \end{variable}
% \end{macro}
%
% \begin{variable}{\g_str_result_tl}
%   The \cs{g_str_result_tl} variable is used to hold the result
%   of various internal string operations which are typically
%   performed in a group. The variable is global so that it remains
%   defined outside the group, to be assigned to a user provided variable.
%    \begin{macrocode}
\tl_new:N \g_str_result_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_str_char_int, \l_str_bytes_int}
%   When converting from various escaped forms to raw characters,
%   we often need to read several digits (hexadecimal or octal depending
%   on the case) and keep track of the corresponding character code
%   in \cs{l_str_char_int}. For \textsc{utf-8} support, the number of bytes
%   of for the current character is stored in \cs{l_str_bytes_int}.
%    \begin{macrocode}
\int_new:N \l_str_char_int
\int_new:N \l_str_bytes_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \c_backslash_str,
%     \c_lbrace_str,
%     \c_rbrace_str,
%     \c_hash_str,
%     \c_tilde_str,
%     \c_percent_str
%   }
%   For all of those strings, \cs{cs_to_str:N} produce characters
%   with the correct category code.
%    \begin{macrocode}
\tl_const:Nx \c_backslash_str { \cs_to_str:N \\ }
\tl_const:Nx \c_lbrace_str    { \cs_to_str:N \{ }
\tl_const:Nx \c_rbrace_str    { \cs_to_str:N \} }
\tl_const:Nx \c_hash_str      { \cs_to_str:N \# }
\tl_const:Nx \c_tilde_str     { \cs_to_str:N \~ }
\tl_const:Nx \c_percent_str   { \cs_to_str:N \% }
%    \end{macrocode}
% \end{variable}
%
% \subsection{Internal functions}
%
% \subsubsection{Escaping spaces}
%
% \begin{macro}[EXP]{\tl_to_other_str:N, \tl_to_other_str:n}
% \begin{macro}[EXP,aux]{\tl_to_other_str_loop:w, \tl_to_other_str_end:w}
%   Replaces all spaces by \enquote{other} spaces, after converting
%   the token list to a string via \cs{tl_to_str:n}.
%    \begin{macrocode}
\group_begin:
\char_set_lccode:nn { `\* } { `\  }
\char_set_lccode:nn { `\A } { `\A }
\tl_to_lowercase:n
  {
    \group_end:
    \cs_new:Npn \tl_to_other_str:n #1
      {
        \exp_after:wN \tl_to_other_str_loop:w \tl_to_str:n {#1} ~ %
        A ~ A ~ A ~ A ~ A ~ A ~ A ~ A ~ \q_mark \q_stop
      }
    \cs_new_nopar:Npn \tl_to_other_str_loop:w
      #1 ~ #2 ~ #3 ~ #4 ~ #5 ~ #6 ~ #7 ~ #8 ~ #9 \q_stop
      {
        \if_meaning:w A #8
          \tl_to_other_str_end:w
        \fi:
        \tl_to_other_str_loop:w
        #9 #1 * #2 * #3 * #4 * #5 * #6 * #7 * #8 * \q_stop
      }
    \cs_new_nopar:Npn \tl_to_other_str_end:w \fi: #1 \q_mark #2 * A #3 \q_stop
      { \fi: #2 }
  }
\cs_new_nopar:Npn \tl_to_other_str:N { \exp_args:No \tl_to_other_str:n }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_sanitize_args:Nn, \str_sanitize_args:Nnn}
%   Here, \texttt{f}-expansion does not lose leading spaces,
%   since they have catcode \enquote{other} after \cs{str_sanitize:n}.
%    \begin{macrocode}
\cs_new:Npn \str_sanitize_args:Nn #1#2
  { \exp_args:Nf #1 { \tl_to_other_str:n {#2} } }
\cs_new:Npn \str_sanitize_args:Nnn #1#2#3
  {
    \exp_args:Nff #1
      { \tl_to_other_str:n {#2} }
      { \tl_to_other_str:n {#3} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\str_aux_gset_other:Nn}
% \begin{macro}[aux,EXP]{\str_aux_gset_other_loop:w}
% \begin{macro}[aux,EXP]{\str_aux_gset_other_end:w}
%    \begin{macrocode}
\group_begin:
\char_set_lccode:nn { `\* } { `\  }
\char_set_lccode:nn { `\A } { `\A }
\tl_to_lowercase:n
  {
    \group_end:
    \cs_new_protected:Npn \str_aux_gset_other:Nn #1#2
      {
        \tl_gset:Nx #1
          {
            \exp_after:wN \str_aux_gset_other_loop:w \tl_to_str:n {#2} ~ %
            A ~ A ~ A ~ A ~ A ~ A ~ A ~ A ~ A ~ \q_mark \q_stop
          }
      }
    \cs_new_nopar:Npn \str_aux_gset_other_loop:w
      #1 ~ #2 ~ #3 ~ #4 ~ #5 ~ #6 ~ #7 ~ #8 ~ #9 ~
      {
        \if_meaning:w A #9
          \str_aux_gset_other_end:w
        \fi:
        #1 * #2 * #3 * #4 * #5 * #6 * #7 * #8 * #9
        \str_aux_gset_other_loop:w *
      }
    \cs_new_nopar:Npn \str_aux_gset_other_end:w \fi: #1 * A #2 \q_stop
      { \fi: #1 }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Mapping}
%
% \begin{macro}[rEXP,int]{\str_map_tokens:nn}
% \begin{macro}[rEXP,int]{\str_map_tokens:Nn}
% \begin{macro}[rEXP,aux]{\str_map_tokens_aux:nn}
% \begin{macro}[rEXP,aux]{\str_map_tokens_loop:nw}
% \begin{macro}[rEXP,aux]{\str_map_tokens_loop:nN}
% \begin{macro}[rEXP,int]{\str_map_break_do:n}
%   We simply need to be careful with spaces.
%   Spaces are fed to the mapped tokens with
%   category code $12$, not $10$.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_map_tokens:Nn
  { \exp_args:No \str_map_tokens:nn }
\cs_new:Npn \str_map_tokens:nn #1
  { \exp_args:No \str_map_tokens_aux:nn { \tl_to_str:n {#1} } }
\cs_new:Npn \str_map_tokens_aux:nn #1#2
  {
    \str_map_tokens_loop:nw {#2} #1
      { ? \use_none_delimit_by_q_recursion_stop:w }
      ?~ ?~ ?~ ?~ ?~ ?~ ?~ ?~ \q_recursion_stop
  }
\group_begin:
  \char_set_lccode:nn { `* } { `\ }
  \tl_to_lowercase:n
    {
      \group_end:
      \cs_new:Npn \str_map_tokens_loop:nw #1 #2~ #3~ #4~ #5~ #6~ #7~ #8~ #9~
        {
          \str_map_tokens_loop:nN {#1} #2* #3* #4* #5* #6* #7* #8* #9*
            { ? \use_none_delimit_by_q_stop:w } \q_stop
          \str_map_tokens_loop:nw {#1}
        }
    }
\cs_new:Npn \str_map_tokens_loop:nN #1#2
  {
    \use_none:n #2
    #1 #2
    \str_map_tokens_loop:nN {#1}
  }
\cs_new_eq:NN \str_map_break_do:n \use_i_delimit_by_q_recursion_stop:nw
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Characters given by their position}
%
% \begin{macro}[EXP]{\str_length:N}
% \begin{macro}[EXP]{\str_length:n}
% \begin{macro}[EXP]{\str_length_ignore_spaces:n}
% \begin{macro}[EXP]{\str_length_unsafe:n}
% \begin{macro}[EXP,aux]{\str_length_aux:n,\str_length_loop:NNNNNNNNN}
%   The length of a string is found by first changing all spaces
%   to other spaces using \cs{tl_to_other_str:n}, then counting
%   characters $9$ at a time. When the end is reached, |#9|
%   has the form |X|\meta{digit}, the catcode test is true,
%   the digit gets added to the sum, and the loop is terminated
%   by \cs{use_none_delimit_by_q_stop:w}.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_length:N { \exp_args:No \str_length:n }
\cs_new:Npn \str_length:n { \str_sanitize_args:Nn \str_length_unsafe:n }
\cs_new_nopar:Npn \str_length_unsafe:n #1
  { \str_length_aux:n { \str_length_loop:NNNNNNNNN #1 } }
\cs_new:Npn \str_length_ignore_spaces:n #1
  {
    \str_length_aux:n
      { \exp_after:wN \str_length_loop:NNNNNNNNN \tl_to_str:n {#1} }
  }
\cs_new:Npn \str_length_aux:n #1
  {
    \int_eval:n
      {
        #1
        { X \c_eight } { X \c_seven } { X \c_six   }
        { X \c_five  } { X \c_four  } { X \c_three }
        { X \c_two   } { X \c_one   } { X \c_zero  }
        \q_stop
      }
  }
\cs_set:Npn \str_length_loop:NNNNNNNNN #1#2#3#4#5#6#7#8#9
  {
    \if_catcode:w X #9
      \exp_after:wN \use_none_delimit_by_q_stop:w
    \fi:
    \c_nine + \str_length_loop:NNNNNNNNN
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_head:N}
% \begin{macro}[EXP]{\str_head:n}
% \begin{macro}[EXP]{\str_head_ignore_spaces:n}
% \begin{macro}[EXP]{\str_head_unsafe:n}
% \begin{macro}[EXP,aux]{\str_head_aux:w}
%   The cases of \cs{str_head_ignore_spaces:n} and
%   \cs{str_head_unsafe:n} are mostly identical to
%   \cs{tl_head:n}.
%   As usual, \cs{str_head:N} expands its argument and hands it to
%   \cs{str_head:n}. To circumvent the fact that \TeX{} skips spaces
%   when grabbing undelimited macro parameters, \cs{str_head_aux:w}
%   takes an argument delimited by a space. If |#1| starts with a
%   non-space character, \cs{use_i_delimit_by_q_stop:nw} leaves that
%   in the input stream. On the other hand, if |#1| starts with a
%   space, the \cs{str_head_aux:w} takes an empty argument, and
%   the single (braced) space in the definition of \cs{str_head_aux:w}
%   makes its way to the output. Finally, for an empty argument,
%   the (braced) empty brace group in the definition of \cs{str_head:n}
%   gives an empty result after passing through
%   \cs{use_i_delimit_by_q_stop:nw}.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_head:N { \exp_args:No \str_head:n }
\cs_set:Npn \str_head:n #1
  {
    \exp_after:wN \str_head_aux:w
    \tl_to_str:n {#1}
    { { } } ~ \q_stop
  }
\cs_set_nopar:Npn \str_head_aux:w #1 ~ %
  { \use_i_delimit_by_q_stop:nw #1 { ~ } }
\cs_new:Npn \str_head_ignore_spaces:n #1
  { \exp_after:wN \use_i_delimit_by_q_stop:nw \tl_to_str:n {#1} { } \q_stop }
\cs_new_nopar:Npn \str_head_unsafe:n #1
  { \use_i_delimit_by_q_stop:nw #1 { } \q_stop }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_tail:N}
% \begin{macro}[EXP]{\str_tail:n}
% \begin{macro}[EXP]{\str_tail_ignore_spaces:n}
% \begin{macro}[EXP]{\str_tail_unsafe:n}
% \begin{macro}[EXP,aux]{\str_tail_aux:w}
% \begin{macro}[EXP,aux]{\str_tail_aux_ii:w}
%   As when fetching the head of a string, the cases
%   \enquote{\texttt{ignore_spaces:n}} and \enquote{\texttt{unsafe:n}}
%   are similar to \cs{tl_tail:n}.
%   The more commonly used \cs{str_tail:n} function is a little bit
%   more convoluted: hitting the front of the string with
%   \cs{reverse_if:N} \cs{if_charcode:w} \cs{scan_stop:}
%   removes the first character (which necessarily makes the test true,
%   since it cannot match \cs{scan_stop:}). The auxiliary function inserts
%   the required \cs{fi:} to close the conditional, and leaves the tail
%   of the string in the input string. The details are such that an empty
%   string has an empty tail.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_tail:N { \exp_args:No \str_tail:n }
\cs_set:Npn \str_tail:n #1
  {
    \exp_after:wN \str_tail_aux:w
    \reverse_if:N \if_charcode:w
        \scan_stop: \tl_to_str:n {#1} X X \q_stop
  }
\cs_set_nopar:Npn \str_tail_aux:w #1 X #2 \q_stop { \fi: #1 }
\cs_new:Npn \str_tail_ignore_spaces:n #1
  {
    \exp_after:wN \str_tail_aux_ii:w
    \tl_to_str:n {#1} X { } X \q_stop
  }
\cs_new_nopar:Npn \str_tail_unsafe:n #1
  { \str_tail_aux_ii:w #1 X { } X \q_stop }
\cs_new_nopar:Npn \str_tail_aux_ii:w #1 #2 X #3 \q_stop { #2 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,int]{\str_skip_do:nn}
% \begin{macro}[EXP,aux]{\str_skip_aux:nnnnnnnnn}
% \begin{macro}[EXP,aux]{\str_skip_end:nn}
% \begin{macro}[EXP,aux]{\str_skip_end_ii:nwn}
%   Removes |max(#1,0)| characters then leaves |#2| in the input stream.
%   We remove characters $7$ at a time. When the number of characters
%   to remove is not a multiple of $7$, we need to remove less than
%   $7$ characters in the last step. This is done by inserting a number
%   of \texttt{X}, which are discarded as if they were part of the string.
%    \begin{macrocode}
\cs_new:Npn \str_skip_do:nn #1
  {
    \if_num:w \int_eval:w #1 > \c_seven
      \exp_after:wN \str_skip_aux:nnnnnnnnn
    \else:
      \exp_after:wN \str_skip_end:n
    \fi:
      {#1}
  }
\cs_new:Npn \str_skip_aux:nnnnnnnnn #1#2#3#4#5#6#7#8#9
  { \exp_args:Nf \str_skip_do:nn { \int_eval:n { #1 - \c_seven } } {#2} }
\cs_new:Npn \str_skip_end:n #1
  {
    \if_case:w \int_eval:w #1 \int_eval_end:
         \str_skip_end_ii:nwn { XXXXXXX }
    \or: \str_skip_end_ii:nwn { XXXXXX }
    \or: \str_skip_end_ii:nwn { XXXXX }
    \or: \str_skip_end_ii:nwn { XXXX }
    \or: \str_skip_end_ii:nwn { XXX }
    \or: \str_skip_end_ii:nwn { XX }
    \or: \str_skip_end_ii:nwn { X }
    \or: \str_skip_end_ii:nwn {  }
    \else: \str_skip_end_ii:nwn { XXXXXXX }
    \fi:
  }
\cs_new:Npn \str_skip_end_ii:nwn #1#2 \fi: #3
  { \fi: \use_i:nnnnnnnn {#3} #1 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,int]{\str_collect_do:nn}
% \begin{macro}[EXP,aux]{\str_collect_aux:n,\str_collect_aux:nnNNNNNNN}
% \begin{macro}[EXP,aux]
%   {
%     \str_collect_end:nn,
%     \str_collect_end_ii:nwn,
%     \str_collect_end_iii:nwNNNNNNN
%   }
%   Collects |max(#1,0)| characters, and feeds them as an argument to |#2|.
%   Again, we grab $7$ characters at a time. Instead of inserting
%   a string of \texttt{X} to fill in to a multiple of $7$, we insert
%   empty groups, so that they disappear in this context where arguments
%   are accumulated.
%    \begin{macrocode}
\cs_new:Npn \str_collect_do:nn #1#2
  { \str_collect_aux:n {#1} { \str_collect_end_iii:nwNNNNNNN {#2} } }
\cs_new:Npn \str_collect_aux:n #1
  {
    \int_compare:nNnTF {#1} > \c_seven
      { \str_collect_aux:nnNNNNNNN }
      { \str_collect_end:n }
      {#1}
  }
\cs_new:Npn \str_collect_aux:nnNNNNNNN #1#2 #3#4#5#6#7#8#9
  {
    \exp_args:Nf \str_collect_aux:n
      { \int_eval:n { #1 - \c_seven } }
      { #2 #3#4#5#6#7#8#9 }
  }
\cs_new:Npn \str_collect_end:n #1
  {
    \if_case:w \int_eval:w #1 \int_eval_end:
         \str_collect_end_ii:nwn { { } { } { } { } { } { } { } }
    \or: \str_collect_end_ii:nwn { { } { } { } { } { } { } }
    \or: \str_collect_end_ii:nwn { { } { } { } { } { } }
    \or: \str_collect_end_ii:nwn { { } { } { } { } }
    \or: \str_collect_end_ii:nwn { { } { } { } }
    \or: \str_collect_end_ii:nwn { { } { } }
    \or: \str_collect_end_ii:nwn { { } }
    \or: \str_collect_end_ii:nwn {  }
    \else: \str_collect_end_ii:nwn { { } { } { } { } { } { } { } }
    \fi:
  }
\cs_new:Npn \str_collect_end_ii:nwn #1#2 \fi: #3
  { \fi: #3 \q_stop #1 }
\cs_new:Npn \str_collect_end_iii:nwNNNNNNN #1 #2 \q_stop #3#4#5#6#7#8#9
  { #1 {#2#3#4#5#6#7#8#9} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_item:Nn}
% \begin{macro}[EXP]{\str_item:nn}
% \begin{macro}[EXP]{\str_item_ignore_spaces:nn}
% \begin{macro}[EXP]{\str_item_unsafe:nn}
% \begin{macro}[EXP,aux]{\str_item_aux:nn}
%   This is mostly shuffling arguments around to avoid measuring
%   the length of the string more than once, and make sure that
%   the parameters given to \cs{str_skip_do:nn} are necessarily
%   within the bounds of the length of the string.
%   The \cs{str_item_ignore_spaces:nn} function cheats a little bit
%   in that it doesn't hand to \cs{str_item_unsafe:nn} a truly
%   \enquote{safe} string. This is alright, as everything else
%   is done with undelimited arguments.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_item:Nn { \exp_args:No \str_item:nn }
\cs_new:Npn \str_item:nn #1#2
  {
    \exp_args:Nf \tl_to_str:n
      { \str_sanitize_args:Nn \str_item_unsafe:nn {#1} {#2} }
  }
\cs_new:Npn \str_item_ignore_spaces:nn #1
  { \exp_args:No \str_item_unsafe:nn { \tl_to_str:n {#1} } }
\cs_new_nopar:Npn \str_item_unsafe:nn #1#2
  {
    \exp_args:Nff \str_item_aux:nn
      { \int_eval:n {#2} }
      { \str_length_unsafe:n {#1} }
      #1
    \q_stop
  }
\cs_new_nopar:Npn \str_item_aux:nn #1#2
  {
    \int_compare:nNnTF {#1} < \c_zero
      {
        \int_compare:nNnTF {#1} < {-#2}
          { \use_none_delimit_by_q_stop:w }
          {
            \str_skip_do:nn { #1 + #2 }
              { \use_i_delimit_by_q_stop:nw }
          }
      }
      {
        \int_compare:nNnTF {#1} < {#2}
          {
            \str_skip_do:nn {#1}
              { \use_i_delimit_by_q_stop:nw }
          }
          { \use_none_delimit_by_q_stop:w }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\str_substr:Nnn}
% \begin{macro}[EXP]{\str_substr:nnn}
% \begin{macro}[EXP]{\str_substr_ignore_spaces:nnn}
% \begin{macro}[EXP]{\str_substr_unsafe:nnn}
% \begin{macro}[EXP,aux]{\str_substr_aux:nnnw}
% \begin{macro}[EXP,aux]{\str_substr_aux_ii:nnw}
% \begin{macro}[EXP,aux]{\str_aux_eval_args:Nnnn}
% \begin{macro}[EXP,aux]{\str_aux_normalize_range:nn}
%   Sanitize the string, then limit the second and third arguments
%   to be at most the length of the string (this avoids needing
%   to check for the end of the string when grabbing characters).
%   Afterwards, skip characters, then keep some more, and finally
%   drop the end of the string.
%    \begin{macrocode}
\cs_new_nopar:Npn \str_substr:Nnn { \exp_args:No \str_substr:nnn }
\cs_new:Npn \str_substr:nnn #1#2#3
  {
    \exp_args:Nf \tl_to_str:n
      { \str_sanitize_args:Nn \str_substr_unsafe:nnn {#1} {#2} {#3} }
  }
\cs_new:Npn \str_substr_ignore_spaces:nnn #1
  { \exp_args:No \str_substr_unsafe:nnn { \tl_to_str:n {#1} } }
\cs_new:Npn \str_substr_unsafe:nnn #1#2#3
  {
    \str_aux_eval_args:Nnnn \str_substr_aux:nnnw
      { \str_length_unsafe:n {#1} }
      {#2}
      {#3}
      #1
    \q_stop
  }
\cs_new:Npn \str_substr_aux:nnnw #1#2#3
  {
    \exp_args:Nf \str_substr_aux_ii:nnw
      { \str_aux_normalize_range:nn {#2} {#1} }
      { \str_aux_normalize_range:nn {#3} {#1} }
  }
\cs_new:Npn \str_substr_aux_ii:nnw #1#2
  {
    \str_skip_do:nn {#1}
      {
        \exp_args:Nf \str_collect_do:nn
          { \int_eval:n { #2 - #1 } }
          { \use_i_delimit_by_q_stop:nw }
      }
  }
\cs_new:Npn \str_aux_eval_args:Nnnn #1#2#3#4
  {
    \exp_after:wN #1
    \exp_after:wN { \int_value:w \int_eval:w #2 \exp_after:wN }
    \exp_after:wN { \int_value:w \int_eval:w #3 \exp_after:wN }
    \exp_after:wN { \int_value:w \int_eval:w #4 }
  }
\cs_new:Npn \str_aux_normalize_range:nn #1#2
  {
    \int_eval:n
      {
        \if_num:w #1 < \c_zero
          \if_num:w #1 < - #2 \exp_stop_f:
            \c_zero
          \else:
            #1 + #2
          \fi:
        \else:
          \if_num:w #1 < #2 \exp_stop_f:
            #1
          \else:
            #2
          \fi:
        \fi:
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{String conditionals}
%
% \begin{macro}[EXP,pTF]{\str_if_eq:NN}
% \begin{macro}[EXP,pTF]{\str_if_eq:nn,\str_if_eq:xx}
%   The \texttt{nn} and \texttt{xx} variants are already
%   defined in \pkg{l3basics}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \str_if_eq:NN #1#2 { p , TF , T , F }
  {
    \if_int_compare:w \pdftex_strcmp:D { \tl_to_str:N #1 } { \tl_to_str:N #2 }
      = \c_zero \prg_return_true: \else: \prg_return_false: \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\str_if_contains_char:NN}
% \begin{macro}[EXP,pTF]{\str_if_contains_char:nN}
% \begin{macro}[EXP,aux]{\str_if_contains_char_aux:NN}
% \begin{macro}[EXP,aux]{\str_if_contains_char_end:w}
%   Loop over the characters of the string, comparing character codes.
%   We allow |#2| to be a single-character control sequence, hence the
%   use of \cs{int_compare:nNnT} rather than \cs{token_if_eq_charcode:NNT}.
%   The loop is broken if character codes match. Otherwise we return
%   \enquote{false}.
%    \begin{macrocode}
\prg_new_conditional:Npnn \str_if_contains_char:NN #1#2 { p , T , F , TF }
  {
    \str_map_tokens:Nn #1 { \str_if_contains_char_aux:NN #2 }
    \prg_return_false:
  }
\prg_new_conditional:Npnn \str_if_contains_char:nN #1#2 { p , T , F , TF }
  {
    \str_map_tokens:nn {#1} { \str_if_contains_char_aux:NN #2 }
    \prg_return_false:
  }
\cs_new_nopar:Npn \str_if_contains_char_aux:NN #1#2
  {
    \if_num:w `#1 = `#2 \exp_stop_f:
      \str_if_contains_char_end:w
    \fi:
  }
\cs_new_nopar:Npn \str_if_contains_char_end:w \fi: #1 \prg_return_false:
  { \fi: \prg_return_true: }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\str_if_bytes:N}
% \begin{macro}[EXP,aux]{\str_if_bytes_aux:N}
%   Loop over the string, checking if every character code is less than $256$.
%    \begin{macrocode}
\prg_new_conditional:Npnn \str_if_bytes:N #1 { p , T , F , TF }
  {
    \str_map_tokens:Nn #1 { \str_if_bytes_aux:N }
    \prg_return_true:
  }
\cs_new_nopar:Npn \str_if_bytes_aux:N #1
  {
    \int_compare:nNnF {`#1} < \c_two_hundred_fifty_six
      {
        \use_i_delimit_by_q_recursion_stop:nw
          { \prg_return_false: \use_none:n }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Conversions}
%
% \subsubsection{Internal conditionals}
%
% \begin{macro}[aux]{\str_aux_hexadecimal_test:NTF}
%   This test is used when reading hexadecimal digits, for the |\x| escape
%   sequence. It returns \meta{true} if the
%   token is a hexadecimal digit, and \meta{false} otherwise. It has the
%   additional side-effect of updating the value of
%   \cs{l_str_char_int} (number formed in base $16$ from the digits
%   read so far).
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \str_aux_hexadecimal_test:N #1 { TF }
  {
    \tl_if_in:onTF { \tl_to_str:n { abcdef } } {#1}
      {
        \int_set:Nn \l_str_char_int
          { \c_sixteen * \l_str_char_int + `#1 - 87 }
        \prg_return_true:
      }
      {
        \if_num:w \c_fifteen < "1 \exp_not:N #1 \exp_stop_f:
          \int_set:Nn \l_str_char_int
            { \c_sixteen * \l_str_char_int + "#1 }
          \prg_return_true:
        \else:
          \prg_return_false:
        \fi:
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\str_aux_octal_use:NTF}
%    \begin{macrocode}
\prg_new_conditional:Npnn \str_aux_octal_use:N #1 { TF }
  {
    \if_num:w \c_two < '1 #1 \exp_stop_f:
      #1 \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux]{\str_aux_hexadecimal_use:NTF}
%    \begin{macrocode}
\prg_new_conditional:Npnn \str_aux_hexadecimal_use:N #1 { TF }
  {
    \if_num:w \c_two < "1 #1 \exp_stop_f:
      #1 \prg_return_true:
    \else:
      \if_case:w \int_eval:w `#1 - `a \int_eval_end:
           A \prg_return_true:
      \or: B \prg_return_true:
      \or: C \prg_return_true:
      \or: D \prg_return_true:
      \or: E \prg_return_true:
      \or: F \prg_return_true:
      \else: \prg_return_false:
      \fi:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Producing one byte or character}
%
% \begin{macro}[int]{\str_byte:n}
% \begin{macro}[int]{\str_byte_hexadecimal:n}
% \begin{macro}[aux]{\str_byte:w, \str_byte_end:}
%   For now, no error detection.
%   The value $-1$ produces an empty result: this is used in
%   \cs{str_bytes_unescape_hexadecimal:NN}.
%    \begin{macrocode}
\cs_new:Npn \str_byte_hexadecimal:n #1 { \str_byte:n { "#1 } }
\cs_new:Npn \str_byte:n #1 { \str_byte:w #1 \str_byte_end: }
\cs_new:Npn \str_byte:w { \cs:w c_str_byte_ \int_use:N \int_eval:w }
\cs_new:Npn \str_byte_end: { \int_eval_end: _tl \cs_end: }
\group_begin:
  \char_set_catcode_other:N \^^@
  \prg_stepwise_inline:nnnn { 0 } { 1 } { 255 }
    {
      \char_set_lccode:nn { \c_zero } { #1 }
      \tl_to_lowercase:n { \tl_const:cn { c_str_byte_#1_tl } { ^^@ } }
    }
\group_end:
\tl_const:cn { c_str_byte_-1_tl } { }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_aux_convert_store:}
% \begin{variable}{\c_max_char_int}
%   This is non-expandable.
%    \begin{macrocode}
\pdftex_if_engine:TF
  { \int_const:Nn \c_max_char_int { 255 } }
  { \int_const:Nn \c_max_char_int { 1114111 } }
\group_begin:
  \char_set_catcode_other:n { `\^^@ }
  \cs_new_protected_nopar:Npn \str_aux_convert_store:
    {
      \if_int_compare:w \l_str_char_int > \c_max_char_int
        \msg_kernel_error:nnx { str } { utf-8-pdftex-overflow }
          { \int_use:N \l_str_char_int }
      \else:
        \tex_lccode:D \c_zero \l_str_char_int
        \tl_to_lowercase:n { \tl_gput_right:Nx \g_str_result_tl {^^@} }
      \fi:
    }
\group_end:
%    \end{macrocode}
% \end{variable}
% \end{macro}
%
% \subsubsection{Unescape user input}
%
% The code of this section is used both here for \cs{str_(g)input:Nn},
% and in the regular expression module to go through the regular expression
% once before actually parsing it. The goal in that case is to turn any
% character with a meaning in regular expressions (\texttt{*}, \texttt{?},
% \texttt{\{}, etc.) into a marker indicating that this was a special
% character,
% and replace any escaped character by the corresponding unescaped character,
% so that the \pkg{l3regex} code can avoid caring about escaping issues
% (those can become quite complex to handle in combination with ranges
% in character classes).
%
% The idea is to feed unescaped characters to one function,
% escaped characters to another, and feed |\a|, |\e|, |\f|,
% |\n|, |\r|, |\t| and |\x| converted to the appropriate
% character to a third function. Spaces are ignored unless
% escaped.
% For the \cs{str_(g)input:Nn} application, all the functions are simply
% \cs{token_to_str:N} (this ensures that spaces correctly get assigned
% category code $10$).
% For the \pkg{l3regex} applications, the functions do some further
% tests on the character they receive.
%
% \begin{macro}{\str_input:Nn,\str_ginput:Nn}
%   Simple wrappers around the internal \cs{str_aux_escape:NNNn}.
%    \begin{macrocode}
\cs_new_protected:Npn \str_input:Nn #1#2
  {
    \str_aux_escape:NNNn \token_to_str:N \token_to_str:N \token_to_str:N {#2}
    \tl_set_eq:NN #1 \g_str_result_tl
  }
\cs_new_protected:Npn \str_ginput:Nn #1#2
  {
    \str_aux_escape:NNNn \token_to_str:N \token_to_str:N \token_to_str:N {#2}
    \tl_gset_eq:NN #1 \g_str_result_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\str_aux_escape:NNNn}
% \begin{macro}[aux]{\str_aux_escape_unescaped:N}
% \begin{macro}[aux]{\str_aux_escape_escaped:N}
% \begin{macro}[aux]{\str_aux_escape_raw:N}
% \begin{macro}[aux]{\str_aux_escape_loop:N}
% \begin{macro}[aux]+\str_aux_escape_\:w+
%   Treat the argument as an \meta{escaped string},
%   and store the corresponding \meta{string} globally
%   in \cs{g_str_result_tl}.
%    \begin{macrocode}
\cs_new_eq:NN \str_aux_escape_unescaped:N \use:n
\cs_new_eq:NN \str_aux_escape_escaped:N   \use:n
\cs_new_eq:NN \str_aux_escape_raw:N       \use:n
\cs_new_protected:Npn \str_aux_escape:NNNn #1#2#3#4
  {
    \group_begin:
      \cs_set_nopar:Npn \str_aux_escape_unescaped:N { #1 }
      \cs_set_nopar:Npn \str_aux_escape_escaped:N { #2 }
      \cs_set_nopar:Npn \str_aux_escape_raw:N { #3 }
      \int_set:Nn \tex_escapechar:D { 92 }
      \str_aux_gset_other:Nn \g_str_result_tl {#4}
      \tl_gset:Nx \g_str_result_tl
        {
          \exp_after:wN \str_aux_escape_loop:N \g_str_result_tl
          \q_recursion_tail \q_recursion_stop
        }
    \group_end:
  }
\cs_new_nopar:Npn \str_aux_escape_loop:N #1
  {
    \cs_if_exist_use:cF { str_aux_escape_\token_to_str:N #1:w }
      { \str_aux_escape_unescaped:N #1 }
    \str_aux_escape_loop:N
  }
\cs_new_nopar:cpn { str_aux_escape_ \c_backslash_str :w }
    \str_aux_escape_loop:N #1
  {
    \cs_if_exist_use:cF { str_aux_escape_/\token_to_str:N #1:w }
      { \str_aux_escape_escaped:N #1 }
    \str_aux_escape_loop:N
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]+\str_aux_escape_\q_recursion_tail:w+
% \begin{macro}[aux]+\str_aux_escape_/\q_recursion_tail:w+
% \begin{macro}[aux]+\str_aux_escape_ :w+
% \begin{macro}[aux]
%   {
%     \str_aux_escape_/a:w, \str_aux_escape_/e:w, \str_aux_escape_/f:w,
%     \str_aux_escape_/n:w, \str_aux_escape_/r:w, \str_aux_escape_/t:w
%   }
%   The loop is ended upon seeing \cs{q_recursion_tail}.
%   Spaces are ignored, and |\a|, |\e|, |\f|, |\n|, |\r|, |\t| take
%   their meaning here.
%    \begin{macrocode}
\cs_new_eq:cN
  { str_aux_escape_ \c_backslash_str q_recursion_tail :w }
  \use_none_delimit_by_q_recursion_stop:w
\cs_new_eq:cN
  { str_aux_escape_ / \c_backslash_str q_recursion_tail :w }
  \use_none_delimit_by_q_recursion_stop:w
\cs_new_nopar:cpn { str_aux_escape_~:w } { }
\cs_new_nopar:cpx { str_aux_escape_/a:w }
  { \exp_not:N \str_aux_escape_raw:N \iow_char:N \^^G }
\cs_new_nopar:cpx { str_aux_escape_/t:w }
  { \exp_not:N \str_aux_escape_raw:N \iow_char:N \^^I }
\cs_new_nopar:cpx { str_aux_escape_/n:w }
  { \exp_not:N \str_aux_escape_raw:N \iow_char:N \^^J }
\cs_new_nopar:cpx { str_aux_escape_/f:w }
  { \exp_not:N \str_aux_escape_raw:N \iow_char:N \^^L }
\cs_new_nopar:cpx { str_aux_escape_/r:w }
  { \exp_not:N \str_aux_escape_raw:N \iow_char:N \^^M }
\cs_new_nopar:cpx { str_aux_escape_/e:w }
  { \exp_not:N \str_aux_escape_raw:N \iow_char:N \^^[ }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux]{\str_aux_escape_/x:w}
% \begin{macro}[aux]{\str_aux_escape_x_test:N}
% \begin{macro}[aux]{\str_aux_escape_x_unbraced_i:N}
% \begin{macro}[aux]{\str_aux_escape_x_unbraced_ii:N}
% \begin{macro}[aux]{\str_aux_escape_x_braced_loop:N}
% \begin{macro}[aux]{\str_aux_escape_x_braced_end:N}
% \begin{macro}[aux]{\str_aux_escape_x_end:}
%   When |\x| is encountered, interrupt the assignment,
%   and distinguish the cases of a braced or unbraced syntax.
%   In the braced case, collect arbitrarily many hexadecimal digits,
%   building the number in \cs{l_str_char_int} (this is a side effect
%   of \cs{str_aux_hexadecimal_test:NTF}), and check that
%   the run of digits was interrupted by a closing brace.
%   In the unbraced case, collect up to two hexadecimal digits,
%   possibly less, building the character number in \cs{l_str_char_int}.
%   In both cases, once all digits have been collected, use
%   the \TeX{} primitive \tn{lowercase} to produce that character,
%   and use a \cs{if_false:} trick to restart the assignment.
%    \begin{macrocode}
\cs_new_nopar:cpn { str_aux_escape_/x:w } \str_aux_escape_loop:N
  {
    \if_false: { \fi: }
    \int_zero:N \l_str_char_int
    \str_aux_escape_x_test:N
  }
\cs_new_protected_nopar:Npx \str_aux_escape_x_test:N #1
  {
    \exp_not:N \token_if_eq_charcode:NNTF \c_space_token #1
      { \exp_not:N \str_aux_escape_x_test:N }
      {
        \exp_not:N \token_if_eq_charcode:NNTF \c_lbrace_str #1
          { \exp_not:N \str_aux_escape_x_braced_loop:N }
          { \exp_not:N \str_aux_escape_x_unbraced_i:N #1 }
      }
  }
\cs_new_protected_nopar:Npn \str_aux_escape_x_unbraced_i:N #1
  {
    \str_aux_hexadecimal_test:NTF #1
      { \str_aux_escape_x_unbraced_ii:N }
      { \str_aux_escape_x_end: #1 }
  }
\cs_new_protected_nopar:Npn \str_aux_escape_x_unbraced_ii:N #1
  {
    \token_if_eq_charcode:NNTF \c_space_token #1
      { \str_aux_escape_x_unbraced_ii:N }
      {
        \str_aux_hexadecimal_test:NTF #1
          { \str_aux_escape_x_end: }
          { \str_aux_escape_x_end: #1 }
      }
  }
\cs_new_protected_nopar:Npn \str_aux_escape_x_braced_loop:N #1
  {
    \token_if_eq_charcode:NNTF \c_space_token #1
      { \str_aux_escape_x_braced_loop:N }
      {
        \str_aux_hexadecimal_test:NTF #1
          { \str_aux_escape_x_braced_loop:N }
          { \str_aux_escape_x_braced_end:N #1 }
      }
  }
\cs_new_protected_nopar:Npx \str_aux_escape_x_braced_end:N #1
  {
    \exp_not:N \token_if_eq_charcode:NNTF \c_rbrace_str #1
      { \exp_not:N \str_aux_escape_x_end: }
      {
        \msg_kernel_error:nn { str } { x-missing-brace }
        \exp_not:N \str_aux_escape_x_end: #1
      }
  }
\group_begin:
  \char_set_catcode_other:N \^^@
  \cs_new_protected_nopar:Npn \str_aux_escape_x_end:
    {
      \group_begin:
      \char_set_lccode:nn { \c_zero } { \l_str_char_int }
      \tl_to_lowercase:n
        {
          \group_end:
          \tl_gput_right:Nx \g_str_result_tl
            { \if_false: } \fi:
            \str_aux_escape_raw:N ^^@
            \str_aux_escape_loop:N
        }
    }
\group_end:
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Escape and unescape strings for PDF use}
%
% \begin{macro}[int,rEXP]{\str_aux_byte_to_hexadecimal:N}
% \begin{macro}[int,rEXP]{\str_aux_byte_to_octal:N}
% \begin{macro}[aux]{\str_aux_byte_check:NT}
%    \begin{macrocode}
\pdftex_if_engine:TF
  { \cs_new_eq:NN \str_aux_byte_check:NT \use_ii:nn }
  {
    \cs_new_nopar:Npn \str_aux_byte_check:NT #1
      {
        \int_compare:nNnTF {`#1} > { 255 }
          { \msg_expandable_kernel_error:nnn { str } { bad-byte } {#1} }
      }
  }
\cs_new_nopar:Npn \str_aux_byte_to_hexadecimal:N #1
  {
    \str_aux_byte_check:NT #1
      {
        \int_to_letter:n { \int_div_truncate:nn {`#1} \c_sixteen }
        \int_to_letter:n { \int_mod:nn {`#1} \c_sixteen }
      }
  }
\cs_new_nopar:Npn \str_aux_byte_to_octal:N #1
  {
    \int_compare:nNnTF {`#1} < { 64 }
      {
        0
        \int_to_letter:n { \int_div_truncate:nn {`#1} \c_eight }
        \int_to_letter:n { \int_mod:nn {`#1} \c_eight }
      }
      { \str_aux_byte_check:NT #1 { \int_to_octal:n {`#1} } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[rEXP]{\str_bytes_escape_hexadecimal:n}
%    \begin{macrocode}
\cs_new:Npn \str_bytes_escape_hexadecimal:n #1
  { \str_map_tokens:nn {#1} \str_aux_byte_to_hexadecimal:N }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[rEXP]{\str_bytes_escape_name:n}
% \begin{variable}{\c_str_bytes_escape_name_str}
% \begin{macro}[rEXP,aux]{\str_bytes_escape_name_aux:N}
%    \begin{macrocode}
\tl_const:Nx \c_str_bytes_escape_name_str
  { \c_hash_str \c_percent_str \c_lbrace_str \c_rbrace_str ()/<>[] }
\cs_new:Npn \str_bytes_escape_name:n #1
  { \str_map_tokens:nn {#1} \str_bytes_escape_name_aux:N }
\cs_new_nopar:Npn \str_bytes_escape_name_aux:N #1
  {
    \int_compare:nNnTF {`#1} < { "21 }
      { \c_hash_str \str_aux_byte_to_hexadecimal:N #1 }
      {
        \int_compare:nNnTF {`#1} > { "7E }
          { \c_hash_str \str_aux_byte_to_hexadecimal:N #1 }
          {
            \str_if_contains_char:NNTF \c_str_bytes_escape_name_str #1
              { \c_hash_str \str_aux_byte_to_hexadecimal:N #1 }
              {#1}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{variable}
% \end{macro}
%
% \begin{macro}[rEXP]{\str_bytes_escape_string:n}
% \begin{variable}{\c_str_bytes_escape_string_str}
% \begin{macro}[rEXP,aux]{\str_bytes_escape_string_aux:N}
%   Any character below (and including) space, and any character
%   above (and including) \texttt{del}, are converted to octal.
%   One backslash is added before each parenthesis and backslash.
%    \begin{macrocode}
\tl_const:Nx \c_str_bytes_escape_string_str { \c_backslash_str ( ) }
\cs_new:Npn \str_bytes_escape_string:n #1
  { \str_map_tokens:nn {#1} \str_bytes_escape_string_aux:N }
\cs_new_nopar:Npn \str_bytes_escape_string_aux:N #1
  {
    \int_compare:nNnTF {`#1} < { "21 }
      { \c_backslash_str \str_aux_byte_to_octal:N #1 }
      {
        \int_compare:nNnTF {`#1} > { "7E }
          { \c_backslash_str \str_aux_byte_to_octal:N #1 }
          {
            \str_if_contains_char:NNT \c_str_bytes_escape_string_str #1
              { \c_backslash_str }
            #1
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{variable}
% \end{macro}
%
% \begin{macro}[rEXP]{\str_bytes_unescape_hexadecimal:n}
% \begin{macro}[aux]{\str_bytes_unescape_hexadecimal_aux:N}
% \begin{macro}[rEXP,aux]{\str_bytes_unescape_hexadecimal_aux_ii:N}
%   Takes chars two by two, and interprets each pair as a hexadecimal code
%   for a character. Any non-hexadecimal-digit is ignored. An odd-length
%   string gets a |0| appended to it (this is equivalent to appending a |0|
%   in all cases, and dropping it if it is alone).
%    \begin{macrocode}
\cs_new:Npn \str_bytes_unescape_hexadecimal:n #1
  {
    \str_byte:w "
      \exp_after:wN \str_bytes_unescape_hexadecimal_aux:N
        \tl_to_str:n {#1} 0
      { ? 0 - \c_one \use_none_delimit_by_q_stop:w } \q_stop
    \str_byte_end:
  }
\cs_new_nopar:Npn \str_bytes_unescape_hexadecimal_aux:N #1
  {
    \use_none:n #1
    \str_aux_hexadecimal_use:NTF #1
      \str_bytes_unescape_hexadecimal_aux_ii:N
      \str_bytes_unescape_hexadecimal_aux:N
  }
\cs_new_nopar:Npn \str_bytes_unescape_hexadecimal_aux_ii:N #1
  {
    \use_none:n #1
    \str_aux_hexadecimal_use:NTF #1
      {
        \str_byte_end:
        \str_byte:w " \str_bytes_unescape_hexadecimal_aux:N
      }
      \str_bytes_unescape_hexadecimal_aux_ii:N
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[rEXP]{\str_bytes_unescape_name:n}
% \begin{macro}[rEXP,aux]{\str_bytes_unescape_name_aux:ww}
% \begin{macro}[rEXP,aux]{\str_bytes_unescape_name_aux:NNw}
%   This changes all occurrences of |#| followed by two upper- or lowercase
%   hexadecimal digits by the corresponding unescaped character.
%    \begin{macrocode}
\group_begin:
  \char_set_lccode:nn {`\*} {`\#}
  \tl_to_lowercase:n
    {
      \group_end:
      \cs_new:Npn \str_bytes_unescape_name:n #1
        {
          \exp_after:wN \str_bytes_unescape_name_aux:ww
            \tl_to_str:n {#1}
          * { ? \use_none_delimit_by_q_stop:w } ? ~ \q_stop
        }
      \cs_new_nopar:Npn \str_bytes_unescape_name_aux:ww #1 * #2 ~
        {
          #1
          \str_bytes_unescape_name_aux:NNw #2 ?? \q_stop
          \str_bytes_unescape_name_aux:ww #2 ~
        }
    }
\cs_new_nopar:Npn \str_bytes_unescape_name_aux:NNw #1#2#3 \q_stop
  {
    \use_none:n #1
    \str_byte:w "
      \str_aux_hexadecimal_use:NTF #1
        {
          \str_aux_hexadecimal_use:NTF #2
            { }
            { * \c_zero + "23 \use_i:nn }
        }
        { 23 \use_i:nn }
    \str_byte_end:
    \use_i:nnn
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[rEXP]{\str_bytes_unescape_string:n}
% \begin{macro}[rEXP,aux]{\str_bytes_unescape_string_aux:ww}
% \begin{macro}[rEXP,aux]{\str_bytes_unescape_string_aux:NNNw}
% \begin{macro}[rEXP,aux]{\str_bytes_unescape_string_aux:NNNNN}
%   Here, we need to detect backslashes, which escape characters
%   as follows.
%   \begin{itemize}
%   \item[\ttfamily\string\n] Line feed ($10$)
%   \item[\ttfamily\string\r] Carriage return ($13$)
%   \item[\ttfamily\string\t] Horizontal tab ($9$)
%   \item[\ttfamily\string\b] Backspace ($8$)
%   \item[\ttfamily\string\f] Form feed ($12$)
%   \item[\ttfamily\string\(] Left parenthesis
%   \item[\ttfamily\string\)] Right parenthesis
%   \item[\ttfamily\string\\] Backslash
%   \item[\ttfamily\string\ddd] Character code \texttt{ddd} (octal)
%   \end{itemize}
%   If followed by an end-of-line character, the backslash and
%   the end-of-line are ignored. If followed by anything else,
%   the backslash is ignored.
%   The PDF specification indicates that LF, CR, and CRLF should be
%   converted to LF: \emph{this is not implemented here}.
%    \begin{macrocode}
\group_begin:
  \char_set_lccode:nn {`\*} {`\\}
  \char_set_catcode_other:N \^^J
  \char_set_catcode_other:N \^^M
  \tl_to_lowercase:n
    {
      \cs_new:Npn \str_bytes_unescape_string:n #1
        {
          \exp_after:wN \str_bytes_unescape_string_aux:ww
            \tl_to_str:n {#1}
          * { ? \use_none_delimit_by_q_stop:w } ? ~ \q_stop
        }
      \cs_new_nopar:Npn \str_bytes_unescape_string_aux:ww #1 * #2 ~
        {
          #1
          \str_bytes_unescape_string_aux:NNNw #2 ??? \q_stop
          \str_bytes_unescape_string_aux:ww #2 ~
        }
    }
  \cs_new_nopar:Npn \str_bytes_unescape_string_aux:NNNw #1#2#3#4 \q_stop
    {
      \use_none:n #1
      \str_byte:w '
        \str_aux_octal_use:NTF #1
          {
            \str_aux_octal_use:NTF #2
              {
                \str_aux_octal_use:NTF #3
                  {
                    \if_int_compare:w #1 > \c_three
                      - 256
                    \fi:
                    \str_bytes_unescape_string_aux:NNNNN
                  }
                  { \str_bytes_unescape_string_aux:NNNNN ? }
              }
              { \str_bytes_unescape_string_aux:NNNNN ?? }
          }
          {
            \prg_case_str:xxn {#1}
              {
                { n } { 12 }
                { r } { 15 }
                { t } { 11 }
                { b } { 10 }
                { f } { 14 }
                { ( } { 50 }
                { ) } { 51 }
                { \c_backslash_str } { 134 }
                { ^^J } { 0 - \c_one }
                { ^^M } { 0 - \c_one }
              }
              { 0 - \c_one \use_none:n }
            \use_i_ii:nnn
          }
      \str_byte_end:
    }
  \cs_new_nopar:Npn \str_bytes_unescape_string_aux:NNNNN #1#2#3#4#5
    { \str_byte_end: \str_bytes_unescape_string_aux:ww }
\group_end:
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Percent encoding}
%
% \begin{macro}[rEXP]{\str_bytes_percent_encode:n}
% \begin{variable}{\c_str_bytes_percent_encode_str}
% \begin{variable}{\c_str_bytes_percent_encode_not_str}
% \begin{macro}[rEXP,aux]{\str_bytes_percent_encode_aux:N}
%    \begin{macrocode}
\tl_const:Nx \c_str_bytes_percent_encode_str { \tl_to_str:n { [] } }
\tl_const:Nx \c_str_bytes_percent_encode_not_str { \tl_to_str:n { "-.<> } }
\cs_new:Npn \str_bytes_percent_encode:n #1
  { \str_map_tokens:nn {#1} \str_bytes_percent_encode_aux:N }
\cs_new_nopar:Npn \str_bytes_percent_encode_aux:N #1
  {
    \int_compare:nNnTF {`#1} < { "41 }
      {
        \str_if_contains_char:NNTF \c_str_bytes_percent_encode_not_str #1
          { #1 }
          { \c_percent_str \str_aux_byte_to_hexadecimal:N #1 }
      }
      {
        \int_compare:nNnTF {`#1} > { "7E }
          { \c_percent_str \str_aux_byte_to_hexadecimal:N #1 }
          {
            \str_if_contains_char:NNTF \c_str_bytes_percent_encode_str #1
              { \c_percent_str \str_aux_byte_to_hexadecimal:N #1 }
              { #1 }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{variable}
% \end{variable}
% \end{macro}
%
% \begin{macro}[rEXP]{\str_bytes_percent_decode:n}
% \begin{macro}[rEXP,aux]{\str_bytes_percent_decode_aux:ww}
% \begin{macro}[rEXP,aux]{\str_bytes_percent_decode_aux:NNw}
%    \begin{macrocode}
\group_begin:
  \char_set_lccode:nn {`\*} {`\%}
  \tl_to_lowercase:n
    {
      \group_end:
      \cs_new:Npn \str_bytes_percent_decode:n #1
        {
          \exp_after:wN \str_bytes_percent_decode_aux:ww
            \tl_to_str:n {#1}
          * { ? \use_none_delimit_by_q_stop:w } ? ~ \q_stop
        }
      \cs_new_nopar:Npn \str_bytes_percent_decode_aux:ww #1 * #2 ~
        {
          #1
          \str_bytes_percent_decode_aux:NNw #2 ?? \q_stop
          \str_bytes_percent_decode_aux:ww #2 ~
        }
    }
\cs_new_nopar:Npn \str_bytes_percent_decode_aux:NNw #1#2#3 \q_stop
  {
    \use_none:n #1
    \str_byte:w "
      \str_aux_hexadecimal_use:NTF #1
        {
          \str_aux_hexadecimal_use:NTF #2
            { }
            { * \c_zero + "25 \use_i:nn }
        }
        { 25 \use_i:nn }
    \str_byte_end:
    \use_i:nnn
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Encoding conversions}
%
% All conversions are done by converting the string to a comma list of
% integers (ending with a comma, unless it is empty): each character
% is converted to \enquote{\ttfamily \meta{character code},}.
%
% \begin{macro}[rEXP]{\str_bytes_convert:nnn}
% \begin{macro}[aux, rEXP]{\str_bytes_convert_aux:NNnnn}
%   We build the conversion functions for the two steps,
%   sanitizing the encoding name given by the user with
%   \cs{str_aux_encoding_clean:n}. For unknown encodings,
%   the conversion functions don't exist, an error is
%   raised, and the resulting string is empty.
%   Normally, nesting such conversion functions should not work,
%   since they are only \enquote{restricted-expandable},
%   but the outer function (conversion from the \textsc{internal}
%   format to the target encoding) performs \texttt{f}-expansion
%   before grabbing each character code.
%    \begin{macrocode}
\cs_new:Npn \str_bytes_convert:nnn #1#2
  {
    \exp_args:Ncc \str_bytes_convert_aux:NNnnn
      { str_\str_aux_encoding_clean:n {#1} _to_internal:n }
      { str_internal_to_ \str_aux_encoding_clean:n {#2} :n }
      {#1}
      {#2}
  }
\cs_new:Npn \str_bytes_convert_aux:NNnnn #1#2#3#4#5
  {
    \cs_if_exist:NTF #2
      {
        #2
          {
            \cs_if_exist:NTF #1
              { #1 {#5} }
              {
                \msg_expandable_kernel_error:nnn
                  { str } { unknown-encoding } {#3}
              }
          }
      }
      {
        \msg_expandable_kernel_error:nnn
          { str } { unknown-encoding } {#4}
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\str_aux_encoding_clean:n}
% \begin{macro}[aux, rEXP]{\str_aux_encoding_clean_loop:N}
%   The goal here is to interpret the encoding name given by the user
%   and expand to the \enquote{internal} encoding name, for use in a csname.
%   We go through the string and only keep ascii digits and letters,
%   lowercased. For example, \texttt{UTF-8-be} becomes \texttt{utf8be}.
%    \begin{macrocode}
\cs_new:Npn \str_aux_encoding_clean:n #1
  {
    \exp_after:wN \str_aux_encoding_clean_loop:N
      \tl_to_str:n {#1} { ? \use_none_delimit_by_q_stop:w } \q_stop
  }
\cs_new:Npn \str_aux_encoding_clean_loop:N #1
  {
    \use_none:n #1
    \if_num:w `#1 < \c_ninety_one
      \if_num:w `#1 < \c_sixty_five
        \if_num:w \c_two < 1#1 \exp_stop_f:
          #1
        \fi:
      \else:
        \str_byte:n { `#1 + \c_thirty_two }
      \fi:
    \else:
      \if_num:w `#1 < \c_ninety_seven
      \else:
        \if_num:w `#1 < \c_one_hundred_twenty_three
          #1
        \fi:
      \fi:
    \fi:
    \str_aux_encoding_clean_loop:N
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\str_exp_after:Nf}
% \begin{macro}{\str_exp_after:NNf}
%   Expand what follows in the input stream.
%   Those functions are similar to \cs{exp_last_unbraced:Nf}
%   and \cs{exp_last_unbraced:NNf}.
%    \begin{macrocode}
\cs_new:Npn \str_exp_after:Nf #1
  { \exp_after:wN #1 \tex_romannumeral:D -`0 }
\cs_new:Npn \str_exp_after:NNf #1#2
  {
    \exp_after:wN #1
    \exp_after:wN #2
    \tex_romannumeral:D -`0
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\str_internal_to_internal:n}
%   This \enquote{do-nothing} function is called when
%   the user requests a conversion to the internal format
%   (presumably for debugging purposes).
%    \begin{macrocode}
\cs_new_eq:NN \str_internal_to_internal:n \use:n
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Convert to and from native strings}
%
% \begin{macro}{\str_native_to_internal:n}
% \begin{macro}{\str_native_to_internal_aux:N}
%   Convert each character to its character code, one at a time.
%    \begin{macrocode}
\cs_new:Npn \str_native_to_internal:n #1
  { \str_map_tokens:nn {#1} \str_native_to_internal_aux:N }
\cs_new:Npn \str_native_to_internal_aux:N #1
  { \int_value:w `#1 , }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, rEXP]{\str_internal_to_native:n}
%   It is impossible to convert from the internal format
%   to a native string, because \TeX{} provides no mechanism to
%   produce arbitrary characters expandably (the bytes are
%   hard-coded in multiple token list constants). Hence we tell
%   the user to use \cs{str_set_convert:Nnn} defined below,
%   instead of \cs{str_bytes_convert:nnn}.
%    \begin{macrocode}
\cs_new:cpn { str_internal_to_native:n } #1
  { \msg_expandable_kernel_error:nn { str } { to-native } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\str_set_convert:Nnn}
% \begin{macro}[aux]{\str_set_convert_aux:w}
%   Convert the string from the given encoding
%   to the internal format. Loop over the result,
%   \texttt{f}-expanding it as we go.
%    \begin{macrocode}
\cs_new_protected:Npn \str_set_convert:Nnn #1#2#3
  {
    \tl_gclear:N \g_str_result_tl
    \str_exp_after:Nf \str_set_convert_aux:w
      \exp_args:Nc \cs_if_exist_use:NTF
        { str_\str_aux_encoding_clean:n {#2} _to_internal:n }
        { {#3} }
        {
          \msg_expandable_kernel_error:nnn
            { str } { unknown-encoding } {#2}
        }
      { \q_stop \prg_map_break: } ,
    \prg_break_point:n { }
    \tl_set_eq:NN #1 \g_str_result_tl
  }
\cs_new_protected_nopar:Npn \str_set_convert_aux:w #1 ,
  {
    \use_none_delimit_by_q_stop:w #1 \q_stop
    \int_set:Nn \l_str_char_int {#1}
    \str_aux_convert_store:
    \str_exp_after:Nf \str_set_convert_aux:w
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%^^A todo: document that ^^20 should be "other" in byte strings.
%
% \subsubsection{\textsc{utf-16} support}
%
% The definitions are done in a category code regime where
% the bytes $253$, $254$ and $255$ used by the replacement
% character and the byte order mark have catcode \enquote{other}.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_other:N \^^fd
  \char_set_catcode_other:N \^^fe
  \char_set_catcode_other:N \^^ff
%    \end{macrocode}
%
% \begin{variable}{\c_str_utf_xvi_replacement_char_str}
% \begin{variable}{\c_str_replacement_char_int}
%   When converting, invalid bytes are replaced by the Unicode
%   replacement character \textsc{u-fffd}.
%    \begin{macrocode}
\str_const:Nx \c_str_utf_xvi_replacement_char_str { ^^ff ^^fd }
\int_const:Nn \c_str_replacement_char_int { "FFFD }
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{macro}[int, rEXP]{\str_internal_to_utf16:n}
% \begin{macro}[int, rEXP]{\str_internal_to_utf16be:n}
% \begin{macro}[int, rEXP]{\str_internal_to_utf16le:n}
% \begin{macro}[aux, rEXP]
%   {
%     \str_aux_to_utf_xvi:Nw,
%     \str_aux_to_utf_xvi_be:n,
%     \str_aux_to_utf_xvi_le:n
%   }
%   Convert characters one by one in a loop, with different
%   behaviours depending on the character code:
%   \begin{itemize}
%   \item $[0, 55295]$ converted to two bytes;
%   \item $[55296, 57343]$ cannot be converted, replaced by
%     the replacement character (stored in
%     \cs{c_str_utf_xvi_replacement_char_str});
%   \item $[57344, 65535]$ converted to two bytes;
%   \item $[65536, 1114111]$ converted to a pair of surrogates,
%     each two bytes.
%   \end{itemize}
%   The auxiliary \cs{str_aux_to_utf_xvi_be:n} converts a number
%   in the range $[0, 65536]$ to a pair of bytes.
%    \begin{macrocode}
  \cs_new:cpx { str_internal_to_utf16:n }
    { ^^fe ^^ff \exp_not:c { str_internal_to_utf16be:n } }
  \cs_new:cpn { str_internal_to_utf16be:n } #1
    {
      \str_exp_after:NNf \str_aux_to_utf_xvi:Nw \str_aux_to_utf_xvi_be:n
        #1 { \q_stop \prg_map_break: } ,
      \prg_break_point:n { }
    }
  \cs_new:cpn { str_internal_to_utf16le:n } #1
    {
      \str_exp_after:NNf \str_aux_to_utf_xvi:Nw \str_aux_to_utf_xvi_le:n
        #1 { \q_stop \prg_map_break: } ,
      \prg_break_point:n { }
    }
  \cs_new_nopar:Npn \str_aux_to_utf_xvi:Nw #1#2 ,
    {
      \use_none_delimit_by_q_stop:w #2 \q_stop
      \if_int_compare:w #2 < "D800 \exp_stop_f:
        #1 {#2}
      \else:
        \if_int_compare:w #2 < "10000 \exp_stop_f:
          \if_int_compare:w #2 < "E000 \exp_stop_f:
            #1 {#2}
          \else:
            \msg_kernel_expandable_error:nnx
              { str } { utf16-surrogate } {#2}
            \c_str_utf_xvi_replacement_char_str
          \fi:
        \else:
          \exp_args:Nf #1 { \int_div_truncate:nn {#2} {"400} + "D800 }
          \exp_args:Nf #1 { \int_mod:nn {#2} {"400} + "DC00 }
        \fi:
      \fi:
      \str_exp_after:NNf \str_aux_to_utf_xvi:Nw #1
    }
  \cs_new_nopar:Npn \str_aux_to_utf_xvi_be:n #1
    {
      \str_byte:n { \int_div_truncate:nn {#1} {"100} }
      \str_byte:n { \int_mod:nn {#1} {"100} }
    }
  \cs_new_nopar:Npn \str_aux_to_utf_xvi_le:n #1
    {
      \str_byte:n { \int_mod:nn {#1} {"100} }
      \str_byte:n { \int_div_truncate:nn {#1} {"100} }
    }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, rEXP]
%   {
%     \str_utf16_to_internal:n,
%     \str_utf16be_to_internal:n,
%     \str_utf16le_to_internal:n
%   }
% \begin{macro}[aux, rEXP]
%   {
%     \str_aux_from_utf_xvi:nn,
%     \str_aux_from_utf_xvi_error_ii:N,
%     \str_aux_from_utf_xvi_error:NwNnNNnn,
%     \str_aux_from_utf_xvi_error:NwNNN
%   }
%   Conversion from \textsc{utf-16} to the internal representation.
%   Three cases for the endianness, in all three we loop over the
%   string, reading two bytes at a time (sometimes four).
%
%   For non-surrogate bytes, the end of the loop is detected with
%   the construction |\use_none:nn #2#1|. Within the loop, |#1|
%   and |#2| are each one byte, and the construction vanishes.
%   The end-markers are more than one token each, and \cs{use_none:nn}
%   will thus leave some tokens in the input stream.
%   If the string had an even number of bytes, then after expanding
%   \cs{use_none:nn} we get \cs{prg_map_break:}, ending the mapping.
%   If the string had an odd number of bytes, then
%   \cs{str_aux_from_utf_xvi_error_ii:N} \meta{last byte}
%   is called, and triggers an appropriate error.
%
%   On the other hand, after a leading surrogate is read, we test for
%   the end of the loop with |\use_none_delimit_by_q_stop:w #2#1|.
%   Given the construction of the end-markers, this calls
%   \cs{str_aux_from_utf_xvi_error:NwNnNNnn}, which raises the
%   appropriate error, and cleans up (don't ask how |;-p|).
%    \begin{macrocode}
  \cs_new:cpn { str_utf16_to_internal:n }
    { \str_aux_from_utf_xvi:nn { \str_aux_from_utf_xvi_bom:NN } }
  \cs_new:cpn { str_utf16be_to_internal:n }
    {
      \str_aux_from_utf_xvi:nn
        { \str_aux_from_utf_xvi:NNN \use_i_ii:nnn }
    }
  \cs_new:cpn { str_utf16le_to_internal:n } #1
    {
      \str_aux_from_utf_xvi:nn
        { \str_aux_from_utf_xvi:NNN \use_i:nn }
    }
  \cs_new:Npn \str_aux_from_utf_xvi:nn #1#2
    {
      #1 #2
        {
          \q_stop \str_aux_from_utf_xvi_error:NwNnNNnn
          \str_aux_from_utf_xvi_error_ii:N
        }
        {
          \q_stop \str_aux_from_utf_xvi_error:NwNnNNnn
          \prg_map_break:
        }
      \prg_break_point:n { }
    }
  \cs_new:Npn \str_aux_from_utf_xvi_error_ii:N #1
    {
      \msg_expandable_kernel_error:nnn
        { str } { utf16-extra-byte } {#1}
      \prg_map_break:
    }
  \cs_new:Npn \str_aux_from_utf_xvi_error:NwNnNNnn
      #1#2 \q_stop #3#4#5#6#7#8
    { \str_aux_from_utf_xvi_error:NwNNN #1 #8 }
  \cs_new:Npn \str_aux_from_utf_xvi_error:NwNNN #1 #2 , #3#4#5
    { #2 , #1#5 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[aux, rEXP]{\str_aux_from_utf_xvi_bom:NN}
%   Find and remove the BOM, then use the auxiliaries
%   used for big-endian or little-endian strings.
%    \begin{macrocode}
  \cs_new:Npn \str_aux_utf_xvi_bom:NN #1#2
    {
      \str_if_eq:nnTF { #1#2 } { ^^ff ^^fe }
        { \str_aux_from_utf_xvi:NNN \use_i:nn }
        {
          \str_if_eq:nnTF { #1#2 } { ^^fe ^^ff }
            { \str_aux_from_utf_xvi:NNN \use_i_ii:nnn }
            { \str_aux_from_utf_xvi:NNN \use_i_ii:nnn #1 #2 }
        }
    }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[aux, rEXP]
%   {
%     \str_aux_from_utf_xvi:NNN,
%     \str_aux_from_utf_xvi:wNNw,
%     \str_aux_from_utf_xvi:wNNNN
%   }
%   The first argument of \cs{str_aux_from_utf_xvi:NNN}
%   is such that |#1`#2#3| expands to |`#2| if the string
%   is big-endian, and |`#3| if the string is little-endian.
%   If the most significant byte is between |"D8| and |"DB|
%   (inclusive), then the pair of bytes is a high surrogate,
%   and we fetch the following pair, which must be a low surrogate.
%   If it is between |"DC| and |"DF| (inclusive), then the pair
%   is a low surrogate, which should not appear there.
%    \begin{macrocode}
  \cs_new:Npn \str_aux_from_utf_xvi:NNN #1#2#3
    {
      \use_none:nn #3#2
      \int_use:N \int_eval:w
        \if_case:w
          \int_eval:w ( #1 `#2#3 - "D6 ) / \c_four \int_eval_end:
        \or: \exp_after:wN \str_aux_from_utf_xvi:wNNNN
        \or: \exp_after:wN \str_aux_from_utf_xvi:wNNw
        \fi:
        "100 * #1`#2#3 + #1`#3#2 ,
      \str_aux_from_utf_xvi:NNN #1
    }
  \cs_new:Npn \str_aux_from_utf_xvi:wNNw #1 `#2#3 #4,
    {
      \msg_expandable_kernel_error:nnn
        { str } { utf-16-surrogate } { #2#3 }
      \c_str_replacement_int ,
    }
  \cs_new:Npn \str_aux_from_utf_xvi:wNNNN #1, #2#3#4#5
    {
      \use_none_delimit_by_q_stop:w #5#4 \q_stop
      \int_compare:nNnTF { ( #3`#4#5 - "DA ) / \c_four } = \c_one
        {
          ( #1 - "D800 ) * "10000
            + #3`#4#5 * "100 + #3`#5#4 - "DC00 ,
          #2
        }
        {
          \str_aux_from_utf_xvi:wNNw #1 ,
          #2 #3 #4 #5
        }
    }
%    \end{macrocode}
% \end{macro}
%
% Restore the original catcodes of bytes $254$ and $255$.
%    \begin{macrocode}
\group_end:
%    \end{macrocode}
%
%
% \subsubsection{\textsc{utf-8} support}
%
% \begin{macro}[int, rEXP]{\str_internal_to_utf8:n}
% \begin{macro}[aux, rEXP]
%   {
%     \str_aux_to_utf_viii:w,
%     \str_aux_to_utf_viii:nnnnw
%   }
%   Loop through the internal string (\texttt{f}-expanding as we go),
%   Convert each character to the \textsc{utf-8} representation.
%    \begin{macrocode}
\cs_new:cpn { str_internal_to_utf8:n } #1
  {
    \str_exp_after:Nf \str_aux_to_utf_viii:w
      #1 { \q_stop \prg_map_break: } ,
    \prg_break_point:n { }
  }
\cs_new:Npn \str_aux_to_utf_viii:w #1 ,
  {
    \use_none_delimit_by_q_stop:w #1 \q_stop
    \str_aux_to_utf_viii:nnnnw
      { #1 } { \c_minus_one + \c_zero * \use_none:n }
      {        128 } { \c_zero }
      {         32 } {     192 }
      { \c_sixteen } {     224 }
      {   \c_eight } {     240 }
    \q_stop
    \str_exp_after:Nf \str_aux_to_utf_viii:w
  }
\cs_new_nopar:Npn \str_aux_to_utf_viii:nnnnw #1#2#3#4 #5 \q_stop
  {
    \int_compare:nNnTF {#1} < {#3}
      { \str_byte:n { #1 + #4 } }
      {
        \exp_args:Nf \str_aux_to_utf_viii:nnnnw
          { \int_div_truncate:nn {#1} {64} }
          {#1}
        #5 \q_stop
      }
    \str_byte:n { #2 - 64 * ( #1 - \c_two ) }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, rEXP]{\str_utf8_to_internal:n}
% \begin{macro}[aux, rEXP]
%   {
%     \str_aux_from_utf_viii:N,
%     \str_aux_from_utf_viii:wwNN,
%     \str_aux_from_utf_viii:wNNww
%   }
% \begin{macro}[aux, rEXP]
%   {
%     \str_aux_from_utf_viii_error:N,
%     \str_aux_from_utf_viii_error:NwN,
%     \str_aux_from_utf_viii_error:
%   }
%   As usual, loop through the string.
% ^^A todo: refuse "D800 -- "DFFF?
%    \begin{macrocode}
\cs_new:cpn { str_utf8_to_internal:n } #1
  {
    \str_aux_from_utf_viii:N #1
      { ? \prg_map_break: \q_stop \str_aux_from_utf_viii_error: }
    \prg_break_point:n { }
  }
\cs_new:Npn \str_aux_from_utf_viii:N #1
  {
    \use_none:n #1
    \int_use:N \int_eval:w
      \if_num:w `#1 < 192 \exp_stop_f:
        \if_num:w `#1 < 128 \exp_stop_f:
          `#1
        \else:
          \msg_expandable_kernel_error:nnn
            { str } { utf8-extra-conti } {#1}
          \c_str_replacement_char_int
        \fi:
      \else:
        \if_num:w `#1 < 245 \exp_stop_f:
          \exp_after:wN \str_aux_from_utf_viii:wwNN
            \int_use:N \int_eval:w `#1 - 192
        \else:
          \msg_expandable_kernel_error:nnn
            { str } { utf8-invalid-byte } {#1}
          \c_str_replacement_char_int
        \fi:
      \fi:
    ,
    \use_none_delimit_by_q_stop:w
      "80     ,
      "800    ,
      "10000  ,
      "10FFFF ,
    \q_stop
    \str_aux_from_utf_viii:N
  }
\cs_new:Npn \str_aux_from_utf_viii:wwNN #1 , #2 \q_stop #3 #4
  {
    \use_none_delimit_by_q_stop:w #4 \q_stop
    \exp_after:wN \str_aux_from_utf_viii:wNNww
      \int_use:N \int_eval:w #1 * 64 + `#4 - 128 ,
      #4
      #2
    \q_stop #3
  }
\cs_new:Npn \str_aux_from_utf_viii:wNNww #1, #2 #3#4, #5,
  {
    \if_num:w \int_eval:w ( `#2 + \c_thirty_two ) / 64 = \c_three
      \if_num:w #1 < #4 \exp_stop_f:
        \str_aux_from_utf_viii_error:N #1
      \else:
        \if_num:w #1 < #5 \exp_stop_f:
          #1
        \else:
          \exp_after:wN \str_aux_from_utf_viii:wwNN
            \int_use:N \int_eval:w #1 - #5
        \fi:
      \fi:
    \else:
      \exp_after:wN \str_aux_from_utf_viii_error:NwN
      \exp_after:wN #2
    \fi:
    , #3#5,
  }
\cs_new:Npn \str_aux_from_utf_viii_error:N #1
  {
    \msg_expandable_kernel_error:nnn
      { str } { utf8-overlong } {#1}
    \c_str_replacement_char_int
  }
\cs_new:Npn \str_aux_from_utf_viii_error:NwN #1 #2 \q_stop #3
  {
    \msg_expandable_kernel_error:nnn
      { str } { utf8-missing-conti } {#1}
    \c_str_replacement_char_int ,
    #3 #1
  }
\cs_new:Npn \str_aux_from_utf_viii_error:
  {
    \msg_expandable_kernel_error:nn
      { str } { utf8-premature-end }
    \c_str_replacement_char_int ,
    \prg_map_break:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{\textsc{utf-32} support}
%
% The definitions are done in a category code regime where
% the bytes $0$, $254$ and $255$ used by the byte order mark
% have catcode \enquote{other}.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_other:N \^^00
  \char_set_catcode_other:N \^^fe
  \char_set_catcode_other:N \^^ff
%    \end{macrocode}
%
% \begin{macro}[int, rEXP]
%   {
%     \str_internal_to_utf32:n,
%     \str_internal_to_utf32be:n,
%     \str_internal_to_utf32le:n
%   }
% \begin{macro}[aux, rEXP]
%   {
%     \str_aux_to_utf_xxxii_be:w,
%     \str_aux_to_utf_xxxii_le:w
%   }
%    \begin{macrocode}
  \cs_new:cpx { str_internal_to_utf32:n }
    { ^^00 ^^00 ^^fe ^^ff \exp_not:c { str_internal_to_utf32be:n } }
  \cs_new:cpn { str_internal_to_utf32be:n } #1
    {
      \str_exp_after:Nf \str_aux_to_utf_xxxii_be:w
        #1
        { \q_stop \prg_map_break: }
      \prg_break_point:n { }
    }
  \cs_new:Npn \str_aux_to_utf_xxxii_be:w #1 ,
    {
      \use_none_delimit_by_q_stop:w #1 \q_stop
      ^^00
      \str_byte:n { \int_div_truncate:nn {#1} { "10000 } }
      \str_byte:n
        { \int_mod:nn { \int_div_truncate:nn {#1} {"100} } {"100} }
      \str_byte:n { \int_mod:nn {#1} {"100} }
      \str_exp_after:Nf \str_aux_to_utf_xxxii_be:w
    }
  \cs_new:cpn { str_internal_to_utf32le:n } #1
    {
      \str_exp_after:Nf \str_aux_to_utf_xxxii_le:w
        #1
        { \q_stop \prg_map_break: }
      \prg_break_point:n { }
    }
  \cs_new:Npn \str_aux_to_utf_xxxii_le:w #1 ,
    {
      \use_none_delimit_by_q_stop:w #1 \q_stop
      \str_byte:n { \int_mod:nn {#1} {"100} }
      \str_byte:n
        { \int_mod:nn { \int_div_truncate:nn {#1} {"100} } {"100} }
      \str_byte:n { \int_div_truncate:nn {#1} { "10000 } }
      ^^00
      \str_exp_after:Nf \str_aux_to_utf_xxxii_le:w
    }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, rEXP]
%   {
%     \str_utf32_to_internal:n,
%     \str_utf32be_to_internal:n,
%     \str_utf32le_to_internal:n,
%   }
% \begin{macro}[aux, rEXP]
%   {
%     \str_aux_from_utf_xxxii:nn,
%     \str_aux_from_utf_xxxii_bom:NNNN,
%     \str_aux_from_utf_xxxii:NNNNN,
%     \str_aux_from_utf_xxxii_error:nnn
%   }
%    \begin{macrocode}
  \cs_new:cpn { str_utf32_to_internal:n }
    { \str_aux_from_utf_xxxii:nn { \str_aux_from_utf_xxxii_bom:NNNN } }
  \cs_new:cpn { str_utf32be_to_internal:n }
    {
      \str_aux_from_utf_xxxii:nn
        { \str_aux_from_utf_xxxii:NNNNN \use_i_ii:nnn }
    }
  \cs_new:cpn { str_utf32le_to_internal:n }
    {
      \str_aux_from_utf_xxxii:nn
        { \str_aux_from_utf_xxxii:NNNNN \use_i:nn }
    }
  \cs_new:Npn \str_aux_from_utf_xxxii:nn #1#2
    {
      #1 #2
        { ? \str_aux_from_utf_xxxii_error:nnn }
        { ? \str_aux_from_utf_xxxii_error:nnn { } }
        { ? \str_aux_from_utf_xxxii_error:nnn { } { } }
        { ? \prg_map_break: }
      \prg_break_point:n { }
    }
  \cs_new:Npn \str_aux_from_utf_xxxii_bom:NNNN #1#2#3#4
    {
      \str_if_eq:nnTF { #1#2#3#4 } { ^^ff ^^fe ^^00 ^^00 }
        { \str_aux_from_utf_xxxii:NNNNN \use_i:nn }
        {
          \str_if_eq:nnTF { #1#2#3#4 } { ^^00 ^^00 ^^fe ^^ff }
            { \str_aux_from_utf_xxxii:NNNNN \use_i_ii:nnn }
            { \str_aux_from_utf_xxxii:NNNNN \use_i_ii:nnn #1#2#3#4 }
        }
    }
  \cs_new:Npn \str_aux_from_utf_xxxii:NNNNN #1#2#3#4#5
    {
      \use_none:nnnn #5#2#3#4
      \int_use:N \int_eval:w
        \if_num:w \int_eval:w #1`#2#5 * "100 + #1`#3#4 > "10 \exp_stop_f:
          \msg_kernel_expandable_error:nnn
            { str } { utf32-overflow } { #1#2#3#4 }
          \c_str_replacement_char_int
        \else:
          #1`#2#5*"110000 + #1`#3#4*"10000 + #1`#4#3*"100 + #1`#5#2
        \fi:
      ,
      \str_aux_from_utf_xxxii:NNNNN
    }
  \cs_new:Npn \str_aux_from_utf_xxxii_error:nnn #1#2#3
    {
      \msg_kernel_expandable_error:nnn
        { str } { utf32-truncated } { #1#2#3 }
    }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% Restore the original catcodes of bytes $0$, $254$ and $255$.
%    \begin{macrocode}
\group_end:
%    \end{macrocode}
%
% \subsection{Messages}
%
%    \begin{macrocode}
\msg_kernel_new:nnnn { str } { x-missing-brace }
  { Missing~closing~brace~in~ \token_to_str:N \x ~byte~sequence. }
  {
    You~wrote~something~like~
    `\iow_char:N\\x\{ \int_to_hexadecimal:n { \l_str_char_int }'.~
    The~closing~brace~is~missing.
  }
\msg_kernel_new:nnn { str } { utf-8-invalid-byte }
  {
    \int_compare:nNnTF {`#1} < { 256 }
      { Byte~number~ \int_eval:n {`#1} ~invalid~in~utf-8~encoding. }
      { The~character~number~ \int_eval:n {`#1} ~is~not~a~byte. }
  }
\msg_kernel_new:nnn { str } { utf-8-missing-byte }
  { The~byte~number~ \int_eval:n {`#1} ~is~not~a~valid~continuation~byte. }
\msg_kernel_new:nnn { str } { utf-8-extra-byte }
  { The~byte~number~ \int_eval:n {`#1} ~is~only~valid~as~a~continuation~byte. }
\msg_kernel_new:nnnn { str } { utf-8-premature-end }
  { Incomplete~last~UTF-8~character. }
  {
    The~sequence~of~byte~that~to~be~converted~to~UTF-8~
    ended~before~the~last~character~was~complete.~Perhaps~
    it~was~mistakenly~truncated?
  }
\msg_kernel_new:nnn { str } { utf-8-pdftex-overflow }
  { The~character~number~#1~is~too~big~for~pdfTeX. }
\msg_kernel_new:nnn { str } { bad-byte } { Invalid~byte~`#1'. }
\msg_kernel_new:nnn { str } { utf-32-extra }
  { Extra~bytes~in~UTF-32~encoded~string. }
%    \end{macrocode}
%
% \subsection{Deprecated string functions}
%
% \begin{macro}{\str_length_skip_spaces:N, \str_length_skip_spaces:n}
%   The naming scheme is a little bit more consistent
%   with \enquote{ignore_spaces} instead of \enquote{skip_spaces}.
%    \begin{macrocode}
\cs_set:Npn \str_length_skip_spaces:N
  { \exp_args:No \str_length_skip_spaces:n }
\cs_set_eq:NN \str_length_skip_spaces:n \str_length_ignore_spaces:n
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</initex|package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
